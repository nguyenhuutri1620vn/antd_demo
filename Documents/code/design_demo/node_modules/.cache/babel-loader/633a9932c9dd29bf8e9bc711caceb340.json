{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { ModifierKey } from '../types';\nimport { Dom } from '../util';\nimport { Base } from './base';\nexport class PanningManager extends Base {\n  get widgetOptions() {\n    return this.options.panning;\n  }\n\n  get pannable() {\n    return this.widgetOptions && this.widgetOptions.enabled === true;\n  }\n\n  init() {\n    this.startListening();\n    this.updateClassName();\n  }\n\n  startListening() {\n    const eventTypes = this.widgetOptions.eventTypes;\n\n    if (!eventTypes) {\n      return;\n    }\n\n    if (eventTypes.includes('leftMouseDown')) {\n      this.graph.on('blank:mousedown', this.preparePanning, this);\n      this.graph.on('node:unhandled:mousedown', this.preparePanning, this);\n      this.graph.on('edge:unhandled:mousedown', this.preparePanning, this);\n    }\n\n    if (eventTypes.includes('rightMouseDown')) {\n      this.onRightMouseDown = this.onRightMouseDown.bind(this);\n      this.view.$(this.graph.container).on('mousedown', this.onRightMouseDown);\n    }\n\n    if (eventTypes.includes('mouseWheel')) {\n      this.mousewheelHandle = new Dom.MouseWheelHandle(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));\n      this.mousewheelHandle.enable();\n    }\n  }\n\n  stopListening() {\n    const eventTypes = this.widgetOptions.eventTypes;\n\n    if (!eventTypes) {\n      return;\n    }\n\n    if (eventTypes.includes('leftMouseDown')) {\n      this.graph.off('blank:mousedown', this.preparePanning, this);\n      this.graph.off('node:unhandled:mousedown', this.preparePanning, this);\n      this.graph.off('edge:unhandled:mousedown', this.preparePanning, this);\n    }\n\n    if (eventTypes.includes('rightMouseDown')) {\n      this.view.$(this.graph.container).off('mousedown', this.onRightMouseDown);\n    }\n\n    if (eventTypes.includes('mouseWheel')) {\n      if (this.mousewheelHandle) {\n        this.mousewheelHandle.disable();\n      }\n    }\n  }\n\n  preparePanning(_ref) {\n    let {\n      e\n    } = _ref;\n\n    if (this.allowPanning(e, true) || this.allowPanning(e) && !this.graph.selection.allowRubberband(e, true)) {\n      this.startPanning(e);\n    }\n  }\n\n  allowPanning(e, strict) {\n    return this.pannable && ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict) && this.graph.hook.allowPanning(e);\n  }\n\n  startPanning(evt) {\n    const e = this.view.normalizeEvent(evt);\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.panning = true;\n    this.updateClassName();\n    this.view.$(document.body).on({\n      'mousemove.panning touchmove.panning': this.pan.bind(this),\n      'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n      'mouseleave.panning': this.stopPanning.bind(this)\n    });\n    this.view.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n  }\n\n  pan(evt) {\n    const e = this.view.normalizeEvent(evt);\n    const dx = e.clientX - this.clientX;\n    const dy = e.clientY - this.clientY;\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.graph.translateBy(dx, dy);\n  } // eslint-disable-next-line\n\n\n  stopPanning(e) {\n    this.panning = false;\n    this.updateClassName();\n    this.view.$(document.body).off('.panning');\n    this.view.$(window).off('.panning');\n  }\n\n  updateClassName() {\n    const container = this.view.container;\n    const panning = this.view.prefixClassName('graph-panning');\n    const pannable = this.view.prefixClassName('graph-pannable');\n\n    if (this.pannable) {\n      if (this.panning) {\n        Dom.addClass(container, panning);\n        Dom.removeClass(container, pannable);\n      } else {\n        Dom.removeClass(container, panning);\n        Dom.addClass(container, pannable);\n      }\n    } else {\n      Dom.removeClass(container, panning);\n      Dom.removeClass(container, pannable);\n    }\n  }\n\n  onRightMouseDown(e) {\n    if (e.button === 2 && this.allowPanning(e, true)) {\n      this.startPanning(e);\n    }\n  }\n\n  allowMouseWheel(e) {\n    return this.pannable && !e.ctrlKey;\n  }\n\n  onMouseWheel(e, deltaX, deltaY) {\n    if (!e.ctrlKey) {\n      this.graph.translateBy(-deltaX, -deltaY);\n    }\n  }\n\n  autoPanning(x, y) {\n    const buffer = 10;\n    const graphArea = this.graph.getGraphArea();\n    let dx = 0;\n    let dy = 0;\n\n    if (x <= graphArea.left + buffer) {\n      dx = -buffer;\n    }\n\n    if (y <= graphArea.top + buffer) {\n      dy = -buffer;\n    }\n\n    if (x >= graphArea.right - buffer) {\n      dx = buffer;\n    }\n\n    if (y >= graphArea.bottom - buffer) {\n      dy = buffer;\n    }\n\n    if (dx !== 0 || dy !== 0) {\n      this.graph.translateBy(-dx, -dy);\n    }\n  }\n\n  enablePanning() {\n    if (!this.pannable) {\n      this.widgetOptions.enabled = true;\n      this.updateClassName();\n    }\n  }\n\n  disablePanning() {\n    if (this.pannable) {\n      this.widgetOptions.enabled = false;\n      this.updateClassName();\n    }\n  }\n\n  dispose() {\n    this.stopListening();\n  }\n\n}\n\n__decorate([Base.dispose()], PanningManager.prototype, \"dispose\", null);","map":null,"metadata":{},"sourceType":"module"}