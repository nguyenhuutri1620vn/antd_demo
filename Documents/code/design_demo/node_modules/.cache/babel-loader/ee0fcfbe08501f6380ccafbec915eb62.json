{"ast":null,"code":"import SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\n\nfunction xrange(n, exception) {\n  let range = [];\n\n  for (let i = 0; i < n; i++) {\n    if (i !== exception) {\n      range.push(i);\n    }\n  }\n\n  return range;\n}\n\nfunction dependenciesOneRow(error, matrix, index) {\n  let thresholdValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10e-10;\n  let thresholdError = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10e-10;\n\n  if (error > thresholdError) {\n    return new Array(matrix.rows + 1).fill(0);\n  } else {\n    let returnArray = matrix.addRow(index, [0]);\n\n    for (let i = 0; i < returnArray.rows; i++) {\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\n        returnArray.set(i, 0, 0);\n      }\n    }\n\n    return returnArray.to1DArray();\n  }\n}\n\nexport function linearDependencies(matrix) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    thresholdValue = 10e-10,\n    thresholdError = 10e-10\n  } = options;\n  matrix = Matrix.checkMatrix(matrix);\n  let n = matrix.rows;\n  let results = new Matrix(n, n);\n\n  for (let i = 0; i < n; i++) {\n    let b = Matrix.columnVector(matrix.getRow(i));\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\n    let svd = new SingularValueDecomposition(Abis);\n    let x = svd.solve(b);\n    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();\n    results.setRow(i, dependenciesOneRow(error, x, i, thresholdValue, thresholdError));\n  }\n\n  return results;\n}","map":null,"metadata":{},"sourceType":"module"}