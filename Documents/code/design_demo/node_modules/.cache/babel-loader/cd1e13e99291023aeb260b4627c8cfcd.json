{"ast":null,"code":"export { isFunction, once, noop, debounce, defer } from 'lodash-es';\nexport function apply(fn, ctx, args) {\n  if (args) {\n    switch (args.length) {\n      case 0:\n        return fn.call(ctx);\n\n      case 1:\n        return fn.call(ctx, args[0]);\n\n      case 2:\n        return fn.call(ctx, args[0], args[1]);\n\n      case 3:\n        return fn.call(ctx, args[0], args[1], args[2]);\n\n      case 4:\n        return fn.call(ctx, args[0], args[1], args[2], args[3]);\n\n      case 5:\n        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);\n\n      case 6:\n        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);\n\n      default:\n        return fn.apply(ctx, args);\n    }\n  }\n\n  return fn.call(ctx);\n}\nexport function call(fn, ctx) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return apply(fn, ctx, args);\n}\n\nfunction repush(array, item) {\n  for (let i = 0, ii = array.length; i < ii; i += 1) {\n    if (array[i] === item) {\n      return array.push(array.splice(i, 1)[0]);\n    }\n  }\n}\n\nexport function cacher(fn, ctx, postProcessor) {\n  const keys = [];\n  const cache = {};\n\n  const f = function () {\n    let hasCache = false;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    const key = args.join('\\u2400');\n\n    if (key in cache) {\n      hasCache = true;\n      repush(keys, key);\n    } else {\n      if (keys.length >= 1000) {\n        delete cache[keys.shift()];\n      }\n\n      keys.push(key);\n      cache[key] = apply(fn, ctx || null, args);\n    }\n\n    return postProcessor ? postProcessor(cache[key], hasCache) : cache[key];\n  };\n\n  return f;\n}","map":null,"metadata":{},"sourceType":"module"}