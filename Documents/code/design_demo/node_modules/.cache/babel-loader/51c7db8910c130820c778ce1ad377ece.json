{"ast":null,"code":"'use strict';\n\nmodule.exports = TinySDF;\nmodule.exports.default = TinySDF;\nvar INF = 1e20;\n\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n  this.fontSize = fontSize || 24;\n  this.buffer = buffer === undefined ? 3 : buffer;\n  this.cutoff = cutoff || 0.25;\n  this.fontFamily = fontFamily || 'sans-serif';\n  this.fontWeight = fontWeight || 'normal';\n  this.radius = radius || 8; // For backwards compatibility, we honor the implicit contract that the\n  // size of the returned bitmap will be fontSize + buffer * 2\n\n  var size = this.size = this.fontSize + this.buffer * 2; // Glyphs may be slightly larger than their fontSize. The canvas already\n  // has buffer space, but create extra buffer space in the output grid for the\n  // \"halo\" to extend into (if metric extraction is enabled)\n\n  var gridSize = size + this.buffer * 2;\n  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;\n\n  if (!isMiniAli) {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.canvas.height = size;\n  } else {\n    this.canvas = my.createOffscreenCanvas(size, size, '2d');\n  }\n\n  this.ctx = this.canvas.getContext('2d');\n  this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n  this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n\n  this.ctx.fillStyle = 'black'; // temporary arrays for the distance transform\n\n  this.gridOuter = new Float64Array(gridSize * gridSize);\n  this.gridInner = new Float64Array(gridSize * gridSize);\n  this.f = new Float64Array(gridSize);\n  this.z = new Float64Array(gridSize + 1);\n  this.v = new Uint16Array(gridSize);\n  this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined; // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n\n  if (isMiniAli) {\n    this.middle = Math.round(size / 2 * 1);\n  } else {\n    this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n  }\n}\n\nfunction prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {\n  // Initialize grids outside the glyph range to alpha 0\n  gridOuter.fill(INF, 0, width * height);\n  gridInner.fill(0, 0, width * height);\n  var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics\n\n  for (var y = 0; y < glyphHeight; y++) {\n    for (var x = 0; x < glyphWidth; x++) {\n      var j = (y + offset) * width + x + offset;\n      var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n\n      if (a === 1) {\n        gridOuter[j] = 0;\n        gridInner[j] = INF;\n      } else if (a === 0) {\n        gridOuter[j] = INF;\n        gridInner[j] = 0;\n      } else {\n        var b = Math.max(0, 0.5 - a);\n        var c = Math.max(0, a - 0.5);\n        gridOuter[j] = b * b;\n        gridInner[j] = c * c;\n      }\n    }\n  }\n}\n\nfunction extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {\n  for (var i = 0; i < width * height; i++) {\n    var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n    alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));\n  }\n}\n\nTinySDF.prototype._draw = function (char, getMetrics) {\n  var textMetrics = this.ctx.measureText(char); // Older browsers only expose the glyph width\n  // This is enough for basic layout with all glyphs using the same fixed size\n\n  var advance = textMetrics.width;\n  var doubleBuffer = 2 * this.buffer;\n  var width, glyphWidth, height, glyphHeight, top;\n  var imgTop, imgLeft, baselinePosition; // If the browser supports bounding box metrics, we can generate a smaller\n  // SDF. This is a significant performance win.\n\n  if (getMetrics && this.useMetrics) {\n    // The integer/pixel part of the top alignment is encoded in metrics.top\n    // The remainder is implicitly encoded in the rasterization\n    top = Math.floor(textMetrics.actualBoundingBoxAscent);\n    baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);\n    imgTop = this.buffer;\n    imgLeft = this.buffer; // If the glyph overflows the canvas size, it will be clipped at the\n    // bottom/right\n\n    glyphWidth = Math.min(this.size, Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));\n    glyphHeight = Math.min(this.size - imgTop, Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));\n    width = glyphWidth + doubleBuffer;\n    height = glyphHeight + doubleBuffer;\n    this.ctx.textBaseline = 'alphabetic';\n  } else {\n    width = glyphWidth = this.size;\n    height = glyphHeight = this.size; // 19 points is an approximation of the \"cap height\" ascent from alphabetic\n    // baseline (even though actual drawing is from middle baseline, we can\n    // use the approximation because every glyph fills the em box)\n\n    top = 19 * this.fontSize / 24;\n    imgTop = imgLeft = 0;\n    baselinePosition = this.middle;\n    this.ctx.textBaseline = 'middle';\n  }\n\n  var imgData;\n\n  if (glyphWidth && glyphHeight) {\n    this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);\n    this.ctx.fillText(char, this.buffer, baselinePosition);\n    imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);\n  }\n\n  var alphaChannel = new Uint8ClampedArray(width * height);\n  prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);\n  edt(this.gridOuter, width, height, this.f, this.v, this.z);\n  edt(this.gridInner, width, height, this.f, this.v, this.z);\n  extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);\n  return {\n    data: alphaChannel,\n    metrics: {\n      width: glyphWidth,\n      height: glyphHeight,\n      sdfWidth: width,\n      sdfHeight: height,\n      top: top,\n      left: 0,\n      advance: advance\n    }\n  };\n};\n\nTinySDF.prototype.draw = function (char) {\n  return this._draw(char, false).data;\n};\n\nTinySDF.prototype.drawWithMetrics = function (char) {\n  return this._draw(char, true);\n}; // 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\n\n\nfunction edt(data, width, height, f, v, z) {\n  for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);\n\n  for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);\n} // 1D squared distance transform\n\n\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n  var q, k, s, r;\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = INF;\n\n  for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];\n\n  for (q = 1, k = 0, s = 0; q < length; q++) {\n    do {\n      r = v[k];\n      s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;\n    } while (s <= z[k] && --k > -1);\n\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = INF;\n  }\n\n  for (q = 0, k = 0; q < length; q++) {\n    while (z[k + 1] < q) k++;\n\n    r = v[k];\n    grid[offset + q * stride] = f[r] + (q - r) * (q - r);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}