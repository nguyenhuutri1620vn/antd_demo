{"ast":null,"code":"const extendStatics = Object.setPrototypeOf || {\n  __proto__: []\n} instanceof Array && function (d, b) {\n  d.__proto__ = b; // eslint-disable-line no-proto\n} || function (d, b) {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const p in b) {\n    if (Object.prototype.hasOwnProperty.call(b, p)) {\n      d[p] = b[p];\n    }\n  }\n};\n/**\n * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309\n */\n// eslint-disable-next-line\n\n\nexport function inherit(cls, base) {\n  extendStatics(cls, base);\n\n  function tmp() {\n    this.constructor = cls;\n  }\n\n  cls.prototype = base === null ? Object.create(base) : (tmp.prototype = base.prototype, new tmp());\n}\n\nclass A {}\n\nconst isNativeClass = /^\\s*class\\s+/.test(`${A}`) || /^\\s*class\\s*\\{/.test(`${class {}}`);\n/**\n * Extends class with specified class name.\n */\n// eslint-disable-next-line\n\nexport function createClass(className, base) {\n  let cls;\n\n  if (isNativeClass) {\n    // eslint-disable-next-line no-new-func\n    cls = new Function('base', `return class ${className} extends base { }`)(base);\n  } else {\n    // eslint-disable-next-line no-new-func\n    cls = new Function('base', `return function ${className}() { return base.apply(this, arguments) }`)(base);\n    inherit(cls, base);\n  }\n\n  return cls;\n}","map":null,"metadata":{},"sourceType":"module"}