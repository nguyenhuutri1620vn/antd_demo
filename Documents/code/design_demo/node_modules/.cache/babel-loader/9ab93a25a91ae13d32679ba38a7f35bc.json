{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport * as d3Force from \"d3-force\";\nimport forceInABox from \"./force-in-a-box\";\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * 经典力导布局 force-directed\n */\n\nexport class ForceLayout extends Base {\n  constructor(options) {\n    super();\n    /** 向心力作用点 */\n\n    this.center = [0, 0];\n    /** 节点作用力 */\n\n    this.nodeStrength = null;\n    /** 边的作用力, 默认为根据节点的入度出度自适应 */\n\n    this.edgeStrength = null;\n    /** 是否防止节点相互覆盖 */\n\n    this.preventOverlap = false;\n    /** 聚类节点作用力 */\n\n    this.clusterNodeStrength = null;\n    /** 聚类边作用力 */\n\n    this.clusterEdgeStrength = null;\n    /** 聚类边长度 */\n\n    this.clusterEdgeDistance = null;\n    /** 聚类节点大小 / 直径，直径越大，越分散 */\n\n    this.clusterNodeSize = null;\n    /** 用于 foci 的力 */\n\n    this.clusterFociStrength = null;\n    /** 默认边长度 */\n\n    this.linkDistance = 50;\n    /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n\n    this.alphaDecay = 0.028;\n    /** 停止迭代的阈值 */\n\n    this.alphaMin = 0.001;\n    /** 当前阈值 */\n\n    this.alpha = 0.3;\n    /** 防止重叠的力强度 */\n\n    this.collideStrength = 1;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    this.workerEnabled = false;\n\n    this.tick = () => {};\n    /** 布局完成回调 */\n\n\n    this.onLayoutEnd = () => {};\n    /** 是否正在布局 */\n\n\n    this.ticking = undefined;\n\n    if (options) {\n      this.updateCfg(options);\n    }\n  }\n\n  getDefaultCfg() {\n    return {\n      center: [0, 0],\n      nodeStrength: null,\n      edgeStrength: null,\n      preventOverlap: false,\n      nodeSize: undefined,\n      nodeSpacing: undefined,\n      linkDistance: 50,\n      forceSimulation: null,\n      alphaDecay: 0.028,\n      alphaMin: 0.001,\n      alpha: 0.3,\n      collideStrength: 1,\n      clustering: false,\n      clusterNodeStrength: -1,\n      clusterEdgeStrength: 0.1,\n      clusterEdgeDistance: 100,\n      clusterFociStrength: 0.8,\n      clusterNodeSize: 10,\n\n      tick() {},\n\n      onLayoutEnd() {},\n\n      // 是否启用web worker。前提是在web worker里执行布局，否则无效\n      workerEnabled: false\n    };\n  }\n  /**\n   * 初始化\n   * @param {object} data 数据\n   */\n\n\n  init(data) {\n    const self = this;\n    self.nodes = data.nodes || [];\n    const edges = data.edges || [];\n    self.edges = edges.map(edge => {\n      const res = {};\n      const expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n      Object.keys(edge).forEach(key => {\n        if (!(expectKeys.indexOf(key) > -1)) {\n          res[key] = edge[key];\n        }\n      });\n      return res;\n    });\n    self.ticking = false;\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute(reloadData) {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges; // 如果正在布局，忽略布局请求\n\n    if (self.ticking) {\n      return;\n    }\n\n    let simulation = self.forceSimulation;\n    const alphaMin = self.alphaMin;\n    const alphaDecay = self.alphaDecay;\n    const alpha = self.alpha;\n\n    if (!simulation) {\n      try {\n        // 定义节点的力\n        const nodeForce = d3Force.forceManyBody();\n\n        if (self.nodeStrength) {\n          nodeForce.strength(self.nodeStrength);\n        }\n\n        simulation = d3Force.forceSimulation().nodes(nodes);\n\n        if (self.clustering) {\n          const clusterForce = forceInABox();\n          clusterForce.centerX(self.center[0]).centerY(self.center[1]).template(\"force\").strength(self.clusterFociStrength);\n\n          if (edges) {\n            clusterForce.links(edges);\n          }\n\n          if (nodes) {\n            clusterForce.nodes(nodes);\n          }\n\n          clusterForce.forceLinkDistance(self.clusterEdgeDistance).forceLinkStrength(self.clusterEdgeStrength).forceCharge(self.clusterNodeStrength).forceNodeSize(self.clusterNodeSize);\n          self.clusterForce = clusterForce;\n          simulation.force(\"group\", clusterForce);\n        }\n\n        simulation.force(\"center\", d3Force.forceCenter(self.center[0], self.center[1])).force(\"charge\", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);\n\n        if (self.preventOverlap) {\n          self.overlapProcess(simulation);\n        } // 如果有边，定义边的力\n\n\n        if (edges) {\n          // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n          const edgeForce = d3Force.forceLink().id(d => d.id).links(edges);\n\n          if (self.edgeStrength) {\n            edgeForce.strength(self.edgeStrength);\n          }\n\n          if (self.linkDistance) {\n            edgeForce.distance(self.linkDistance);\n          }\n\n          self.edgeForce = edgeForce;\n          simulation.force(\"link\", edgeForce);\n        }\n\n        if (self.workerEnabled && !isInWorker()) {\n          // 如果不是运行在web worker里，不用web worker布局\n          self.workerEnabled = false;\n          console.warn(\"workerEnabled option is only supported when running in web worker.\");\n        }\n\n        if (!self.workerEnabled) {\n          simulation.on(\"tick\", () => {\n            self.tick();\n          }).on(\"end\", () => {\n            self.ticking = false;\n            if (self.onLayoutEnd) self.onLayoutEnd();\n          });\n          self.ticking = true;\n        } else {\n          // worker is enabled\n          simulation.stop();\n          const totalTicks = getSimulationTicks(simulation);\n\n          for (let currentTick = 1; currentTick <= totalTicks; currentTick++) {\n            simulation.tick(); // currentTick starts from 1.\n\n            postMessage({\n              nodes,\n              currentTick,\n              totalTicks,\n              type: LAYOUT_MESSAGE.TICK\n            }, undefined);\n          }\n\n          self.ticking = false;\n        }\n\n        self.forceSimulation = simulation;\n        self.ticking = true;\n      } catch (e) {\n        self.ticking = false;\n        console.warn(e);\n      }\n    } else {\n      if (reloadData) {\n        if (self.clustering && self.clusterForce) {\n          self.clusterForce.nodes(nodes);\n          self.clusterForce.links(edges);\n        }\n\n        simulation.nodes(nodes);\n        if (edges && self.edgeForce) self.edgeForce.links(edges);else if (edges && !self.edgeForce) {\n          // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n          const edgeForce = d3Force.forceLink().id(d => d.id).links(edges);\n\n          if (self.edgeStrength) {\n            edgeForce.strength(self.edgeStrength);\n          }\n\n          if (self.linkDistance) {\n            edgeForce.distance(self.linkDistance);\n          }\n\n          self.edgeForce = edgeForce;\n          simulation.force(\"link\", edgeForce);\n        }\n      }\n\n      if (self.preventOverlap) {\n        self.overlapProcess(simulation);\n      }\n\n      simulation.alpha(alpha).restart();\n      this.ticking = true;\n    }\n  }\n  /**\n   * 防止重叠\n   * @param {object} simulation 力模拟模型\n   */\n\n\n  overlapProcess(simulation) {\n    const self = this;\n    const nodeSize = self.nodeSize;\n    const nodeSpacing = self.nodeSpacing;\n    let nodeSizeFunc;\n    let nodeSpacingFunc;\n    const collideStrength = self.collideStrength;\n\n    if (isNumber(nodeSpacing)) {\n      nodeSpacingFunc = () => nodeSpacing;\n    } else if (isFunction(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = () => 0;\n    }\n\n    if (!nodeSize) {\n      nodeSizeFunc = d => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2 + nodeSpacingFunc(d);\n          }\n\n          if (isObject(d.size)) {\n            const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return res / 2 + nodeSpacingFunc(d);\n          }\n\n          return d.size / 2 + nodeSpacingFunc(d);\n        }\n\n        return 10 + nodeSpacingFunc(d);\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = d => {\n        const size = nodeSize(d);\n        return size + nodeSpacingFunc(d);\n      };\n    } else if (isArray(nodeSize)) {\n      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      const radius = larger / 2;\n\n      nodeSizeFunc = d => radius + nodeSpacingFunc(d);\n    } else if (isNumber(nodeSize)) {\n      const radius = nodeSize / 2;\n\n      nodeSizeFunc = d => radius + nodeSpacingFunc(d);\n    } else {\n      nodeSizeFunc = () => 10;\n    } // forceCollide's parameter is a radius\n\n\n    simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n  }\n  /**\n   * 更新布局配置，但不执行布局\n   * @param {object} cfg 需要更新的配置项\n   */\n\n\n  updateCfg(cfg) {\n    const self = this;\n\n    if (self.ticking) {\n      self.forceSimulation.stop();\n      self.ticking = false;\n    }\n\n    self.forceSimulation = null;\n    Object.assign(self, cfg);\n  }\n\n  destroy() {\n    const self = this;\n\n    if (self.ticking) {\n      self.forceSimulation.stop();\n      self.ticking = false;\n    }\n\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  }\n\n} // Return total ticks of d3-force simulation\n\nfunction getSimulationTicks(simulation) {\n  const alphaMin = simulation.alphaMin();\n  const alphaTarget = simulation.alphaTarget();\n  const alpha = simulation.alpha();\n  const totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());\n  const totalTicks = Math.ceil(totalTicksFloat);\n  return totalTicks;\n} // 判断是否运行在web worker里\n\n\nfunction isInWorker() {\n  // eslint-disable-next-line no-undef\n  return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}","map":null,"metadata":{},"sourceType":"module"}