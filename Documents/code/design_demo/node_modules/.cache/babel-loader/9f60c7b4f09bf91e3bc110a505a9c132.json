{"ast":null,"code":"import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\nimport { hypotenuse } from './util';\nexport default class SingularValueDecomposition {\n  constructor(value) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    if (value.isEmpty()) {\n      throw new Error('Matrix must be non-empty');\n    }\n\n    let m = value.rows;\n    let n = value.columns;\n    const {\n      computeLeftSingularVectors = true,\n      computeRightSingularVectors = true,\n      autoTranspose = false\n    } = options;\n    let wantu = Boolean(computeLeftSingularVectors);\n    let wantv = Boolean(computeRightSingularVectors);\n    let swapped = false;\n    let a;\n\n    if (m < n) {\n      if (!autoTranspose) {\n        a = value.clone(); // eslint-disable-next-line no-console\n\n        console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n      } else {\n        a = value.transpose();\n        m = a.rows;\n        n = a.columns;\n        swapped = true;\n        let aux = wantu;\n        wantu = wantv;\n        wantv = aux;\n      }\n    } else {\n      a = value.clone();\n    }\n\n    let nu = Math.min(m, n);\n    let ni = Math.min(m + 1, n);\n    let s = new Float64Array(ni);\n    let U = new Matrix(m, nu);\n    let V = new Matrix(n, n);\n    let e = new Float64Array(n);\n    let work = new Float64Array(m);\n    let si = new Float64Array(ni);\n\n    for (let i = 0; i < ni; i++) si[i] = i;\n\n    let nct = Math.min(m - 1, n);\n    let nrt = Math.max(0, Math.min(n - 2, m));\n    let mrc = Math.max(nct, nrt);\n\n    for (let k = 0; k < mrc; k++) {\n      if (k < nct) {\n        s[k] = 0;\n\n        for (let i = k; i < m; i++) {\n          s[k] = hypotenuse(s[k], a.get(i, k));\n        }\n\n        if (s[k] !== 0) {\n          if (a.get(k, k) < 0) {\n            s[k] = -s[k];\n          }\n\n          for (let i = k; i < m; i++) {\n            a.set(i, k, a.get(i, k) / s[k]);\n          }\n\n          a.set(k, k, a.get(k, k) + 1);\n        }\n\n        s[k] = -s[k];\n      }\n\n      for (let j = k + 1; j < n; j++) {\n        if (k < nct && s[k] !== 0) {\n          let t = 0;\n\n          for (let i = k; i < m; i++) {\n            t += a.get(i, k) * a.get(i, j);\n          }\n\n          t = -t / a.get(k, k);\n\n          for (let i = k; i < m; i++) {\n            a.set(i, j, a.get(i, j) + t * a.get(i, k));\n          }\n        }\n\n        e[j] = a.get(k, j);\n      }\n\n      if (wantu && k < nct) {\n        for (let i = k; i < m; i++) {\n          U.set(i, k, a.get(i, k));\n        }\n      }\n\n      if (k < nrt) {\n        e[k] = 0;\n\n        for (let i = k + 1; i < n; i++) {\n          e[k] = hypotenuse(e[k], e[i]);\n        }\n\n        if (e[k] !== 0) {\n          if (e[k + 1] < 0) {\n            e[k] = 0 - e[k];\n          }\n\n          for (let i = k + 1; i < n; i++) {\n            e[i] /= e[k];\n          }\n\n          e[k + 1] += 1;\n        }\n\n        e[k] = -e[k];\n\n        if (k + 1 < m && e[k] !== 0) {\n          for (let i = k + 1; i < m; i++) {\n            work[i] = 0;\n          }\n\n          for (let i = k + 1; i < m; i++) {\n            for (let j = k + 1; j < n; j++) {\n              work[i] += e[j] * a.get(i, j);\n            }\n          }\n\n          for (let j = k + 1; j < n; j++) {\n            let t = -e[j] / e[k + 1];\n\n            for (let i = k + 1; i < m; i++) {\n              a.set(i, j, a.get(i, j) + t * work[i]);\n            }\n          }\n        }\n\n        if (wantv) {\n          for (let i = k + 1; i < n; i++) {\n            V.set(i, k, e[i]);\n          }\n        }\n      }\n    }\n\n    let p = Math.min(n, m + 1);\n\n    if (nct < n) {\n      s[nct] = a.get(nct, nct);\n    }\n\n    if (m < p) {\n      s[p - 1] = 0;\n    }\n\n    if (nrt + 1 < p) {\n      e[nrt] = a.get(nrt, p - 1);\n    }\n\n    e[p - 1] = 0;\n\n    if (wantu) {\n      for (let j = nct; j < nu; j++) {\n        for (let i = 0; i < m; i++) {\n          U.set(i, j, 0);\n        }\n\n        U.set(j, j, 1);\n      }\n\n      for (let k = nct - 1; k >= 0; k--) {\n        if (s[k] !== 0) {\n          for (let j = k + 1; j < nu; j++) {\n            let t = 0;\n\n            for (let i = k; i < m; i++) {\n              t += U.get(i, k) * U.get(i, j);\n            }\n\n            t = -t / U.get(k, k);\n\n            for (let i = k; i < m; i++) {\n              U.set(i, j, U.get(i, j) + t * U.get(i, k));\n            }\n          }\n\n          for (let i = k; i < m; i++) {\n            U.set(i, k, -U.get(i, k));\n          }\n\n          U.set(k, k, 1 + U.get(k, k));\n\n          for (let i = 0; i < k - 1; i++) {\n            U.set(i, k, 0);\n          }\n        } else {\n          for (let i = 0; i < m; i++) {\n            U.set(i, k, 0);\n          }\n\n          U.set(k, k, 1);\n        }\n      }\n    }\n\n    if (wantv) {\n      for (let k = n - 1; k >= 0; k--) {\n        if (k < nrt && e[k] !== 0) {\n          for (let j = k + 1; j < n; j++) {\n            let t = 0;\n\n            for (let i = k + 1; i < n; i++) {\n              t += V.get(i, k) * V.get(i, j);\n            }\n\n            t = -t / V.get(k + 1, k);\n\n            for (let i = k + 1; i < n; i++) {\n              V.set(i, j, V.get(i, j) + t * V.get(i, k));\n            }\n          }\n        }\n\n        for (let i = 0; i < n; i++) {\n          V.set(i, k, 0);\n        }\n\n        V.set(k, k, 1);\n      }\n    }\n\n    let pp = p - 1;\n    let iter = 0;\n    let eps = Number.EPSILON;\n\n    while (p > 0) {\n      let k, kase;\n\n      for (k = p - 2; k >= -1; k--) {\n        if (k === -1) {\n          break;\n        }\n\n        const alpha = Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));\n\n        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {\n          e[k] = 0;\n          break;\n        }\n      }\n\n      if (k === p - 2) {\n        kase = 4;\n      } else {\n        let ks;\n\n        for (ks = p - 1; ks >= k; ks--) {\n          if (ks === k) {\n            break;\n          }\n\n          let t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n\n          if (Math.abs(s[ks]) <= eps * t) {\n            s[ks] = 0;\n            break;\n          }\n        }\n\n        if (ks === k) {\n          kase = 3;\n        } else if (ks === p - 1) {\n          kase = 1;\n        } else {\n          kase = 2;\n          k = ks;\n        }\n      }\n\n      k++;\n\n      switch (kase) {\n        case 1:\n          {\n            let f = e[p - 2];\n            e[p - 2] = 0;\n\n            for (let j = p - 2; j >= k; j--) {\n              let t = hypotenuse(s[j], f);\n              let cs = s[j] / t;\n              let sn = f / t;\n              s[j] = t;\n\n              if (j !== k) {\n                f = -sn * e[j - 1];\n                e[j - 1] = cs * e[j - 1];\n              }\n\n              if (wantv) {\n                for (let i = 0; i < n; i++) {\n                  t = cs * V.get(i, j) + sn * V.get(i, p - 1);\n                  V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));\n                  V.set(i, j, t);\n                }\n              }\n            }\n\n            break;\n          }\n\n        case 2:\n          {\n            let f = e[k - 1];\n            e[k - 1] = 0;\n\n            for (let j = k; j < p; j++) {\n              let t = hypotenuse(s[j], f);\n              let cs = s[j] / t;\n              let sn = f / t;\n              s[j] = t;\n              f = -sn * e[j];\n              e[j] = cs * e[j];\n\n              if (wantu) {\n                for (let i = 0; i < m; i++) {\n                  t = cs * U.get(i, j) + sn * U.get(i, k - 1);\n                  U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));\n                  U.set(i, j, t);\n                }\n              }\n            }\n\n            break;\n          }\n\n        case 3:\n          {\n            const scale = Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2]), Math.abs(e[p - 2]), Math.abs(s[k]), Math.abs(e[k]));\n            const sp = s[p - 1] / scale;\n            const spm1 = s[p - 2] / scale;\n            const epm1 = e[p - 2] / scale;\n            const sk = s[k] / scale;\n            const ek = e[k] / scale;\n            const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n            const c = sp * epm1 * (sp * epm1);\n            let shift = 0;\n\n            if (b !== 0 || c !== 0) {\n              if (b < 0) {\n                shift = 0 - Math.sqrt(b * b + c);\n              } else {\n                shift = Math.sqrt(b * b + c);\n              }\n\n              shift = c / (b + shift);\n            }\n\n            let f = (sk + sp) * (sk - sp) + shift;\n            let g = sk * ek;\n\n            for (let j = k; j < p - 1; j++) {\n              let t = hypotenuse(f, g);\n              if (t === 0) t = Number.MIN_VALUE;\n              let cs = f / t;\n              let sn = g / t;\n\n              if (j !== k) {\n                e[j - 1] = t;\n              }\n\n              f = cs * s[j] + sn * e[j];\n              e[j] = cs * e[j] - sn * s[j];\n              g = sn * s[j + 1];\n              s[j + 1] = cs * s[j + 1];\n\n              if (wantv) {\n                for (let i = 0; i < n; i++) {\n                  t = cs * V.get(i, j) + sn * V.get(i, j + 1);\n                  V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));\n                  V.set(i, j, t);\n                }\n              }\n\n              t = hypotenuse(f, g);\n              if (t === 0) t = Number.MIN_VALUE;\n              cs = f / t;\n              sn = g / t;\n              s[j] = t;\n              f = cs * e[j] + sn * s[j + 1];\n              s[j + 1] = -sn * e[j] + cs * s[j + 1];\n              g = sn * e[j + 1];\n              e[j + 1] = cs * e[j + 1];\n\n              if (wantu && j < m - 1) {\n                for (let i = 0; i < m; i++) {\n                  t = cs * U.get(i, j) + sn * U.get(i, j + 1);\n                  U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));\n                  U.set(i, j, t);\n                }\n              }\n            }\n\n            e[p - 2] = f;\n            iter = iter + 1;\n            break;\n          }\n\n        case 4:\n          {\n            if (s[k] <= 0) {\n              s[k] = s[k] < 0 ? -s[k] : 0;\n\n              if (wantv) {\n                for (let i = 0; i <= pp; i++) {\n                  V.set(i, k, -V.get(i, k));\n                }\n              }\n            }\n\n            while (k < pp) {\n              if (s[k] >= s[k + 1]) {\n                break;\n              }\n\n              let t = s[k];\n              s[k] = s[k + 1];\n              s[k + 1] = t;\n\n              if (wantv && k < n - 1) {\n                for (let i = 0; i < n; i++) {\n                  t = V.get(i, k + 1);\n                  V.set(i, k + 1, V.get(i, k));\n                  V.set(i, k, t);\n                }\n              }\n\n              if (wantu && k < m - 1) {\n                for (let i = 0; i < m; i++) {\n                  t = U.get(i, k + 1);\n                  U.set(i, k + 1, U.get(i, k));\n                  U.set(i, k, t);\n                }\n              }\n\n              k++;\n            }\n\n            iter = 0;\n            p--;\n            break;\n          }\n        // no default\n      }\n    }\n\n    if (swapped) {\n      let tmp = V;\n      V = U;\n      U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n  }\n\n  solve(value) {\n    let Y = value;\n    let e = this.threshold;\n    let scols = this.s.length;\n    let Ls = Matrix.zeros(scols, scols);\n\n    for (let i = 0; i < scols; i++) {\n      if (Math.abs(this.s[i]) <= e) {\n        Ls.set(i, i, 0);\n      } else {\n        Ls.set(i, i, 1 / this.s[i]);\n      }\n    }\n\n    let U = this.U;\n    let V = this.rightSingularVectors;\n    let VL = V.mmul(Ls);\n    let vrows = V.rows;\n    let urows = U.rows;\n    let VLU = Matrix.zeros(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n\n        for (let k = 0; k < scols; k++) {\n          sum += VL.get(i, k) * U.get(j, k);\n        }\n\n        VLU.set(i, j, sum);\n      }\n    }\n\n    return VLU.mmul(Y);\n  }\n\n  solveForDiagonal(value) {\n    return this.solve(Matrix.diag(value));\n  }\n\n  inverse() {\n    let V = this.V;\n    let e = this.threshold;\n    let vrows = V.rows;\n    let vcols = V.columns;\n    let X = new Matrix(vrows, this.s.length);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < vcols; j++) {\n        if (Math.abs(this.s[j]) > e) {\n          X.set(i, j, V.get(i, j) / this.s[j]);\n        }\n      }\n    }\n\n    let U = this.U;\n    let urows = U.rows;\n    let ucols = U.columns;\n    let Y = new Matrix(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n\n        for (let k = 0; k < ucols; k++) {\n          sum += X.get(i, k) * U.get(j, k);\n        }\n\n        Y.set(i, j, sum);\n      }\n    }\n\n    return Y;\n  }\n\n  get condition() {\n    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n  }\n\n  get norm2() {\n    return this.s[0];\n  }\n\n  get rank() {\n    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;\n    let r = 0;\n    let s = this.s;\n\n    for (let i = 0, ii = s.length; i < ii; i++) {\n      if (s[i] > tol) {\n        r++;\n      }\n    }\n\n    return r;\n  }\n\n  get diagonal() {\n    return Array.from(this.s);\n  }\n\n  get threshold() {\n    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];\n  }\n\n  get leftSingularVectors() {\n    return this.U;\n  }\n\n  get rightSingularVectors() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    return Matrix.diag(this.s);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}