{"ast":null,"code":"import { FunctionExt } from '../../../util';\nimport { Point, Rectangle } from '../../../geometry';\nimport { SortedSet } from './sorted-set';\nimport { ObstacleMap } from './obstacle-map';\nimport * as util from './util';\nimport { resolveOptions } from './options';\n/**\n * Finds the route between two points (`from`, `to`).\n */\n\nfunction findRoute(edgeView, from, to, map, options) {\n  const precision = options.precision;\n  let sourceEndpoint;\n  let targetEndpoint;\n\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(util.getSourceEndpoint(edgeView, options).clone(), precision);\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision);\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(util.getTargetEndpoint(edgeView, options).clone(), precision);\n  } else {\n    targetEndpoint = util.round(to.clone(), precision);\n  } // Get grid for this route.\n\n\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint); // Get pathfinding points.\n  // -----------------------\n\n  const startPoint = sourceEndpoint;\n  const endPoint = targetEndpoint;\n  let startPoints;\n  let endPoints;\n\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(startPoint, from, options.startDirections, grid, options);\n  } else {\n    startPoints = [startPoint];\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);\n  } else {\n    endPoints = [endPoint];\n  } // take into account only accessible rect points (those not under obstacles)\n\n\n  startPoints = startPoints.filter(p => map.isAccessible(p));\n  endPoints = endPoints.filter(p => map.isAccessible(p)); // There is an accessible route point on both sides.\n\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet(); // Keeps the actual points for given nodes of the open set.\n\n    const points = {}; // Keeps the point that is immediate predecessor of given element.\n\n    const parents = {}; // Cost from start to a point along best known path.\n\n    const costs = {};\n\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i];\n      const key = util.getKey(startPoint);\n      openSet.add(key, util.getCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n\n    const previousRouteDirectionAngle = options.previousDirectionAngle; // undefined for first route\n\n    const isPathBeginning = previousRouteDirectionAngle === undefined; // directions\n\n    let direction;\n    let directionChange;\n    const directions = util.getGridOffsets(grid, options);\n    const numDirections = directions.length;\n    const endPointsKeys = endPoints.reduce((res, endPoint) => {\n      const key = util.getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []); // main route finding loop\n\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);\n    let loopsRemaining = options.maxLoopCount;\n\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop();\n      const currentPoint = points[currentKey];\n      const currentParent = parents[currentKey];\n      const currentCost = costs[currentKey];\n      const isStartPoint = currentPoint.equals(startPoint);\n      const isRouteBeginning = currentParent == null;\n      let previousDirectionAngle;\n\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle;\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);\n      } else {\n        previousDirectionAngle = null;\n      } // Check if we reached any endpoint\n\n\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints;\n\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle;\n        return util.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);\n      } // Go over all possible directions and find neighbors\n\n\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i];\n        const directionAngle = direction.angle;\n        directionChange = util.getDirectionChange(previousDirectionAngle, directionAngle); // Don't use the point changed rapidly.\n\n        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {\n          continue;\n        }\n\n        const neighborPoint = util.align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);\n        const neighborKey = util.getKey(neighborPoint); // Closed points were already evaluated.\n\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue;\n        } // Neighbor is an end point.\n\n\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint);\n\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);\n            const endDirectionChange = util.getDirectionChange(directionAngle, endDirectionAngle);\n\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue;\n            }\n          }\n        } // The current direction is ok.\n        // ----------------------------\n\n\n        const neighborCost = direction.cost;\n        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];\n        const costFromStart = currentCost + neighborCost + neighborPenalty; // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + util.getCost(neighborPoint, endPoints));\n        }\n      }\n\n      loopsRemaining -= 1;\n    }\n  }\n\n  if (options.fallbackRoute) {\n    return FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);\n  }\n\n  return null;\n}\n\nexport const router = function (vertices, optionsRaw, edgeView) {\n  const options = resolveOptions(optionsRaw);\n  const sourceBBox = util.getSourceBBox(edgeView, options);\n  const targetBBox = util.getTargetBBox(edgeView, options);\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options); // pathfinding\n\n  const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);\n  const oldVertices = vertices.map(p => Point.create(p));\n  const newVertices = []; // The origin of first route's grid, does not need snapping\n\n  let tailPoint = sourceEndpoint;\n  let from;\n  let to;\n\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i]; // This is the last iteration\n\n    if (to == null) {\n      to = targetBBox; // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n\n      const edge = edgeView.cell;\n      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;\n\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from;\n        const dragTo = to.getOrigin();\n        partialRoute = FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);\n      }\n    } // Find the partial route\n\n\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options);\n    } // Cannot found the partial route.\n\n\n    if (partialRoute === null) {\n      return FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);\n    } // Remove the first point if the previous partial route has\n    // the same point as last.\n\n\n    const leadPoint = partialRoute[0];\n\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift();\n    } // Save tailPoint for next iteration\n\n\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    newVertices.push(...partialRoute);\n  }\n\n  return newVertices;\n};","map":null,"metadata":{},"sourceType":"module"}