{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction getAnchorAlignment(anchor) {\n  var horizontalAlign = 0.5;\n  var verticalAlign = 0.5;\n\n  switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n      horizontalAlign = 1;\n      break;\n\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n      horizontalAlign = 0;\n      break;\n\n    default:\n      horizontalAlign = 0.5;\n  }\n\n  switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n      verticalAlign = 1;\n      break;\n\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n      verticalAlign = 0;\n      break;\n\n    default:\n      verticalAlign = 0.5;\n  }\n\n  return {\n    horizontalAlign: horizontalAlign,\n    verticalAlign: verticalAlign\n  };\n}\n\nfunction justifyLine(positionedGlyphs, glyphMap, start, end, justify) {\n  if (!justify) {\n    return;\n  }\n\n  var lastPositionedGlyph = positionedGlyphs[end];\n  var glyph = lastPositionedGlyph.glyph;\n\n  if (glyph) {\n    var lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;\n    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n    for (var j = start; j <= end; j++) {\n      positionedGlyphs[j].x -= lineIndent;\n    }\n  }\n}\n\nfunction align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {\n  var shiftX = (justify - horizontalAlign) * maxLineLength;\n  var shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n\n  var _iterator = _createForOfIteratorHelper(positionedGlyphs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var glyphs = _step.value;\n      glyphs.x += shiftX;\n      glyphs.y += shiftY;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {\n  var yOffset = -8;\n  var x = 0;\n  var y = yOffset;\n  var maxLineLength = 0;\n  var positionedGlyphs = shaping.positionedGlyphs;\n  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  var lineStartIndex = positionedGlyphs.length;\n  lines.forEach(function (line) {\n    line.split('').forEach(function (char) {\n      var glyph = glyphMap[char];\n      var baselineOffset = 0;\n\n      if (glyph) {\n        positionedGlyphs.push({\n          glyph: char,\n          x: x,\n          y: y + baselineOffset,\n          vertical: false,\n          scale: 1,\n          metrics: glyph\n        });\n        x += glyph.advance + spacing;\n      }\n    });\n\n    if (positionedGlyphs.length !== lineStartIndex) {\n      var lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n\n    x = 0;\n    y -= lineHeight + 5;\n  });\n\n  var _getAnchorAlignment = getAnchorAlignment(textAnchor),\n      horizontalAlign = _getAnchorAlignment.horizontalAlign,\n      verticalAlign = _getAnchorAlignment.verticalAlign;\n\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n  var height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\nfunction shapeIconFont(shaping, glyphMap, iconfonts, lineHeight, textAnchor, textJustify, spacing) {\n  var yOffset = -8;\n  var x = 0;\n  var y = yOffset;\n  var maxLineLength = 0;\n  var positionedGlyphs = shaping.positionedGlyphs;\n  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  var lineStartIndex = positionedGlyphs.length;\n  iconfonts.forEach(function (iconfont) {\n    var glyph = glyphMap[iconfont];\n    var baselineOffset = 0;\n\n    if (glyph) {\n      positionedGlyphs.push({\n        glyph: iconfont,\n        x: x,\n        y: y + baselineOffset,\n        vertical: false,\n        scale: 1,\n        metrics: glyph\n      });\n      x += glyph.advance + spacing;\n    }\n\n    if (positionedGlyphs.length !== lineStartIndex) {\n      var lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n\n    x = 0;\n    y -= lineHeight + 5;\n  });\n\n  var _getAnchorAlignment2 = getAnchorAlignment(textAnchor),\n      horizontalAlign = _getAnchorAlignment2.horizontalAlign,\n      verticalAlign = _getAnchorAlignment2.verticalAlign;\n\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, iconfonts.length);\n  var height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\nexport function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing) {\n  var translate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [0, 0];\n  var isIconFont = arguments.length > 7 ? arguments[7] : undefined;\n  var lines = text.split('\\n');\n  var positionedGlyphs = [];\n  var shaping = {\n    positionedGlyphs: positionedGlyphs,\n    top: translate[1],\n    bottom: translate[1],\n    left: translate[0],\n    right: translate[0],\n    lineCount: lines.length,\n    text: text\n  };\n  isIconFont ? shapeIconFont(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing) : shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);\n\n  if (!positionedGlyphs.length) {\n    return false;\n  }\n\n  return shaping;\n}\nexport function getGlyphQuads(shaping) {\n  var textOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n  var alongLine = arguments.length > 2 ? arguments[2] : undefined;\n  var _shaping$positionedGl = shaping.positionedGlyphs,\n      positionedGlyphs = _shaping$positionedGl === void 0 ? [] : _shaping$positionedGl;\n  var quads = [];\n\n  var _iterator2 = _createForOfIteratorHelper(positionedGlyphs),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var positionedGlyph = _step2.value;\n      var rect = positionedGlyph.metrics;\n      var rectBuffer = 4;\n      var halfAdvance = rect.advance * positionedGlyph.scale / 2;\n      var glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];\n      var builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n      var x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n      var y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n      var x2 = x1 + rect.width * positionedGlyph.scale;\n      var y2 = y1 + rect.height * positionedGlyph.scale;\n      var tl = {\n        x: x1,\n        y: y1\n      };\n      var tr = {\n        x: x2,\n        y: y1\n      };\n      var bl = {\n        x: x1,\n        y: y2\n      };\n      var br = {\n        x: x2,\n        y: y2\n      };\n      quads.push({\n        tl: tl,\n        tr: tr,\n        bl: bl,\n        br: br,\n        tex: rect,\n        glyphOffset: glyphOffset\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return quads;\n}","map":null,"metadata":{},"sourceType":"module"}