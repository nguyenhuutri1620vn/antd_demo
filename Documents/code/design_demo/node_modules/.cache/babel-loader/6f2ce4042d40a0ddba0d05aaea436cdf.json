{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.getOutDegreeAsync = exports.getNeighborsAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.getAdjMatrixAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectCycleAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.connectedComponentAsync = exports.GADDIAsync = void 0;\n\nvar _createWorker = _interopRequireDefault(require(\"./createWorker\"));\n\nvar _constant = require(\"./constant\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\n\n\nvar getAdjMatrixAsync = function getAdjMatrixAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);\n};\n/**\n * 图的连通分量\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\n\n\nexports.getAdjMatrixAsync = getAdjMatrixAsync;\n\nvar connectedComponentAsync = function connectedComponentAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);\n};\n/**\n * 获取节点的度\n * @param graphData 图数据\n */\n\n\nexports.connectedComponentAsync = connectedComponentAsync;\n\nvar getDegreeAsync = function getDegreeAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);\n};\n/**\n * 获取节点的入度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\n\nexports.getDegreeAsync = getDegreeAsync;\n\nvar getInDegreeAsync = function getInDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);\n};\n/**\n * 获取节点的出度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\n\nexports.getInDegreeAsync = getInDegreeAsync;\n\nvar getOutDegreeAsync = function getOutDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);\n};\n/**\n * 检测图中的(有向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.getOutDegreeAsync = getOutDegreeAsync;\n\nvar detectCycleAsync = function detectCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);\n};\n/**\n * 检测图中的(无向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.detectCycleAsync = detectCycleAsync;\n\nvar detectAllCyclesAsync = function detectAllCyclesAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);\n};\n/**\n * 检测图中的所有(有向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.detectAllCyclesAsync = detectAllCyclesAsync;\n\nvar detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);\n};\n/**\n * 检测图中的所有(无向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;\n\nvar detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);\n};\n/**\n * Dijkstra's algorithm, See {@link https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}\n * @param graphData 图数据\n */\n\n\nexports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;\n\nvar dijkstraAsync = function dijkstraAsync(graphData, source, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);\n};\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n */\n\n\nexports.dijkstraAsync = dijkstraAsync;\n\nvar findAllPathAsync = function findAllPathAsync(graphData, start, end, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end, directed]);\n};\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n * @param weightPropertyName 边权重的属名称，若数据中没有权重，则默认每条边权重为 1\n */\n\n\nexports.findAllPathAsync = findAllPathAsync;\n\nvar findShortestPathAsync = function findShortestPathAsync(graphData, start, end, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end, directed, weightPropertyName]);\n};\n/**\n * Floyd–Warshall algorithm, See {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm}\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\n\n\nexports.findShortestPathAsync = findShortestPathAsync;\n\nvar floydWarshallAsync = function floydWarshallAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);\n};\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\n\nexports.floydWarshallAsync = floydWarshallAsync;\n\nvar labelPropagationAsync = function labelPropagationAsync(graphData, directed, weightPropertyName, maxIteration) {\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n\n  return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold\n */\n\n\nexports.labelPropagationAsync = labelPropagationAsync;\n\nvar louvainAsync = function louvainAsync(graphData, directed, weightPropertyName, threshold) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);\n};\n/**\n * 最小生成树，See {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nexports.louvainAsync = louvainAsync;\n\nvar minimumSpanningTreeAsync = function minimumSpanningTreeAsync(graphData, weight, algo) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);\n};\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\n */\n\n\nexports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;\n\nvar pageRankAsync = function pageRankAsync(graphData, epsilon, linkProb) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);\n};\n/**\n * 获取指定节点的所有邻居\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n * @param type 邻居类型\n */\n\n\nexports.pageRankAsync = pageRankAsync;\n\nvar getNeighborsAsync = function getNeighborsAsync(nodeId, edges, type) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);\n};\n/**\n * GADDI 图模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\n\n\nexports.getNeighborsAsync = getNeighborsAsync;\n\nvar GADDIAsync = function GADDIAsync(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n\n  return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp]);\n};\n\nexports.GADDIAsync = GADDIAsync;","map":null,"metadata":{},"sourceType":"script"}