{"ast":null,"code":"import { Point, Path } from '../../geometry';\nexport const rounded = function (sourcePoint, targetPoint, routePoints) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const path = new Path();\n  path.appendSegment(Path.createSegment('M', sourcePoint));\n  const f13 = 1 / 3;\n  const f23 = 2 / 3;\n  const radius = options.radius || 10;\n  let prevDistance;\n  let nextDistance;\n\n  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {\n    const curr = Point.create(routePoints[i]);\n    const prev = routePoints[i - 1] || sourcePoint;\n    const next = routePoints[i + 1] || targetPoint;\n    prevDistance = nextDistance || curr.distance(prev) / 2;\n    nextDistance = curr.distance(next) / 2;\n    const startMove = -Math.min(radius, prevDistance);\n    const endMove = -Math.min(radius, nextDistance);\n    const roundedStart = curr.clone().move(prev, startMove).round();\n    const roundedEnd = curr.clone().move(next, endMove).round();\n    const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);\n    const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);\n    path.appendSegment(Path.createSegment('L', roundedStart));\n    path.appendSegment(Path.createSegment('C', control1, control2, roundedEnd));\n  }\n\n  path.appendSegment(Path.createSegment('L', targetPoint));\n  return options.raw ? path : path.serialize();\n};","map":null,"metadata":{},"sourceType":"module"}