{"ast":null,"code":"const isEdgeView = (val, _ref) => {\n  let {\n    view\n  } = _ref;\n  return view.cell.isEdge();\n};\n\nexport const connection = {\n  qualify: isEdgeView,\n\n  set(val, args) {\n    const view = args.view;\n    const stubs = val.stubs || 0;\n    let d;\n\n    if (Number.isFinite(stubs) && stubs !== 0) {\n      let offset;\n\n      if (stubs < 0) {\n        const len = view.getConnectionLength() || 0;\n        offset = (len + stubs) / 2;\n      } else {\n        offset = stubs;\n      }\n\n      const path = view.getConnection();\n\n      if (path) {\n        const sourceParts = path.divideAtLength(offset);\n        const targetParts = path.divideAtLength(-offset);\n\n        if (sourceParts && targetParts) {\n          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n        }\n      }\n    }\n\n    return {\n      d: d || view.getConnectionPathData()\n    };\n  }\n\n};\nexport const atConnectionLengthKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: true\n  })\n};\nexport const atConnectionLengthIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: false\n  })\n};\nexport const atConnectionRatioKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: true\n  })\n};\nexport const atConnectionRatioIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: false\n  })\n}; // aliases\n// -------\n\nexport const atConnectionLength = atConnectionLengthKeepGradient;\nexport const atConnectionRatio = atConnectionRatioKeepGradient; // utils\n// -----\n\nfunction atConnectionWrapper(method, options) {\n  const zeroVector = {\n    x: 1,\n    y: 0\n  };\n  return (value, args) => {\n    let p;\n    let angle;\n    const view = args.view;\n    const tangent = view[method](Number(value));\n\n    if (tangent) {\n      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = view.path.start;\n      angle = 0;\n    }\n\n    if (angle === 0) {\n      return {\n        transform: `translate(${p.x},${p.y}')`\n      };\n    }\n\n    return {\n      transform: `translate(${p.x},${p.y}') rotate(${angle})`\n    };\n  };\n}","map":null,"metadata":{},"sourceType":"module"}