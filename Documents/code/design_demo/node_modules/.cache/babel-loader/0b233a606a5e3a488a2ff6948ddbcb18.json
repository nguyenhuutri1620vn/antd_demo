{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _mergeWith from \"lodash/mergeWith\";\nimport _isString from \"lodash/isString\";\nimport _isFunction from \"lodash/isFunction\";\nimport _cloneDeep from \"lodash/cloneDeep\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { SyncHook } from '@antv/async-hook';\nimport { bBoxToBounds, extent, padBounds } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport { getParser, getTransform } from './factory';\nimport { cluster } from './transform/cluster';\nimport { statMap } from './utils/statistics';\nimport { getColumn } from './utils/util';\n\nfunction mergeCustomizer(objValue, srcValue) {\n  if (Array.isArray(srcValue)) {\n    return srcValue;\n  }\n}\n\nvar Source = function (_EventEmitter) {\n  _inherits(Source, _EventEmitter);\n\n  var _super = _createSuper(Source);\n\n  function Source(data, cfg) {\n    var _this;\n\n    _classCallCheck(this, Source);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"data\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"extent\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"hooks\", {\n      init: new SyncHook()\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"parser\", {\n      type: 'geojson'\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"transforms\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"cluster\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"clusterOptions\", {\n      enable: false,\n      radius: 40,\n      maxZoom: 20,\n      zoom: -99,\n      method: 'count'\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"mapService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"invalidExtent\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"dataArrayChanged\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"originData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"rawData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cfg\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"clusterIndex\", void 0);\n\n    _this.originData = data;\n\n    _this.initCfg(cfg);\n\n    _this.hooks.init.tap('parser', function () {\n      _this.excuteParser();\n    });\n\n    _this.hooks.init.tap('cluster', function () {\n      _this.initCluster();\n    });\n\n    _this.hooks.init.tap('transform', function () {\n      _this.executeTrans();\n    });\n\n    _this.init();\n\n    return _this;\n  }\n\n  _createClass(Source, [{\n    key: \"setData\",\n    value: function setData(data, options) {\n      this.originData = data;\n      this.dataArrayChanged = false;\n      this.initCfg(options);\n      this.init();\n      this.emit('update');\n    }\n  }, {\n    key: \"getClusters\",\n    value: function getClusters(zoom) {\n      return this.clusterIndex.getClusters(this.caculClusterExtent(2), zoom);\n    }\n  }, {\n    key: \"getClustersLeaves\",\n    value: function getClustersLeaves(id) {\n      return this.clusterIndex.getLeaves(id, Infinity);\n    }\n  }, {\n    key: \"updateClusterData\",\n    value: function updateClusterData(zoom) {\n      var _this2 = this;\n\n      var _this$clusterOptions = this.clusterOptions,\n          _this$clusterOptions$ = _this$clusterOptions.method,\n          method = _this$clusterOptions$ === void 0 ? 'sum' : _this$clusterOptions$,\n          field = _this$clusterOptions.field;\n      var data = this.clusterIndex.getClusters(this.caculClusterExtent(2), Math.floor(zoom));\n      this.clusterOptions.zoom = zoom;\n      data.forEach(function (p) {\n        if (!p.id) {\n          p.properties.point_count = 1;\n        }\n      });\n\n      if (field || _isFunction(method)) {\n        data = data.map(function (item) {\n          var id = item.id;\n\n          if (id) {\n            var points = _this2.clusterIndex.getLeaves(id, Infinity);\n\n            var properties = points.map(function (d) {\n              return d.properties;\n            });\n            var statNum;\n\n            if (_isString(method) && field) {\n              var column = getColumn(properties, field);\n              statNum = statMap[method](column);\n            }\n\n            if (_isFunction(method)) {\n              statNum = method(properties);\n            }\n\n            item.properties.stat = statNum;\n          } else {\n            item.properties.point_count = 1;\n          }\n\n          return item;\n        });\n      }\n\n      this.data = getParser('geojson')({\n        type: 'FeatureCollection',\n        features: data\n      });\n      this.executeTrans();\n    }\n  }, {\n    key: \"getFeatureById\",\n    value: function getFeatureById(id) {\n      var _this$parser$type = this.parser.type,\n          type = _this$parser$type === void 0 ? 'geojson' : _this$parser$type;\n\n      if (type === 'geojson' && !this.cluster) {\n        var feature = id < this.originData.features.length ? this.originData.features[id] : 'null';\n\n        var newFeature = _cloneDeep(feature);\n\n        if (this.transforms.length !== 0 || this.dataArrayChanged) {\n          var item = this.data.dataArray.find(function (dataItem) {\n            return dataItem._id === id;\n          });\n          newFeature.properties = item;\n        }\n\n        return newFeature;\n      } else {\n        return id < this.data.dataArray.length ? this.data.dataArray[id] : 'null';\n      }\n    }\n  }, {\n    key: \"updateFeaturePropertiesById\",\n    value: function updateFeaturePropertiesById(id, properties) {\n      this.data.dataArray = this.data.dataArray.map(function (dataItem) {\n        if (dataItem._id === id) {\n          return _objectSpread(_objectSpread({}, dataItem), properties);\n        }\n\n        return dataItem;\n      });\n      this.dataArrayChanged = true;\n      this.emit('update');\n    }\n  }, {\n    key: \"getFeatureId\",\n    value: function getFeatureId(field, value) {\n      var feature = this.data.dataArray.find(function (dataItem) {\n        return dataItem[field] === value;\n      });\n      return feature === null || feature === void 0 ? void 0 : feature._id;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.removeAllListeners();\n      this.originData = null;\n      this.clusterIndex = null;\n      this.data = null;\n    }\n  }, {\n    key: \"caculClusterExtent\",\n    value: function caculClusterExtent(bufferRatio) {\n      var newBounds = [[-Infinity, -Infinity], [Infinity, Infinity]];\n\n      if (!this.invalidExtent) {\n        newBounds = padBounds(bBoxToBounds(this.extent), bufferRatio);\n      }\n\n      return newBounds[0].concat(newBounds[1]);\n    }\n  }, {\n    key: \"initCfg\",\n    value: function initCfg(option) {\n      this.cfg = _mergeWith(this.cfg, option, mergeCustomizer);\n      var cfg = this.cfg;\n\n      if (cfg) {\n        if (cfg.parser) {\n          this.parser = cfg.parser;\n        }\n\n        if (cfg.transforms) {\n          this.transforms = cfg.transforms;\n        }\n\n        this.cluster = cfg.cluster || false;\n\n        if (cfg.clusterOptions) {\n          this.cluster = true;\n          this.clusterOptions = _objectSpread(_objectSpread({}, this.clusterOptions), cfg.clusterOptions);\n        }\n      }\n    }\n  }, {\n    key: \"excuteParser\",\n    value: function excuteParser() {\n      var parser = this.parser;\n      var type = parser.type || 'geojson';\n\n      if (type === 'imagetile') {\n        this.data = {\n          tileurl: this.originData,\n          dataArray: []\n        };\n        return;\n      }\n\n      var sourceParser = getParser(type);\n      this.data = sourceParser(this.originData, parser);\n      this.extent = extent(this.data.dataArray);\n      this.invalidExtent = this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3];\n    }\n  }, {\n    key: \"executeTrans\",\n    value: function executeTrans() {\n      var _this3 = this;\n\n      var trans = this.transforms;\n      trans.forEach(function (tran) {\n        var type = tran.type;\n        var data = getTransform(type)(_this3.data, tran);\n        Object.assign(_this3.data, data);\n      });\n    }\n  }, {\n    key: \"initCluster\",\n    value: function initCluster() {\n      if (!this.cluster) {\n        return;\n      }\n\n      var clusterOptions = this.clusterOptions || {};\n      this.clusterIndex = cluster(this.data, clusterOptions);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.hooks.init.call(this);\n    }\n  }]);\n\n  return Source;\n}(EventEmitter);\n\nexport { Source as default };","map":null,"metadata":{},"sourceType":"module"}