{"ast":null,"code":"import { Dom, ObjectExt, FunctionExt } from '../../util';\nimport { Point, Line } from '../../geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nexport class Segments extends ToolsView.ToolItem {\n  constructor() {\n    super(...arguments);\n    this.handles = [];\n  }\n\n  get vertices() {\n    return this.cellView.cell.getVertices();\n  }\n\n  update() {\n    this.render();\n    return this;\n  }\n\n  onRender() {\n    Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));\n    this.resetHandles();\n    const edgeView = this.cellView;\n    const vertices = [...this.vertices];\n    vertices.unshift(edgeView.sourcePoint);\n    vertices.push(edgeView.targetPoint);\n\n    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {\n      const vertex = vertices[i];\n      const nextVertex = vertices[i + 1];\n      const handle = this.renderHandle(vertex, nextVertex, i);\n      this.stamp(handle.container);\n      this.handles.push(handle);\n    }\n\n    return this;\n  }\n\n  renderHandle(vertex, nextVertex, index) {\n    const handle = this.options.createHandle({\n      index,\n      graph: this.graph,\n      guard: evt => this.guard(evt),\n      attrs: this.options.attrs || {}\n    });\n\n    if (this.options.processHandle) {\n      this.options.processHandle(handle);\n    }\n\n    this.graph.hook.onToolItemCreated({\n      name: 'segments',\n      cell: this.cell,\n      view: this.cellView,\n      tool: handle\n    });\n    this.updateHandle(handle, vertex, nextVertex);\n    this.container.appendChild(handle.container);\n    this.startHandleListening(handle);\n    return handle;\n  }\n\n  startHandleListening(handle) {\n    handle.on('change', this.onHandleChange, this);\n    handle.on('changing', this.onHandleChanging, this);\n    handle.on('changed', this.onHandleChanged, this);\n  }\n\n  stopHandleListening(handle) {\n    handle.off('change', this.onHandleChange, this);\n    handle.off('changing', this.onHandleChanging, this);\n    handle.off('changed', this.onHandleChanged, this);\n  }\n\n  resetHandles() {\n    const handles = this.handles;\n    this.handles = [];\n\n    if (handles) {\n      handles.forEach(handle => {\n        this.stopHandleListening(handle);\n        handle.remove();\n      });\n    }\n  }\n\n  shiftHandleIndexes(delta) {\n    const handles = this.handles;\n\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      handles[i].options.index += delta;\n    }\n  }\n\n  resetAnchor(type, anchor) {\n    const edge = this.cellView.cell;\n    const options = {\n      ui: true,\n      toolId: this.cid\n    };\n\n    if (anchor) {\n      edge.prop([type, 'anchor'], anchor, options);\n    } else {\n      edge.removeProp([type, 'anchor'], options);\n    }\n  }\n\n  snapHandle(handle, position, data) {\n    const axis = handle.options.axis;\n    const index = handle.options.index;\n    const edgeView = this.cellView;\n    const edge = edgeView.cell;\n    const vertices = edge.getVertices();\n    const prev = vertices[index - 2] || data.sourceAnchor;\n    const next = vertices[index + 1] || data.targetAnchor;\n    const snapRadius = this.options.snapRadius;\n\n    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n      position[axis] = prev[axis];\n    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n      position[axis] = next[axis];\n    }\n\n    return position;\n  }\n\n  onHandleChanging(_ref) {\n    let {\n      handle,\n      e\n    } = _ref;\n    const graph = this.graph;\n    const options = this.options;\n    const edgeView = this.cellView;\n    const anchorFn = options.anchor;\n    const axis = handle.options.axis;\n    const index = handle.options.index - 1;\n    const data = this.getEventData(e);\n    const evt = this.normalizeEvent(e);\n    const coords = graph.snapToGrid(evt.clientX, evt.clientY);\n    const position = this.snapHandle(handle, coords.clone(), data);\n    const vertices = ObjectExt.cloneDeep(this.vertices);\n    let vertex = vertices[index];\n    let nextVertex = vertices[index + 1]; // First Segment\n\n    const sourceView = edgeView.sourceView;\n    const sourceBBox = edgeView.sourceBBox;\n    let changeSourceAnchor = false;\n    let deleteSourceAnchor = false;\n\n    if (!vertex) {\n      vertex = edgeView.sourceAnchor.toJSON();\n      vertex[axis] = position[axis];\n\n      if (sourceBBox.containsPoint(vertex)) {\n        changeSourceAnchor = true;\n      } else {\n        vertices.unshift(vertex);\n        this.shiftHandleIndexes(1);\n        deleteSourceAnchor = true;\n      }\n    } else if (index === 0) {\n      if (sourceBBox.containsPoint(vertex)) {\n        vertices.shift();\n        this.shiftHandleIndexes(-1);\n        changeSourceAnchor = true;\n      } else {\n        vertex[axis] = position[axis];\n        deleteSourceAnchor = true;\n      }\n    } else {\n      vertex[axis] = position[axis];\n    }\n\n    if (typeof anchorFn === 'function' && sourceView) {\n      if (changeSourceAnchor) {\n        const sourceAnchorPosition = data.sourceAnchor.clone();\n        sourceAnchorPosition[axis] = position[axis];\n        const sourceAnchor = FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);\n        this.resetAnchor('source', sourceAnchor);\n      }\n\n      if (deleteSourceAnchor) {\n        this.resetAnchor('source', data.sourceAnchorDef);\n      }\n    } // Last segment\n\n\n    const targetView = edgeView.targetView;\n    const targetBBox = edgeView.targetBBox;\n    let changeTargetAnchor = false;\n    let deleteTargetAnchor = false;\n\n    if (!nextVertex) {\n      nextVertex = edgeView.targetAnchor.toJSON();\n      nextVertex[axis] = position[axis];\n\n      if (targetBBox.containsPoint(nextVertex)) {\n        changeTargetAnchor = true;\n      } else {\n        vertices.push(nextVertex);\n        deleteTargetAnchor = true;\n      }\n    } else if (index === vertices.length - 2) {\n      if (targetBBox.containsPoint(nextVertex)) {\n        vertices.pop();\n        changeTargetAnchor = true;\n      } else {\n        nextVertex[axis] = position[axis];\n        deleteTargetAnchor = true;\n      }\n    } else {\n      nextVertex[axis] = position[axis];\n    }\n\n    if (typeof anchorFn === 'function' && targetView) {\n      if (changeTargetAnchor) {\n        const targetAnchorPosition = data.targetAnchor.clone();\n        targetAnchorPosition[axis] = position[axis];\n        const targetAnchor = FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);\n        this.resetAnchor('target', targetAnchor);\n      }\n\n      if (deleteTargetAnchor) {\n        this.resetAnchor('target', data.targetAnchorDef);\n      }\n    }\n\n    if (!Point.equalPoints(vertices, this.vertices)) {\n      this.cellView.cell.setVertices(vertices, {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n\n    this.updateHandle(handle, vertex, nextVertex, 0);\n\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, coords.x, coords.y);\n    }\n  }\n\n  onHandleChange(_ref2) {\n    let {\n      handle,\n      e\n    } = _ref2;\n    const options = this.options;\n    const handles = this.handles;\n    const edgeView = this.cellView;\n    const index = handle.options.index;\n\n    if (!Array.isArray(handles)) {\n      return;\n    }\n\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      if (i !== index) {\n        handles[i].hide();\n      }\n    }\n\n    this.focus();\n    this.setEventData(e, {\n      sourceAnchor: edgeView.sourceAnchor.clone(),\n      targetAnchor: edgeView.targetAnchor.clone(),\n      sourceAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),\n      targetAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor']))\n    });\n    this.cell.startBatch('move-segment', {\n      ui: true,\n      toolId: this.cid\n    });\n\n    if (!options.stopPropagation) {\n      const normalizedEvent = this.normalizeEvent(e);\n      const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);\n    }\n  }\n\n  onHandleChanged(_ref3) {\n    let {\n      e\n    } = _ref3;\n    const options = this.options;\n    const edgeView = this.cellView;\n\n    if (options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({\n        ui: true,\n        toolId: this.cid\n      });\n    }\n\n    const normalizedEvent = this.normalizeEvent(e);\n    const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n    this.render();\n    this.blur();\n    this.cell.stopBatch('move-segment', {\n      ui: true,\n      toolId: this.cid\n    });\n\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);\n    }\n\n    edgeView.checkMouseleave(normalizedEvent);\n    options.onChanged && options.onChanged({\n      edge: edgeView.cell,\n      edgeView\n    });\n  }\n\n  updateHandle(handle, vertex, nextVertex) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const precision = this.options.precision || 0;\n    const vertical = Math.abs(vertex.x - nextVertex.x) < precision;\n    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;\n\n    if (vertical || horizontal) {\n      const segmentLine = new Line(vertex, nextVertex);\n      const length = segmentLine.length();\n\n      if (length < this.options.threshold) {\n        handle.hide();\n      } else {\n        const position = segmentLine.getCenter();\n        const axis = vertical ? 'x' : 'y';\n        position[axis] += offset || 0;\n        const angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n        handle.updatePosition(position.x, position.y, angle, this.cellView);\n        handle.show();\n        handle.options.axis = axis;\n      }\n    } else {\n      handle.hide();\n    }\n  }\n\n  onRemove() {\n    this.resetHandles();\n  }\n\n}\n\n(function (Segments) {\n  class Handle extends View {\n    constructor(options) {\n      super();\n      this.options = options;\n      this.render();\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown'\n      });\n    }\n\n    render() {\n      this.container = View.createElement('rect', true);\n      const attrs = this.options.attrs;\n\n      if (typeof attrs === 'function') {\n        const defaults = Segments.getDefaults();\n        this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n      } else {\n        this.setAttrs(attrs);\n      }\n\n      this.addClass(this.prefixClassName('edge-tool-segment'));\n    }\n\n    updatePosition(x, y, angle, view) {\n      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);\n      let matrix = Dom.createSVGMatrix().translate(p.x, p.y);\n\n      if (!p.equals({\n        x,\n        y\n      })) {\n        const line = new Line(x, y, p.x, p.y);\n        let deg = line.vector().vectorAngle(new Point(1, 0));\n\n        if (deg !== 0) {\n          deg += 90;\n        }\n\n        matrix = matrix.rotate(deg);\n      } else {\n        matrix = matrix.rotate(angle);\n      }\n\n      this.setAttrs({\n        transform: Dom.matrixToTransformString(matrix),\n        cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize'\n      });\n    }\n\n    onMouseDown(evt) {\n      if (this.options.guard(evt)) {\n        return;\n      }\n\n      this.trigger('change', {\n        e: evt,\n        handle: this\n      });\n      evt.stopPropagation();\n      evt.preventDefault();\n      this.options.graph.view.undelegateEvents();\n      this.delegateDocumentEvents({\n        mousemove: 'onMouseMove',\n        touchmove: 'onMouseMove',\n        mouseup: 'onMouseUp',\n        touchend: 'onMouseUp',\n        touchcancel: 'onMouseUp'\n      }, evt.data);\n    }\n\n    onMouseMove(evt) {\n      this.emit('changing', {\n        e: evt,\n        handle: this\n      });\n    }\n\n    onMouseUp(evt) {\n      this.emit('changed', {\n        e: evt,\n        handle: this\n      });\n      this.undelegateDocumentEvents();\n      this.options.graph.view.delegateEvents();\n    }\n\n    show() {\n      this.container.style.display = '';\n    }\n\n    hide() {\n      this.container.style.display = 'none';\n    }\n\n  }\n\n  Segments.Handle = Handle;\n})(Segments || (Segments = {}));\n\n(function (Segments) {\n  Segments.config({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2\n    },\n    createHandle: options => new Segments.Handle(options),\n    anchor: Util.getAnchor\n  });\n})(Segments || (Segments = {}));","map":null,"metadata":{},"sourceType":"module"}