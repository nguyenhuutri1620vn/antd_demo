{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { StringExt, Dom, Vector } from '../util';\nimport { Filter } from '../registry';\nimport { Markup } from '../view';\nimport { Base } from './base';\nexport class DefsManager extends Base {\n  get cid() {\n    return this.graph.view.cid;\n  }\n\n  get svg() {\n    return this.view.svg;\n  }\n\n  get defs() {\n    return this.view.defs;\n  }\n\n  isDefined(id) {\n    return this.svg.getElementById(id) != null;\n  }\n\n  filter(options) {\n    let filterId = options.id;\n    const name = options.name;\n\n    if (!filterId) {\n      filterId = `filter-${name}-${this.cid}-${StringExt.hashcode(JSON.stringify(options))}`;\n    }\n\n    if (!this.isDefined(filterId)) {\n      const fn = Filter.registry.get(name);\n\n      if (fn == null) {\n        return Filter.registry.onNotFound(name);\n      }\n\n      const markup = fn(options.args || {}); // Set the filter area to be 3x the bounding box of the cell\n      // and center the filter around the cell.\n\n      const attrs = Object.assign(Object.assign({\n        x: -1,\n        y: -1,\n        width: 3,\n        height: 3,\n        filterUnits: 'objectBoundingBox'\n      }, options.attrs), {\n        id: filterId\n      });\n      Vector.create(Markup.sanitize(markup), attrs).appendTo(this.defs);\n    }\n\n    return filterId;\n  }\n\n  gradient(options) {\n    let id = options.id;\n    const type = options.type;\n\n    if (!id) {\n      id = `gradient-${type}-${this.cid}-${StringExt.hashcode(JSON.stringify(options))}`;\n    }\n\n    if (!this.isDefined(id)) {\n      const stops = options.stops;\n      const arr = stops.map(stop => {\n        const opacity = stop.opacity != null && Number.isFinite(stop.opacity) ? stop.opacity : 1;\n        return `<stop offset=\"${stop.offset}\" stop-color=\"${stop.color}\" stop-opacity=\"${opacity}\"/>`;\n      });\n      const markup = `<${type}>${arr.join('')}</${type}>`;\n      const attrs = Object.assign({\n        id\n      }, options.attrs);\n      Vector.create(markup, attrs).appendTo(this.defs);\n    }\n\n    return id;\n  }\n\n  marker(options) {\n    const {\n      id,\n      refX,\n      refY,\n      markerUnits,\n      markerOrient,\n      tagName,\n      children\n    } = options,\n          attrs = __rest(options, [\"id\", \"refX\", \"refY\", \"markerUnits\", \"markerOrient\", \"tagName\", \"children\"]);\n\n    let markerId = id;\n\n    if (!markerId) {\n      markerId = `marker-${this.cid}-${StringExt.hashcode(JSON.stringify(options))}`;\n    }\n\n    if (!this.isDefined(markerId)) {\n      if (tagName !== 'path') {\n        // remove unnecessary d attribute inherit from standard edge.\n        delete attrs.d;\n      }\n\n      const pathMarker = Vector.create('marker', {\n        refX,\n        refY,\n        id: markerId,\n        overflow: 'visible',\n        orient: markerOrient != null ? markerOrient : 'auto',\n        markerUnits: markerUnits || 'userSpaceOnUse'\n      }, children ? children.map(_a => {\n        var {\n          tagName\n        } = _a,\n            other = __rest(_a, [\"tagName\"]);\n\n        return Vector.create(`${tagName}` || 'path', Dom.kebablizeAttrs(Object.assign(Object.assign({}, attrs), other)));\n      }) : [Vector.create(tagName || 'path', Dom.kebablizeAttrs(attrs))]);\n      this.defs.appendChild(pathMarker.node);\n    }\n\n    return markerId;\n  }\n\n  remove(id) {\n    const elem = this.svg.getElementById(id);\n\n    if (elem && elem.parentNode) {\n      elem.parentNode.removeChild(elem);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}