{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/**\n * 基于 G 的刻度时间轴组件\n */\n\n\nimport { ext } from '@antv/matrix-util';\nimport { isNumber, isString } from '@antv/util';\nimport TimeBarTooltip from './timeBarTooltip';\nimport ControllerBtn from './controllerBtn';\nimport { VALUE_CHANGE, TIMELINE_START, TIMELINE_END, PLAY_PAUSE_BTN, NEXT_STEP_BTN, PRE_STEP_BTN, TIMEBAR_CONFIG_CHANGE } from './constant';\nvar transform = ext.transform;\nvar DEFAULT_SELECTEDTICK_STYLE = {\n  fill: '#5B8FF9'\n};\nvar DEFAULT_UNSELECTEDTICK_STYLE = {\n  fill: '#e6e8e9'\n};\n\nvar TimeBarSlice =\n/** @class */\nfunction () {\n  function TimeBarSlice(cfgs) {\n    this.frameCount = 0;\n    this.fontFamily = 'Arial, sans-serif';\n    var graph = cfgs.graph,\n        canvas = cfgs.canvas,\n        group = cfgs.group,\n        width = cfgs.width,\n        height = cfgs.height,\n        padding = cfgs.padding,\n        data = cfgs.data,\n        start = cfgs.start,\n        end = cfgs.end,\n        _a = cfgs.x,\n        x = _a === void 0 ? 0 : _a,\n        _b = cfgs.y,\n        y = _b === void 0 ? 0 : _b,\n        tickLabelFormatter = cfgs.tickLabelFormatter,\n        _c = cfgs.selectedTickStyle,\n        selectedTickStyle = _c === void 0 ? DEFAULT_SELECTEDTICK_STYLE : _c,\n        _d = cfgs.unselectedTickStyle,\n        unselectedTickStyle = _d === void 0 ? DEFAULT_UNSELECTEDTICK_STYLE : _d,\n        tooltipBackgroundColor = cfgs.tooltipBackgroundColor,\n        tooltipFomatter = cfgs.tooltipFomatter,\n        tickLabelStyle = cfgs.tickLabelStyle;\n    this.graph = graph;\n    this.group = group;\n    this.sliceGroup = group.addGroup({\n      name: 'slice-group'\n    });\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this.padding = padding;\n    this.data = data;\n    this.start = start;\n    this.end = end;\n    this.tickLabelFormatter = tickLabelFormatter;\n    this.tickLabelStyle = tickLabelStyle || {};\n    this.selectedTickStyle = selectedTickStyle;\n    this.unselectedTickStyle = unselectedTickStyle;\n    this.x = x;\n    this.y = y;\n    this.tooltipBackgroundColor = tooltipBackgroundColor;\n    this.tooltipFomatter = tooltipFomatter; // 初始化 fontFamily，如果有浏览器，取 body 上的字体，防止文字更新时局部渲染造成的重影\n\n    this.fontFamily = typeof window !== 'undefined' ? window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif' : 'Arial, sans-serif';\n    this.renderSlices();\n    this.initEvent();\n  }\n\n  TimeBarSlice.prototype.renderSlices = function () {\n    var _this = this;\n\n    var _a = this,\n        width = _a.width,\n        height = _a.height,\n        padding = _a.padding,\n        data = _a.data,\n        start = _a.start,\n        end = _a.end,\n        tickLabelFormatter = _a.tickLabelFormatter,\n        selectedTickStyle = _a.selectedTickStyle,\n        unselectedTickStyle = _a.unselectedTickStyle,\n        tickLabelStyle = _a.tickLabelStyle;\n\n    var realWidth = width - 2 * padding;\n    var fontSize = 10;\n    var labelLineHeight = 4;\n    var labelAreaHeight = 3 * padding + labelLineHeight + fontSize;\n    var ticksAreaHeight = height - labelAreaHeight - 2 * padding;\n    var gap = 2;\n    var ticksLength = data.length;\n    var tickWidth = (realWidth - gap * (ticksLength - 1)) / ticksLength;\n    this.tickWidth = tickWidth;\n    var sliceGroup = this.sliceGroup;\n    var tickRects = [];\n    var labels = [];\n    var startTickId = Math.round(ticksLength * start);\n    var endTickId = Math.round(ticksLength * end);\n    this.startTickRectId = startTickId;\n    this.endTickRectId = endTickId;\n    var rotate = tickLabelStyle.rotate;\n    delete tickLabelStyle.rotate;\n    data.forEach(function (d, i) {\n      // draw the tick rects\n      var selected = i >= startTickId && i <= endTickId;\n      var tickStyle = selected ? selectedTickStyle : unselectedTickStyle;\n      var rect = sliceGroup.addShape('rect', {\n        attrs: __assign({\n          x: padding + i * (tickWidth + gap),\n          y: padding,\n          width: tickWidth,\n          height: ticksAreaHeight\n        }, tickStyle),\n        draggable: true,\n        name: \"tick-rect-\".concat(i)\n      }); // draw the pick tick rects\n\n      var pickRect = sliceGroup.addShape('rect', {\n        attrs: {\n          x: padding + i * tickWidth + gap * (2 * i - 1) / 2,\n          y: padding,\n          width: i === 0 || i === ticksLength - 1 ? tickWidth + gap / 2 : tickWidth + gap,\n          height: ticksAreaHeight,\n          fill: '#fff',\n          opacity: 0\n        },\n        draggable: true,\n        name: \"pick-rect-\".concat(i)\n      });\n      pickRect.toFront();\n      var rectBBox = rect.getBBox();\n      var centerX = (rectBBox.minX + rectBBox.maxX) / 2;\n      tickRects.push({\n        rect: rect,\n        pickRect: pickRect,\n        value: d.date,\n        x: centerX,\n        y: rectBBox.minY\n      });\n      var label;\n\n      if (tickLabelFormatter) {\n        label = tickLabelFormatter(d);\n\n        if (!isString(label) && label) {\n          // return true\n          label = d.date;\n        }\n      } else if (i % Math.round(ticksLength / 10) === 0) {\n        label = d.date;\n      }\n\n      if (label) {\n        labels.push(label); // draw tick lines\n\n        var lineStartY = rectBBox.maxY + padding * 2;\n        sliceGroup.addShape('line', {\n          attrs: {\n            stroke: '#BFBFBF',\n            x1: centerX,\n            y1: lineStartY,\n            x2: centerX,\n            y2: lineStartY + labelLineHeight\n          },\n          name: 'tick-line'\n        });\n        var labelStartY = lineStartY + labelLineHeight + padding;\n        var text = sliceGroup.addShape('text', {\n          attrs: __assign({\n            fill: '#8c8c8c',\n            stroke: '#fff',\n            lineWidth: 1,\n            x: centerX,\n            y: labelStartY,\n            textAlign: 'center',\n            text: label,\n            textBaseline: 'top',\n            fontSize: 10,\n            fontFamily: _this.fontFamily || 'Arial, sans-serif'\n          }, tickLabelStyle),\n          capture: false,\n          name: 'tick-label'\n        });\n        var textBBox = text.getBBox();\n\n        if (textBBox.maxX > width) {\n          text.attr('textAlign', 'right');\n        } else if (textBBox.minX < 0) {\n          text.attr('textAlign', 'left');\n        }\n\n        if (isNumber(rotate) && labels.length !== 10) {\n          var matrix = transform([1, 0, 0, 0, 1, 0, 0, 0, 1], [['t', -centerX, -labelStartY], ['r', rotate], ['t', centerX - 5, labelStartY + 2]]);\n          text.attr({\n            textAlign: 'left',\n            matrix: matrix\n          });\n        }\n\n        if (labels.length === 1) {\n          text.attr({\n            textAlign: 'left'\n          });\n        } else if (labels.length === 10) {\n          text.attr({\n            textAlign: 'right'\n          });\n        } // draw tick labels\n\n      }\n    });\n    this.tickRects = tickRects; // 渲染播放、快进和后退的控制按钮\n\n    var group = this.group;\n    this.currentSpeed = 1;\n    this.controllerBtnGroup = new ControllerBtn({\n      group: group,\n      x: this.x,\n      y: this.y + height + 5,\n      width: width,\n      height: 40,\n      hideTimeTypeController: true,\n      speed: this.currentSpeed,\n      fontFamily: this.fontFamily || 'Arial, sans-serif'\n    });\n  };\n\n  TimeBarSlice.prototype.initEvent = function () {\n    var _this = this;\n\n    var sliceGroup = this.sliceGroup;\n    sliceGroup.on('click', function (e) {\n      var targetRect = e.target;\n      if (targetRect.get('type') !== 'rect' || !targetRect.get('name')) return;\n      var id = parseInt(targetRect.get('name').split('-')[2], 10);\n\n      if (!isNaN(id)) {\n        var tickRects_1 = _this.tickRects; // cancel the selected ticks\n\n        var unselectedTickStyle_1 = _this.unselectedTickStyle;\n        tickRects_1.forEach(function (tickRect) {\n          tickRect.rect.attr(unselectedTickStyle_1);\n        });\n        var selectedTickStyle = _this.selectedTickStyle;\n        tickRects_1[id].rect.attr(selectedTickStyle);\n        _this.startTickRectId = id;\n        _this.endTickRectId = id;\n        var ticksLength = tickRects_1.length;\n        var start = id / ticksLength;\n\n        _this.graph.emit(VALUE_CHANGE, {\n          value: [start, start]\n        });\n      }\n    });\n    sliceGroup.on('dragstart', function (e) {\n      var tickRects = _this.tickRects; // cancel the selected ticks\n\n      var unselectedTickStyle = _this.unselectedTickStyle;\n      tickRects.forEach(function (tickRect) {\n        tickRect.rect.attr(unselectedTickStyle);\n      });\n      var targetRect = e.target;\n      var id = parseInt(targetRect.get('name').split('-')[2], 10);\n      var selectedTickStyle = _this.selectedTickStyle;\n      tickRects[id].rect.attr(selectedTickStyle);\n      _this.startTickRectId = id;\n      var ticksLength = tickRects.length;\n      var start = id / ticksLength;\n\n      _this.graph.emit(VALUE_CHANGE, {\n        value: [start, start]\n      });\n\n      _this.dragging = true;\n    });\n    sliceGroup.on('dragover', function (e) {\n      if (!_this.dragging) return;\n      if (e.target.get('type') !== 'rect') return;\n      var id = parseInt(e.target.get('name').split('-')[2], 10);\n      var startTickRectId = _this.startTickRectId;\n      var tickRects = _this.tickRects;\n      var selectedTickStyle = _this.selectedTickStyle;\n      var unselectedTickStyle = _this.unselectedTickStyle;\n\n      for (var i = 0; i < tickRects.length; i++) {\n        var style = i >= startTickRectId && i <= id ? selectedTickStyle : unselectedTickStyle;\n        tickRects[i].rect.attr(style);\n      }\n\n      var ticksLength = tickRects.length;\n      _this.endTickRectId = id;\n      var start = startTickRectId / ticksLength;\n      var end = id / ticksLength;\n\n      _this.graph.emit(VALUE_CHANGE, {\n        value: [start, end]\n      });\n    });\n    sliceGroup.on('drop', function (e) {\n      if (!_this.dragging) return;\n      _this.dragging = false;\n      if (e.target.get('type') !== 'rect') return;\n      var startTickRectId = _this.startTickRectId;\n      var id = parseInt(e.target.get('name').split('-')[2], 10);\n      if (id < startTickRectId) return;\n      var selectedTickStyle = _this.selectedTickStyle;\n      var tickRects = _this.tickRects;\n      tickRects[id].rect.attr(selectedTickStyle);\n      _this.endTickRectId = id;\n      var ticksLength = tickRects.length;\n      var start = startTickRectId / ticksLength;\n      var end = id / ticksLength;\n\n      _this.graph.emit(VALUE_CHANGE, {\n        value: [start, end]\n      });\n    }); // tooltip\n\n    var _a = this,\n        tooltipBackgroundColor = _a.tooltipBackgroundColor,\n        tooltipFomatter = _a.tooltipFomatter,\n        canvas = _a.canvas;\n\n    var tooltip = new TimeBarTooltip({\n      container: canvas.get('container'),\n      backgroundColor: tooltipBackgroundColor\n    });\n    var tickRects = this.tickRects;\n    tickRects.forEach(function (tickRect) {\n      var pickRect = tickRect.pickRect;\n      pickRect.on('mouseenter', function (e) {\n        var rect = e.target;\n        if (rect.get('type') !== 'rect') return;\n        var id = parseInt(rect.get('name').split('-')[2], 10);\n        var clientPoint = canvas.getClientByPoint(tickRects[id].x, tickRects[id].y);\n        tooltip.show({\n          x: tickRects[id].x,\n          y: tickRects[id].y,\n          clientX: clientPoint.x,\n          clientY: clientPoint.y,\n          text: tooltipFomatter ? tooltipFomatter(tickRects[id].value) : tickRects[id].value\n        });\n      });\n      pickRect.on('mouseleave', function (e) {\n        tooltip.hide();\n      });\n    }); // play controller events\n\n    var group = this.group; // 播放区按钮控制\n\n    /** 播放/暂停事件 */\n\n    group.on(\"\".concat(PLAY_PAUSE_BTN, \":click\"), function () {\n      _this.isPlay = !_this.isPlay;\n\n      _this.changePlayStatus();\n    }); // 处理前进一步的事件\n\n    group.on(\"\".concat(NEXT_STEP_BTN, \":click\"), function () {\n      _this.updateStartEnd(1);\n    }); // 处理后退一步的事件\n\n    group.on(\"\".concat(PRE_STEP_BTN, \":click\"), function () {\n      _this.updateStartEnd(-1);\n    });\n    group.on(TIMEBAR_CONFIG_CHANGE, function (_a) {\n      var type = _a.type,\n          speed = _a.speed;\n      _this.currentSpeed = speed;\n    });\n  };\n\n  TimeBarSlice.prototype.changePlayStatus = function (isSync) {\n    if (isSync === void 0) {\n      isSync = true;\n    }\n\n    this.controllerBtnGroup.playButton.update({\n      isPlay: this.isPlay\n    });\n\n    if (this.isPlay) {\n      // 开始播放\n      this.playHandler = this.startPlay();\n      this.graph.emit(TIMELINE_START, null);\n    } else {\n      // 结束播放\n      if (this.playHandler) {\n        if (typeof window !== 'undefined') window.cancelAnimationFrame(this.playHandler);\n\n        if (isSync) {\n          this.graph.emit(TIMELINE_END, null);\n        }\n      }\n    }\n  };\n\n  TimeBarSlice.prototype.startPlay = function () {\n    var _this = this;\n\n    return typeof window !== 'undefined' ? window.requestAnimationFrame(function () {\n      var speed = _this.currentSpeed; // 一分钟刷新一次\n\n      if (_this.frameCount % (60 / speed) === 0) {\n        _this.frameCount = 0;\n\n        _this.updateStartEnd(1);\n      }\n\n      _this.frameCount++;\n\n      if (_this.isPlay) {\n        _this.playHandler = _this.startPlay();\n      }\n    }) : undefined;\n  };\n\n  TimeBarSlice.prototype.updateStartEnd = function (sign) {\n    var self = this;\n    var tickRects = this.tickRects;\n    var ticksLength = tickRects.length;\n    var unselectedTickStyle = this.unselectedTickStyle;\n    var selectedTickStyle = this.selectedTickStyle;\n    var previousEndTickRectId = self.endTickRectId;\n\n    if (sign > 0) {\n      self.endTickRectId++;\n    } else {\n      tickRects[self.endTickRectId].rect.attr(unselectedTickStyle);\n      self.endTickRectId--;\n    } // 若此时 start 与 end 不同，范围前进/后退/播放\n\n\n    if (previousEndTickRectId !== self.startTickRectId) {\n      if (self.endTickRectId < self.startTickRectId) {\n        self.startTickRectId = self.endTickRectId;\n      }\n    } else {\n      // 否则是单帧的前进/后退/播放\n      for (var i = self.startTickRectId; i <= self.endTickRectId - 1; i++) {\n        tickRects[i].rect.attr(unselectedTickStyle);\n      }\n\n      self.startTickRectId = self.endTickRectId;\n    }\n\n    if (tickRects[self.endTickRectId]) {\n      tickRects[self.endTickRectId].rect.attr(selectedTickStyle);\n      var start = self.startTickRectId / ticksLength;\n      var end = self.endTickRectId / ticksLength;\n      this.graph.emit(VALUE_CHANGE, {\n        value: [start, end]\n      });\n    }\n  };\n\n  TimeBarSlice.prototype.destory = function () {\n    this.graph.off(VALUE_CHANGE);\n    var group = this.sliceGroup;\n    group.off('click');\n    group.off('dragstart');\n    group.off('dragover');\n    group.off('drop');\n    this.tickRects.forEach(function (tickRect) {\n      var pickRect = tickRect.pickRect;\n      pickRect.off('mouseenter');\n      pickRect.off('mouseleave');\n    });\n    this.tickRects.length = 0;\n    group.off(\"\".concat(PLAY_PAUSE_BTN, \":click\"));\n    group.off(\"\".concat(NEXT_STEP_BTN, \":click\"));\n    group.off(\"\".concat(PRE_STEP_BTN, \":click\"));\n    group.off(TIMEBAR_CONFIG_CHANGE);\n    this.sliceGroup.destroy();\n  };\n\n  return TimeBarSlice;\n}();\n\nexport default TimeBarSlice;","map":null,"metadata":{},"sourceType":"module"}