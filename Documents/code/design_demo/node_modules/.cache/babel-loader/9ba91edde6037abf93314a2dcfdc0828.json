{"ast":null,"code":"import { Angle, Point, Line, Rectangle, Polyline } from '../../geometry';\nimport { createSvgElement } from './elem';\nconst svgDocument = createSvgElement('svg');\nconst transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\nconst transformSeparatorRegex = /[ ,]+/;\nconst transformationListRegex = /^(\\w+)\\((.*)\\)/;\n/**\n * Returns a SVG point object initialized with the `x` and `y` coordinates.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint\n */\n\nexport function createSVGPoint(x, y) {\n  const p = svgDocument.createSVGPoint();\n  p.x = x;\n  p.y = y;\n  return p;\n}\n/**\n * Returns the SVG transformation matrix initialized with the given matrix.\n *\n * The given matrix is an object of the form:\n * {\n *   a: number\n *   b: number\n *   c: number\n *   d: number\n *   e: number\n *   f: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\n\nexport function createSVGMatrix(matrix) {\n  const mat = svgDocument.createSVGMatrix();\n\n  if (matrix != null) {\n    const source = matrix;\n    const target = mat; // eslint-disable-next-line\n\n    for (const key in source) {\n      target[key] = source[key];\n    }\n  }\n\n  return mat;\n}\n/**\n * Returns a SVG transform object.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform\n */\n\nexport function createSVGTransform(matrix) {\n  if (matrix != null) {\n    if (!(matrix instanceof DOMMatrix)) {\n      matrix = createSVGMatrix(matrix); // eslint-disable-line\n    }\n\n    return svgDocument.createSVGTransformFromMatrix(matrix);\n  }\n\n  return svgDocument.createSVGTransform();\n}\n/**\n * Returns the SVG transformation matrix built from the `transformString`.\n *\n * E.g. 'translate(10,10) scale(2,2)' will result in matrix:\n * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`\n */\n\nexport function transformStringToMatrix(transform) {\n  let mat = createSVGMatrix();\n  const matches = transform != null && transform.match(transformRegex);\n\n  if (!matches) {\n    return mat;\n  }\n\n  for (let i = 0, n = matches.length; i < n; i += 1) {\n    const transformationString = matches[i];\n    const transformationMatch = transformationString.match(transformationListRegex);\n\n    if (transformationMatch) {\n      let sx;\n      let sy;\n      let tx;\n      let ty;\n      let angle;\n      let ctm = createSVGMatrix();\n      const args = transformationMatch[2].split(transformSeparatorRegex);\n\n      switch (transformationMatch[1].toLowerCase()) {\n        case 'scale':\n          sx = parseFloat(args[0]);\n          sy = args[1] === undefined ? sx : parseFloat(args[1]);\n          ctm = ctm.scaleNonUniform(sx, sy);\n          break;\n\n        case 'translate':\n          tx = parseFloat(args[0]);\n          ty = parseFloat(args[1]);\n          ctm = ctm.translate(tx, ty);\n          break;\n\n        case 'rotate':\n          angle = parseFloat(args[0]);\n          tx = parseFloat(args[1]) || 0;\n          ty = parseFloat(args[2]) || 0;\n\n          if (tx !== 0 || ty !== 0) {\n            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n          } else {\n            ctm = ctm.rotate(angle);\n          }\n\n          break;\n\n        case 'skewx':\n          angle = parseFloat(args[0]);\n          ctm = ctm.skewX(angle);\n          break;\n\n        case 'skewy':\n          angle = parseFloat(args[0]);\n          ctm = ctm.skewY(angle);\n          break;\n\n        case 'matrix':\n          ctm.a = parseFloat(args[0]);\n          ctm.b = parseFloat(args[1]);\n          ctm.c = parseFloat(args[2]);\n          ctm.d = parseFloat(args[3]);\n          ctm.e = parseFloat(args[4]);\n          ctm.f = parseFloat(args[5]);\n          break;\n\n        default:\n          continue;\n      }\n\n      mat = mat.multiply(ctm);\n    }\n  }\n\n  return mat;\n}\nexport function matrixToTransformString(matrix) {\n  const m = matrix || {};\n  const a = m.a != null ? m.a : 1;\n  const b = m.b != null ? m.b : 0;\n  const c = m.c != null ? m.c : 0;\n  const d = m.d != null ? m.d : 1;\n  const e = m.e != null ? m.e : 0;\n  const f = m.f != null ? m.f : 0;\n  return `matrix(${a},${b},${c},${d},${e},${f})`;\n}\nexport function parseTransformString(transform) {\n  let translation;\n  let rotation;\n  let scale;\n\n  if (transform) {\n    const separator = transformSeparatorRegex; // Allow reading transform string with a single matrix\n\n    if (transform.trim().indexOf('matrix') >= 0) {\n      const matrix = transformStringToMatrix(transform);\n      const decomposedMatrix = decomposeMatrix(matrix);\n      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n      rotation = [decomposedMatrix.rotation];\n      scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n      const transformations = [];\n\n      if (translation[0] !== 0 || translation[1] !== 0) {\n        transformations.push(`translate(${translation.join(',')})`);\n      }\n\n      if (scale[0] !== 1 || scale[1] !== 1) {\n        transformations.push(`scale(${scale.join(',')})`);\n      }\n\n      if (rotation[0] !== 0) {\n        transformations.push(`rotate(${rotation[0]})`);\n      }\n\n      transform = transformations.join(' '); // eslint-disable-line\n    } else {\n      const translateMatch = transform.match(/translate\\((.*?)\\)/);\n\n      if (translateMatch) {\n        translation = translateMatch[1].split(separator);\n      }\n\n      const rotateMatch = transform.match(/rotate\\((.*?)\\)/);\n\n      if (rotateMatch) {\n        rotation = rotateMatch[1].split(separator);\n      }\n\n      const scaleMatch = transform.match(/scale\\((.*?)\\)/);\n\n      if (scaleMatch) {\n        scale = scaleMatch[1].split(separator);\n      }\n    }\n  }\n\n  const sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n  return {\n    raw: transform || '',\n    translation: {\n      tx: translation && translation[0] ? parseInt(translation[0], 10) : 0,\n      ty: translation && translation[1] ? parseInt(translation[1], 10) : 0\n    },\n    rotation: {\n      angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,\n      cx: rotation && rotation[1] ? parseInt(rotation[1], 10) : undefined,\n      cy: rotation && rotation[2] ? parseInt(rotation[2], 10) : undefined\n    },\n    scale: {\n      sx,\n      sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n    }\n  };\n}\n\nfunction deltaTransformPoint(matrix, point) {\n  const dx = point.x * matrix.a + point.y * matrix.c + 0;\n  const dy = point.x * matrix.b + point.y * matrix.d + 0;\n  return {\n    x: dx,\n    y: dy\n  };\n}\n/**\n * Decomposes the SVG transformation matrix into separate transformations.\n *\n * Returns an object of the form:\n * {\n *   translateX: number\n *   translateY: number\n *   scaleX: number\n *   scaleY: number\n *   skewX: number\n *   skewY: number\n *   rotation: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\n\n\nexport function decomposeMatrix(matrix) {\n  // @see https://gist.github.com/2052247\n  const px = deltaTransformPoint(matrix, {\n    x: 0,\n    y: 1\n  });\n  const py = deltaTransformPoint(matrix, {\n    x: 1,\n    y: 0\n  });\n  const skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;\n  const skewY = 180 / Math.PI * Math.atan2(py.y, py.x);\n  return {\n    skewX,\n    skewY,\n    translateX: matrix.e,\n    translateY: matrix.f,\n    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n    rotation: skewX\n  };\n}\nexport function matrixToScale(matrix) {\n  let a;\n  let b;\n  let c;\n  let d;\n\n  if (matrix) {\n    a = matrix.a == null ? 1 : matrix.a;\n    d = matrix.d == null ? 1 : matrix.d;\n    b = matrix.b;\n    c = matrix.c;\n  } else {\n    a = d = 1;\n  }\n\n  return {\n    sx: b ? Math.sqrt(a * a + b * b) : a,\n    sy: c ? Math.sqrt(c * c + d * d) : d\n  };\n}\nexport function matrixToRotation(matrix) {\n  let p = {\n    x: 0,\n    y: 1\n  };\n\n  if (matrix) {\n    p = deltaTransformPoint(matrix, p);\n  }\n\n  return {\n    angle: Angle.normalize(Angle.toDeg(Math.atan2(p.y, p.x)) - 90)\n  };\n}\nexport function matrixToTranslation(matrix) {\n  return {\n    tx: matrix && matrix.e || 0,\n    ty: matrix && matrix.f || 0\n  };\n}\n/**\n * Transforms point by an SVG transformation represented by `matrix`.\n */\n\nexport function transformPoint(point, matrix) {\n  const ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);\n  return new Point(ret.x, ret.y);\n}\n/**\n * Transforms line by an SVG transformation represented by `matrix`.\n */\n\nexport function transformLine(line, matrix) {\n  return new Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));\n}\n/**\n * Transforms polyline by an SVG transformation represented by `matrix`.\n */\n\nexport function transformPolyline(polyline, matrix) {\n  let points = polyline instanceof Polyline ? polyline.points : polyline;\n\n  if (!Array.isArray(points)) {\n    points = [];\n  }\n\n  return new Polyline(points.map(p => transformPoint(p, matrix)));\n}\nexport function transformRectangle(rect, matrix) {\n  const p = svgDocument.createSVGPoint();\n  p.x = rect.x;\n  p.y = rect.y;\n  const corner1 = p.matrixTransform(matrix);\n  p.x = rect.x + rect.width;\n  p.y = rect.y;\n  const corner2 = p.matrixTransform(matrix);\n  p.x = rect.x + rect.width;\n  p.y = rect.y + rect.height;\n  const corner3 = p.matrixTransform(matrix);\n  p.x = rect.x;\n  p.y = rect.y + rect.height;\n  const corner4 = p.matrixTransform(matrix);\n  const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);\n  const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);\n  const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);\n  const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);\n  return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n}","map":null,"metadata":{},"sourceType":"module"}