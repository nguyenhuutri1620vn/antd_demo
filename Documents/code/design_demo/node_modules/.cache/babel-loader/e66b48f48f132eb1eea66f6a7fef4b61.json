{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Basecoat } from '../common';\nimport { Attr } from '../registry';\nimport { Animation } from './animation';\nimport { Store } from './store';\nexport class Cell extends Basecoat {\n  constructor() {\n    let metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    const ctor = this.constructor;\n    const defaults = ctor.getDefaults(true);\n    const props = ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));\n    this.id = props.id || StringExt.uuid();\n    this.store = new Store(props);\n    this.animation = new Animation(this);\n    this.setup();\n    this.init();\n    this.postprocess(metadata);\n  }\n\n  static config(presets) {\n    const {\n      markup,\n      propHooks,\n      attrHooks\n    } = presets,\n          others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n\n    if (markup != null) {\n      this.markup = markup;\n    }\n\n    if (propHooks) {\n      this.propHooks = this.propHooks.slice();\n\n      if (Array.isArray(propHooks)) {\n        this.propHooks.push(...propHooks);\n      } else if (typeof propHooks === 'function') {\n        this.propHooks.push(propHooks);\n      } else {\n        Object.keys(propHooks).forEach(name => {\n          const hook = propHooks[name];\n\n          if (typeof hook === 'function') {\n            this.propHooks.push(hook);\n          }\n        });\n      }\n    }\n\n    if (attrHooks) {\n      this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n    }\n\n    this.defaults = ObjectExt.merge({}, this.defaults, others);\n  }\n\n  static getMarkup() {\n    return this.markup;\n  }\n\n  static getDefaults(raw) {\n    return raw ? this.defaults : ObjectExt.cloneDeep(this.defaults);\n  }\n\n  static getAttrHooks() {\n    return this.attrHooks;\n  }\n\n  static applyPropHooks(cell, metadata) {\n    return this.propHooks.reduce((memo, hook) => {\n      return hook ? FunctionExt.call(hook, cell, memo) : memo;\n    }, metadata);\n  } // #endregion\n\n\n  get [Symbol.toStringTag]() {\n    return Cell.toStringTag;\n  }\n\n  init() {} // #region model\n\n\n  get model() {\n    return this._model;\n  }\n\n  set model(model) {\n    if (this._model !== model) {\n      this._model = model;\n    }\n  } // #endregion\n\n\n  preprocess(metadata, ignoreIdCheck) {\n    const id = metadata.id;\n    const ctor = this.constructor;\n    const props = ctor.applyPropHooks(this, metadata);\n\n    if (id == null && ignoreIdCheck !== true) {\n      props.id = StringExt.uuid();\n    }\n\n    return props;\n  }\n\n  postprocess(metadata) {} // eslint-disable-line\n\n\n  setup() {\n    this.store.on('change:*', metadata => {\n      const {\n        key,\n        current,\n        previous,\n        options\n      } = metadata;\n      this.notify('change:*', {\n        key,\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      this.notify(`change:${key}`, {\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      const type = key;\n\n      if (type === 'source' || type === 'target') {\n        this.notify(`change:terminal`, {\n          type,\n          current,\n          previous,\n          options,\n          cell: this\n        });\n      }\n    });\n    this.store.on('changed', _ref => {\n      let {\n        options\n      } = _ref;\n      return this.notify('changed', {\n        options,\n        cell: this\n      });\n    });\n  }\n\n  notify(name, args) {\n    this.trigger(name, args);\n    const model = this.model;\n\n    if (model) {\n      model.notify(`cell:${name}`, args);\n\n      if (this.isNode()) {\n        model.notify(`node:${name}`, Object.assign(Object.assign({}, args), {\n          node: this\n        }));\n      } else if (this.isEdge()) {\n        model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), {\n          edge: this\n        }));\n      }\n    }\n\n    return this;\n  }\n\n  isNode() {\n    return false;\n  }\n\n  isEdge() {\n    return false;\n  }\n\n  isSameStore(cell) {\n    return this.store === cell.store;\n  }\n\n  get view() {\n    return this.store.get('view');\n  }\n\n  get shape() {\n    return this.store.get('shape', '');\n  }\n\n  getProp(key, defaultValue) {\n    if (key == null) {\n      return this.store.get();\n    }\n\n    return this.store.get(key, defaultValue);\n  }\n\n  setProp(key, value, options) {\n    if (typeof key === 'string') {\n      this.store.set(key, value, options);\n    } else {\n      const props = this.preprocess(key, true);\n      this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n      this.postprocess(key);\n    }\n\n    return this;\n  }\n\n  removeProp(key, options) {\n    if (typeof key === 'string' || Array.isArray(key)) {\n      this.store.removeByPath(key, options);\n    } else {\n      this.store.remove(options);\n    }\n\n    return this;\n  }\n\n  hasChanged(key) {\n    return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n  }\n\n  getPropByPath(path) {\n    return this.store.getByPath(path);\n  }\n\n  setPropByPath(path, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (this.model) {\n      // update inner reference\n      if (path === 'children') {\n        this._children = value ? value.map(id => this.model.getCell(id)).filter(child => child != null) : null;\n      } else if (path === 'parent') {\n        this._parent = value ? this.model.getCell(value) : null;\n      }\n    }\n\n    this.store.setByPath(path, value, options);\n    return this;\n  }\n\n  removePropByPath(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const paths = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` the CellView will\n    // recognize a `dirty` flag and re-render itself in order to remove\n    // the attribute from SVGElement.\n\n    if (paths[0] === 'attrs') {\n      options.dirty = true;\n    }\n\n    this.store.removeByPath(paths, options);\n    return this;\n  }\n\n  prop(key, value, options) {\n    if (key == null) {\n      return this.getProp();\n    }\n\n    if (typeof key === 'string' || Array.isArray(key)) {\n      if (arguments.length === 1) {\n        return this.getPropByPath(key);\n      }\n\n      if (value == null) {\n        return this.removePropByPath(key, options || {});\n      }\n\n      return this.setPropByPath(key, value, options || {});\n    }\n\n    return this.setProp(key, value || {});\n  }\n\n  previous(name) {\n    return this.store.getPrevious(name);\n  } // #endregion\n  // #region zIndex\n\n\n  get zIndex() {\n    return this.getZIndex();\n  }\n\n  set zIndex(z) {\n    if (z == null) {\n      this.removeZIndex();\n    } else {\n      this.setZIndex(z);\n    }\n  }\n\n  getZIndex() {\n    return this.store.get('zIndex');\n  }\n\n  setZIndex(z) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('zIndex', z, options);\n    return this;\n  }\n\n  removeZIndex() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('zIndex', options);\n    return this;\n  }\n\n  toFront() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const model = this.model;\n\n    if (model) {\n      let z = model.getMaxZIndex();\n      let cells;\n\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      z = z - cells.length + 1;\n      const count = model.total();\n      let changed = model.indexOf(this) !== count - cells.length;\n\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n\n      if (changed) {\n        this.batchUpdate('to-front', () => {\n          z += cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n\n    return this;\n  }\n\n  toBack() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const model = this.model;\n\n    if (model) {\n      let z = model.getMinZIndex();\n      let cells;\n\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      let changed = model.indexOf(this) !== 0;\n\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n\n      if (changed) {\n        this.batchUpdate('to-back', () => {\n          z -= cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n\n    return this;\n  } // #endregion\n  // #region markup\n\n\n  get markup() {\n    return this.getMarkup();\n  }\n\n  set markup(value) {\n    if (value == null) {\n      this.removeMarkup();\n    } else {\n      this.setMarkup(value);\n    }\n  }\n\n  getMarkup() {\n    let markup = this.store.get('markup');\n\n    if (markup == null) {\n      const ctor = this.constructor;\n      markup = ctor.getMarkup();\n    }\n\n    return markup;\n  }\n\n  setMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('markup', markup, options);\n    return this;\n  }\n\n  removeMarkup() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('markup', options);\n    return this;\n  } // #endregion\n  // #region attrs\n\n\n  get attrs() {\n    return this.getAttrs();\n  }\n\n  set attrs(value) {\n    if (value == null) {\n      this.removeAttrs();\n    } else {\n      this.setAttrs(value);\n    }\n  }\n\n  getAttrs() {\n    const result = this.store.get('attrs');\n    return result ? Object.assign({}, result) : {};\n  }\n\n  setAttrs(attrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (attrs == null) {\n      this.removeAttrs(options);\n    } else {\n      const set = attrs => this.store.set('attrs', attrs, options);\n\n      if (options.overwrite === true) {\n        set(attrs);\n      } else {\n        const prev = this.getAttrs();\n\n        if (options.deep === false) {\n          set(Object.assign(Object.assign({}, prev), attrs));\n        } else {\n          set(ObjectExt.merge({}, prev, attrs));\n        }\n      }\n    }\n\n    return this;\n  }\n\n  replaceAttrs(attrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n\n  updateAttrs(attrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n\n  removeAttrs() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('attrs', options);\n    return this;\n  }\n\n  getAttrDefinition(attrName) {\n    if (!attrName) {\n      return null;\n    }\n\n    const ctor = this.constructor;\n    const hooks = ctor.getAttrHooks() || {};\n    let definition = hooks[attrName] || Attr.registry.get(attrName);\n\n    if (!definition) {\n      const name = StringExt.camelCase(attrName);\n      definition = hooks[name] || Attr.registry.get(name);\n    }\n\n    return definition || null;\n  }\n\n  getAttrByPath(path) {\n    if (path == null || path === '') {\n      return this.getAttrs();\n    }\n\n    return this.getPropByPath(this.prefixAttrPath(path));\n  }\n\n  setAttrByPath(path, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.setPropByPath(this.prefixAttrPath(path), value, options);\n    return this;\n  }\n\n  removeAttrByPath(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.removePropByPath(this.prefixAttrPath(path), options);\n    return this;\n  }\n\n  prefixAttrPath(path) {\n    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;\n  }\n\n  attr(path, value, options) {\n    if (path == null) {\n      return this.getAttrByPath();\n    }\n\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 1) {\n        return this.getAttrByPath(path);\n      }\n\n      if (value == null) {\n        return this.removeAttrByPath(path, options || {});\n      }\n\n      return this.setAttrByPath(path, value, options || {});\n    }\n\n    return this.setAttrs(path, value || {});\n  } // #endregion\n  // #region visible\n\n\n  get visible() {\n    return this.isVisible();\n  }\n\n  set visible(value) {\n    this.setVisible(value);\n  }\n\n  setVisible(visible) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('visible', visible, options);\n    return this;\n  }\n\n  isVisible() {\n    return this.store.get('visible') !== false;\n  }\n\n  show() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.isVisible()) {\n      this.setVisible(true, options);\n    }\n\n    return this;\n  }\n\n  hide() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.isVisible()) {\n      this.setVisible(false, options);\n    }\n\n    return this;\n  }\n\n  toggleVisible(isVisible) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n    const localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n\n    if (visible) {\n      this.show(localOptions);\n    } else {\n      this.hide(localOptions);\n    }\n\n    return this;\n  } // #endregion\n  // #region data\n\n\n  get data() {\n    return this.getData();\n  }\n\n  set data(val) {\n    this.setData(val);\n  }\n\n  getData() {\n    return this.store.get('data');\n  }\n\n  setData(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (data == null) {\n      this.removeData(options);\n    } else {\n      const set = data => this.store.set('data', data, options);\n\n      if (options.overwrite === true) {\n        set(data);\n      } else {\n        const prev = this.getData();\n\n        if (options.deep === false) {\n          set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n        } else {\n          set(ObjectExt.merge({}, prev, data));\n        }\n      }\n    }\n\n    return this;\n  }\n\n  replaceData(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n\n  updateData(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n\n  removeData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('data', options);\n    return this;\n  } // #endregion\n  // #region parent children\n\n\n  get parent() {\n    return this.getParent();\n  }\n\n  get children() {\n    return this.getChildren();\n  }\n\n  getParentId() {\n    return this.store.get('parent');\n  }\n\n  getParent() {\n    const parentId = this.getParentId();\n\n    if (parentId && this.model) {\n      const parent = this.model.getCell(parentId);\n      this._parent = parent;\n      return parent;\n    }\n\n    return null;\n  }\n\n  getChildren() {\n    const childrenIds = this.store.get('children');\n\n    if (childrenIds && childrenIds.length && this.model) {\n      const children = childrenIds.map(id => {\n        var _a;\n\n        return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id);\n      }).filter(cell => cell != null);\n      this._children = children;\n      return [...children];\n    }\n\n    return null;\n  }\n\n  hasParent() {\n    return this.parent != null;\n  }\n\n  isParentOf(child) {\n    return child != null && child.getParent() === this;\n  }\n\n  isChildOf(parent) {\n    return parent != null && this.getParent() === parent;\n  }\n\n  eachChild(iterator, context) {\n    if (this.children) {\n      this.children.forEach(iterator, context);\n    }\n\n    return this;\n  }\n\n  filterChild(filter, context) {\n    return this.children ? this.children.filter(filter, context) : [];\n  }\n\n  getChildCount() {\n    return this.children == null ? 0 : this.children.length;\n  }\n\n  getChildIndex(child) {\n    return this.children == null ? -1 : this.children.indexOf(child);\n  }\n\n  getChildAt(index) {\n    return this.children != null && index >= 0 ? this.children[index] : null;\n  }\n\n  getAncestors() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const ancestors = [];\n    let parent = this.getParent();\n\n    while (parent) {\n      ancestors.push(parent);\n      parent = options.deep !== false ? parent.getParent() : null;\n    }\n\n    return ancestors;\n  }\n\n  getDescendants() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.deep !== false) {\n      // breadth first\n      if (options.breadthFirst) {\n        const cells = [];\n        const queue = this.getChildren() || [];\n\n        while (queue.length > 0) {\n          const parent = queue.shift();\n          const children = parent.getChildren();\n          cells.push(parent);\n\n          if (children) {\n            queue.push(...children);\n          }\n        }\n\n        return cells;\n      } // depth first\n\n\n      {\n        const cells = this.getChildren() || [];\n        cells.forEach(cell => {\n          cells.push(...cell.getDescendants(options));\n        });\n        return cells;\n      }\n    }\n\n    return this.getChildren() || [];\n  }\n\n  isDescendantOf(ancestor) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ancestor == null) {\n      return false;\n    }\n\n    if (options.deep !== false) {\n      let current = this.getParent();\n\n      while (current) {\n        if (current === ancestor) {\n          return true;\n        }\n\n        current = current.getParent();\n      }\n\n      return false;\n    }\n\n    return this.isChildOf(ancestor);\n  }\n\n  isAncestorOf(descendant) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (descendant == null) {\n      return false;\n    }\n\n    return descendant.isDescendantOf(this, options);\n  }\n\n  contains(cell) {\n    return this.isAncestorOf(cell);\n  }\n\n  getCommonAncestor() {\n    for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {\n      cells[_key] = arguments[_key];\n    }\n\n    return Cell.getCommonAncestor(this, ...cells);\n  }\n\n  setParent(parent) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._parent = parent;\n\n    if (parent) {\n      this.store.set('parent', parent.id, options);\n    } else {\n      this.store.remove('parent', options);\n    }\n\n    return this;\n  }\n\n  setChildren(children) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._children = children;\n\n    if (children != null) {\n      this.store.set('children', children.map(child => child.id), options);\n    } else {\n      this.store.remove('children', options);\n    }\n\n    return this;\n  }\n\n  unembed(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const children = this.children;\n\n    if (children != null && child != null) {\n      const index = this.getChildIndex(child);\n\n      if (index !== -1) {\n        children.splice(index, 1);\n        child.setParent(null, options);\n        this.setChildren(children, options);\n      }\n    }\n\n    return this;\n  }\n\n  embed(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    child.addTo(this, options);\n    return this;\n  }\n\n  addTo(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (Cell.isCell(target)) {\n      target.addChild(this, options);\n    } else {\n      target.addCell(this, options);\n    }\n\n    return this;\n  }\n\n  insertTo(parent, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    parent.insertChild(this, index, options);\n    return this;\n  }\n\n  addChild(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.insertChild(child, undefined, options);\n  }\n\n  insertChild(child, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (child != null && child !== this) {\n      const oldParent = child.getParent();\n      const changed = this !== oldParent;\n      let pos = index;\n\n      if (pos == null) {\n        pos = this.getChildCount();\n\n        if (!changed) {\n          pos -= 1;\n        }\n      } // remove from old parent\n\n\n      if (oldParent) {\n        const children = oldParent.getChildren();\n\n        if (children) {\n          const index = children.indexOf(child);\n\n          if (index >= 0) {\n            child.setParent(null, options);\n            children.splice(index, 1);\n            oldParent.setChildren(children, options);\n          }\n        }\n      }\n\n      let children = this.children;\n\n      if (children == null) {\n        children = [];\n        children.push(child);\n      } else {\n        children.splice(pos, 0, child);\n      }\n\n      child.setParent(this, options);\n      this.setChildren(children, options);\n\n      if (changed && this.model) {\n        const incomings = this.model.getIncomingEdges(this);\n        const outgoings = this.model.getOutgoingEdges(this);\n\n        if (incomings) {\n          incomings.forEach(edge => edge.updateParent(options));\n        }\n\n        if (outgoings) {\n          outgoings.forEach(edge => edge.updateParent(options));\n        }\n      }\n\n      if (this.model) {\n        this.model.addCell(child, options);\n      }\n    }\n\n    return this;\n  }\n\n  removeFromParent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const parent = this.getParent();\n\n    if (parent != null) {\n      const index = parent.getChildIndex(this);\n      parent.removeChildAt(index, options);\n    }\n\n    return this;\n  }\n\n  removeChild(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.getChildIndex(child);\n    return this.removeChildAt(index, options);\n  }\n\n  removeChildAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const child = this.getChildAt(index);\n    const children = this.children;\n\n    if (children != null && child != null) {\n      this.unembed(child, options);\n      child.remove(options);\n    }\n\n    return child;\n  }\n\n  remove() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.batchUpdate('remove', () => {\n      const parent = this.getParent();\n\n      if (parent) {\n        parent.removeChild(this, options);\n      }\n\n      if (options.deep !== false) {\n        this.eachChild(child => child.remove(options));\n      }\n\n      if (this.model) {\n        this.model.removeCell(this, options);\n      }\n    });\n    return this;\n  }\n\n  transition(path, target) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let delim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n    return this.animation.start(path, target, options, delim);\n  }\n\n  stopTransition(path, options) {\n    let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n    this.animation.stop(path, options, delim);\n    return this;\n  }\n\n  getTransitions() {\n    return this.animation.get();\n  } // #endregion\n  // #region transform\n  // eslint-disable-next-line\n\n\n  translate(tx, ty, options) {\n    return this;\n  }\n\n  scale(sx, // eslint-disable-line\n  sy, // eslint-disable-line\n  origin, // eslint-disable-line\n  options) {\n    return this;\n  }\n\n  addTools(items, obj, options) {\n    const toolItems = Array.isArray(items) ? items : [items];\n    const name = typeof obj === 'string' ? obj : null;\n    const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n\n    if (config.reset) {\n      return this.setTools({\n        name,\n        items: toolItems,\n        local: config.local\n      }, config);\n    }\n\n    let tools = ObjectExt.cloneDeep(this.getTools());\n\n    if (tools == null || name == null || tools.name === name) {\n      if (tools == null) {\n        tools = {};\n      }\n\n      if (!tools.items) {\n        tools.items = [];\n      }\n\n      tools.name = name;\n      tools.items = [...tools.items, ...toolItems];\n      return this.setTools(Object.assign({}, tools), config);\n    }\n  }\n\n  setTools(tools) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (tools == null) {\n      this.removeTools();\n    } else {\n      this.store.set('tools', Cell.normalizeTools(tools), options);\n    }\n\n    return this;\n  }\n\n  getTools() {\n    return this.store.get('tools');\n  }\n\n  removeTools() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('tools', options);\n    return this;\n  }\n\n  hasTools(name) {\n    const tools = this.getTools();\n\n    if (tools == null) {\n      return false;\n    }\n\n    if (name == null) {\n      return true;\n    }\n\n    return tools.name === name;\n  }\n\n  hasTool(name) {\n    const tools = this.getTools();\n\n    if (tools == null) {\n      return false;\n    }\n\n    return tools.items.some(item => typeof item === 'string' ? item === name : item.name === name);\n  }\n\n  removeTool(nameOrIndex) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const tools = ObjectExt.cloneDeep(this.getTools());\n\n    if (tools) {\n      let updated = false;\n      const items = tools.items.slice();\n\n      const remove = index => {\n        items.splice(index, 1);\n        updated = true;\n      };\n\n      if (typeof nameOrIndex === 'number') {\n        remove(nameOrIndex);\n      } else {\n        for (let i = items.length - 1; i >= 0; i -= 1) {\n          const item = items[i];\n          const exist = typeof item === 'string' ? item === nameOrIndex : item.name === nameOrIndex;\n\n          if (exist) {\n            remove(i);\n          }\n        }\n      }\n\n      if (updated) {\n        tools.items = items;\n        this.setTools(tools, options);\n      }\n    }\n\n    return this;\n  } // #endregion\n  // #region common\n  // eslint-disable-next-line\n\n\n  getBBox(options) {\n    return new Rectangle();\n  } // eslint-disable-next-line\n\n\n  getConnectionPoint(edge, type) {\n    return new Point();\n  }\n\n  toJSON() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const props = Object.assign({}, this.store.get());\n    const toString = Object.prototype.toString;\n    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n\n    if (!props.shape) {\n      const ctor = this.constructor;\n      throw new Error(`Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${ctor.name || toString.call(ctor)}\"`);\n    }\n\n    const ctor = this.constructor;\n    const diff = options.diff === true;\n    const attrs = props.attrs || {};\n    const presets = ctor.getDefaults(true); // When `options.diff` is `true`, we should process the custom options,\n    // such as `width`, `height` etc. to ensure the comparing work correctly.\n\n    const defaults = diff ? this.preprocess(presets, true) : presets;\n    const defaultAttrs = defaults.attrs || {};\n    const finalAttrs = {};\n    Object.keys(props).forEach(key => {\n      const val = props[key];\n\n      if (val != null && !Array.isArray(val) && typeof val === 'object' && !ObjectExt.isPlainObject(val)) {\n        throw new Error(`Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(val)}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`);\n      }\n\n      if (key !== 'attrs' && key !== 'shape' && diff) {\n        const preset = defaults[key];\n\n        if (ObjectExt.isEqual(val, preset)) {\n          delete props[key];\n        }\n      }\n    });\n    Object.keys(attrs).forEach(key => {\n      const attr = attrs[key];\n      const defaultAttr = defaultAttrs[key];\n      Object.keys(attr).forEach(name => {\n        const value = attr[name];\n        const defaultValue = defaultAttr ? defaultAttr[name] : null;\n\n        if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n          Object.keys(value).forEach(subName => {\n            const subValue = value[subName];\n\n            if (defaultAttr == null || defaultValue == null || !ObjectExt.isObject(defaultValue) || !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n              if (finalAttrs[key] == null) {\n                finalAttrs[key] = {};\n              }\n\n              if (finalAttrs[key][name] == null) {\n                finalAttrs[key][name] = {};\n              }\n\n              const tmp = finalAttrs[key][name];\n              tmp[subName] = subValue;\n            }\n          });\n        } else if (defaultAttr == null || !ObjectExt.isEqual(defaultValue, value)) {\n          // `value` is not an object, default attribute with `key` does not\n          // exist or it is different than the attribute value set on the cell.\n          if (finalAttrs[key] == null) {\n            finalAttrs[key] = {};\n          }\n\n          finalAttrs[key][name] = value;\n        }\n      });\n    });\n    const finalProps = Object.assign(Object.assign({}, props), {\n      attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs\n    });\n\n    if (finalProps.attrs == null) {\n      delete finalProps.attrs;\n    }\n\n    const ret = finalProps;\n\n    if (ret.angle === 0) {\n      delete ret.angle;\n    }\n\n    return ObjectExt.cloneDeep(ret);\n  }\n\n  clone() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.deep) {\n      const data = Object.assign({}, this.store.get());\n\n      if (!options.keepId) {\n        delete data.id;\n      }\n\n      delete data.parent;\n      delete data.children;\n      const ctor = this.constructor;\n      return new ctor(data); // eslint-disable-line new-cap\n    } // Deep cloning. Clone the cell itself and all its children.\n\n\n    const map = Cell.deepClone(this);\n    return map[this.id];\n  }\n\n  findView(graph) {\n    return graph.renderer.findViewByCell(this);\n  } // #endregion\n  // #region batch\n\n\n  startBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n    this.notify('batch:start', {\n      name,\n      data,\n      cell: this\n    });\n\n    if (model) {\n      model.startBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n\n    return this;\n  }\n\n  stopBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n\n    if (model) {\n      model.stopBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n\n    this.notify('batch:stop', {\n      name,\n      data,\n      cell: this\n    });\n    return this;\n  }\n\n  batchUpdate(name, execute, data) {\n    // The model is null after cell was removed(remove batch).\n    // So we should temp save model to trigger pairing batch event.\n    const model = this.model;\n    this.startBatch(name, data, model);\n    const result = execute();\n    this.stopBatch(name, data, model);\n    return result;\n  } // #endregion\n  // #region IDisposable\n\n\n  dispose() {\n    this.removeFromParent();\n    this.store.dispose();\n  }\n\n}\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n\n__decorate([Basecoat.dispose()], Cell.prototype, \"dispose\", null);\n\n(function (Cell) {\n  function normalizeTools(raw) {\n    if (typeof raw === 'string') {\n      return {\n        items: [raw]\n      };\n    }\n\n    if (Array.isArray(raw)) {\n      return {\n        items: raw\n      };\n    }\n\n    if (raw.items) {\n      return raw;\n    }\n\n    return {\n      items: [raw]\n    };\n  }\n\n  Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.toStringTag = `X6.${Cell.name}`;\n\n  function isCell(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Cell) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const cell = instance;\n\n    if ((tag == null || tag === Cell.toStringTag) && typeof cell.isNode === 'function' && typeof cell.isEdge === 'function' && typeof cell.prop === 'function' && typeof cell.attr === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  function getCommonAncestor() {\n    for (var _len2 = arguments.length, cells = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      cells[_key2] = arguments[_key2];\n    }\n\n    const ancestors = cells.filter(cell => cell != null).map(cell => cell.getAncestors()).sort((a, b) => {\n      return a.length - b.length;\n    });\n    const first = ancestors.shift();\n    return first.find(cell => ancestors.every(item => item.includes(cell))) || null;\n  }\n\n  Cell.getCommonAncestor = getCommonAncestor;\n\n  function getCellsBBox(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let bbox = null;\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const cell = cells[i];\n      let rect = cell.getBBox(options);\n\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle();\n\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle);\n          }\n        }\n\n        bbox = bbox == null ? rect : bbox.union(rect);\n      }\n    }\n\n    return bbox;\n  }\n\n  Cell.getCellsBBox = getCellsBBox;\n\n  function deepClone(cell) {\n    const cells = [cell, ...cell.getDescendants({\n      deep: true\n    })];\n    return Cell.cloneCells(cells);\n  }\n\n  Cell.deepClone = deepClone;\n\n  function cloneCells(cells) {\n    const inputs = ArrayExt.uniq(cells);\n    const cloneMap = inputs.reduce((map, cell) => {\n      map[cell.id] = cell.clone();\n      return map;\n    }, {});\n    inputs.forEach(cell => {\n      const clone = cloneMap[cell.id];\n\n      if (clone.isEdge()) {\n        const sourceId = clone.getSourceCellId();\n        const targetId = clone.getTargetCellId();\n\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {\n            cell: cloneMap[sourceId].id\n          }));\n        }\n\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {\n            cell: cloneMap[targetId].id\n          }));\n        }\n      } // Find the parent of the original cell\n\n\n      const parent = cell.getParent();\n\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id]);\n      } // Find the children of the original cell\n\n\n      const children = cell.getChildren();\n\n      if (children && children.length) {\n        const embeds = children.reduce((memo, child) => {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id]);\n          }\n\n          return memo;\n        }, []);\n\n        if (embeds.length > 0) {\n          clone.setChildren(embeds);\n        }\n      }\n    });\n    return cloneMap;\n  }\n\n  Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.config({\n    propHooks(_a) {\n      var {\n        tools\n      } = _a,\n          metadata = __rest(_a, [\"tools\"]);\n\n      if (tools) {\n        metadata.tools = Cell.normalizeTools(tools);\n      }\n\n      return metadata;\n    }\n\n  });\n})(Cell || (Cell = {}));","map":null,"metadata":{},"sourceType":"module"}