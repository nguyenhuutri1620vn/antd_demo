{"ast":null,"code":"import { Util } from '../../global';\nimport { NumberExt } from '../../util';\nimport { Angle, Point } from '../../geometry';\nimport { Widget } from '../common';\nimport { notify } from './util';\nexport class Transform extends Widget {\n  get node() {\n    return this.cell;\n  }\n\n  get containerClassName() {\n    return this.prefixClassName('widget-transform');\n  }\n\n  get resizeClassName() {\n    return `${this.containerClassName}-resize`;\n  }\n\n  get rotateClassName() {\n    return `${this.containerClassName}-rotate`;\n  }\n\n  init(options) {\n    this.options = Object.assign(Object.assign({}, Private.defaultOptions), options);\n    this.render();\n    this.startListening();\n  }\n\n  startListening() {\n    this.delegateEvents({\n      [`mousedown .${this.resizeClassName}`]: 'startResizing',\n      [`touchstart .${this.resizeClassName}`]: 'startResizing',\n      [`mousedown .${this.rotateClassName}`]: 'startRotating',\n      [`touchstart .${this.rotateClassName}`]: 'startRotating'\n    });\n    this.model.on('*', this.update, this);\n    this.graph.on('scale', this.update, this);\n    this.graph.on('translate', this.update, this);\n    this.node.on('removed', this.remove, this);\n    this.model.on('reseted', this.remove, this);\n    this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);\n    this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);\n    super.startListening();\n  }\n\n  stopListening() {\n    this.undelegateEvents();\n    this.model.off('*', this.update, this);\n    this.graph.off('scale', this.update, this);\n    this.graph.off('translate', this.update, this);\n    this.node.off('removed', this.remove, this);\n    this.model.off('reseted', this.remove, this);\n    this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);\n    this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);\n    super.stopListening();\n  }\n\n  renderHandles() {\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container);\n    const $knob = this.$('<div/>').prop('draggable', false);\n    const $rotate = $knob.clone().addClass(this.rotateClassName);\n    const $resizes = Private.POSITIONS.map(pos => {\n      return $knob.clone().addClass(this.resizeClassName).attr('data-position', pos);\n    });\n    this.empty();\n    this.$container.append($resizes, $rotate);\n  }\n\n  render() {\n    this.renderHandles();\n    this.view.addClass(Private.NODE_CLS);\n    this.$container.addClass(this.containerClassName).toggleClass('no-orth-resize', this.options.preserveAspectRatio || !this.options.orthogonalResizing).toggleClass('no-resize', !this.options.resizable).toggleClass('no-rotate', !this.options.rotatable);\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n\n    this.graph.container.appendChild(this.container);\n    return this.update();\n  }\n\n  update() {\n    const ctm = this.graph.matrix();\n    const bbox = this.node.getBBox();\n    bbox.x *= ctm.a;\n    bbox.x += ctm.e;\n    bbox.y *= ctm.d;\n    bbox.y += ctm.f;\n    bbox.width *= ctm.a;\n    bbox.height *= ctm.d;\n    const angle = Angle.normalize(this.node.getAngle());\n    const transform = angle !== 0 ? `rotate(${angle}deg)` : '';\n    this.$container.css({\n      transform,\n      width: bbox.width,\n      height: bbox.height,\n      left: bbox.x,\n      top: bbox.y\n    });\n    this.updateResizerDirections();\n    return this;\n  }\n\n  remove() {\n    this.view.removeClass(Private.NODE_CLS);\n    return super.remove();\n  }\n\n  onKnobMouseDown() {\n    this.startHandle();\n  }\n\n  onKnobMouseUp() {\n    this.stopHandle();\n  }\n\n  updateResizerDirections() {\n    // Update the directions on the resizer divs while the node being rotated.\n    // The directions are represented by cardinal points (N,S,E,W). For example\n    // the div originally pointed to north needs to be changed to point to south\n    // if the node was rotated by 180 degrees.\n    const angle = Angle.normalize(this.node.getAngle());\n    const shift = Math.floor(angle * (Private.DIRECTIONS.length / 360));\n\n    if (shift !== this.prevShift) {\n      // Create the current directions array based on the calculated shift.\n      const directions = Private.DIRECTIONS.slice(shift).concat(Private.DIRECTIONS.slice(0, shift));\n\n      const className = dir => `${this.containerClassName}-cursor-${dir}`;\n\n      this.$container.find(`.${this.resizeClassName}`).removeClass(Private.DIRECTIONS.map(dir => className(dir)).join(' ')).each((index, elem) => {\n        this.$(elem).addClass(className(directions[index]));\n      });\n      this.prevShift = shift;\n    }\n  }\n\n  getTrueDirection(dir) {\n    const angle = Angle.normalize(this.node.getAngle());\n    let index = Private.POSITIONS.indexOf(dir);\n    index += Math.floor(angle * (Private.POSITIONS.length / 360));\n    index %= Private.POSITIONS.length;\n    return Private.POSITIONS[index];\n  }\n\n  toValidResizeDirection(dir) {\n    return {\n      top: 'top-left',\n      bottom: 'bottom-right',\n      left: 'bottom-left',\n      right: 'top-right'\n    }[dir] || dir;\n  }\n\n  startResizing(evt) {\n    evt.stopPropagation();\n    this.model.startBatch('resize', {\n      cid: this.cid\n    });\n    const dir = this.$(evt.target).attr('data-position');\n    const view = this.graph.findViewByCell(this.node);\n    this.prepareResizing(evt, dir);\n    this.startAction(evt);\n    notify('node:resize:mousedown', evt, view);\n  }\n\n  prepareResizing(evt, relativeDirection) {\n    const trueDirection = this.getTrueDirection(relativeDirection);\n    let rx = 0;\n    let ry = 0;\n    relativeDirection.split('-').forEach(direction => {\n      rx = {\n        left: -1,\n        right: 1\n      }[direction] || rx;\n      ry = {\n        top: -1,\n        bottom: 1\n      }[direction] || ry;\n    });\n    const direction = this.toValidResizeDirection(relativeDirection);\n    const selector = {\n      'top-right': 'bottomLeft',\n      'top-left': 'bottomRight',\n      'bottom-left': 'topRight',\n      'bottom-right': 'topLeft'\n    }[direction];\n    const angle = Angle.normalize(this.node.getAngle());\n    this.setEventData(evt, {\n      selector,\n      direction,\n      trueDirection,\n      relativeDirection,\n      angle,\n      resizeX: rx,\n      resizeY: ry,\n      action: 'resizing'\n    });\n  }\n\n  startRotating(evt) {\n    evt.stopPropagation();\n    this.model.startBatch('rotate', {\n      cid: this.cid\n    });\n    const view = this.graph.findViewByCell(this.node);\n    const center = this.node.getBBox().getCenter();\n    const e = this.normalizeEvent(evt);\n    const client = this.graph.snapToGrid(e.clientX, e.clientY);\n    this.setEventData(evt, {\n      center,\n      action: 'rotating',\n      angle: Angle.normalize(this.node.getAngle()),\n      start: Point.create(client).theta(center)\n    });\n    this.startAction(evt);\n    notify('node:rotate:mousedown', evt, view);\n  }\n\n  onMouseMove(evt) {\n    const view = this.graph.findViewByCell(this.node);\n    let data = this.getEventData(evt);\n\n    if (data.action) {\n      const e = this.normalizeEvent(evt);\n      let clientX = e.clientX;\n      let clientY = e.clientY;\n      const scroller = this.graph.scroller.widget;\n      const restrict = this.options.restrictedResizing;\n\n      if (restrict === true || typeof restrict === 'number') {\n        const factor = restrict === true ? 0 : restrict;\n        const fix = scroller ? Math.max(factor, 8) : factor;\n        const rect = this.graph.container.getBoundingClientRect();\n        clientX = NumberExt.clamp(clientX, rect.left + fix, rect.right - fix);\n        clientY = NumberExt.clamp(clientY, rect.top + fix, rect.bottom - fix);\n      } else if (this.options.autoScrollOnResizing && scroller) {\n        scroller.autoScroll(clientX, clientY);\n      }\n\n      const pos = this.graph.snapToGrid(clientX, clientY);\n      const gridSize = this.graph.getGridSize();\n      const node = this.node;\n      const options = this.options;\n\n      if (data.action === 'resizing') {\n        data = data;\n\n        if (!data.resized) {\n          if (view) {\n            view.addClass('node-resizing');\n            notify('node:resize', evt, view);\n          }\n\n          data.resized = true;\n        }\n\n        const currentBBox = node.getBBox();\n        const requestedSize = Point.create(pos).rotate(data.angle, currentBBox.getCenter()).diff(currentBBox[data.selector]);\n        let width = data.resizeX ? requestedSize.x * data.resizeX : currentBBox.width;\n        let height = data.resizeY ? requestedSize.y * data.resizeY : currentBBox.height;\n        const rawWidth = width;\n        const rawHeight = height;\n        width = Util.snapToGrid(width, gridSize);\n        height = Util.snapToGrid(height, gridSize);\n        width = Math.max(width, options.minWidth || gridSize);\n        height = Math.max(height, options.minHeight || gridSize);\n        width = Math.min(width, options.maxWidth || Infinity);\n        height = Math.min(height, options.maxHeight || Infinity);\n\n        if (options.preserveAspectRatio) {\n          const candidateWidth = currentBBox.width * height / currentBBox.height;\n          const candidateHeight = currentBBox.height * width / currentBBox.width;\n\n          if (width < candidateWidth) {\n            height = candidateHeight;\n          } else {\n            width = candidateWidth;\n          }\n        }\n\n        const relativeDirection = data.relativeDirection;\n\n        if (options.allowReverse && (rawWidth <= -width || rawHeight <= -height)) {\n          let reverted;\n\n          if (relativeDirection === 'left') {\n            if (rawWidth <= -width) {\n              reverted = 'right';\n            }\n          } else if (relativeDirection === 'right') {\n            if (rawWidth <= -width) {\n              reverted = 'left';\n            }\n          } else if (relativeDirection === 'top') {\n            if (rawHeight <= -height) {\n              reverted = 'bottom';\n            }\n          } else if (relativeDirection === 'bottom') {\n            if (rawHeight <= -height) {\n              reverted = 'top';\n            }\n          } else if (relativeDirection === 'top-left') {\n            if (rawWidth <= -width && rawHeight <= -height) {\n              reverted = 'bottom-right';\n            } else if (rawWidth <= -width) {\n              reverted = 'top-right';\n            } else if (rawHeight <= -height) {\n              reverted = 'bottom-left';\n            }\n          } else if (relativeDirection === 'top-right') {\n            if (rawWidth <= -width && rawHeight <= -height) {\n              reverted = 'bottom-left';\n            } else if (rawWidth <= -width) {\n              reverted = 'top-left';\n            } else if (rawHeight <= -height) {\n              reverted = 'bottom-right';\n            }\n          } else if (relativeDirection === 'bottom-left') {\n            if (rawWidth <= -width && rawHeight <= -height) {\n              reverted = 'top-right';\n            } else if (rawWidth <= -width) {\n              reverted = 'bottom-right';\n            } else if (rawHeight <= -height) {\n              reverted = 'top-left';\n            }\n          } else if (relativeDirection === 'bottom-right') {\n            if (rawWidth <= -width && rawHeight <= -height) {\n              reverted = 'top-left';\n            } else if (rawWidth <= -width) {\n              reverted = 'bottom-left';\n            } else if (rawHeight <= -height) {\n              reverted = 'top-right';\n            }\n          }\n\n          const revertedDir = reverted;\n          this.stopHandle();\n          const $handle = this.$container.find(`.${this.resizeClassName}[data-position=\"${revertedDir}\"]`);\n          this.startHandle($handle[0]);\n          this.prepareResizing(evt, revertedDir);\n          this.onMouseMove(evt);\n        }\n\n        if (currentBBox.width !== width || currentBBox.height !== height) {\n          const resizeOptions = {\n            ui: true,\n            direction: data.direction,\n            relativeDirection: data.relativeDirection,\n            trueDirection: data.trueDirection,\n            minWidth: options.minWidth,\n            minHeight: options.minHeight,\n            maxWidth: options.maxWidth,\n            maxHeight: options.maxHeight,\n            preserveAspectRatio: options.preserveAspectRatio === true\n          };\n          node.resize(width, height, resizeOptions);\n          notify('node:resizing', evt, view);\n        }\n\n        notify('node:resize:mousemove', evt, view);\n      } else if (data.action === 'rotating') {\n        data = data;\n\n        if (!data.rotated) {\n          if (view) {\n            view.addClass('node-rotating');\n            notify('node:rotate', evt, view);\n          }\n\n          data.rotated = true;\n        }\n\n        const currentAngle = node.getAngle();\n        const theta = data.start - Point.create(pos).theta(data.center);\n        let target = data.angle + theta;\n\n        if (options.rotateGrid) {\n          target = Util.snapToGrid(target, options.rotateGrid);\n        }\n\n        if (currentAngle !== target) {\n          node.rotate(target, {\n            absolute: true\n          });\n          notify('node:rotating', evt, view);\n        }\n\n        notify('node:rotate:mousemove', evt, view);\n      }\n    }\n  }\n\n  onMouseUp(evt) {\n    const view = this.graph.findViewByCell(this.node);\n    const data = this.getEventData(evt);\n\n    if (data.action) {\n      this.stopAction(evt);\n      this.model.stopBatch(data.action === 'resizing' ? 'resize' : 'rotate', {\n        cid: this.cid\n      });\n\n      if (data.action === 'resizing') {\n        notify('node:resize:mouseup', evt, view);\n      } else if (data.action === 'rotating') {\n        notify('node:rotate:mouseup', evt, view);\n      }\n    }\n  }\n\n  startHandle(handle) {\n    this.handle = handle || null;\n    this.$container.addClass(`${this.containerClassName}-active`);\n\n    if (handle) {\n      this.$(handle).addClass(`${this.containerClassName}-active-handle`);\n      const pos = handle.getAttribute('data-position');\n\n      if (pos) {\n        const dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];\n        this.$container.addClass(`${this.containerClassName}-cursor-${dir}`);\n      }\n    }\n  }\n\n  stopHandle() {\n    this.$container.removeClass(`${this.containerClassName}-active`);\n\n    if (this.handle) {\n      this.$(this.handle).removeClass(`${this.containerClassName}-active-handle`);\n      const pos = this.handle.getAttribute('data-position');\n\n      if (pos) {\n        const dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];\n        this.$container.removeClass(`${this.containerClassName}-cursor-${dir}`);\n      }\n\n      this.handle = null;\n    }\n  }\n\n  startAction(evt) {\n    this.startHandle(evt.target);\n    this.graph.view.undelegateEvents();\n    this.delegateDocumentEvents(Private.documentEvents, evt.data);\n  }\n\n  stopAction(evt) {\n    this.stopHandle();\n    this.undelegateDocumentEvents();\n    this.graph.view.delegateEvents();\n    const view = this.graph.findViewByCell(this.node);\n    const data = this.getEventData(evt);\n\n    if (view) {\n      view.removeClass(`node-${data.action}`);\n\n      if (data.action === 'resizing' && data.resized) {\n        notify('node:resized', evt, view);\n      } else if (data.action === 'rotating' && data.rotated) {\n        notify('node:rotated', evt, view);\n      }\n    }\n  }\n\n}\nvar Private;\n\n(function (Private) {\n  Private.NODE_CLS = 'has-widget-transform';\n  Private.DIRECTIONS = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];\n  Private.POSITIONS = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];\n  Private.documentEvents = {\n    mousemove: 'onMouseMove',\n    touchmove: 'onMouseMove',\n    mouseup: 'onMouseUp',\n    touchend: 'onMouseUp'\n  };\n  Private.defaultOptions = {\n    minWidth: 0,\n    minHeight: 0,\n    maxWidth: Infinity,\n    maxHeight: Infinity,\n    rotateGrid: 15,\n    rotatable: true,\n    preserveAspectRatio: false,\n    orthogonalResizing: true,\n    restrictedResizing: false,\n    autoScrollOnResizing: true,\n    allowReverse: true\n  };\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}