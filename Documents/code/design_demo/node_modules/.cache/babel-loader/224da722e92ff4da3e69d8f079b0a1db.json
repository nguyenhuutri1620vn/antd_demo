{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useRef, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport G6 from '@antv/g6';\nimport { isObject, isString, isEqual, isFunction } from '@antv/util';\nimport { getGraphSize, processMinimap, getCommonConfig, getArrowCfg, getMarkerPosition, setTag, getLevelData, getGraphId, renderGraph, bindStateEvents, bindDefaultEvents, bindSourceMapCollapseEvents, deepClone } from '../utils';\nimport { createToolbar } from '../components/toolbar';\nexport default function useGraph(graphClass, config, extra) {\n  if (extra === void 0) {\n    extra = {};\n  }\n\n  var container = useRef(null);\n  var graphRef = useRef();\n  var graphOptions = useRef(); // data 单独处理，会被 G6 修改\n\n  var graphData = useRef();\n  var data = config.data,\n      width = config.width,\n      height = config.height,\n      layout = config.layout,\n      minimapCfg = config.minimapCfg,\n      behaviors = config.behaviors,\n      fitCenter = config.fitCenter,\n      nodeCfg = config.nodeCfg,\n      edgeCfg = config.edgeCfg,\n      markerCfg = config.markerCfg,\n      level = config.level,\n      toolbarCfg = config.toolbarCfg;\n  var graph = graphRef.current;\n  /** 隐藏孤立边 */\n\n  var setEdgesState = function (edges) {\n    edges.forEach(function (edge) {\n      var _a, _b;\n\n      var _c = edge.getModel(),\n          source = _c.source,\n          target = _c.target;\n\n      var sourceVisible = (_a = graph === null || graph === void 0 ? void 0 : graph.findById(source)) === null || _a === void 0 ? void 0 : _a.get('visible');\n      var targetVisible = (_b = graph === null || graph === void 0 ? void 0 : graph.findById(target)) === null || _b === void 0 ? void 0 : _b.get('visible');\n\n      if (sourceVisible === false || targetVisible === false) {\n        edge.changeVisibility(false);\n      }\n    });\n  };\n\n  var changeData = function () {\n    var _a;\n\n    if (!graph) {\n      return;\n    }\n\n    var currentData = data;\n\n    if (level) {\n      currentData = setTag(data);\n    }\n\n    graph.changeData(level ? getLevelData(currentData, level) : data);\n    (_a = graph.get('eventData')) === null || _a === void 0 ? void 0 : _a.setData(currentData);\n    setEdgesState(graph.getEdges());\n\n    if (fitCenter) {\n      graph.fitCenter();\n    }\n  };\n\n  var updateLayout = function () {\n    graph === null || graph === void 0 ? void 0 : graph.updateLayout(layout);\n\n    if (fitCenter) {\n      graph === null || graph === void 0 ? void 0 : graph.fitCenter();\n    }\n  };\n\n  var updateNodes = function () {\n    if (!graph) {\n      return;\n    }\n\n    var _a = nodeCfg !== null && nodeCfg !== void 0 ? nodeCfg : {},\n        nodeType = _a.type,\n        nodeAnchorPoints = _a.anchorPoints,\n        nodeStyle = _a.style,\n        nodeLabelCfg = _a.title;\n\n    graph.getNodes().forEach(function (node) {\n      graph.updateItem(node, {\n        nodeCfg: nodeCfg,\n        markerCfg: markerCfg,\n        type: nodeType,\n        style: nodeStyle,\n        anchorPoints: nodeAnchorPoints,\n        labelCfg: nodeLabelCfg\n      });\n    });\n  };\n\n  var updateEdges = function () {\n    if (!graph) {\n      return;\n    }\n\n    var _a = edgeCfg !== null && edgeCfg !== void 0 ? edgeCfg : {},\n        edgeType = _a.type,\n        edgeStyle = _a.style,\n        startArrowCfg = _a.startArrow,\n        endArrowCfg = _a.endArrow,\n        labelCfg = _a.label;\n\n    graph.getEdges().forEach(function (edge) {\n      // 资金流向图\n      if (edgeType === 'fund-line') {\n        graph.updateItem(edge, {\n          edgeCfg: edgeCfg\n        });\n      } else {\n        var edgeCfgModel = edge.getModel();\n        var startArrow = getArrowCfg(startArrowCfg, edgeCfgModel);\n        var endArrow = getArrowCfg(endArrowCfg, edgeCfgModel);\n\n        var _a = labelCfg !== null && labelCfg !== void 0 ? labelCfg : {},\n            style = _a.style,\n            content = _a.content;\n\n        graph.updateItem(edge, {\n          type: edgeType,\n          label: getCommonConfig(content, edgeCfgModel, graph),\n          labelCfg: {\n            style: getCommonConfig(style, edgeCfgModel, graph)\n          },\n          style: __assign({\n            stroke: '#ccc',\n            startArrow: startArrow,\n            endArrow: endArrow\n          }, typeof edgeStyle === 'function' ? edgeStyle(edgeCfgModel, graph) : edgeStyle)\n        });\n      }\n    });\n  }; // 目前仅支持更新位置\n\n\n  var updateMarker = function () {\n    if (!graph) {\n      return;\n    }\n\n    graph.getNodes().forEach(function (node) {\n      var _a = (typeof markerCfg === 'function' ? markerCfg(node.getModel(), node.get('group')) : markerCfg).position,\n          position = _a === void 0 ? 'right' : _a;\n\n      var _b = node.getBBox(),\n          width = _b.width,\n          height = _b.height;\n\n      var markerShape = node.get('group').get('children').find(function (item) {\n        return item.get('name') === 'collapse-icon';\n      });\n\n      if (markerShape) {\n        markerShape === null || markerShape === void 0 ? void 0 : markerShape.attr(__assign({}, getMarkerPosition(position, [width, height])));\n      }\n    });\n  };\n\n  var getEdgeStateStyles = function (edgeStateStyles) {\n    var _a = extra.name,\n        name = _a === void 0 ? '' : _a;\n\n    if (name !== 'FundFlowGraph') {\n      return edgeStateStyles;\n    }\n\n    if (!edgeStateStyles) {\n      return;\n    }\n\n    var _b = edgeStateStyles.hover,\n        hover = _b === void 0 ? {} : _b;\n    var endArrow = hover.endArrow,\n        startArrow = hover.startArrow;\n\n    if (!endArrow && !startArrow) {\n      return edgeStateStyles;\n    }\n\n    return {\n      hover: __assign(__assign({}, hover), {\n        endArrow: endArrow ? getArrowCfg(endArrow) : false,\n        startArrow: startArrow ? getArrowCfg(startArrow) : false\n      })\n    };\n  };\n\n  useEffect(function () {\n    if (graph && !graph.destroyed) {\n      if (isEqual(data, graphData.current)) {\n        return;\n      }\n\n      graphData.current = deepClone(data);\n      changeData();\n    }\n  }, [data]);\n  useEffect(function () {\n    var _a, _b, _c, _d, _e;\n\n    if (graph && !graph.destroyed) {\n      if (isEqual(config, graphOptions.current)) {\n        return;\n      }\n\n      if (!isEqual(layout, (_a = graphOptions.current) === null || _a === void 0 ? void 0 : _a.layout)) {\n        updateLayout();\n      }\n\n      if (!isEqual(minimapCfg, (_b = graphOptions.current) === null || _b === void 0 ? void 0 : _b.minimapCfg)) {\n        processMinimap(minimapCfg, graph);\n      }\n\n      if (!isEqual(nodeCfg, (_c = graphOptions.current) === null || _c === void 0 ? void 0 : _c.nodeCfg)) {\n        updateNodes();\n      }\n\n      if (!isEqual(edgeCfg, (_d = graphOptions.current) === null || _d === void 0 ? void 0 : _d.edgeCfg)) {\n        updateEdges();\n      }\n\n      if (!isEqual(markerCfg, (_e = graphOptions.current) === null || _e === void 0 ? void 0 : _e.markerCfg)) {\n        updateMarker();\n      }\n\n      graphOptions.current = config;\n    }\n  }, [config]);\n  useEffect(function () {\n    if (graph && !graph.destroyed) {\n      var graphSize = getGraphSize(width, height, container);\n      graph.changeSize(graphSize[0], graphSize[1]);\n    }\n  }, [container, width, height]);\n  useEffect(function () {\n    if (graph && !graph.destroyed) {\n      var defaultMode = graph.get('modes').default;\n      var removingBehaviors_1 = [];\n      defaultMode.forEach(function (be) {\n        if (isObject(be)) {\n          removingBehaviors_1.push(be.type);\n        } else if (isString(be)) {\n          removingBehaviors_1.push(be);\n        }\n      });\n      graph.removeBehaviors(removingBehaviors_1, 'default');\n      graph.addBehaviors(behaviors, 'default');\n    }\n  }, [behaviors]);\n  useEffect(function () {\n    if (container.current && graphClass) {\n      var _a = extra.name,\n          name_1 = _a === void 0 ? '' : _a;\n      var graphSize = getGraphSize(width, height, container);\n      var plugins = [];\n      var nodeCfg_1 = config.nodeCfg,\n          edgeCfg_1 = config.edgeCfg,\n          behaviors_1 = config.behaviors,\n          layout_1 = config.layout,\n          animate = config.animate,\n          autoFit = config.autoFit,\n          fitCenter_1 = config.fitCenter,\n          onReady = config.onReady,\n          tooltipCfg = config.tooltipCfg;\n\n      var _b = nodeCfg_1 !== null && nodeCfg_1 !== void 0 ? nodeCfg_1 : {},\n          nodeType_1 = _b.type,\n          nodeSize = _b.size,\n          nodeAnchorPoints = _b.anchorPoints,\n          nodeStateStyles = _b.nodeStateStyles,\n          nodeStyle_1 = _b.style,\n          nodeLabelCfg_1 = _b.title,\n          linkCenter = _b.linkCenter,\n          getChildren = _b.getChildren;\n\n      var _c = edgeCfg_1 !== null && edgeCfg_1 !== void 0 ? edgeCfg_1 : {},\n          edgeType = _c.type,\n          edgeStyle_1 = _c.style,\n          startArrowCfg_1 = _c.startArrow,\n          endArrowCfg_1 = _c.endArrow,\n          labelCfg_1 = _c.label,\n          edgeStateStyles = _c.edgeStateStyles;\n\n      if (tooltipCfg && isFunction(tooltipCfg.customContent)) {\n        var customContent_1 = tooltipCfg.customContent,\n            rest = __rest(tooltipCfg, [\"customContent\"]);\n\n        var createNode_1 = function (children) {\n          var mountPoint = document.createElement('div');\n          mountPoint.className = 'g6-tooltip';\n          ReactDOM.render(children, mountPoint);\n          return mountPoint;\n        };\n\n        var tooltipPlugin = new G6.Tooltip(__assign(__assign({\n          offsetX: 10,\n          offsetY: 20,\n          itemTypes: ['node']\n        }, rest), {\n          getContent: function (e) {\n            return createNode_1(customContent_1(e.item.getModel()));\n          }\n        }));\n        plugins.push(tooltipPlugin);\n      }\n\n      graphRef.current = new G6[graphClass]({\n        container: container.current,\n        width: graphSize[0],\n        height: graphSize[1],\n        animate: animate,\n        linkCenter: linkCenter,\n        modes: {\n          default: behaviors_1\n        },\n        defaultNode: {\n          type: nodeType_1,\n          size: nodeSize,\n          anchorPoints: nodeAnchorPoints,\n          nodeCfg: nodeCfg_1\n        },\n        defaultEdge: {\n          type: edgeType,\n          edgeCfg: edgeCfg_1,\n          labelCfg: labelCfg_1 === null || labelCfg_1 === void 0 ? void 0 : labelCfg_1.style\n        },\n        nodeStateStyles: nodeStateStyles,\n        edgeStateStyles: getEdgeStateStyles(edgeStateStyles),\n        layout: layout_1,\n        fitView: autoFit,\n        fitCenter: fitCenter_1,\n        plugins: plugins\n      });\n      var graphId = getGraphId(graphRef.current);\n      var graph_1 = graphRef.current;\n      graph_1.set('id', graphId);\n\n      var getLabel_1 = function (value) {\n        // 辐射树图\n        if (isString(value)) {\n          return value;\n        }\n\n        if (name_1 === 'FundFlowGraph') {\n          return value === null || value === void 0 ? void 0 : value.text;\n        }\n\n        return value === null || value === void 0 ? void 0 : value.title;\n      };\n\n      var customNode_1 = ['fund-card', 'indicator-card']; // defaultNode 默认只能绑定 plainObject，针对 Function 类型需要通过该模式绑定\n\n      graph_1.node(function (node) {\n        if (customNode_1.includes(nodeType_1) || name_1 === 'OrganizationGraph') {\n          node.markerCfg = markerCfg;\n          return {};\n        }\n\n        var style = (nodeLabelCfg_1 !== null && nodeLabelCfg_1 !== void 0 ? nodeLabelCfg_1 : {}).style;\n        return {\n          label: getLabel_1(node.value),\n          labelCfg: {\n            style: getCommonConfig(style, node, graph_1)\n          },\n          style: __assign({\n            stroke: '#ccc'\n          }, typeof nodeStyle_1 === 'function' ? nodeStyle_1(node, graph_1) : nodeStyle_1)\n        };\n      });\n\n      var getEdgeLabel_1 = function (edge) {\n        var content = (labelCfg_1 !== null && labelCfg_1 !== void 0 ? labelCfg_1 : {}).content;\n\n        if (['DecompositionTreeGraph', 'OrganizationGraph', 'RadialTreeGraph'].includes(name_1)) {\n          return getCommonConfig(content, edge, graph_1);\n        }\n\n        if (name_1 === 'FundFlowGraph') {\n          var value = edge.value; // @ts-ignore\n\n          return typeof value === 'object' ? value === null || value === void 0 ? void 0 : value.text : value;\n        }\n\n        return edge.value;\n      };\n\n      if (edgeType !== 'fund-line') {\n        graph_1.edge(function (edge) {\n          var startArrow = getArrowCfg(startArrowCfg_1, edge);\n          var endArrow = getArrowCfg(endArrowCfg_1, edge);\n          var style = (labelCfg_1 !== null && labelCfg_1 !== void 0 ? labelCfg_1 : {}).style;\n          return {\n            label: getEdgeLabel_1(edge),\n            labelCfg: {\n              style: getCommonConfig(style, edge, graph_1)\n            },\n            style: __assign({\n              stroke: '#ccc',\n              startArrow: startArrow,\n              endArrow: endArrow\n            }, typeof edgeStyle_1 === 'function' ? edgeStyle_1(edge, graph_1) : edgeStyle_1)\n          };\n        });\n      }\n\n      processMinimap(minimapCfg, graph_1);\n      bindStateEvents(graph_1, config);\n\n      if (markerCfg) {\n        var sourceGraph = ['FlowAnalysisGraph', 'FundFlowGraph'];\n        sourceGraph.includes(name_1) ? bindSourceMapCollapseEvents(graph_1) : bindDefaultEvents(graph_1, level, getChildren);\n      }\n\n      renderGraph(graph_1, data, level);\n\n      if (fitCenter_1) {\n        graph_1.fitCenter();\n      }\n\n      if (onReady) {\n        onReady(graph_1);\n      }\n    }\n  }, []);\n  useEffect(function () {\n    if (graphRef.current && toolbarCfg) {\n      createToolbar({\n        graph: graphRef.current,\n        container: container.current,\n        toolbarCfg: toolbarCfg\n      });\n    }\n  }, [graphRef, toolbarCfg]);\n  useEffect(function () {\n    return function () {\n      if ((graph === null || graph === void 0 ? void 0 : graph.current) && !graph.current.destroyed) {\n        graph.current.destroy();\n      }\n    };\n  }, []);\n  return {\n    container: container\n  };\n}","map":null,"metadata":{},"sourceType":"module"}