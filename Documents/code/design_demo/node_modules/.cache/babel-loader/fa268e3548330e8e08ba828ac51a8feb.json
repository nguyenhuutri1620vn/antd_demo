{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { lngLatToMeters } from '@antv/l7-utils';\nimport earcut from 'earcut';\nimport { vec3 } from 'gl-matrix';\nimport { EARTH_RADIUS, EARTH_RADIUS_OUTER, EARTH_SEGMENTS, lglt2xyz, primitiveSphere } from '../earth/utils';\nimport ExtrudePolyline from '../utils/extrude_polyline';\nimport { calculateCentroid, calculatePointsCenterAndRadius } from '../utils/geo';\nimport extrudePolygon, { extrude_PolygonNormal, fillPolygon } from './shape/extrude';\nimport { geometryShape } from './shape/Path';\nvar GeometryCache = {};\nexport function PointFillTriangulation(feature) {\n  var coordinates = calculateCentroid(feature.coordinates);\n  return {\n    vertices: [].concat(_toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates)),\n    indices: [0, 1, 2, 2, 3, 0],\n    size: coordinates.length\n  };\n}\nexport function GlobelPointFillTriangulation(feature) {\n  var coordinates = calculateCentroid(feature.coordinates);\n  var xyz = lglt2xyz(coordinates);\n  return {\n    vertices: [].concat(_toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz)),\n    indices: [0, 1, 2, 2, 3, 0],\n    size: xyz.length\n  };\n}\nexport function PointExtrudeTriangulation(feature) {\n  var shape = feature.shape;\n\n  var _getGeometry = getGeometry(shape, false),\n      positions = _getGeometry.positions,\n      index = _getGeometry.index,\n      normals = _getGeometry.normals;\n\n  return {\n    vertices: positions,\n    indices: index,\n    normals: normals,\n    size: 5\n  };\n}\nexport function PointImageTriangulation(feature) {\n  var coordinates = calculateCentroid(feature.coordinates);\n  return {\n    vertices: _toConsumableArray(coordinates),\n    indices: [0],\n    size: coordinates.length\n  };\n}\nexport function LineTriangulation(feature) {\n  var coordinates = feature.coordinates,\n      originCoordinates = feature.originCoordinates,\n      version = feature.version;\n  var line = new ExtrudePolyline({\n    dash: true,\n    join: 'bevel'\n  });\n\n  if (version === 'GAODE2.x') {\n    var path1 = coordinates;\n\n    if (!Array.isArray(path1[0][0])) {\n      path1 = [coordinates];\n    }\n\n    var path2 = originCoordinates;\n\n    if (!Array.isArray(path2[0][0])) {\n      path2 = [originCoordinates];\n    }\n\n    for (var i = 0; i < path1.length; i++) {\n      var item1 = path1[i];\n      var item2 = path2[i];\n      line.extrude_gaode2(item1, item2);\n    }\n  } else {\n    var path = coordinates;\n\n    if (!Array.isArray(path[0][0])) {\n      path = [coordinates];\n    }\n\n    path.forEach(function (item) {\n      line.extrude(item);\n    });\n  }\n\n  var linebuffer = line.complex;\n  return {\n    vertices: linebuffer.positions,\n    indices: linebuffer.indices,\n    normals: linebuffer.normals,\n    size: 6\n  };\n}\nexport function SimpleLineTriangulation(feature) {\n  var coordinates = feature.coordinates,\n      originCoordinates = feature.originCoordinates,\n      version = feature.version;\n  var line = new ExtrudePolyline({\n    dash: true,\n    join: 'bevel'\n  });\n\n  if (version === 'GAODE2.x') {\n    var path1 = coordinates;\n\n    if (!Array.isArray(path1[0][0])) {\n      path1 = [coordinates];\n    }\n\n    var path2 = originCoordinates;\n\n    if (!Array.isArray(path2[0][0])) {\n      path2 = [originCoordinates];\n    }\n\n    for (var i = 0; i < path1.length; i++) {\n      var item1 = path1[i];\n      var item2 = path2[i];\n      line.simpleExtrude_gaode2(item1, item2);\n    }\n  } else {\n    var path = coordinates;\n\n    if (!Array.isArray(path[0][0])) {\n      path = [coordinates];\n    }\n\n    path.forEach(function (item) {\n      line.simpleExtrude(item);\n    });\n  }\n\n  var linebuffer = line.complex;\n  return {\n    vertices: linebuffer.positions,\n    indices: linebuffer.indices,\n    normals: linebuffer.normals,\n    size: 6\n  };\n}\nexport function polygonTriangulation(feature) {\n  var coordinates = feature.coordinates;\n  var flattengeo = earcut.flatten(coordinates);\n  var vertices = flattengeo.vertices,\n      dimensions = flattengeo.dimensions,\n      holes = flattengeo.holes;\n  return {\n    indices: earcut(vertices, holes, dimensions),\n    vertices: vertices,\n    size: dimensions\n  };\n}\nexport function polygonTriangulationWithCenter(feature) {\n  var coordinates = feature.coordinates;\n  var flattengeo = earcut.flatten(coordinates);\n  var vertices = flattengeo.vertices,\n      dimensions = flattengeo.dimensions,\n      holes = flattengeo.holes;\n  return {\n    indices: earcut(vertices, holes, dimensions),\n    vertices: getVerticesWithCenter(vertices),\n    size: dimensions + 4\n  };\n}\n\nfunction getVerticesWithCenter(vertices) {\n  var verticesWithCenter = [];\n\n  var _calculatePointsCente = calculatePointsCenterAndRadius(vertices),\n      center = _calculatePointsCente.center,\n      radius = _calculatePointsCente.radius;\n\n  for (var i = 0; i < vertices.length; i += 2) {\n    var lng = vertices[i];\n    var lat = vertices[i + 1];\n    verticesWithCenter.push.apply(verticesWithCenter, [lng, lat, 0].concat(_toConsumableArray(center), [radius]));\n  }\n\n  return verticesWithCenter;\n}\n\nexport function PolygonExtrudeTriangulation(feature) {\n  var coordinates = feature.coordinates;\n\n  var _extrude_PolygonNorma = extrude_PolygonNormal(coordinates, true),\n      positions = _extrude_PolygonNorma.positions,\n      index = _extrude_PolygonNorma.index,\n      normals = _extrude_PolygonNorma.normals;\n\n  return {\n    vertices: positions,\n    indices: index,\n    normals: normals,\n    size: 5\n  };\n}\nexport function HeatmapGridTriangulation(feature) {\n  var shape = feature.shape;\n\n  var _getHeatmapGeometry = getHeatmapGeometry(shape),\n      positions = _getHeatmapGeometry.positions,\n      index = _getHeatmapGeometry.index;\n\n  return {\n    vertices: positions,\n    indices: index,\n    size: 3\n  };\n}\nexport function RasterImageTriangulation(feature) {\n  var coordinates = feature.coordinates;\n  var positions = [].concat(_toConsumableArray(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], _toConsumableArray(coordinates[1]), [0, 1, 0], _toConsumableArray(coordinates[0]), [0, 0, 1], _toConsumableArray(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);\n  var indexs = [0, 1, 2, 3, 4, 5];\n  return {\n    vertices: positions,\n    indices: indexs,\n    size: 5\n  };\n}\nexport function LineArcTriangulation(feature, segmentNumber) {\n  var segNum = segmentNumber ? segmentNumber : 30;\n  var coordinates = feature.coordinates;\n  var positions = [];\n  var indexArray = [];\n\n  var _loop = function _loop(i) {\n    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);\n\n    if (i !== segNum - 1) {\n      indexArray.push.apply(indexArray, _toConsumableArray([0, 1, 2, 1, 3, 2].map(function (v) {\n        return i * 2 + v;\n      })));\n    }\n  };\n\n  for (var i = 0; i < segNum; i++) {\n    _loop(i);\n  }\n\n  return {\n    vertices: positions,\n    indices: indexArray,\n    size: 7\n  };\n}\nexport function HeatmapTriangulation(feature) {\n  var coordinates = feature.coordinates;\n\n  if (coordinates.length === 2) {\n    coordinates.push(0);\n  }\n\n  var size = feature.size;\n  var dir = addDir(-1, 1);\n  var dir1 = addDir(1, 1);\n  var dir2 = addDir(-1, -1);\n  var dir3 = addDir(1, -1);\n  var positions = [].concat(_toConsumableArray(coordinates), _toConsumableArray(dir), _toConsumableArray(coordinates), _toConsumableArray(dir2), _toConsumableArray(coordinates), _toConsumableArray(dir3), _toConsumableArray(coordinates), _toConsumableArray(dir1));\n  var indexArray = [0, 1, 2, 3, 0, 2];\n  return {\n    vertices: positions,\n    indices: indexArray,\n    size: 5\n  };\n}\n\nfunction getGeometry(shape) {\n  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (GeometryCache && GeometryCache[shape]) {\n    return GeometryCache[shape];\n  }\n\n  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.cylinder();\n  var geometry = extrude_PolygonNormal([path], needFlat);\n  GeometryCache[shape] = geometry;\n  return geometry;\n}\n\nfunction computeVertexNormals(positions, indexArray) {\n  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var normals = new Float32Array(positions.length / dim * 3);\n  var vA;\n  var vB;\n  var vC;\n  var cb = vec3.create();\n  var ab = vec3.create();\n  var normal = vec3.create();\n\n  for (var i = 0, li = indexArray.length; i < li; i += 3) {\n    vA = indexArray[i + 0] * 3;\n    vB = indexArray[i + 1] * 3;\n    vC = indexArray[i + 2] * 3;\n    var p1 = [positions[vA], positions[vA + 1]];\n    var p2 = [positions[vB], positions[vB + 1]];\n    var p3 = [positions[vC], positions[vC + 1]];\n\n    if (needFlat) {\n      p1 = lngLatToMeters(p1);\n      p2 = lngLatToMeters(p2);\n      p3 = lngLatToMeters(p3);\n    }\n\n    var _p = p1,\n        _p2 = _slicedToArray(_p, 2),\n        ax = _p2[0],\n        ay = _p2[1];\n\n    var pA = vec3.fromValues(ax, ay, positions[vA + 2]);\n\n    var _p3 = p2,\n        _p4 = _slicedToArray(_p3, 2),\n        bx = _p4[0],\n        by = _p4[1];\n\n    var pB = vec3.fromValues(bx, by, positions[vB + 2]);\n\n    var _p5 = p3,\n        _p6 = _slicedToArray(_p5, 2),\n        cx = _p6[0],\n        cy = _p6[1];\n\n    var pC = vec3.fromValues(cx, cy, positions[vC + 2]);\n    vec3.sub(cb, pC, pB);\n    vec3.sub(ab, pA, pB);\n    vec3.cross(normal, cb, ab);\n    normals[vA] += cb[0];\n    normals[vA + 1] += cb[1];\n    normals[vA + 2] += cb[2];\n    normals[vB] += cb[0];\n    normals[vB + 1] += cb[1];\n    normals[vB + 2] += cb[2];\n    normals[vC] += cb[0];\n    normals[vC + 1] += cb[1];\n    normals[vC + 2] += cb[2];\n  }\n\n  normalizeNormals(normals);\n  return normals;\n}\n\nfunction normalizeNormals(normals) {\n  for (var i = 0, li = normals.length; i < li; i += 3) {\n    var normal = vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);\n    var newNormal = vec3.create();\n    vec3.normalize(newNormal, normal);\n    normals.set(newNormal, i);\n  }\n}\n\nfunction checkIsClosed(points) {\n  var p1 = points[0][0];\n  var p2 = points[0][points[0].length - 1];\n  return p1[0] === p2[0] && p1[1] === p2[1];\n}\n\nfunction getHeatmapGeometry(shape) {\n  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];\n  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.circle();\n  var geometry = shape3d.indexOf(shape) === -1 ? fillPolygon([path]) : extrudePolygon([path]);\n  return geometry;\n}\n\nfunction addDir(dirX, dirY) {\n  var x = (dirX + 1) / 2;\n  var y = (dirY + 1) / 2;\n  return [x, y];\n}\n\nexport function earthTriangulation() {\n  var earthmesh = primitiveSphere(EARTH_RADIUS, {\n    segments: EARTH_SEGMENTS\n  });\n  var positionsArr = earthmesh.positionsArr,\n      indicesArr = earthmesh.indicesArr,\n      normalArr = earthmesh.normalArr;\n  return {\n    vertices: positionsArr,\n    indices: indicesArr,\n    size: 5,\n    normals: normalArr\n  };\n}\nexport function earthOuterTriangulation() {\n  var earthmesh = primitiveSphere(EARTH_RADIUS + EARTH_RADIUS_OUTER, {\n    segments: EARTH_SEGMENTS\n  });\n  var positionsArr = earthmesh.positionsArr,\n      indicesArr = earthmesh.indicesArr,\n      normalArr = earthmesh.normalArr;\n  return {\n    vertices: positionsArr,\n    indices: indicesArr,\n    size: 5,\n    normals: normalArr\n  };\n}","map":null,"metadata":{},"sourceType":"module"}