{"ast":null,"code":"import { attr } from './attr';\nimport { createSvgElement } from './elem';\nexport const KAPPA = 0.551784;\n\nfunction getNumbericAttribute(elem, attr) {\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;\n  const v = elem.getAttribute(attr);\n\n  if (v == null) {\n    return defaultValue;\n  }\n\n  const n = parseFloat(v);\n  return Number.isNaN(n) ? defaultValue : n;\n}\n\nexport function sample(elem) {\n  let interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  const length = elem.getTotalLength();\n  const samples = [];\n  let distance = 0;\n  let sample;\n\n  while (distance < length) {\n    sample = elem.getPointAtLength(distance);\n    samples.push({\n      distance,\n      x: sample.x,\n      y: sample.y\n    });\n    distance += interval;\n  }\n\n  return samples;\n}\nexport function lineToPathData(line) {\n  return ['M', getNumbericAttribute(line, 'x1'), getNumbericAttribute(line, 'y1'), 'L', getNumbericAttribute(line, 'x2'), getNumbericAttribute(line, 'y2')].join(' ');\n}\nexport function polygonToPathData(polygon) {\n  const points = getPointsFromSvgElement(polygon);\n\n  if (points.length === 0) {\n    return null;\n  }\n\n  return `${svgPointsToPath(points)} Z`;\n}\nexport function polylineToPathData(polyline) {\n  const points = getPointsFromSvgElement(polyline);\n\n  if (points.length === 0) {\n    return null;\n  }\n\n  return svgPointsToPath(points);\n}\n\nfunction svgPointsToPath(points) {\n  const arr = points.map(p => `${p.x} ${p.y}`);\n  return `M ${arr.join(' L')}`;\n}\n\nexport function getPointsFromSvgElement(elem) {\n  const points = [];\n  const nodePoints = elem.points;\n\n  if (nodePoints) {\n    for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {\n      points.push(nodePoints.getItem(i));\n    }\n  }\n\n  return points;\n}\nexport function circleToPathData(circle) {\n  const cx = getNumbericAttribute(circle, 'cx', 0);\n  const cy = getNumbericAttribute(circle, 'cy', 0);\n  const r = getNumbericAttribute(circle, 'r');\n  const cd = r * KAPPA; // Control distance.\n\n  return ['M', cx, cy - r, 'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, 'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, 'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, 'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, 'Z'].join(' ');\n}\nexport function ellipseToPathData(ellipse) {\n  const cx = getNumbericAttribute(ellipse, 'cx', 0);\n  const cy = getNumbericAttribute(ellipse, 'cy', 0);\n  const rx = getNumbericAttribute(ellipse, 'rx');\n  const ry = getNumbericAttribute(ellipse, 'ry') || rx;\n  const cdx = rx * KAPPA; // Control distance x.\n\n  const cdy = ry * KAPPA; // Control distance y.\n\n  const d = ['M', cx, cy - ry, 'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, 'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, 'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, 'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, 'Z'].join(' ');\n  return d;\n}\nexport function rectangleToPathData(rect) {\n  return rectToPathData({\n    x: getNumbericAttribute(rect, 'x', 0),\n    y: getNumbericAttribute(rect, 'y', 0),\n    width: getNumbericAttribute(rect, 'width', 0),\n    height: getNumbericAttribute(rect, 'height', 0),\n    rx: getNumbericAttribute(rect, 'rx', 0),\n    ry: getNumbericAttribute(rect, 'ry', 0)\n  });\n}\nexport function rectToPathData(r) {\n  let d;\n  const x = r.x;\n  const y = r.y;\n  const width = r.width;\n  const height = r.height;\n  const topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);\n  const bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);\n  const topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);\n  const bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n  if (topRx || bottomRx || topRy || bottomRy) {\n    d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];\n  } else {\n    d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];\n  }\n\n  return d.join(' ');\n}\nexport function toPath(elem) {\n  const path = createSvgElement('path');\n  attr(path, attr(elem));\n  const d = toPathData(elem);\n\n  if (d) {\n    path.setAttribute('d', d);\n  }\n\n  return path;\n}\nexport function toPathData(elem) {\n  const tagName = elem.tagName.toLowerCase();\n\n  switch (tagName) {\n    case 'path':\n      return elem.getAttribute('d');\n\n    case 'line':\n      return lineToPathData(elem);\n\n    case 'polygon':\n      return polygonToPathData(elem);\n\n    case 'polyline':\n      return polylineToPathData(elem);\n\n    case 'ellipse':\n      return ellipseToPathData(elem);\n\n    case 'circle':\n      return circleToPathData(elem);\n\n    case 'rect':\n      return rectangleToPathData(elem);\n\n    default:\n      break;\n  }\n\n  throw new Error(`\"${tagName}\" cannot be converted to svg path element.`);\n} // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n\nexport function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {\n  const svgArcMax = 2 * Math.PI - 1e-6;\n  const r0 = innerRadius;\n  const r1 = outerRadius;\n  let a0 = startAngle;\n  let a1 = endAngle;\n\n  if (a1 < a0) {\n    const tmp = a0;\n    a0 = a1;\n    a1 = tmp;\n  }\n\n  const da = a1 - a0;\n  const df = da < Math.PI ? '0' : '1';\n  const c0 = Math.cos(a0);\n  const s0 = Math.sin(a0);\n  const c1 = Math.cos(a1);\n  const s1 = Math.sin(a1);\n  return da >= svgArcMax ? r0 ? // eslint-disable-next-line\n  `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}M0,${r0}A${r0},${r0} 0 1,0 0,${-r0}A${r0},${r0} 0 1,0 0,${r0}Z` : // eslint-disable-next-line\n  `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}Z` : r0 ? // eslint-disable-next-line\n  `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L${r0 * c1},${r0 * s1}A${r0},${r0} 0 ${df},0 ${r0 * c0},${r0 * s0}Z` : // eslint-disable-next-line\n  `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L0,0` + `Z`;\n}","map":null,"metadata":{},"sourceType":"module"}