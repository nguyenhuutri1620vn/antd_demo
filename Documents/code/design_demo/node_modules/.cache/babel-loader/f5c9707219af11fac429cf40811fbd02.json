{"ast":null,"code":"import { __awaiter, __decorate, __metadata } from \"tslib\";\nimport ReactDOM from 'react-dom';\nimport { Graph as X6Graph, Dom } from '@antv/x6';\nimport { DisposableCollection, Disposable } from '../../common/disposable';\nimport { Deferred } from '../../common/deferred';\nimport { IGraphOptionProvider } from './config';\nimport { singleton, inject, Syringe } from 'mana-syringe';\nimport { IGraphCommandService } from '../../command';\nimport { IModelService } from '../../model-service/interface';\nimport { IHookService } from '../../hooks';\nimport { getEdgeReactComponent } from '../../command-contributions/components/context';\nimport { XFLOW_DEFAULT_EDGE } from '../../constants';\n/** !!! 所有需要使用Graph相关信息的地方, 都统一使用IGraphProvider来获取 */\n\nexport const IGraphProvider = Symbol('IGraphProvider');\nexport const ICommandServiceProvider = Symbol('ICommandServiceProvider');\nexport const IModelServiceProvider = Symbol('IModelServiceProvider');\nlet GraphManager = class GraphManager {\n  constructor() {\n    /** 处理画布实例的销毁 */\n    this.toDisposce = new DisposableCollection();\n    /** 储存画布实例 */\n\n    this.graphMap = new Map();\n    /** 获取X6 Graph 实例 */\n\n    this.getGraph = graphId => __awaiter(this, void 0, void 0, function* () {\n      let graphDefer = this.graphMap.get(graphId);\n\n      if (!graphDefer) {\n        graphDefer = new Deferred();\n        this.graphMap.set(graphId, graphDefer);\n        const options = yield this.optionProvider.getOptions();\n        /** 获取hooks实例： hooks方便其他组件可以修改注册graphOpions/events */\n\n        const hooks = this.hookService.hookProvider();\n        /** 执行hooks：获取graphOptions */\n\n        const mergedOptions = yield hooks.graphOptions.call(options.x6Options);\n        const {\n          graphContainer,\n          edgeRender,\n          nodeRender,\n          edgeTypeParser\n        } = options;\n        /** 执行hooks：获取edge label render */\n\n        const edgeRenderMap = yield hooks.reactEdgeLabelRender.call(edgeRender);\n        /** 执行hooks：更新nodeRender */\n\n        yield hooks.reactNodeRender.call(nodeRender);\n        const {\n          clientHeight,\n          clientWidth\n        } = graphContainer;\n        const commandService = yield this.commandServiceProvider.getCommandService();\n        const modelService = yield this.modelServiceProvider.getModelService();\n        /** 实例化 X6 Graph */\n\n        const graph = new X6Graph(Object.assign(Object.assign({\n          container: graphContainer,\n          width: clientWidth,\n          height: clientHeight\n        }, mergedOptions), {\n          /** X6提供了边渲染的钩子, 可以在这里设置边上需要渲染的React内容 */\n          onEdgeLabelRendered: args => {\n            const {\n              edge,\n              container\n            } = args;\n            this.renderEdgeReactLabel({\n              edge,\n              container,\n              edgeRenderMap,\n              edgeTypeParser,\n              modelService,\n              commandService\n            });\n          }\n        }));\n        /** 执行hooks：绑定事件执行api */\n\n        yield hooks.afterGraphInit.call({\n          graph,\n          commandService,\n          modelService,\n          options\n        });\n        graphDefer.resolve(graph);\n        graph.on('node:moved', _ref => {\n          let {\n            node\n          } = _ref;\n          const nodeData = node.getData();\n          const position = node.position();\n          node.setData(Object.assign(Object.assign({}, nodeData), {\n            x: position === null || position === void 0 ? void 0 : position.x,\n            y: position === null || position === void 0 ? void 0 : position.y\n          }));\n        });\n        graph.on('node:resized', _ref2 => {\n          let {\n            node\n          } = _ref2;\n          const nodeData = node.getData();\n          const size = node.size();\n          node.setData(Object.assign(Object.assign({}, nodeData), {\n            width: size === null || size === void 0 ? void 0 : size.width,\n            height: size === null || size === void 0 ? void 0 : size.height\n          }));\n        });\n        this.toDisposce.push(Disposable.create(() => __awaiter(this, void 0, void 0, function* () {\n          yield hooks.beforeGraphDestroy.call({\n            graph,\n            commandService,\n            modelService,\n            options\n          });\n          this.graphMap.delete(graphId);\n          graph.dispose();\n        })));\n      }\n\n      return graphDefer.promise;\n    });\n\n    this.renderEdgeReactLabel = args => __awaiter(this, void 0, void 0, function* () {\n      const {\n        container,\n        edgeTypeParser,\n        edge,\n        edgeRenderMap,\n        commandService,\n        modelService\n      } = args;\n      const renderKey = edgeTypeParser(edge === null || edge === void 0 ? void 0 : edge.data) || XFLOW_DEFAULT_EDGE;\n      const reactComponent = edgeRenderMap.get(renderKey);\n\n      if (!reactComponent) {\n        return;\n      }\n\n      if (edge && (edge === null || edge === void 0 ? void 0 : edge.data) && reactComponent) {\n        const content = this.edgeAppendForeignObject(edge, container);\n        const WrappedReactComponent = getEdgeReactComponent(reactComponent, commandService, modelService)(edge);\n        ReactDOM.render(WrappedReactComponent, content);\n      }\n    });\n  }\n  /** 实现在连线上渲染React节点 */\n\n\n  edgeAppendForeignObject(x6Edge, container) {\n    const fo = Dom.createSvgElement('foreignObject');\n    const body = Dom.createElementNS('body', Dom.ns.xhtml);\n    const content = Dom.createElementNS('div', Dom.ns.xhtml);\n    const edgeData = x6Edge === null || x6Edge === void 0 ? void 0 : x6Edge.data;\n    const foWdith = (edgeData === null || edgeData === void 0 ? void 0 : edgeData.edgeContentWidth) || 100;\n    const foHeight = (edgeData === null || edgeData === void 0 ? void 0 : edgeData.edgeContentHeigt) || 30;\n    fo.setAttribute('width', `${foWdith}`);\n    fo.setAttribute('height', `${foHeight}`);\n    fo.setAttribute('x', `${-1.0 * foWdith / 2}`);\n    fo.setAttribute('y', `${-1.0 * foHeight / 2}`);\n    body.setAttribute('xhtmls', Dom.ns.xhtml);\n    body.style.width = '100%';\n    body.style.height = '100%';\n    body.style.padding = '0';\n    body.style.margin = '0';\n    body.style.background = 'unset';\n    body.style.overflow = 'visible';\n    body.className = 'xflow-edge-label-body';\n    content.style.width = '100%';\n    content.style.height = '100%';\n    body.appendChild(content);\n    fo.appendChild(body);\n    container.appendChild(fo);\n    return content;\n  }\n\n  dispose() {\n    this.toDisposce.dispose();\n  }\n\n};\n\n__decorate([inject(IGraphOptionProvider), __metadata(\"design:type\", Object)], GraphManager.prototype, \"optionProvider\", void 0);\n\n__decorate([inject(IHookService), __metadata(\"design:type\", Object)], GraphManager.prototype, \"hookService\", void 0);\n\n__decorate([inject(ICommandServiceProvider), __metadata(\"design:type\", Object)], GraphManager.prototype, \"commandServiceProvider\", void 0);\n\n__decorate([inject(IModelServiceProvider), __metadata(\"design:type\", Object)], GraphManager.prototype, \"modelServiceProvider\", void 0);\n\nGraphManager = __decorate([singleton()], GraphManager);\nexport { GraphManager };\nexport const registerGraphModule = register => {\n  /** 注册GraphManager */\n  register(GraphManager);\n  register(IGraphProvider, {\n    lifecycle: Syringe.Lifecycle.singleton,\n    useDynamic: context => {\n      return {\n        getGraphInstance: () => __awaiter(void 0, void 0, void 0, function* () {\n          const graphManager = context.container.get(GraphManager);\n          const graphOptionProvider = context.container.get(IGraphOptionProvider);\n          const graphConfig = yield graphOptionProvider === null || graphOptionProvider === void 0 ? void 0 : graphOptionProvider.getOptions();\n          const x6Graph = yield graphManager === null || graphManager === void 0 ? void 0 : graphManager.getGraph(graphConfig.graphId);\n          return x6Graph;\n        }),\n        getGraphOptions: () => __awaiter(void 0, void 0, void 0, function* () {\n          const graphOptionProvider = context.container.get(IGraphOptionProvider);\n          return graphOptionProvider === null || graphOptionProvider === void 0 ? void 0 : graphOptionProvider.getOptions();\n        })\n      };\n    }\n  });\n  register(ICommandServiceProvider, {\n    lifecycle: Syringe.Lifecycle.singleton,\n    useDynamic: context => {\n      return {\n        getCommandService: () => __awaiter(void 0, void 0, void 0, function* () {\n          const commandService = context.container.get(IGraphCommandService);\n          return commandService;\n        })\n      };\n    }\n  });\n  register(IModelServiceProvider, {\n    lifecycle: Syringe.Lifecycle.singleton,\n    useDynamic: context => {\n      return {\n        getModelService: () => __awaiter(void 0, void 0, void 0, function* () {\n          const modelService = context.container.get(IModelService);\n          return modelService;\n        })\n      };\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module"}