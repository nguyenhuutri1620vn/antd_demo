{"ast":null,"code":"import { ObjectExt, Dom } from '../util';\nimport { Timing, Interp } from '../common';\nexport class Animation {\n  constructor(cell) {\n    this.cell = cell;\n    this.ids = {};\n    this.cache = {};\n  }\n\n  get() {\n    return Object.keys(this.ids);\n  }\n\n  start(path, targetValue) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let delim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n    const startValue = this.cell.getPropByPath(path);\n    const localOptions = ObjectExt.defaults(options, Animation.defaultOptions);\n    const timing = this.getTiming(localOptions.timing);\n    const interpolate = this.getInterp(localOptions.interp, startValue, targetValue);\n    let startTime = 0;\n    const key = Array.isArray(path) ? path.join(delim) : path;\n    const paths = Array.isArray(path) ? path : path.split(delim);\n\n    const iterate = () => {\n      const now = new Date().getTime();\n\n      if (startTime === 0) {\n        startTime = now;\n      }\n\n      const elaspe = now - startTime;\n      let progress = elaspe / localOptions.duration;\n\n      if (progress < 1) {\n        this.ids[key] = Dom.requestAnimationFrame(iterate);\n      } else {\n        progress = 1;\n      }\n\n      const currentValue = interpolate(timing(progress));\n      this.cell.setPropByPath(paths, currentValue);\n\n      if (options.progress) {\n        options.progress(Object.assign({\n          progress,\n          currentValue\n        }, this.getArgs(key)));\n      }\n\n      if (progress === 1) {\n        // TODO: remove in the next major version\n        this.cell.notify('transition:end', this.getArgs(key));\n        this.cell.notify('transition:complete', this.getArgs(key));\n        options.complete && options.complete(this.getArgs(key));\n        this.cell.notify('transition:finish', this.getArgs(key));\n        options.finish && options.finish(this.getArgs(key));\n        this.clean(key);\n      }\n    };\n\n    setTimeout(() => {\n      this.stop(path, undefined, delim);\n      this.cache[key] = {\n        startValue,\n        targetValue,\n        options: localOptions\n      };\n      this.ids[key] = Dom.requestAnimationFrame(iterate); // TODO: remove in the next major version\n\n      this.cell.notify('transition:begin', this.getArgs(key));\n      this.cell.notify('transition:start', this.getArgs(key));\n      options.start && options.start(this.getArgs(key));\n    }, options.delay);\n    return this.stop.bind(this, path, delim, options);\n  }\n\n  stop(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n    const paths = Array.isArray(path) ? path : path.split(delim);\n    Object.keys(this.ids).filter(key => ObjectExt.isEqual(paths, key.split(delim).slice(0, paths.length))).forEach(key => {\n      Dom.cancelAnimationFrame(this.ids[key]);\n      const data = this.cache[key];\n      const commonArgs = this.getArgs(key);\n      const localOptions = Object.assign(Object.assign({}, data.options), options);\n      const jumpedToEnd = localOptions.jumpedToEnd;\n\n      if (jumpedToEnd && data.targetValue != null) {\n        this.cell.setPropByPath(key, data.targetValue);\n        this.cell.notify('transition:end', Object.assign({}, commonArgs));\n        this.cell.notify('transition:complete', Object.assign({}, commonArgs));\n        localOptions.complete && localOptions.complete(Object.assign({}, commonArgs));\n      }\n\n      const stopArgs = Object.assign({\n        jumpedToEnd\n      }, commonArgs);\n      this.cell.notify('transition:stop', Object.assign({}, stopArgs));\n      localOptions.stop && localOptions.stop(Object.assign({}, stopArgs));\n      this.cell.notify('transition:finish', Object.assign({}, commonArgs));\n      localOptions.finish && localOptions.finish(Object.assign({}, commonArgs));\n      this.clean(key);\n    });\n    return this;\n  }\n\n  clean(key) {\n    delete this.ids[key];\n    delete this.cache[key];\n  }\n\n  getTiming(timing) {\n    return typeof timing === 'string' ? Timing[timing] : timing;\n  }\n\n  getInterp(interp, startValue, targetValue) {\n    if (interp) {\n      return interp(startValue, targetValue);\n    }\n\n    if (typeof targetValue === 'number') {\n      return Interp.number(startValue, targetValue);\n    }\n\n    if (typeof targetValue === 'string') {\n      if (targetValue[0] === '#') {\n        return Interp.color(startValue, targetValue);\n      }\n\n      return Interp.unit(startValue, targetValue);\n    }\n\n    return Interp.object(startValue, targetValue);\n  }\n\n  getArgs(key) {\n    const data = this.cache[key];\n    return {\n      path: key,\n      startValue: data.startValue,\n      targetValue: data.targetValue,\n      cell: this.cell\n    };\n  }\n\n}\n\n(function (Animation) {\n  Animation.defaultOptions = {\n    delay: 10,\n    duration: 100,\n    timing: 'linear'\n  };\n})(Animation || (Animation = {}));","map":null,"metadata":{},"sourceType":"module"}