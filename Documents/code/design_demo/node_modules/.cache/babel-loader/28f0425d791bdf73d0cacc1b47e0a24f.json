{"ast":null,"code":"/* eslint-disable no-bitwise */\nexport class FlagManager {\n  constructor(view, actions) {\n    let bootstrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    this.view = view;\n    const flags = {};\n    const attrs = {};\n    let shift = 0;\n    Object.keys(actions).forEach(attr => {\n      let labels = actions[attr];\n\n      if (!Array.isArray(labels)) {\n        labels = [labels];\n      }\n\n      labels.forEach(label => {\n        let flag = flags[label];\n\n        if (!flag) {\n          shift += 1;\n          flag = flags[label] = 1 << shift;\n        }\n\n        attrs[attr] |= flag;\n      });\n    });\n    let labels = bootstrap;\n\n    if (!Array.isArray(labels)) {\n      labels = [labels];\n    }\n\n    labels.forEach(label => {\n      if (!flags[label]) {\n        shift += 1;\n        flags[label] = 1 << shift;\n      }\n    }); // 26 - 30 are reserved for paper flags\n    // 31+ overflows maximal number\n\n    if (shift > 25) {\n      throw new Error('Maximum number of flags exceeded.');\n    }\n\n    this.flags = flags;\n    this.attrs = attrs;\n    this.bootstrap = bootstrap;\n  }\n\n  get cell() {\n    return this.view.cell;\n  }\n\n  getFlag(label) {\n    const flags = this.flags;\n\n    if (flags == null) {\n      return 0;\n    }\n\n    if (Array.isArray(label)) {\n      return label.reduce((memo, key) => memo | flags[key], 0);\n    }\n\n    return flags[label] | 0;\n  }\n\n  hasAction(flag, label) {\n    return flag & this.getFlag(label);\n  }\n\n  removeAction(flag, label) {\n    return flag ^ flag & this.getFlag(label);\n  }\n\n  getBootstrapFlag() {\n    return this.getFlag(this.bootstrap);\n  }\n\n  getChangedFlag() {\n    let flag = 0;\n\n    if (!this.attrs) {\n      return flag;\n    }\n\n    Object.keys(this.attrs).forEach(attr => {\n      if (this.cell.hasChanged(attr)) {\n        flag |= this.attrs[attr];\n      }\n    });\n    return flag;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}