{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Dom, FunctionExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Cell } from '../model';\nimport { View, CellView } from '../view';\nimport { Base } from './base';\nexport class Renderer extends Base {\n  init() {\n    this.resetUpdates();\n    this.startListening(); // Renders existing cells in the model.\n\n    this.resetViews(this.model.getCells()); // Starts rendering loop.\n\n    if (!this.isFrozen() && this.isAsync()) {\n      this.updateViewsAsync();\n    }\n  }\n\n  startListening() {\n    this.model.on('sorted', this.onSortModel, this);\n    this.model.on('reseted', this.onModelReseted, this);\n    this.model.on('batch:stop', this.onBatchStop, this);\n    this.model.on('cell:added', this.onCellAdded, this);\n    this.model.on('cell:removed', this.onCellRemoved, this);\n    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n\n  stopListening() {\n    this.model.off('sorted', this.onSortModel, this);\n    this.model.off('reseted', this.onModelReseted, this);\n    this.model.off('batch:stop', this.onBatchStop, this);\n    this.model.off('cell:added', this.onCellAdded, this);\n    this.model.off('cell:removed', this.onCellRemoved, this);\n    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n\n  resetUpdates() {\n    this.updates = {\n      priorities: [{}, {}, {}],\n      mounted: {},\n      mountedCids: [],\n      unmounted: {},\n      unmountedCids: [],\n      count: 0,\n      sort: false,\n      frozen: false,\n      freezeKey: null,\n      animationId: null\n    };\n  }\n\n  onSortModel() {\n    if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n      return;\n    }\n\n    this.sortViews();\n  }\n\n  onModelReseted(_ref) {\n    let {\n      options\n    } = _ref;\n    this.removeZPivots();\n    this.resetViews(this.model.getCells(), options);\n  }\n\n  onBatchStop(_ref2) {\n    let {\n      name,\n      data\n    } = _ref2;\n\n    if (this.isFrozen()) {\n      return;\n    }\n\n    const model = this.model;\n\n    if (!this.isAsync()) {\n      const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;\n\n      if (updateDelayingBatches.includes(name) && !model.hasActiveBatch(updateDelayingBatches)) {\n        this.updateViews(data);\n      }\n    }\n\n    const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;\n\n    if (sortDelayingBatches.includes(name) && !model.hasActiveBatch(sortDelayingBatches)) {\n      this.sortViews();\n    }\n  }\n\n  onCellAdded(_ref3) {\n    let {\n      cell,\n      options\n    } = _ref3;\n    const position = options.position;\n\n    if (this.isAsync() || typeof position !== 'number') {\n      this.renderView(cell, options);\n    } else {\n      if (options.maxPosition === position) {\n        this.freeze({\n          key: 'addCells'\n        });\n      }\n\n      this.renderView(cell, options);\n\n      if (position === 0) {\n        this.unfreeze({\n          key: 'addCells'\n        });\n      }\n    }\n  }\n\n  onCellRemoved(_ref4) {\n    let {\n      cell,\n      options\n    } = _ref4;\n    const view = this.findViewByCell(cell);\n\n    if (view) {\n      this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);\n    }\n  }\n\n  onCellZIndexChanged(_ref5) {\n    let {\n      cell,\n      options\n    } = _ref5;\n\n    if (this.options.sorting === 'approx') {\n      const view = this.findViewByCell(cell);\n\n      if (view) {\n        this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);\n      }\n    }\n  }\n\n  onCellVisibleChanged(_ref6) {\n    let {\n      cell,\n      current: visible,\n      options\n    } = _ref6;\n\n    // Hide connected edges before cell\n    if (!visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, false);\n    }\n\n    const view = this.findViewByCell(cell);\n\n    if (!visible && view) {\n      this.removeView(cell);\n    } else if (visible && view == null) {\n      this.renderView(cell, options);\n    } // Show connected edges after cell rendered\n\n\n    if (visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, true);\n    }\n  }\n\n  processEdgeOnTerminalVisibleChanged(node, visible) {\n    const getOpposite = (edge, currentTerminal) => {\n      const sourceId = edge.getSourceCellId();\n\n      if (sourceId !== currentTerminal.id) {\n        return edge.getSourceCell();\n      }\n\n      const targetId = edge.getTargetCellId();\n\n      if (targetId !== currentTerminal.id) {\n        return edge.getTargetCell();\n      }\n\n      return null;\n    };\n\n    this.model.getConnectedEdges(node).forEach(edge => {\n      const opposite = getOpposite(edge, node);\n\n      if (opposite == null || opposite.isVisible()) {\n        visible ? edge.show() : edge.hide();\n      }\n    });\n  }\n\n  isEdgeTerminalVisible(edge, terminal) {\n    const cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();\n    const cell = cellId ? this.model.getCell(cellId) : null;\n\n    if (cell && !cell.isVisible()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  requestConnectedEdgesUpdate(view) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (CellView.isCellView(view)) {\n      const cell = view.cell;\n      const edges = this.model.getConnectedEdges(cell);\n\n      for (let j = 0, n = edges.length; j < n; j += 1) {\n        const edge = edges[j];\n        const edgeView = this.findViewByCell(edge);\n\n        if (!edgeView) {\n          continue;\n        }\n\n        const flagLabels = ['update'];\n\n        if (edge.getTargetCell() === cell) {\n          flagLabels.push('target');\n        }\n\n        if (edge.getSourceCell() === cell) {\n          flagLabels.push('source');\n        }\n\n        this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);\n      }\n    }\n  }\n\n  forcePostponedViewUpdate(view, flag) {\n    if (!view || !CellView.isCellView(view)) {\n      return false;\n    }\n\n    const cell = view.cell;\n\n    if (cell.isNode()) {\n      return false;\n    }\n\n    const edgeView = view;\n\n    if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n      // EdgeView is waiting for the source/target cellView to be rendered.\n      // This can happen when the cells are not in the viewport.\n      let sourceFlag = 0;\n      const sourceView = this.findViewByCell(cell.getSourceCell());\n\n      if (sourceView && !this.isViewMounted(sourceView)) {\n        sourceFlag = this.dumpView(sourceView);\n        edgeView.updateTerminalMagnet('source');\n      }\n\n      let targetFlag = 0;\n      const targetView = this.findViewByCell(cell.getTargetCell());\n\n      if (targetView && !this.isViewMounted(targetView)) {\n        targetFlag = this.dumpView(targetView);\n        edgeView.updateTerminalMagnet('target');\n      }\n\n      if (sourceFlag === 0 && targetFlag === 0) {\n        // If leftover flag is 0, all view updates were done.\n        return !this.dumpView(edgeView);\n      }\n    }\n\n    return false;\n  }\n\n  scheduleViewUpdate(view, flag, priority) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const cid = view.cid;\n    const updates = this.updates;\n    let cache = updates.priorities[priority];\n\n    if (!cache) {\n      cache = updates.priorities[priority] = {};\n    }\n\n    const currentFlag = cache[cid] || 0;\n\n    if ((currentFlag & flag) === flag) {\n      return;\n    }\n\n    if (!currentFlag) {\n      updates.count += 1;\n    }\n\n    if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n      // When a view is removed we need to remove the\n      // insert flag as this is a reinsert.\n      cache[cid] ^= Renderer.FLAG_INSERT;\n    } else if (flag & Renderer.FLAG_INSERT && currentFlag & Renderer.FLAG_REMOVE) {\n      // When a view is added we need to remove the remove\n      // flag as this is view was previously removed.\n      cache[cid] ^= Renderer.FLAG_REMOVE;\n    }\n\n    cache[cid] |= flag;\n    this.graph.hook.onViewUpdated(view, flag, options);\n  }\n\n  requestViewUpdate(view, flag, priority) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.scheduleViewUpdate(view, flag, priority, options);\n    const isAsync = this.isAsync();\n\n    if (this.isFrozen() || isAsync && options.async !== false || this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {\n      return;\n    }\n\n    const stats = this.updateViews(options);\n\n    if (isAsync) {\n      this.graph.trigger('render:done', {\n        stats,\n        options\n      });\n    }\n  }\n  /**\n   * Adds view into the DOM and update it.\n   */\n\n\n  dumpView(view) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (view == null) {\n      return 0;\n    }\n\n    const cid = view.cid;\n    const updates = this.updates;\n    const cache = updates.priorities[view.priority];\n    const flag = this.registerMountedView(view) | cache[cid];\n    delete cache[cid];\n\n    if (!flag) {\n      return 0;\n    }\n\n    return this.updateView(view, flag, options);\n  }\n  /**\n   * Adds all views into the DOM and update them.\n   */\n\n\n  dumpViews() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.checkView(options);\n    this.updateViews(options);\n  }\n  /**\n   * Ensure the view associated with the cell is attached\n   * to the DOM and updated.\n   */\n\n\n  requireView(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const view = this.findViewByCell(cell);\n\n    if (view == null) {\n      return null;\n    }\n\n    this.dumpView(view, options);\n    return view;\n  }\n\n  updateView(view, flag) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (view == null) {\n      return 0;\n    }\n\n    if (CellView.isCellView(view)) {\n      if (flag & Renderer.FLAG_REMOVE) {\n        this.removeView(view.cell);\n        return 0;\n      }\n\n      if (flag & Renderer.FLAG_INSERT) {\n        this.insertView(view);\n        flag ^= Renderer.FLAG_INSERT; // eslint-disable-line\n      }\n    }\n\n    if (!flag) {\n      return 0;\n    }\n\n    return view.confirmUpdate(flag, options);\n  }\n\n  updateViews() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let result;\n    let batchCount = 0;\n    let updatedCount = 0;\n    let priority = Renderer.MIN_PRIORITY;\n\n    do {\n      result = this.updateViewsBatch(options);\n      batchCount += 1;\n      updatedCount += result.updatedCount;\n      priority = Math.min(result.priority, priority);\n    } while (!result.empty);\n\n    return {\n      priority,\n      batchCount,\n      updatedCount\n    };\n  }\n\n  updateViewsBatch() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const updates = this.updates;\n    const priorities = updates.priorities;\n    const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;\n    let empty = true;\n    let priority = Renderer.MIN_PRIORITY;\n    let mountedCount = 0;\n    let unmountedCount = 0;\n    let updatedCount = 0;\n    let postponedCount = 0;\n    let checkView = options.checkView || this.options.checkView;\n\n    if (typeof checkView !== 'function') {\n      checkView = null;\n    } // eslint-disable-next-line\n\n\n    main: for (let p = 0, n = priorities.length; p < n; p += 1) {\n      const cache = priorities[p]; // eslint-disable-next-line\n\n      for (const cid in cache) {\n        if (updatedCount >= batchSize) {\n          empty = false; // goto next batch\n\n          break main; // eslint-disable-line no-labels\n        }\n\n        const view = View.views[cid];\n\n        if (!view) {\n          delete cache[cid];\n          continue;\n        }\n\n        let currentFlag = cache[cid]; // Do not check a view for viewport if we are about to remove the view.\n\n        if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n          const isUnmounted = (cid in updates.unmounted);\n\n          if (checkView && !FunctionExt.call(checkView, this.graph, {\n            view: view,\n            unmounted: isUnmounted\n          })) {\n            // Unmount view\n            if (!isUnmounted) {\n              this.registerUnmountedView(view);\n              view.unmount();\n            }\n\n            updates.unmounted[cid] |= currentFlag;\n            delete cache[cid];\n            unmountedCount += 1;\n            continue;\n          } // Mount view\n\n\n          if (isUnmounted) {\n            currentFlag |= Renderer.FLAG_INSERT;\n            mountedCount += 1;\n          }\n\n          currentFlag |= this.registerMountedView(view);\n        }\n\n        const cellView = view;\n        let leftoverFlag = this.updateView(view, currentFlag, options);\n\n        if (leftoverFlag > 0) {\n          const cell = cellView.cell;\n\n          if (cell && cell.isEdge()) {\n            // remove edge view when source cell is invisible\n            if (cellView.hasAction(leftoverFlag, 'source') && !this.isEdgeTerminalVisible(cell, 'source')) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'source');\n              leftoverFlag |= Renderer.FLAG_REMOVE;\n            } // remove edge view when target cell is invisible\n\n\n            if (cellView.hasAction(leftoverFlag, 'target') && !this.isEdgeTerminalVisible(cell, 'target')) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'target');\n              leftoverFlag |= Renderer.FLAG_REMOVE;\n            }\n          }\n        }\n\n        if (leftoverFlag > 0) {\n          // update has not finished\n          cache[cid] = leftoverFlag;\n\n          if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) || cache[cid]) {\n            postponedCount += 1;\n            empty = false;\n            continue;\n          }\n        }\n\n        if (priority > p) {\n          priority = p;\n        }\n\n        updatedCount += 1;\n        delete cache[cid];\n      }\n    }\n\n    return {\n      empty,\n      priority,\n      mountedCount,\n      unmountedCount,\n      updatedCount,\n      postponedCount\n    };\n  }\n\n  updateViewsAsync() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      processed: 0,\n      priority: Renderer.MIN_PRIORITY\n    };\n    const updates = this.updates;\n    const animationId = updates.animationId;\n\n    if (animationId) {\n      Dom.cancelAnimationFrame(animationId);\n\n      if (data.processed === 0) {\n        const beforeFn = options.before;\n\n        if (typeof beforeFn === 'function') {\n          FunctionExt.call(beforeFn, this.graph, this.graph);\n        }\n      }\n\n      const stats = this.updateViewsBatch(options);\n      const checkout = this.checkViewImpl({\n        checkView: options.checkView,\n        mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n        unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount\n      });\n      let processed = data.processed;\n      const total = updates.count;\n      const mountedCount = checkout.mountedCount;\n      const unmountedCount = checkout.unmountedCount;\n\n      if (stats.updatedCount > 0) {\n        // Some updates have been just processed\n        processed += stats.updatedCount + stats.unmountedCount;\n        data.priority = Math.min(stats.priority, data.priority);\n\n        if (stats.empty && mountedCount === 0) {\n          stats.priority = data.priority;\n          stats.mountedCount += mountedCount;\n          stats.unmountedCount += unmountedCount;\n          this.graph.trigger('render:done', {\n            stats,\n            options\n          });\n          data.processed = 0;\n          updates.count = 0;\n        } else {\n          data.processed = processed;\n        }\n      } // Progress callback\n\n\n      const progressFn = options.progress;\n\n      if (total && typeof progressFn === 'function') {\n        FunctionExt.call(progressFn, this.graph, {\n          total,\n          done: stats.empty,\n          current: processed\n        });\n      } // The current frame could have been canceled in a callback\n\n\n      if (updates.animationId !== animationId) {\n        return;\n      }\n    }\n\n    updates.animationId = Dom.requestAnimationFrame(() => {\n      this.updateViewsAsync(options, data);\n    });\n  }\n\n  registerMountedView(view) {\n    const cid = view.cid;\n    const updates = this.updates;\n\n    if (cid in updates.mounted) {\n      return 0;\n    }\n\n    updates.mounted[cid] = true;\n    updates.mountedCids.push(cid);\n    const flag = updates.unmounted[cid] || 0;\n    delete updates.unmounted[cid];\n    return flag;\n  }\n\n  registerUnmountedView(view) {\n    const cid = view.cid;\n    const updates = this.updates;\n\n    if (cid in updates.unmounted) {\n      return 0;\n    }\n\n    updates.unmounted[cid] |= Renderer.FLAG_INSERT;\n    const flag = updates.unmounted[cid];\n    updates.unmountedCids.push(cid);\n    delete updates.mounted[cid];\n    return flag;\n  }\n\n  isViewMounted(view) {\n    if (view == null) {\n      return false;\n    }\n\n    const cid = view.cid;\n    return cid in this.updates.mounted;\n  }\n\n  getMountedViews() {\n    return Object.keys(this.updates.mounted).map(cid => CellView.views[cid]);\n  }\n\n  getUnmountedViews() {\n    return Object.keys(this.updates.unmounted).map(cid => CellView.views[cid]);\n  }\n\n  checkMountedViews(viewportFn, batchSize) {\n    let unmountCount = 0;\n\n    if (typeof viewportFn !== 'function') {\n      return unmountCount;\n    }\n\n    const updates = this.updates;\n    const mounted = updates.mounted;\n    const mountedCids = updates.mountedCids;\n    const size = batchSize == null ? mountedCids.length : Math.min(mountedCids.length, batchSize);\n\n    for (let i = 0; i < size; i += 1) {\n      const cid = mountedCids[i];\n\n      if (!(cid in mounted)) {\n        continue;\n      }\n\n      const view = CellView.views[cid];\n\n      if (view == null) {\n        continue;\n      }\n\n      const shouldMount = FunctionExt.call(viewportFn, this.graph, {\n        view: view,\n        unmounted: true\n      });\n\n      if (shouldMount) {\n        // Push at the end of all mounted ids\n        mountedCids.push(cid);\n        continue;\n      }\n\n      unmountCount += 1;\n      const flag = this.registerUnmountedView(view);\n\n      if (flag) {\n        view.unmount();\n      }\n    } // Get rid of views, that have been unmounted\n\n\n    mountedCids.splice(0, size);\n    return unmountCount;\n  }\n\n  checkUnmountedViews(checkView, batchSize) {\n    let mountCount = 0;\n\n    if (typeof checkView !== 'function') {\n      checkView = null; // eslint-disable-line\n    }\n\n    const updates = this.updates;\n    const unmounted = updates.unmounted;\n    const unmountedCids = updates.unmountedCids;\n    const size = batchSize == null ? unmountedCids.length : Math.min(unmountedCids.length, batchSize);\n\n    for (let i = 0; i < size; i += 1) {\n      const cid = unmountedCids[i];\n\n      if (!(cid in unmounted)) {\n        continue;\n      }\n\n      const view = CellView.views[cid];\n\n      if (view == null) {\n        continue;\n      }\n\n      if (checkView && !FunctionExt.call(checkView, this.graph, {\n        view,\n        unmounted: false\n      })) {\n        unmountedCids.push(cid);\n        continue;\n      }\n\n      mountCount += 1;\n      const flag = this.registerMountedView(view);\n\n      if (flag) {\n        this.scheduleViewUpdate(view, flag, view.priority, {\n          mounting: true\n        });\n      }\n    } // Get rid of views, that have been mounted\n\n\n    unmountedCids.splice(0, size);\n    return mountCount;\n  }\n\n  checkViewImpl() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      mountedBatchSize: Number.MAX_SAFE_INTEGER,\n      unmountedBatchSize: Number.MAX_SAFE_INTEGER\n    };\n    const checkView = options.checkView || this.options.checkView;\n    const unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);\n    const mountedCount = this.checkUnmountedViews(checkView, // Do not check views, that have been just unmounted\n    // and pushed at the end of the cids array\n    unmountedCount > 0 ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize) : options.mountedBatchSize);\n    return {\n      mountedCount,\n      unmountedCount\n    };\n  }\n  /**\n   * Determine every view in the graph should be attached/detached.\n   */\n\n\n  checkView() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.checkViewImpl(options);\n  }\n\n  isFrozen() {\n    return !!this.options.frozen;\n  }\n  /**\n   * Freeze the graph then the graph does not automatically re-render upon\n   * changes in the graph. This is useful when adding large numbers of cells.\n   */\n\n\n  freeze() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const key = options.key;\n    const updates = this.updates;\n    const frozen = this.options.frozen;\n    const freezeKey = updates.freezeKey;\n\n    if (key && key !== freezeKey) {\n      if (frozen && freezeKey) {\n        // key passed, but the graph is already freezed with another key\n        return;\n      }\n\n      updates.frozen = frozen;\n      updates.freezeKey = key;\n    }\n\n    this.options.frozen = true;\n    const animationId = updates.animationId;\n    updates.animationId = null;\n\n    if (this.isAsync() && animationId != null) {\n      Dom.cancelAnimationFrame(animationId);\n    }\n\n    this.graph.trigger('freeze', {\n      key\n    });\n  }\n\n  unfreeze() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const key = options.key;\n    const updates = this.updates;\n    const freezeKey = updates.freezeKey; // key passed, but the graph is already freezed with another key\n\n    if (key && freezeKey && key !== freezeKey) {\n      return;\n    }\n\n    updates.freezeKey = null; // key passed, but the graph is already freezed\n\n    if (key && key === freezeKey && updates.frozen) {\n      return;\n    }\n\n    const callback = () => {\n      this.options.frozen = updates.frozen = false;\n\n      if (updates.sort) {\n        this.sortViews();\n        updates.sort = false;\n      }\n\n      const afterFn = options.after;\n\n      if (afterFn) {\n        FunctionExt.call(afterFn, this.graph, this.graph);\n      }\n\n      this.graph.trigger('unfreeze', {\n        key\n      });\n    };\n\n    if (this.isAsync()) {\n      this.freeze();\n      const onProgress = options.progress;\n      this.updateViewsAsync(Object.assign(Object.assign({}, options), {\n        progress: _ref7 => {\n          let {\n            done,\n            current,\n            total\n          } = _ref7;\n\n          if (onProgress) {\n            FunctionExt.call(onProgress, this.graph, {\n              done,\n              current,\n              total\n            });\n          } // sort views after async render\n\n\n          if (done) {\n            callback();\n          }\n        }\n      }));\n    } else {\n      this.updateViews(options);\n      callback();\n    }\n  }\n\n  isAsync() {\n    return !!this.options.async;\n  }\n\n  setAsync(async) {\n    this.options.async = async;\n  }\n\n  onRemove() {\n    this.freeze();\n    this.removeViews();\n  }\n\n  resetViews() {\n    let cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.resetUpdates();\n    this.removeViews();\n    this.freeze({\n      key: 'reset'\n    });\n\n    for (let i = 0, n = cells.length; i < n; i += 1) {\n      this.renderView(cells[i], options);\n    }\n\n    this.unfreeze({\n      key: 'reset'\n    });\n    this.sortViews();\n  }\n\n  removeView(cell) {\n    const view = this.views[cell.id];\n\n    if (view) {\n      const cid = view.cid;\n      const updates = this.updates;\n      const mounted = updates.mounted;\n      const unmounted = updates.unmounted;\n      view.remove();\n      delete this.views[cell.id];\n      delete mounted[cid];\n      delete unmounted[cid];\n    }\n\n    return view;\n  }\n\n  removeViews() {\n    if (this.views) {\n      Object.keys(this.views).forEach(id => {\n        const view = this.views[id];\n\n        if (view) {\n          this.removeView(view.cell);\n        }\n      });\n    }\n\n    this.views = {};\n  }\n\n  renderView(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = cell.id;\n    const views = this.views;\n    let flag = 0;\n    let view = views[id];\n\n    if (!cell.isVisible()) {\n      return;\n    }\n\n    if (cell.isEdge()) {\n      if (!this.isEdgeTerminalVisible(cell, 'source') || !this.isEdgeTerminalVisible(cell, 'target')) {\n        return;\n      }\n    }\n\n    if (view) {\n      flag = Renderer.FLAG_INSERT;\n    } else {\n      const tmp = this.graph.hook.createCellView(cell);\n\n      if (tmp) {\n        view = views[cell.id] = tmp;\n        view.graph = this.graph;\n        flag = this.registerUnmountedView(view) | view.getBootstrapFlag();\n      }\n    }\n\n    if (view) {\n      this.requestViewUpdate(view, flag, view.priority, options);\n    }\n  }\n\n  isExactSorting() {\n    return this.options.sorting === 'exact';\n  }\n\n  sortViews() {\n    if (!this.isExactSorting()) {\n      return;\n    }\n\n    if (this.isFrozen()) {\n      // sort views once unfrozen\n      this.updates.sort = true;\n      return;\n    }\n\n    this.sortViewsExact();\n  }\n\n  sortElements(elems, comparator) {\n    // Highly inspired by the jquery.sortElements plugin by Padolsey.\n    // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n    const placements = elems.map(elem => {\n      const parentNode = elem.parentNode; // Since the element itself will change position, we have\n      // to have some way of storing it's original position in\n      // the DOM. The easiest way is to have a 'flag' node:\n\n      const nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);\n      return targetNode => {\n        if (parentNode === targetNode) {\n          throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n        } // Insert before flag\n\n\n        parentNode.insertBefore(targetNode, nextSibling); // Remove flag\n\n        parentNode.removeChild(nextSibling);\n      };\n    });\n    elems.sort(comparator).forEach((elem, index) => placements[index](elem));\n  }\n\n  sortViewsExact() {\n    // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n    // const length = elems.length\n    // const cells = []\n    // for (let i = 0; i < length; i++) {\n    //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n    //   cells.push({\n    //     id: cell.id,\n    //     zIndex: cell.getZIndex() || 0,\n    //     elem: elems[i],\n    //   })\n    // }\n    // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n    // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n    // if (moves && moves.length) {\n    //   moves.forEach((move) => {\n    //     if (move.type) {\n    //       const elem = move.item.elem as Element\n    //       const parentNode = elem.parentNode\n    //       const index = move.index\n    //       if (parentNode) {\n    //         if (index === length - 1) {\n    //           parentNode.appendChild(elem)\n    //         } else if (index < length - 1) {\n    //           parentNode.insertBefore(elem, elems[index + 1])\n    //         }\n    //       }\n    //     }\n    //   })\n    // }\n    // Run insertion sort algorithm in order to efficiently sort DOM\n    // elements according to their associated cell `zIndex` attribute.\n    const elems = this.view.$(this.view.stage).children('[data-cell-id]').toArray();\n    const model = this.model;\n    this.sortElements(elems, (a, b) => {\n      const cellA = model.getCell(a.getAttribute('data-cell-id') || '');\n      const cellB = model.getCell(b.getAttribute('data-cell-id') || '');\n      const z1 = cellA.getZIndex() || 0;\n      const z2 = cellB.getZIndex() || 0;\n      return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;\n    });\n  }\n\n  addZPivot() {\n    let zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    if (this.zPivots == null) {\n      this.zPivots = {};\n    }\n\n    const pivots = this.zPivots;\n    let pivot = pivots[zIndex];\n\n    if (pivot) {\n      return pivot;\n    }\n\n    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);\n    let neighborZ = -Infinity; // eslint-disable-next-line\n\n    for (const key in pivots) {\n      const currentZ = +key;\n\n      if (currentZ < zIndex && currentZ > neighborZ) {\n        neighborZ = currentZ;\n\n        if (neighborZ === zIndex - 1) {\n          continue;\n        }\n      }\n    }\n\n    const layer = this.view.stage;\n\n    if (neighborZ !== -Infinity) {\n      const neighborPivot = pivots[neighborZ];\n      layer.insertBefore(pivot, neighborPivot.nextSibling);\n    } else {\n      layer.insertBefore(pivot, layer.firstChild);\n    }\n\n    return pivot;\n  }\n\n  removeZPivots() {\n    if (this.zPivots) {\n      Object.keys(this.zPivots).forEach(z => {\n        const elem = this.zPivots[z];\n\n        if (elem && elem.parentNode) {\n          elem.parentNode.removeChild(elem);\n        }\n      });\n    }\n\n    this.zPivots = {};\n  }\n\n  insertView(view) {\n    const stage = this.view.stage;\n\n    switch (this.options.sorting) {\n      case 'approx':\n        {\n          const zIndex = view.cell.getZIndex();\n          const pivot = this.addZPivot(zIndex);\n          stage.insertBefore(view.container, pivot);\n          break;\n        }\n\n      case 'exact':\n      default:\n        stage.appendChild(view.container);\n        break;\n    }\n  }\n\n  findViewByCell(cell) {\n    if (cell == null) {\n      return null;\n    }\n\n    const id = Cell.isCell(cell) ? cell.id : cell;\n    return this.views[id];\n  }\n\n  findViewByElem(elem) {\n    if (elem == null) {\n      return null;\n    }\n\n    const target = typeof elem === 'string' ? this.view.stage.querySelector(elem) : elem instanceof Element ? elem : elem[0];\n\n    if (target) {\n      const id = this.view.findAttr('data-cell-id', target);\n\n      if (id) {\n        return this.views[id];\n      }\n    }\n\n    return null;\n  }\n\n  findViewsFromPoint(p) {\n    const ref = {\n      x: p.x,\n      y: p.y\n    };\n    return this.model.getCells().map(cell => this.findViewByCell(cell)).filter(view => {\n      if (view != null) {\n        return Dom.getBBox(view.container, {\n          target: this.view.stage\n        }).containsPoint(ref);\n      }\n\n      return false;\n    });\n  }\n\n  findEdgeViewsInArea(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const area = Rectangle.create(rect);\n    return this.model.getEdges().map(edge => this.findViewByCell(edge)).filter(view => {\n      if (view) {\n        const bbox = Dom.getBBox(view.container, {\n          target: this.view.stage\n        });\n\n        if (bbox.width === 0) {\n          bbox.inflate(1, 0);\n        } else if (bbox.height === 0) {\n          bbox.inflate(0, 1);\n        }\n\n        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n      }\n\n      return false;\n    });\n  }\n\n  findViewsInArea(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const area = Rectangle.create(rect);\n    return this.model.getNodes().map(node => this.findViewByCell(node)).filter(view => {\n      if (view) {\n        const bbox = Dom.getBBox(view.container, {\n          target: this.view.stage\n        });\n        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n      }\n\n      return false;\n    });\n  }\n\n  dispose() {\n    this.resetUpdates();\n    this.stopListening();\n  }\n\n}\n\n__decorate([Base.dispose()], Renderer.prototype, \"dispose\", null);\n\n(function (Renderer) {\n  Renderer.FLAG_INSERT = 1 << 30;\n  Renderer.FLAG_REMOVE = 1 << 29;\n  Renderer.MOUNT_BATCH_SIZE = 1000;\n  Renderer.UPDATE_BATCH_SIZE = 1000;\n  Renderer.MIN_PRIORITY = 2;\n  Renderer.SORT_DELAYING_BATCHES = ['add', 'to-front', 'to-back'];\n  Renderer.UPDATE_DELAYING_BATCHES = ['translate'];\n})(Renderer || (Renderer = {}));","map":null,"metadata":{},"sourceType":"module"}