{"ast":null,"code":"import graphlib from '../graphlib';\nimport { slack } from './util';\nimport { minBy } from '../util';\nconst Graph = graphlib.Graph;\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\n\nconst feasibleTree = g => {\n  const t = new Graph({\n    directed: false\n  }); // Choose arbitrary node from which to start our tree\n\n  const start = g.nodes()[0];\n  const size = g.nodeCount();\n  t.setNode(start, {});\n  let edge;\n  let delta;\n\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\n\n\nconst tightTree = (t, g) => {\n  const dfs = v => {\n    g.nodeEdges(v).forEach(e => {\n      const edgeV = e.v;\n      const w = v === edgeV ? e.w : edgeV;\n\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\n\n\nconst feasibleTreeWithLayer = g => {\n  const t = new Graph({\n    directed: false\n  }); // Choose arbitrary node from which to start our tree\n\n  const start = g.nodes()[0];\n  const size = g.nodeCount();\n  t.setNode(start, {});\n  let edge;\n  let delta;\n\n  while (tightTreeWithLayer(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\n\n\nconst tightTreeWithLayer = (t, g) => {\n  const dfs = v => {\n    var _a;\n\n    (_a = g.nodeEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      const edgeV = e.v;\n      const w = v === edgeV ? e.w : edgeV; // 对于指定layer的，直接加入tight-tree，不参与调整\n\n      if (!t.hasNode(w) && (g.node(w).layer !== undefined || !slack(g, e))) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\n\n\nconst findMinSlackEdge = (t, g) => {\n  return minBy(g.edges(), e => {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n\n    return Infinity;\n  });\n};\n\nconst shiftRanks = (t, g, delta) => {\n  t.nodes().forEach(v => {\n    if (!g.node(v).rank) g.node(v).rank = 0;\n    g.node(v).rank += delta;\n  });\n};\n\nexport { feasibleTree, feasibleTreeWithLayer };\nexport default {\n  feasibleTree,\n  feasibleTreeWithLayer\n};","map":null,"metadata":{},"sourceType":"module"}