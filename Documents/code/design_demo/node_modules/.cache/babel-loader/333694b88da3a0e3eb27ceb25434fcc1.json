{"ast":null,"code":"import { ObjectExt, NumberExt, Dom, FunctionExt } from '../../util';\nexport const text = {\n  qualify(text, _ref) {\n    let {\n      attrs\n    } = _ref;\n    return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap);\n  },\n\n  set(text, _ref2) {\n    let {\n      view,\n      elem,\n      attrs\n    } = _ref2;\n    const cacheName = 'x6-text';\n    const $elem = view.$(elem);\n    const cache = $elem.data(cacheName);\n\n    const json = str => {\n      try {\n        return JSON.parse(str);\n      } catch (error) {\n        return str;\n      }\n    };\n\n    const options = {\n      x: attrs.x,\n      eol: attrs.eol,\n      annotations: json(attrs.annotations),\n      textPath: json(attrs['text-path'] || attrs.textPath),\n      textVerticalAnchor: attrs['text-vertical-anchor'] || attrs.textVerticalAnchor,\n      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n      lineHeight: attrs['line-height'] || attrs.lineHeight\n    };\n    const fontSize = attrs['font-size'] || attrs.fontSize;\n    const textHash = JSON.stringify([text, options]);\n\n    if (fontSize) {\n      elem.setAttribute('font-size', fontSize);\n    } // Updates the text only if there was a change in the string\n    // or any of its attributes.\n\n\n    if (cache == null || cache !== textHash) {\n      // Text Along Path Selector\n      const textPath = options.textPath;\n\n      if (textPath != null && typeof textPath === 'object') {\n        const selector = textPath.selector;\n\n        if (typeof selector === 'string') {\n          const pathNode = view.find(selector)[0];\n\n          if (pathNode instanceof SVGPathElement) {\n            Dom.ensureId(pathNode);\n            options.textPath = Object.assign({\n              'xlink:href': `#${pathNode.id}`\n            }, textPath);\n          }\n        }\n      }\n\n      Dom.text(elem, `${text}`, options);\n      $elem.data(cacheName, textHash);\n    }\n  }\n\n};\nexport const textWrap = {\n  qualify: ObjectExt.isPlainObject,\n\n  set(val, _ref3) {\n    let {\n      view,\n      elem,\n      attrs,\n      refBBox\n    } = _ref3;\n    const info = val; // option `width`\n\n    const width = info.width || 0;\n\n    if (NumberExt.isPercentage(width)) {\n      refBBox.width *= parseFloat(width) / 100;\n    } else if (width <= 0) {\n      refBBox.width += width;\n    } else {\n      refBBox.width = width;\n    } // option `height`\n\n\n    const height = info.height || 0;\n\n    if (NumberExt.isPercentage(height)) {\n      refBBox.height *= parseFloat(height) / 100;\n    } else if (height <= 0) {\n      refBBox.height += height;\n    } else {\n      refBBox.height = height;\n    } // option `text`\n\n\n    let wrappedText;\n    let txt = info.text;\n\n    if (txt == null) {\n      txt = attrs.text;\n    }\n\n    if (txt != null) {\n      wrappedText = Dom.breakText(`${txt}`, refBBox, {\n        'font-weight': attrs['font-weight'] || attrs.fontWeight,\n        'font-size': attrs['font-size'] || attrs.fontSize,\n        'font-family': attrs['font-family'] || attrs.fontFamily,\n        lineHeight: attrs.lineHeight\n      }, {\n        svgDocument: view.graph.view.svg,\n        ellipsis: info.ellipsis,\n        hyphen: info.hyphen,\n        breakWord: info.breakWord\n      });\n    } else {\n      wrappedText = '';\n    }\n\n    FunctionExt.call(text.set, this, wrappedText, {\n      view,\n      elem,\n      attrs,\n      refBBox,\n      cell: view.cell\n    });\n  }\n\n};\n\nconst isTextInUse = (val, _ref4) => {\n  let {\n    attrs\n  } = _ref4;\n  return attrs.text !== undefined;\n};\n\nexport const lineHeight = {\n  qualify: isTextInUse\n};\nexport const textVerticalAnchor = {\n  qualify: isTextInUse\n};\nexport const textPath = {\n  qualify: isTextInUse\n};\nexport const annotations = {\n  qualify: isTextInUse\n};\nexport const eol = {\n  qualify: isTextInUse\n};\nexport const displayEmpty = {\n  qualify: isTextInUse\n};","map":null,"metadata":{},"sourceType":"module"}