{"ast":null,"code":"import { Line } from '../line';\nimport { LineTo } from './lineto';\nimport { Segment } from './segment';\nexport class Close extends Segment {\n  get end() {\n    if (!this.subpathStartSegment) {\n      throw new Error('Missing subpath start segment. (This segment needs a subpath ' + 'start segment (e.g. MoveTo), or segment has not yet been added' + ' to a path.)');\n    }\n\n    return this.subpathStartSegment.end;\n  }\n\n  get type() {\n    return 'Z';\n  }\n\n  get line() {\n    return new Line(this.start, this.end);\n  }\n\n  bbox() {\n    return this.line.bbox();\n  }\n\n  closestPoint(p) {\n    return this.line.closestPoint(p);\n  }\n\n  closestPointLength(p) {\n    return this.line.closestPointLength(p);\n  }\n\n  closestPointNormalizedLength(p) {\n    return this.line.closestPointNormalizedLength(p);\n  }\n\n  closestPointTangent(p) {\n    return this.line.closestPointTangent(p);\n  }\n\n  length() {\n    return this.line.length();\n  }\n\n  divideAt(ratio) {\n    const divided = this.line.divideAt(ratio);\n    return [// do not actually cut into the segment, first divided part can stay as Z\n    divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(), new LineTo(divided[1])];\n  }\n\n  divideAtLength(length) {\n    const divided = this.line.divideAtLength(length);\n    return [divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(), new LineTo(divided[1])];\n  }\n\n  getSubdivisions() {\n    return [];\n  }\n\n  pointAt(ratio) {\n    return this.line.pointAt(ratio);\n  }\n\n  pointAtLength(length) {\n    return this.line.pointAtLength(length);\n  }\n\n  tangentAt(ratio) {\n    return this.line.tangentAt(ratio);\n  }\n\n  tangentAtLength(length) {\n    return this.line.tangentAtLength(length);\n  }\n\n  isDifferentiable() {\n    if (!this.previousSegment || !this.subpathStartSegment) {\n      return false;\n    }\n\n    return !this.start.equals(this.end);\n  }\n\n  scale() {\n    return this;\n  }\n\n  rotate() {\n    return this;\n  }\n\n  translate() {\n    return this;\n  }\n\n  equals(s) {\n    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);\n  }\n\n  clone() {\n    return new Close();\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    return this.type;\n  }\n\n}\n\n(function (Close) {\n  function create() {\n    return new Close();\n  }\n\n  Close.create = create;\n})(Close || (Close = {}));","map":null,"metadata":{},"sourceType":"module"}