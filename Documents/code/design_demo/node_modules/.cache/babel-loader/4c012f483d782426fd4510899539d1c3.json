{"ast":null,"code":"import { Ellipse } from '../../geometry';\nimport { toResult } from './util';\nexport const ellipse = (portsPositionArgs, elemBBox, groupPositionArgs) => {\n  const startAngle = groupPositionArgs.start || 0;\n  const stepAngle = groupPositionArgs.step || 20;\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index, count) => (index + 0.5 - count / 2) * stepAngle);\n};\nexport const ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {\n  const startAngle = groupPositionArgs.start || 0;\n  const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, index => {\n    return index * stepAngle;\n  });\n};\n\nfunction ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {\n  const center = elemBBox.getCenter();\n  const start = elemBBox.getTopCenter();\n  const ratio = elemBBox.width / elemBBox.height;\n  const ellipse = Ellipse.fromRect(elemBBox);\n  const count = portsPositionArgs.length;\n  return portsPositionArgs.map((item, index) => {\n    const angle = startAngle + stepFn(index, count);\n    const p = start.clone().rotate(-angle, center).scale(ratio, 1, center);\n    const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;\n\n    if (item.dx || item.dy) {\n      p.translate(item.dx || 0, item.dy || 0);\n    }\n\n    if (item.dr) {\n      p.move(center, item.dr);\n    }\n\n    return toResult(p.round(), theta, item);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}