{"ast":null,"code":"import { resolve } from './util';\n\nconst middleSide = function (view, magnet, refPoint, options) {\n  let bbox;\n  let angle = 0;\n  let center;\n  const node = view.cell;\n\n  if (options.rotate) {\n    bbox = view.getUnrotatedBBoxOfElement(magnet);\n    center = node.getBBox().getCenter();\n    angle = node.getAngle();\n  } else {\n    bbox = view.getBBoxOfElement(magnet);\n  }\n\n  const padding = options.padding;\n\n  if (padding != null && Number.isFinite(padding)) {\n    bbox.inflate(padding);\n  }\n\n  if (options.rotate) {\n    refPoint.rotate(angle, center);\n  }\n\n  const side = bbox.getNearestSideToPoint(refPoint);\n  let result;\n\n  switch (side) {\n    case 'left':\n      result = bbox.getLeftMiddle();\n      break;\n\n    case 'right':\n      result = bbox.getRightMiddle();\n      break;\n\n    case 'top':\n      result = bbox.getTopCenter();\n      break;\n\n    case 'bottom':\n      result = bbox.getBottomCenter();\n      break;\n\n    default:\n      break;\n  }\n\n  const direction = options.direction;\n\n  if (direction === 'H') {\n    if (side === 'top' || side === 'bottom') {\n      if (refPoint.x <= bbox.x + bbox.width) {\n        result = bbox.getLeftMiddle();\n      } else {\n        result = bbox.getRightMiddle();\n      }\n    }\n  } else if (direction === 'V') {\n    if (refPoint.y <= bbox.y + bbox.height) {\n      result = bbox.getTopCenter();\n    } else {\n      result = bbox.getBottomCenter();\n    }\n  }\n\n  return options.rotate ? result.rotate(-angle, center) : result;\n};\n/**\n * Places the anchor of the edge in the middle of the side of view bbox\n * closest to the other endpoint.\n */\n\n\nexport const midSide = resolve(middleSide);","map":null,"metadata":{},"sourceType":"module"}