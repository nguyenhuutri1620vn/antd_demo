{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from \"./dagre/index\";\nimport { isArray, isNumber, isObject, getEdgeTerminal } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 层次布局\n */\n\nexport class DagreLayout extends Base {\n  constructor(options) {\n    super();\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n    this.rankdir = \"TB\";\n    /** 节点水平间距(px) */\n\n    this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n\n    this.sortByCombo = false;\n    /** 是否保留每条边上的dummy node */\n\n    this.edgeLabelSpace = true;\n    this.nodes = [];\n    this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n\n    this.layoutNode = nodeId => {\n      const self = this;\n      const {\n        nodes\n      } = self;\n      const node = nodes.find(node => node.id === nodeId);\n\n      if (node) {\n        const layout = node.layout !== false;\n        return layout;\n      }\n\n      return true;\n    };\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      rankdir: \"TB\",\n      align: undefined,\n      nodeSize: undefined,\n      nodesepFunc: undefined,\n      ranksepFunc: undefined,\n      nodesep: 50,\n      ranksep: 50,\n      controlPoints: false // 是否保留布局连线的控制点\n\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    const self = this;\n    const {\n      nodes,\n      nodeSize,\n      rankdir,\n      combos,\n      begin\n    } = self;\n    if (!nodes) return;\n    const edges = self.edges || [];\n    const g = new dagre.graphlib.Graph({\n      multigraph: true,\n      compound: true\n    });\n    let nodeSizeFunc;\n\n    if (!nodeSize) {\n      nodeSizeFunc = d => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            return d.size;\n          }\n\n          if (isObject(d.size)) {\n            return [d.size.width || 40, d.size.height || 40];\n          }\n\n          return [d.size, d.size];\n        }\n\n        return [40, 40];\n      };\n    } else if (isArray(nodeSize)) {\n      nodeSizeFunc = () => nodeSize;\n    } else {\n      nodeSizeFunc = () => [nodeSize, nodeSize];\n    }\n\n    let horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    let vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n\n    if (rankdir === \"LR\" || rankdir === \"RL\") {\n      horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n      vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    }\n\n    g.setDefaultEdgeLabel(() => ({}));\n    g.setGraph(self);\n    const comboMap = {};\n    nodes.filter(node => node.layout !== false).forEach(node => {\n      const size = nodeSizeFunc(node);\n      const verti = vertisep(node);\n      const hori = horisep(node);\n      const width = size[0] + 2 * hori;\n      const height = size[1] + 2 * verti;\n      const layer = node.layer;\n\n      if (isNumber(layer)) {\n        // 如果有layer属性，加入到node的label中\n        g.setNode(node.id, {\n          width,\n          height,\n          layer\n        });\n      } else {\n        g.setNode(node.id, {\n          width,\n          height\n        });\n      }\n\n      if (this.sortByCombo && node.comboId) {\n        if (!comboMap[node.comboId]) {\n          comboMap[node.comboId] = true;\n          g.setNode(node.comboId, {});\n        }\n\n        g.setParent(node.id, node.comboId);\n      }\n    });\n\n    if (this.sortByCombo && combos) {\n      combos.forEach(combo => {\n        if (!combo.parentId) return;\n\n        if (!comboMap[combo.parentId]) {\n          comboMap[combo.parentId] = true;\n          g.setNode(combo.parentId, {});\n        }\n\n        g.setParent(combo.id, combo.parentId);\n      });\n    }\n\n    edges.forEach(edge => {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      const source = getEdgeTerminal(edge, 'source');\n      const target = getEdgeTerminal(edge, 'target');\n\n      if (this.layoutNode(source) && this.layoutNode(target)) {\n        g.setEdge(source, target, {\n          weight: edge.weight || 1\n        });\n      }\n    }); // 考虑增量图中的原始图\n\n    let prevGraph = undefined;\n\n    if (self.preset) {\n      prevGraph = new dagre.graphlib.Graph({\n        multigraph: true,\n        compound: true\n      });\n      self.preset.nodes.forEach(node => {\n        prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);\n      });\n    }\n\n    dagre.layout(g, {\n      prevGraph,\n      edgeLabelSpace: self.edgeLabelSpace,\n      keepNodeOrder: Boolean(!!self.nodeOrder),\n      nodeOrder: self.nodeOrder\n    });\n    const dBegin = [0, 0];\n\n    if (begin) {\n      let minX = Infinity;\n      let minY = Infinity;\n      g.nodes().forEach(node => {\n        const coord = g.node(node);\n        if (minX > coord.x) minX = coord.x;\n        if (minY > coord.y) minY = coord.y;\n      });\n      g.edges().forEach(edge => {\n        const coord = g.edge(edge);\n        coord.points.forEach(point => {\n          if (minX > point.x) minX = point.x;\n          if (minY > point.y) minY = point.y;\n        });\n      });\n      dBegin[0] = begin[0] - minX;\n      dBegin[1] = begin[1] - minY;\n    }\n\n    g.nodes().forEach(node => {\n      const coord = g.node(node);\n      const i = nodes.findIndex(it => it.id === node);\n      if (!nodes[i]) return;\n      nodes[i].x = coord.x + dBegin[0];\n      nodes[i].y = coord.y + dBegin[1]; // @ts-ignore: pass layer order to data for increment layout use\n\n      nodes[i]._order = coord._order;\n    });\n    g.edges().forEach(edge => {\n      const coord = g.edge(edge);\n      const i = edges.findIndex(it => {\n        const source = getEdgeTerminal(it, 'source');\n        const target = getEdgeTerminal(it, 'target');\n        return source === edge.v && target === edge.w;\n      });\n\n      if (self.edgeLabelSpace && self.controlPoints && edges[i].type !== \"loop\") {\n        edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n        edges[i].controlPoints.forEach(point => {\n          point.x += dBegin[0];\n          point.y += dBegin[1];\n        });\n      }\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  getType() {\n    return \"dagre\";\n  }\n\n}\n\nfunction getFunc(func, value, defaultValue) {\n  let resultFunc;\n\n  if (func) {\n    resultFunc = func;\n  } else if (isNumber(value)) {\n    resultFunc = () => value;\n  } else {\n    resultFunc = () => defaultValue;\n  }\n\n  return resultFunc;\n}","map":null,"metadata":{},"sourceType":"module"}