{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isNil from \"lodash/isNil\";\nimport _camelCase from \"lodash/camelCase\";\n\nvar _dec, _dec2, _class, _class2, _descriptor;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { gl } from '../gl';\nvar quad = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport { TYPES } from '../../../types';\nimport { PassType } from '../IMultiPassRenderer';\nvar BasePostProcessingPass = (_dec = injectable(), _dec2 = inject(TYPES.IShaderModuleService), _dec(_class = (_class2 = function () {\n  function BasePostProcessingPass() {\n    _classCallCheck(this, BasePostProcessingPass);\n\n    _initializerDefineProperty(this, \"shaderModuleService\", _descriptor, this);\n\n    _defineProperty(this, \"rendererService\", void 0);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"quad\", quad);\n\n    _defineProperty(this, \"enabled\", true);\n\n    _defineProperty(this, \"renderToScreen\", false);\n\n    _defineProperty(this, \"model\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"optionsToUpdate\", {});\n  }\n\n  _createClass(BasePostProcessingPass, [{\n    key: \"getName\",\n    value: function getName() {\n      return this.name;\n    }\n  }, {\n    key: \"setName\",\n    value: function setName(name) {\n      this.name = name;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return PassType.PostProcessing;\n    }\n  }, {\n    key: \"init\",\n    value: function init(layer, config) {\n      this.config = config;\n      this.rendererService = layer.getContainer().get(TYPES.IRendererService);\n      this.shaderModuleService = layer.getContainer().get(TYPES.IShaderModuleService);\n      var _this$rendererService = this.rendererService,\n          createAttribute = _this$rendererService.createAttribute,\n          createBuffer = _this$rendererService.createBuffer,\n          createModel = _this$rendererService.createModel;\n\n      var _this$setupShaders = this.setupShaders(),\n          vs = _this$setupShaders.vs,\n          fs = _this$setupShaders.fs,\n          uniforms = _this$setupShaders.uniforms;\n\n      this.model = createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-4, -4, 4, -4, 0, 4],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread(_objectSpread({\n          u_Texture: null\n        }, uniforms), this.config && this.convertOptionsToUniforms(this.config)),\n        depth: {\n          enable: false\n        },\n        count: 3,\n        blend: {\n          enable: this.getName() === 'copy'\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(layer, tex) {\n      var _this = this;\n\n      var postProcessor = layer.multiPassRenderer.getPostProcessor();\n      var _this$rendererService2 = this.rendererService,\n          useFramebuffer = _this$rendererService2.useFramebuffer,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          clear = _this$rendererService2.clear;\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      useFramebuffer(this.renderToScreen ? null : postProcessor.getWriteFBO(), function () {\n        clear({\n          framebuffer: postProcessor.getWriteFBO(),\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0\n        });\n\n        var uniformOptions = _objectSpread({\n          u_BloomFinal: 0.0,\n          u_Texture: postProcessor.getReadFBO(),\n          u_ViewportSize: [width, height]\n        }, _this.convertOptionsToUniforms(_this.optionsToUpdate));\n\n        if (tex) {\n          uniformOptions.u_BloomFinal = 1.0;\n          uniformOptions.u_Texture2 = tex;\n        }\n\n        _this.model.draw({\n          uniforms: uniformOptions\n        });\n      });\n    }\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.enabled;\n    }\n  }, {\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.enabled = enabled;\n    }\n  }, {\n    key: \"setRenderToScreen\",\n    value: function setRenderToScreen(renderToScreen) {\n      this.renderToScreen = renderToScreen;\n    }\n  }, {\n    key: \"updateOptions\",\n    value: function updateOptions(config) {\n      this.optionsToUpdate = _objectSpread(_objectSpread({}, this.optionsToUpdate), config);\n    }\n  }, {\n    key: \"setupShaders\",\n    value: function setupShaders() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"convertOptionsToUniforms\",\n    value: function convertOptionsToUniforms(options) {\n      var uniforms = {};\n      Object.keys(options).forEach(function (optionName) {\n        if (!_isNil(options[optionName])) {\n          uniforms[\"u_\".concat(_upperFirst(_camelCase(optionName)))] = options[optionName];\n        }\n      });\n      return uniforms;\n    }\n  }]);\n\n  return BasePostProcessingPass;\n}(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { BasePostProcessingPass as default };","map":null,"metadata":{},"sourceType":"module"}