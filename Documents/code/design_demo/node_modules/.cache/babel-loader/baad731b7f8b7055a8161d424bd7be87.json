{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport class Polyline extends Geometry {\n  constructor(points) {\n    super();\n\n    if (points != null) {\n      if (typeof points === 'string') {\n        return Polyline.parse(points);\n      }\n\n      this.points = points.map(p => Point.create(p));\n    } else {\n      this.points = [];\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Polyline.toStringTag;\n  }\n\n  get start() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    return this.points[0];\n  }\n\n  get end() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    return this.points[this.points.length - 1];\n  }\n\n  scale(sx, sy) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    this.points.forEach(p => p.scale(sx, sy, origin));\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.points.forEach(p => p.rotate(angle, origin));\n    return this;\n  }\n\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.points.forEach(p => p.translate(t.x, t.y));\n    return this;\n  }\n\n  bbox() {\n    if (this.points.length === 0) {\n      return new Rectangle();\n    }\n\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n    const points = this.points;\n\n    for (let i = 0, ii = points.length; i < ii; i += 1) {\n      const point = points[i];\n      const x = point.x;\n      const y = point.y;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n    }\n\n    return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n  }\n\n  closestPoint(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.pointAtLength(cpLength);\n  }\n\n  closestPointLength(p) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return 0;\n    }\n\n    let length = 0;\n    let cpLength = 0;\n    let minSqrDistance = Infinity;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const line = new Line(points[i], points[i + 1]);\n      const lineLength = line.length();\n      const cpNormalizedLength = line.closestPointNormalizedLength(p);\n      const cp = line.pointAt(cpNormalizedLength);\n      const sqrDistance = cp.squaredDistance(p);\n\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance;\n        cpLength = length + cpNormalizedLength * lineLength;\n      }\n\n      length += lineLength;\n    }\n\n    return cpLength;\n  }\n\n  closestPointNormalizedLength(p) {\n    const cpLength = this.closestPointLength(p);\n\n    if (cpLength === 0) {\n      return 0;\n    }\n\n    const length = this.length();\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointTangent(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.tangentAtLength(cpLength);\n  }\n\n  containsPoint(p) {\n    if (this.points.length === 0) {\n      return false;\n    }\n\n    const ref = Point.clone(p);\n    const x = ref.x;\n    const y = ref.y;\n    const points = this.points;\n    const count = points.length;\n    let startIndex = count - 1;\n    let intersectionCount = 0;\n\n    for (let endIndex = 0; endIndex < count; endIndex += 1) {\n      const start = points[startIndex];\n      const end = points[endIndex];\n\n      if (ref.equals(start)) {\n        return true;\n      }\n\n      const segment = new Line(start, end);\n\n      if (segment.containsPoint(p)) {\n        return true;\n      } // do we have an intersection?\n\n\n      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          const rayEnd = new Point(x + xDifference, y); // right\n\n          const ray = new Line(p, rayEnd);\n\n          if (segment.intersectsWithLine(ray)) {\n            // an intersection was detected to the right of `p`\n            intersectionCount += 1;\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\n      } // move to check the next polyline segment\n\n\n      startIndex = endIndex;\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return intersectionCount % 2 === 1;\n  }\n\n  intersectsWithLine(line) {\n    const intersections = [];\n\n    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const int = line.intersectsWithLine(new Line(a, b));\n\n      if (int) {\n        intersections.push(int);\n      }\n    }\n\n    return intersections.length > 0 ? intersections : null;\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const line = new Line(a, b);\n\n      if (line.isDifferentiable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  length() {\n    let len = 0;\n\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      len += a.distance(b);\n    }\n\n    return len;\n  }\n\n  pointAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    if (count === 1) {\n      return points[0].clone();\n    }\n\n    if (ratio <= 0) {\n      return points[0].clone();\n    }\n\n    if (ratio >= 1) {\n      return points[count - 1].clone();\n    }\n\n    const total = this.length();\n    const length = total * ratio;\n    return this.pointAtLength(length);\n  }\n\n  pointAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    if (count === 1) {\n      return points[0].clone();\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    let tmp = 0;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n\n      if (length <= tmp + d) {\n        return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n      }\n\n      tmp += d;\n    }\n\n    const lastPoint = fromStart ? points[count - 1] : points[0];\n    return lastPoint.clone();\n  }\n\n  tangentAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return null;\n    }\n\n    if (ratio < 0) {\n      ratio = 0; // eslint-disable-line\n    }\n\n    if (ratio > 1) {\n      ratio = 1; // eslint-disable-line\n    }\n\n    const total = this.length();\n    const length = total * ratio;\n    return this.tangentAtLength(length);\n  }\n\n  tangentAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    let lastValidLine;\n    let tmp = 0;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n\n      if (l.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= tmp + d) {\n          return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n        }\n\n        lastValidLine = l;\n      }\n\n      tmp += d;\n    }\n\n    if (lastValidLine) {\n      const ratio = fromStart ? 1 : 0;\n      return lastValidLine.tangentAt(ratio);\n    }\n\n    return null;\n  }\n\n  simplify() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const points = this.points; // we need at least 3 points\n\n    if (points.length < 3) {\n      return this;\n    }\n\n    const threshold = options.threshold || 0; // start at the beginning of the polyline and go forward\n\n    let currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex;\n      const middleIndex = currentIndex + 1;\n      const lastIndex = currentIndex + 2;\n      const firstPoint = points[firstIndex];\n      const middlePoint = points[middleIndex];\n      const lastPoint = points[lastIndex];\n      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\n      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\n      const closestPointDistance = closestPoint.distance(middlePoint);\n\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1; //    = (point after first point becomes first point)\n      }\n    } // `points` array was modified in-place\n\n\n    return this;\n  }\n\n  toHull() {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return new Polyline();\n    } // Step 1: find the starting point -- point with\n    // the lowest y (if equality, highest x).\n\n\n    let startPoint = points[0];\n\n    for (let i = 1; i < count; i += 1) {\n      if (points[i].y < startPoint.y) {\n        startPoint = points[i];\n      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n        startPoint = points[i];\n      }\n    } // Step 2: sort the list of points by angle between line\n    // from start point to current point and the x-axis (theta).\n    // Step 2a: create the point records = [point, originalIndex, angle]\n\n\n    const sortedRecords = [];\n\n    for (let i = 0; i < count; i += 1) {\n      let angle = startPoint.theta(points[i]);\n\n      if (angle === 0) {\n        // Give highest angle to start point.\n        // The start point will end up at end of sorted list.\n        // The start point will end up at beginning of hull points list.\n        angle = 360;\n      }\n\n      sortedRecords.push([points[i], i, angle]);\n    } // Step 2b: sort the list in place\n\n\n    sortedRecords.sort((record1, record2) => {\n      let ret = record1[2] - record2[2];\n\n      if (ret === 0) {\n        ret = record2[1] - record1[1];\n      }\n\n      return ret;\n    }); // Step 2c: duplicate start record from the top of\n    // the stack to the bottom of the stack.\n\n    if (sortedRecords.length > 2) {\n      const startPoint = sortedRecords[sortedRecords.length - 1];\n      sortedRecords.unshift(startPoint);\n    } // Step 3\n    // ------\n    // Step 3a: go through sorted points in order and find those with\n    // right turns, and we want to get our results in clockwise order.\n    // Dictionary of points with left turns - cannot be on the hull.\n\n\n    const insidePoints = {}; // Stack of records with right turns - hull point candidates.\n\n    const hullRecords = [];\n\n    const getKey = record => `${record[0].toString()}@${record[1]}`;\n\n    while (sortedRecords.length !== 0) {\n      const currentRecord = sortedRecords.pop();\n      const currentPoint = currentRecord[0]; // Check if point has already been discarded.\n\n      if (insidePoints[getKey(currentRecord)]) {\n        continue;\n      }\n\n      let correctTurnFound = false;\n\n      while (!correctTurnFound) {\n        if (hullRecords.length < 2) {\n          // Not enough points for comparison, just add current point.\n          hullRecords.push(currentRecord);\n          correctTurnFound = true;\n        } else {\n          const lastHullRecord = hullRecords.pop();\n          const lastHullPoint = lastHullRecord[0];\n          const secondLastHullRecord = hullRecords.pop();\n          const secondLastHullPoint = secondLastHullRecord[0];\n          const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n          if (crossProduct < 0) {\n            // Found a right turn.\n            hullRecords.push(secondLastHullRecord);\n            hullRecords.push(lastHullRecord);\n            hullRecords.push(currentRecord);\n            correctTurnFound = true;\n          } else if (crossProduct === 0) {\n            // the three points are collinear\n            // three options:\n            // there may be a 180 or 0 degree angle at lastHullPoint\n            // or two of the three points are coincident\n            // we have to take rounding errors into account\n            const THRESHOLD = 1e-10;\n            const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\n            if (Math.abs(angleBetween - 180) < THRESHOLD) {\n              // rouding around 180 to 180\n              // if the cross product is 0 because the angle is 180 degrees\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n              // if the cross product is 0 because two points are the same\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n              // rounding around 0 and 360 to 0\n              // if the cross product is 0 because the angle is 0 degrees\n              // remove last hull point from hull BUT do not discard it\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord); // put last hull point back into the sorted point records list\n\n              sortedRecords.push(lastHullRecord); // we are switching the order of the 0deg and 180deg points\n              // correct turn not found\n            }\n          } else {\n            // found a left turn\n            // discard last hull point (add to insidePoints)\n            // insidePoints.unshift(lastHullPoint);\n            insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)\n\n            hullRecords.push(secondLastHullRecord); // do not do anything with current point\n            // correct turn not found\n          }\n        }\n      }\n    } // At this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n    // Step 3b: remove duplicated startPointRecord from the end of the array\n\n\n    if (hullRecords.length > 2) {\n      hullRecords.pop();\n    } // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n\n\n    let lowestHullIndex; // the lowest originalIndex on the hull\n\n    let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\n    for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n      const currentHullIndex = hullRecords[i][1];\n\n      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n        lowestHullIndex = currentHullIndex;\n        indexOfLowestHullIndexRecord = i;\n      }\n    }\n\n    let hullPointRecordsReordered = [];\n\n    if (indexOfLowestHullIndexRecord > 0) {\n      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n    } else {\n      hullPointRecordsReordered = hullRecords;\n    }\n\n    const hullPoints = [];\n\n    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n      hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return new Polyline(hullPoints);\n  }\n\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n\n    if (p.points.length !== this.points.length) {\n      return false;\n    }\n\n    return p.points.every((a, i) => a.equals(this.points[i]));\n  }\n\n  clone() {\n    return new Polyline(this.points.map(p => p.clone()));\n  }\n\n  toJSON() {\n    return this.points.map(p => p.toJSON());\n  }\n\n  serialize() {\n    return this.points.map(p => `${p.x}, ${p.y}`).join(' ');\n  }\n\n}\n\n(function (Polyline) {\n  Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;\n\n  function isPolyline(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Polyline) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const polyline = instance;\n\n    if ((tag == null || tag === Polyline.toStringTag) && typeof polyline.toHull === 'function' && typeof polyline.simplify === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n\n(function (Polyline) {\n  function parse(svgString) {\n    const str = svgString.trim();\n\n    if (str === '') {\n      return new Polyline();\n    }\n\n    const points = [];\n    const coords = str.split(/\\s*,\\s*|\\s+/);\n\n    for (let i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({\n        x: +coords[i],\n        y: +coords[i + 1]\n      });\n    }\n\n    return new Polyline(points);\n  }\n\n  Polyline.parse = parse;\n})(Polyline || (Polyline = {}));","map":null,"metadata":{},"sourceType":"module"}