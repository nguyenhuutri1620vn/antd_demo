{"ast":null,"code":"import { Util } from '../../global/util';\nimport { Point } from '../../geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nexport class Vertices extends ToolsView.ToolItem {\n  constructor() {\n    super(...arguments);\n    this.handles = [];\n  }\n\n  get vertices() {\n    return this.cellView.cell.getVertices();\n  }\n\n  onRender() {\n    this.addClass(this.prefixClassName('edge-tool-vertices'));\n\n    if (this.options.addable) {\n      this.updatePath();\n    }\n\n    this.resetHandles();\n    this.renderHandles();\n    return this;\n  }\n\n  update() {\n    const vertices = this.vertices;\n\n    if (vertices.length === this.handles.length) {\n      this.updateHandles();\n    } else {\n      this.resetHandles();\n      this.renderHandles();\n    }\n\n    if (this.options.addable) {\n      this.updatePath();\n    }\n\n    return this;\n  }\n\n  resetHandles() {\n    const handles = this.handles;\n    this.handles = [];\n\n    if (handles) {\n      handles.forEach(handle => {\n        this.stopHandleListening(handle);\n        handle.remove();\n      });\n    }\n  }\n\n  renderHandles() {\n    const vertices = this.vertices;\n\n    for (let i = 0, l = vertices.length; i < l; i += 1) {\n      const vertex = vertices[i];\n      const createHandle = this.options.createHandle;\n      const processHandle = this.options.processHandle;\n      const handle = createHandle({\n        index: i,\n        graph: this.graph,\n        guard: evt => this.guard(evt),\n        attrs: this.options.attrs || {}\n      });\n\n      if (processHandle) {\n        processHandle(handle);\n      }\n\n      this.graph.hook.onToolItemCreated({\n        name: 'vertices',\n        cell: this.cell,\n        view: this.cellView,\n        tool: handle\n      });\n      handle.updatePosition(vertex.x, vertex.y);\n      this.stamp(handle.container);\n      this.container.appendChild(handle.container);\n      this.handles.push(handle);\n      this.startHandleListening(handle);\n    }\n  }\n\n  updateHandles() {\n    const vertices = this.vertices;\n\n    for (let i = 0, l = vertices.length; i < l; i += 1) {\n      const vertex = vertices[i];\n      const handle = this.handles[i];\n\n      if (handle) {\n        handle.updatePosition(vertex.x, vertex.y);\n      }\n    }\n  }\n\n  updatePath() {\n    const connection = this.childNodes.connection;\n\n    if (connection) {\n      connection.setAttribute('d', this.cellView.getConnectionPathData());\n    }\n  }\n\n  startHandleListening(handle) {\n    const edgeView = this.cellView;\n\n    if (edgeView.can('vertexMovable')) {\n      handle.on('change', this.onHandleChange, this);\n      handle.on('changing', this.onHandleChanging, this);\n      handle.on('changed', this.onHandleChanged, this);\n    }\n\n    if (edgeView.can('vertexDeletable')) {\n      handle.on('remove', this.onHandleRemove, this);\n    }\n  }\n\n  stopHandleListening(handle) {\n    const edgeView = this.cellView;\n\n    if (edgeView.can('vertexMovable')) {\n      handle.off('change', this.onHandleChange, this);\n      handle.off('changing', this.onHandleChanging, this);\n      handle.off('changed', this.onHandleChanged, this);\n    }\n\n    if (edgeView.can('vertexDeletable')) {\n      handle.off('remove', this.onHandleRemove, this);\n    }\n  }\n\n  getNeighborPoints(index) {\n    const edgeView = this.cellView;\n    const vertices = this.vertices;\n    const prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor;\n    const next = index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor;\n    return {\n      prev: Point.create(prev),\n      next: Point.create(next)\n    };\n  }\n\n  getMouseEventArgs(evt) {\n    const e = this.normalizeEvent(evt);\n    const {\n      x,\n      y\n    } = this.graph.snapToGrid(e.clientX, e.clientY);\n    return {\n      e,\n      x,\n      y\n    };\n  }\n\n  onHandleChange(_ref) {\n    let {\n      e\n    } = _ref;\n    this.focus();\n    const edgeView = this.cellView;\n    edgeView.cell.startBatch('move-vertex', {\n      ui: true,\n      toolId: this.cid\n    });\n\n    if (!this.options.stopPropagation) {\n      const {\n        e: evt,\n        x,\n        y\n      } = this.getMouseEventArgs(e);\n      edgeView.notifyMouseDown(evt, x, y);\n    }\n  }\n\n  onHandleChanging(_ref2) {\n    let {\n      handle,\n      e\n    } = _ref2;\n    const edgeView = this.cellView;\n    const index = handle.options.index;\n    const {\n      e: evt,\n      x,\n      y\n    } = this.getMouseEventArgs(e);\n    const vertex = {\n      x,\n      y\n    };\n    this.snapVertex(vertex, index);\n    edgeView.cell.setVertexAt(index, vertex, {\n      ui: true,\n      toolId: this.cid\n    });\n    handle.updatePosition(vertex.x, vertex.y);\n\n    if (!this.options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, x, y);\n    }\n  }\n\n  onHandleChanged(_ref3) {\n    let {\n      e\n    } = _ref3;\n    const options = this.options;\n    const edgeView = this.cellView;\n\n    if (options.addable) {\n      this.updatePath();\n    }\n\n    if (!options.removeRedundancies) {\n      return;\n    }\n\n    const verticesRemoved = edgeView.removeRedundantLinearVertices({\n      ui: true,\n      toolId: this.cid\n    });\n\n    if (verticesRemoved) {\n      this.render();\n    }\n\n    this.blur();\n    edgeView.cell.stopBatch('move-vertex', {\n      ui: true,\n      toolId: this.cid\n    });\n\n    if (this.eventData(e).vertexAdded) {\n      edgeView.cell.stopBatch('add-vertex', {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n\n    const {\n      e: evt,\n      x,\n      y\n    } = this.getMouseEventArgs(e);\n\n    if (!this.options.stopPropagation) {\n      edgeView.notifyMouseUp(evt, x, y);\n    }\n\n    edgeView.checkMouseleave(evt);\n    options.onChanged && options.onChanged({\n      edge: edgeView.cell,\n      edgeView\n    });\n  }\n\n  snapVertex(vertex, index) {\n    const snapRadius = this.options.snapRadius || 0;\n\n    if (snapRadius > 0) {\n      const neighbors = this.getNeighborPoints(index);\n      const prev = neighbors.prev;\n      const next = neighbors.next;\n\n      if (Math.abs(vertex.x - prev.x) < snapRadius) {\n        vertex.x = prev.x;\n      } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n        vertex.x = next.x;\n      }\n\n      if (Math.abs(vertex.y - prev.y) < snapRadius) {\n        vertex.y = neighbors.prev.y;\n      } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n        vertex.y = next.y;\n      }\n    }\n  }\n\n  onHandleRemove(_ref4) {\n    let {\n      handle,\n      e\n    } = _ref4;\n\n    if (this.options.removable) {\n      const index = handle.options.index;\n      const edgeView = this.cellView;\n      edgeView.cell.removeVertexAt(index, {\n        ui: true\n      });\n\n      if (this.options.addable) {\n        this.updatePath();\n      }\n\n      edgeView.checkMouseleave(this.normalizeEvent(e));\n    }\n  }\n\n  onPathMouseDown(evt) {\n    const edgeView = this.cellView;\n\n    if (this.guard(evt) || !this.options.addable || !edgeView.can('vertexAddable')) {\n      return;\n    }\n\n    evt.stopPropagation();\n    evt.preventDefault();\n    const e = this.normalizeEvent(evt);\n    const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();\n    edgeView.cell.startBatch('add-vertex', {\n      ui: true,\n      toolId: this.cid\n    });\n    const index = edgeView.getVertexIndex(vertex.x, vertex.y);\n    this.snapVertex(vertex, index);\n    edgeView.cell.insertVertex(vertex, index, {\n      ui: true,\n      toolId: this.cid\n    });\n    this.render();\n    const handle = this.handles[index];\n    this.eventData(e, {\n      vertexAdded: true\n    });\n    handle.onMouseDown(e);\n  }\n\n  onRemove() {\n    this.resetHandles();\n  }\n\n}\n\n(function (Vertices) {\n  class Handle extends View {\n    constructor(options) {\n      super();\n      this.options = options;\n      this.render();\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown',\n        dblclick: 'onDoubleClick'\n      });\n    }\n\n    get graph() {\n      return this.options.graph;\n    }\n\n    render() {\n      this.container = View.createElement('circle', true);\n      const attrs = this.options.attrs;\n\n      if (typeof attrs === 'function') {\n        const defaults = Vertices.getDefaults();\n        this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n      } else {\n        this.setAttrs(attrs);\n      }\n\n      this.addClass(this.prefixClassName('edge-tool-vertex'));\n    }\n\n    updatePosition(x, y) {\n      this.setAttrs({\n        cx: x,\n        cy: y\n      });\n    }\n\n    onMouseDown(evt) {\n      if (this.options.guard(evt)) {\n        return;\n      }\n\n      evt.stopPropagation();\n      evt.preventDefault();\n      this.graph.view.undelegateEvents();\n      this.delegateDocumentEvents({\n        mousemove: 'onMouseMove',\n        touchmove: 'onMouseMove',\n        mouseup: 'onMouseUp',\n        touchend: 'onMouseUp',\n        touchcancel: 'onMouseUp'\n      }, evt.data);\n      this.emit('change', {\n        e: evt,\n        handle: this\n      });\n    }\n\n    onMouseMove(evt) {\n      this.emit('changing', {\n        e: evt,\n        handle: this\n      });\n    }\n\n    onMouseUp(evt) {\n      this.emit('changed', {\n        e: evt,\n        handle: this\n      });\n      this.undelegateDocumentEvents();\n      this.graph.view.delegateEvents();\n    }\n\n    onDoubleClick(evt) {\n      this.emit('remove', {\n        e: evt,\n        handle: this\n      });\n    }\n\n  }\n\n  Vertices.Handle = Handle;\n})(Vertices || (Vertices = {}));\n\n(function (Vertices) {\n  const pathClassName = Util.prefix('edge-tool-vertex-path');\n  Vertices.config({\n    name: 'vertices',\n    snapRadius: 20,\n    addable: true,\n    removable: true,\n    removeRedundancies: true,\n    stopPropagation: true,\n    attrs: {\n      r: 6,\n      fill: '#333',\n      stroke: '#fff',\n      cursor: 'move',\n      'stroke-width': 2\n    },\n    createHandle: options => new Vertices.Handle(options),\n    markup: [{\n      tagName: 'path',\n      selector: 'connection',\n      className: pathClassName,\n      attrs: {\n        fill: 'none',\n        stroke: 'transparent',\n        'stroke-width': 10,\n        cursor: 'pointer'\n      }\n    }],\n    events: {\n      [`mousedown .${pathClassName}`]: 'onPathMouseDown',\n      [`touchstart .${pathClassName}`]: 'onPathMouseDown'\n    }\n  });\n})(Vertices || (Vertices = {}));","map":null,"metadata":{},"sourceType":"module"}