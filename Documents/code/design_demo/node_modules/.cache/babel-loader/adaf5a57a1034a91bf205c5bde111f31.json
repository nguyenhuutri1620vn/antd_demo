{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { ObjectExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Background } from '../registry';\nimport { Base } from './base';\nexport class BackgroundManager extends Base {\n  get elem() {\n    return this.view.background;\n  }\n\n  init() {\n    this.startListening();\n\n    if (this.options.background) {\n      this.draw(this.options.background);\n    }\n  }\n\n  startListening() {\n    this.graph.on('scale', this.update, this);\n    this.graph.on('translate', this.update, this);\n  }\n\n  stopListening() {\n    this.graph.off('scale', this.update, this);\n    this.graph.off('translate', this.update, this);\n  }\n\n  updateBackgroundImage() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let backgroundSize = options.size || 'auto auto';\n    let backgroundPosition = options.position || 'center';\n    const scale = this.graph.transform.getScale();\n    const ts = this.graph.translate(); // backgroundPosition\n\n    if (typeof backgroundPosition === 'object') {\n      const x = ts.tx + scale.sx * (backgroundPosition.x || 0);\n      const y = ts.ty + scale.sy * (backgroundPosition.y || 0);\n      backgroundPosition = `${x}px ${y}px`;\n    } // backgroundSize\n\n\n    if (typeof backgroundSize === 'object') {\n      backgroundSize = Rectangle.fromSize(backgroundSize).scale(scale.sx, scale.sy);\n      backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`;\n    }\n\n    this.elem.style.backgroundSize = backgroundSize;\n    this.elem.style.backgroundPosition = backgroundPosition;\n  }\n\n  drawBackgroundImage(img) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!(img instanceof HTMLImageElement)) {\n      this.elem.style.backgroundImage = '';\n      return;\n    } // draw multiple times to show the last image\n\n\n    const cache = this.optionsCache;\n\n    if (cache && cache.image !== options.image) {\n      return;\n    }\n\n    let uri;\n    const opacity = options.opacity;\n    const backgroundSize = options.size;\n    let backgroundRepeat = options.repeat || 'no-repeat';\n    const pattern = Background.registry.get(backgroundRepeat);\n\n    if (typeof pattern === 'function') {\n      const quality = options.quality || 1;\n      img.width *= quality;\n      img.height *= quality;\n      const canvas = pattern(img, options);\n\n      if (!(canvas instanceof HTMLCanvasElement)) {\n        throw new Error('Background pattern must return an HTML Canvas instance');\n      }\n\n      uri = canvas.toDataURL('image/png'); // `repeat` was changed in pattern function\n\n      if (options.repeat && backgroundRepeat !== options.repeat) {\n        backgroundRepeat = options.repeat;\n      } else {\n        backgroundRepeat = 'repeat';\n      }\n\n      if (typeof backgroundSize === 'object') {\n        // recalculate the tile size if an object passed in\n        backgroundSize.width *= canvas.width / img.width;\n        backgroundSize.height *= canvas.height / img.height;\n      } else if (backgroundSize === undefined) {\n        // calcule the tile size if no provided\n        options.size = {\n          width: canvas.width / quality,\n          height: canvas.height / quality\n        };\n      }\n    } else {\n      uri = img.src;\n\n      if (backgroundSize === undefined) {\n        options.size = {\n          width: img.width,\n          height: img.height\n        };\n      }\n    }\n\n    if (cache != null && typeof options.size === 'object' && options.image === cache.image && options.repeat === cache.repeat && options.quality === cache.quality) {\n      cache.size = ObjectExt.clone(options.size);\n    }\n\n    const style = this.elem.style;\n    style.backgroundImage = `url(${uri})`;\n    style.backgroundRepeat = backgroundRepeat;\n    style.opacity = opacity == null || opacity >= 1 ? '' : `${opacity}`;\n    this.updateBackgroundImage(options);\n  }\n\n  updateBackgroundColor(color) {\n    this.elem.style.backgroundColor = color || '';\n  }\n\n  updateBackgroundOptions(options) {\n    this.graph.options.background = options;\n  }\n\n  update() {\n    if (this.optionsCache) {\n      this.updateBackgroundImage(this.optionsCache);\n    }\n  }\n\n  draw(options) {\n    const opts = options || {};\n    this.updateBackgroundOptions(options);\n    this.updateBackgroundColor(opts.color);\n\n    if (opts.image) {\n      this.optionsCache = ObjectExt.clone(opts);\n      const img = document.createElement('img');\n\n      img.onload = () => this.drawBackgroundImage(img, options);\n\n      img.setAttribute('crossorigin', 'anonymous');\n      img.src = opts.image;\n    } else {\n      this.drawBackgroundImage(null);\n      this.optionsCache = null;\n    }\n  }\n\n  clear() {\n    this.draw();\n  }\n\n  dispose() {\n    this.clear();\n    this.stopListening();\n  }\n\n}\n\n__decorate([Base.dispose()], BackgroundManager.prototype, \"dispose\", null);","map":null,"metadata":{},"sourceType":"module"}