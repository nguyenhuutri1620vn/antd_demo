{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport React from 'react';\nimport uniqBy from 'lodash/uniqBy';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { // utils\nDisposable, // context\nuseXFlowApp, // models\nMODELS, createComponentModel, // commands\nXFlowModelCommands } from '@antv/xflow-core';\nimport { TREE_ROOT_ID } from './constants';\nexport var NsNodeTreePanelModel;\n\n(function (NsNodeTreePanelModel) {\n  NsNodeTreePanelModel.id = 'TREE_PANEL_MODEL';\n\n  NsNodeTreePanelModel.useModel = model => __awaiter(this, void 0, void 0, function* () {\n    return model.awaitModel(NsNodeTreePanelModel.id);\n  });\n})(NsNodeTreePanelModel || (NsNodeTreePanelModel = {}));\n/** 方便其他组件执行Command改变Panel内部状态 */\n\n\nexport const executeNodeDndTreeCommand = (cmds, updateModel) => {\n  cmds.executeCommand(XFlowModelCommands.UPDATE_MODEL.id, {\n    getModel: modelService => __awaiter(void 0, void 0, void 0, function* () {\n      return NsNodeTreePanelModel.useModel(modelService);\n    }),\n    updateModel: updateModel\n  });\n};\nexport const useTreePanelData = props => {\n  const {\n    treeDataService,\n    searchService\n  } = props;\n  const {\n    modelService\n  } = useXFlowApp();\n  /** 使用model */\n\n  const [state, setState, panelModel] = createComponentModel({\n    treeData: [],\n    searchList: [],\n    treeNodeList: [],\n    expandedKeys: [],\n    defaultExpandAll: false,\n    keyword: ''\n  });\n  /** 注册成为全局状态，方便其他组件联动 */\n\n  React.useEffect(() => {\n    if (modelService.findDeferredModel(NsNodeTreePanelModel.id)) {\n      return;\n    }\n\n    modelService.registerModel({\n      id: NsNodeTreePanelModel.id,\n      modelFactory: () => panelModel,\n      watchChange: self => __awaiter(void 0, void 0, void 0, function* () {\n        const graphMetaModel = yield MODELS.GRAPH_META.getModel(modelService); //useContext(MODELS.GRAPH_META.id)\n\n        const fetch = meta => __awaiter(void 0, void 0, void 0, function* () {\n          const listData = yield treeDataService(meta, modelService);\n          const {\n            treeData,\n            rootNodes\n          } = NodeList2Tree(listData);\n          const currentState = yield self.getValidValue(); // 设置默认展开的keys\n\n          const expandedKeys = currentState.expandedKeys.length > 0 ? currentState.expandedKeys : rootNodes.map(i => i.id);\n          return {\n            listData,\n            treeData,\n            expandedKeys\n          };\n        });\n\n        const graphMetaDisposable = graphMetaModel.watch(meta => __awaiter(void 0, void 0, void 0, function* () {\n          const data = yield fetch(meta);\n          self.setValue({\n            treeNodeList: data.listData,\n            treeData: data.treeData,\n            expandedKeys: data.expandedKeys,\n            defaultExpandAll: false,\n            keyword: '',\n            searchList: []\n          });\n        }));\n        return Disposable.create(() => {\n          graphMetaDisposable.dispose();\n        });\n      })\n    });\n    /* eslint-disable-next-line  */\n  }, []);\n  /** 折叠文件夹 */\n\n  const onFolderExpand = React.useCallback(expandedKeys => {\n    setState(modelState => {\n      modelState.expandedKeys = expandedKeys;\n    });\n  }, [setState]);\n  /** 搜索 */\n\n  const onKeywordChange = React.useCallback(keyword => __awaiter(void 0, void 0, void 0, function* () {\n    if (!searchService) {\n      return console.warn('searchService is not defined');\n    }\n\n    if (keyword) {\n      const list = yield searchService(state.treeNodeList, keyword);\n      setState(modelState => {\n        modelState.keyword = keyword;\n        modelState.searchList = list;\n      });\n    } else {\n      setState(modelState => {\n        modelState.keyword = '';\n        modelState.searchList = [];\n      });\n    }\n  }), // eslint-disable-next-line\n  [searchService, state.treeNodeList]);\n  return {\n    state,\n    setState,\n    onKeywordChange,\n    onFolderExpand\n  };\n}; // 将list数据转换为树\n\nexport function NodeList2Tree() {\n  let treeNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  const getGroupByIdMap = list => {\n    const uniqList = uniqBy(list, 'id');\n    const groups = uniqList.reduce((map, node) => {\n      const parentId = node.parentId || TREE_ROOT_ID;\n\n      if (!map.has(parentId)) {\n        map.set(parentId, []);\n      }\n\n      const group = map.get(parentId);\n      group.push(node);\n      return map;\n    }, new Map());\n    return groups;\n  };\n\n  const groupMap = getGroupByIdMap(cloneDeep(treeNodes));\n\n  function iterator(nodes, groupMapArgs) {\n    return nodes.map(node => {\n      if (groupMapArgs.has(node.id)) {\n        const children = groupMapArgs.get(node.id);\n        node.key = node.id;\n        node.isDirectory = true;\n        node.children = iterator(children, groupMapArgs) || [];\n      } else {\n        node.isLeaf = true;\n      }\n\n      return node;\n    });\n  }\n\n  const rootNodes = groupMap.get(TREE_ROOT_ID) || [];\n  const treeData = iterator(rootNodes, groupMap);\n  return {\n    treeData,\n    rootNodes\n  };\n}","map":null,"metadata":{},"sourceType":"module"}