{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { AbstractLayout } from '@antv/g6-core';\nimport { Layout } from '../../layout';\nimport { LayoutWorker } from '../../layout/worker/layout.worker';\nimport { LAYOUT_MESSAGE } from '../../layout/worker/layoutConst';\nimport { gpuDetector } from '../../util/gpu';\nimport { mix, clone } from '@antv/util'; // eslint-disable-next-line @typescript-eslint/no-implied-eval\n\nvar mockRaf = function mockRaf(cb) {\n  return setTimeout(cb, 16);\n};\n\nvar mockCaf = function mockCaf(reqId) {\n  return clearTimeout(reqId);\n};\n\nvar helper = {\n  // pollyfill\n  requestAnimationFrame: function requestAnimationFrame(callback) {\n    var fn = typeof window !== 'undefined' ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || mockRaf : mockRaf;\n    return fn(callback);\n  },\n  cancelAnimationFrame: function cancelAnimationFrame(requestId) {\n    var fn = typeof window !== 'undefined' ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || mockCaf : mockCaf;\n    return fn(requestId);\n  }\n};\nvar GPU_LAYOUT_NAMES = ['fruchterman', 'gForce'];\nvar LAYOUT_PIPES_ADJUST_NAMES = ['force', 'grid', 'circular'];\n\nvar LayoutController =\n/** @class */\nfunction (_super) {\n  __extends(LayoutController, _super); // the configurations of the layout\n  // private layoutCfg: any; // LayoutOptions\n  // the type name of the layout\n  // private layoutType: string;\n  // private data: GraphData;\n  // private layoutMethods: typeof Layout;\n\n\n  function LayoutController(graph) {\n    var _this = _super.call(this, graph) || this;\n\n    _this.graph = graph;\n    _this.layoutCfg = graph.get('layout') || {};\n    _this.layoutType = _this.getLayoutType();\n    _this.worker = null;\n    _this.workerData = {};\n\n    _this.initLayout();\n\n    return _this;\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  LayoutController.prototype.initLayout = function () {// no data before rendering\n  }; // get layout worker and create one if not exists\n\n\n  LayoutController.prototype.getWorker = function () {\n    if (this.worker) {\n      return this.worker;\n    }\n\n    if (typeof Worker === 'undefined') {\n      // 如果当前浏览器不支持 web worker，则不使用 web worker\n      console.warn('Web worker is not supported in current browser.');\n      this.worker = null;\n    } else {\n      this.worker = LayoutWorker(this.layoutCfg.workerScriptURL);\n    }\n\n    return this.worker;\n  }; // stop layout worker\n\n\n  LayoutController.prototype.stopWorker = function () {\n    var workerData = this.workerData;\n\n    if (!this.worker) {\n      return;\n    }\n\n    this.worker.terminate();\n    this.worker = null; // 重新开始新的布局之前，先取消之前布局的requestAnimationFrame。\n\n    if (workerData.requestId) {\n      helper.cancelAnimationFrame(workerData.requestId);\n      workerData.requestId = null;\n    }\n\n    if (workerData.requestId2) {\n      helper.cancelAnimationFrame(workerData.requestId2);\n      workerData.requestId2 = null;\n    }\n  };\n\n  LayoutController.prototype.execLayoutMethod = function (layoutCfg, order) {\n    var _this = this;\n\n    return new Promise(function (reslove, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var graph, layoutType, isForce, onTick_1, tick, enableTick, layoutMethod, onTick_2, tick, layoutData;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              graph = this.graph;\n              if (!graph || graph.get('destroyed')) return [2\n              /*return*/\n              ];\n              layoutType = layoutCfg.type; // 每个布局方法都需要注册\n\n              layoutCfg.onLayoutEnd = function () {\n                graph.emit('aftersublayout', {\n                  type: layoutType\n                });\n                reslove();\n              }; // 若用户指定开启 gpu，且当前浏览器支持 webgl，且该算法存在 GPU 版本（目前仅支持 fruchterman 和 gForce），使用 gpu 版本的布局\n\n\n              if (layoutType && this.isGPU) {\n                if (!this.hasGPUVersion(layoutType)) {\n                  console.warn(\"The '\".concat(layoutType, \"' layout does not support GPU calculation for now, it will run in CPU.\"));\n                } else {\n                  layoutType = \"\".concat(layoutType, \"-gpu\");\n                }\n              }\n\n              isForce = layoutType === 'force' || layoutType === 'g6force' || layoutType === 'gForce';\n\n              if (isForce) {\n                onTick_1 = layoutCfg.onTick;\n\n                tick = function tick() {\n                  if (onTick_1) {\n                    onTick_1();\n                  }\n\n                  graph.refreshPositions();\n                };\n\n                layoutCfg.tick = tick;\n              } else if (layoutCfg.type === 'comboForce') {\n                layoutCfg.comboTrees = graph.get('comboTrees');\n              }\n\n              enableTick = false;\n\n              try {\n                layoutMethod = new Layout[layoutType](layoutCfg);\n              } catch (e) {\n                console.warn(\"The layout method: '\".concat(layoutType, \"' does not exist! Please specify it first.\"));\n                reject();\n              } // 是否需要迭代的方式完成布局。这里是来自布局对象的实例属性，是由布局的定义者在布局类定义的。\n\n\n              enableTick = layoutMethod.enableTick;\n\n              if (enableTick) {\n                onTick_2 = layoutCfg.onTick;\n\n                tick = function tick() {\n                  if (onTick_2) {\n                    onTick_2();\n                  }\n\n                  graph.refreshPositions();\n                };\n\n                layoutMethod.tick = tick;\n              }\n\n              layoutData = this.filterLayoutData(this.data, layoutCfg);\n              addLayoutOrder(layoutData, order);\n              layoutMethod.init(layoutData); // 若存在节点没有位置信息，且没有设置 layout，在 initPositions 中 random 给出了所有节点的位置，不需要再次执行 random 布局\n              // 所有节点都有位置信息，且指定了 layout，则执行布局（代表不是第一次进行布局）\n\n              graph.emit('beforesublayout', {\n                type: layoutType\n              });\n              return [4\n              /*yield*/\n              , layoutMethod.execute()];\n\n            case 1:\n              _a.sent();\n\n              if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd) layoutCfg.onLayoutEnd();\n              this.layoutMethods[order] = layoutMethod;\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n\n  LayoutController.prototype.updateLayoutMethod = function (layoutMethod, layoutCfg) {\n    var _this = this;\n\n    return new Promise(function (reslove, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var graph, layoutType, layoutData;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              graph = this.graph;\n              layoutType = layoutCfg === null || layoutCfg === void 0 ? void 0 : layoutCfg.type; // 每个布局方法都需要注册\n\n              layoutCfg.onLayoutEnd = function () {\n                graph.emit('aftersublayout', {\n                  type: layoutType\n                });\n                reslove();\n              };\n\n              layoutData = this.filterLayoutData(this.data, layoutCfg);\n              layoutMethod.init(layoutData);\n              layoutMethod.updateCfg(layoutCfg);\n              graph.emit('beforesublayout', {\n                type: layoutType\n              });\n              return [4\n              /*yield*/\n              , layoutMethod.execute()];\n\n            case 1:\n              _a.sent();\n\n              if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd) layoutCfg.onLayoutEnd();\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * @param {function} success callback\n   * @return {boolean} 是否使用web worker布局\n   */\n\n\n  LayoutController.prototype.layout = function (success) {\n    var _this = this;\n\n    var graph = this.graph;\n    this.data = this.setDataFromGraph();\n    var _a = this.data,\n        nodes = _a.nodes,\n        hiddenNodes = _a.hiddenNodes;\n\n    if (!nodes) {\n      return false;\n    }\n\n    var width = graph.get('width');\n    var height = graph.get('height');\n    var layoutCfg = {};\n    Object.assign(layoutCfg, {\n      width: width,\n      height: height,\n      center: [width / 2, height / 2]\n    }, this.layoutCfg);\n    this.layoutCfg = layoutCfg;\n    this.destoryLayoutMethods();\n    graph.emit('beforelayout');\n    this.initPositions(layoutCfg.center, nodes); // init hidden nodes\n\n    this.initPositions(layoutCfg.center, hiddenNodes); // 防止用户直接用 -gpu 结尾指定布局\n\n    var layoutType = layoutCfg.type;\n\n    if (layoutType && layoutType.split('-')[1] === 'gpu') {\n      layoutType = layoutType.split('-')[0];\n      layoutCfg.gpuEnabled = true;\n    } // 若用户指定开启 gpu，且当前浏览器支持 webgl，且该算法存在 GPU 版本（目前仅支持 fruchterman 和 gForce），使用 gpu 版本的布局\n\n\n    var enableGPU = false;\n\n    if (layoutCfg.gpuEnabled) {\n      enableGPU = true; // 打开下面语句将会导致 webworker 报找不到 window\n\n      if (!gpuDetector().webgl) {\n        console.warn(\"Your browser does not support webGL or GPGPU. The layout will run in CPU.\");\n        enableGPU = false;\n      }\n    }\n\n    this.isGPU = enableGPU; // 在 onAllLayoutEnd 中执行用户自定义 onLayoutEnd，触发 afterlayout、更新节点位置、fitView/fitCenter、触发 afterrender\n\n    var onLayoutEnd = layoutCfg.onLayoutEnd,\n        layoutEndFormatted = layoutCfg.layoutEndFormatted,\n        adjust = layoutCfg.adjust;\n\n    if (!layoutEndFormatted) {\n      layoutCfg.layoutEndFormatted = true;\n\n      layoutCfg.onAllLayoutEnd = function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                // 执行用户自定义 onLayoutEnd\n                if (onLayoutEnd) {\n                  onLayoutEnd();\n                } // 更新节点位置\n\n\n                this.refreshLayout();\n                if (!(adjust && layoutCfg.pipes)) return [3\n                /*break*/\n                , 2];\n                return [4\n                /*yield*/\n                , this.adjustPipesBox(this.data, adjust)];\n\n              case 1:\n                _a.sent();\n\n                this.refreshLayout();\n                _a.label = 2;\n\n              case 2:\n                // 触发 afterlayout\n                graph.emit('afterlayout');\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      };\n    }\n\n    this.stopWorker();\n\n    if (layoutCfg.workerEnabled && this.layoutWithWorker(this.data)) {\n      // 如果启用布局web worker并且浏览器支持web worker，用web worker布局。否则回退到不用web worker布局。\n      return true;\n    }\n\n    var start = Promise.resolve();\n\n    if (layoutCfg.type) {\n      start = start.then(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , this.execLayoutMethod(layoutCfg, 0)];\n\n              case 1:\n                return [2\n                /*return*/\n                , _a.sent()];\n            }\n          });\n        });\n      });\n    } else if (layoutCfg.pipes) {\n      layoutCfg.pipes.forEach(function (cfg, index) {\n        start = start.then(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/\n                  , this.execLayoutMethod(cfg, index)];\n\n                case 1:\n                  return [2\n                  /*return*/\n                  , _a.sent()];\n              }\n            });\n          });\n        });\n      });\n    } // 最后统一在外部调用onAllLayoutEnd\n\n\n    start.then(function () {\n      if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd(); // 在执行 execute 后立即执行 success，且在 timeBar 中有 throttle，可以防止 timeBar 监听 afterrender 进行 changeData 后 layout，从而死循环\n      // 对于 force 一类布局完成后的 fitView 需要用户自己在 onLayoutEnd 中配置\n\n      if (success) success();\n    }).catch(function (error) {\n      console.warn('graph layout failed,', error);\n    });\n    return false;\n  };\n  /**\n   * layout with web worker\n   * @param {object} data graph data\n   * @return {boolean} 是否支持web worker\n   */\n\n\n  LayoutController.prototype.layoutWithWorker = function (data) {\n    var _this = this;\n\n    var _a = this,\n        layoutCfg = _a.layoutCfg,\n        graph = _a.graph;\n\n    var worker = this.getWorker(); // 每次worker message event handler调用之间的共享数据，会被修改。\n\n    var workerData = this.workerData;\n\n    if (!worker) {\n      return false;\n    }\n\n    workerData.requestId = null;\n    workerData.requestId2 = null;\n    workerData.currentTick = null;\n    workerData.currentTickData = null;\n    graph.emit('beforelayout');\n    var start = Promise.resolve();\n\n    if (layoutCfg.type) {\n      start = start.then(function () {\n        return _this.runWebworker(worker, data, layoutCfg);\n      });\n    } else if (layoutCfg.pipes) {\n      var _loop_1 = function _loop_1(cfg) {\n        start = start.then(function () {\n          return _this.runWebworker(worker, data, cfg);\n        });\n      };\n\n      for (var _i = 0, _b = layoutCfg.pipes; _i < _b.length; _i++) {\n        var cfg = _b[_i];\n\n        _loop_1(cfg);\n      }\n    } // 最后统一在外部调用onAllLayoutEnd\n\n\n    start.then(function () {\n      if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd();\n    }).catch(function (error) {\n      console.error('layout failed', error);\n    });\n    return true;\n  };\n\n  LayoutController.prototype.runWebworker = function (worker, allData, layoutCfg) {\n    var _this = this;\n\n    var isGPU = this.isGPU;\n    var data = this.filterLayoutData(allData, layoutCfg);\n    var nodes = data.nodes,\n        edges = data.edges;\n    var offScreenCanvas = document.createElement('canvas');\n    var gpuWorkerAbility = isGPU && typeof window !== 'undefined' && // eslint-disable-next-line @typescript-eslint/dot-notation\n    window.navigator && !navigator[\"gpu\"] && // WebGPU 还不支持 OffscreenCanvas\n    'OffscreenCanvas' in window && 'transferControlToOffscreen' in offScreenCanvas; // NOTE: postMessage的message参数里面不能包含函数，否则postMessage会报错，\n    // 例如：'function could not be cloned'。\n    // 详情参考：https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    // 所以这里需要把过滤layoutCfg里的函数字段过滤掉。\n\n    var filteredLayoutCfg = filterObject(layoutCfg, function (value) {\n      return typeof value !== 'function';\n    });\n\n    if (!gpuWorkerAbility) {\n      worker.postMessage({\n        type: LAYOUT_MESSAGE.RUN,\n        nodes: nodes,\n        edges: edges,\n        layoutCfg: filteredLayoutCfg\n      });\n    } else {\n      var offscreen = offScreenCanvas.transferControlToOffscreen(); // filteredLayoutCfg.canvas = offscreen;\n\n      filteredLayoutCfg.type = \"\".concat(filteredLayoutCfg.type, \"-gpu\");\n      worker.postMessage({\n        type: LAYOUT_MESSAGE.GPURUN,\n        nodes: nodes,\n        edges: edges,\n        layoutCfg: filteredLayoutCfg,\n        canvas: offscreen\n      }, [offscreen]);\n    }\n\n    return new Promise(function (reslove, reject) {\n      worker.onmessage = function (event) {\n        _this.handleWorkerMessage(reslove, reject, event, data, layoutCfg);\n      };\n    });\n  }; // success callback will be called when updating graph positions for the first time.\n\n\n  LayoutController.prototype.handleWorkerMessage = function (reslove, reject, event, data, layoutCfg) {\n    var _a = this,\n        graph = _a.graph,\n        workerData = _a.workerData;\n\n    var eventData = event.data;\n    var type = eventData.type;\n\n    var onTick = function onTick() {\n      if (layoutCfg.onTick) {\n        layoutCfg.onTick();\n      }\n    };\n\n    switch (type) {\n      case LAYOUT_MESSAGE.TICK:\n        workerData.currentTick = eventData.currentTick;\n        workerData.currentTickData = eventData;\n\n        if (!workerData.requestId) {\n          workerData.requestId = helper.requestAnimationFrame(function requestId() {\n            updateLayoutPosition(data, eventData);\n            graph.refreshPositions();\n            onTick();\n\n            if (eventData.currentTick === eventData.totalTicks) {\n              // 如果是最后一次tick\n              reslove();\n            } else if (workerData.currentTick === eventData.totalTicks) {\n              // 注意这里workerData.currentTick可能已经不再是前面赋值时候的值了，\n              // 因为在requestAnimationFrame等待时间里，可能产生新的tick。\n              // 如果当前tick不是最后一次tick，并且所有的tick消息都已发出来了，那么需要用最后一次tick的数据再刷新一次。\n              workerData.requestId2 = helper.requestAnimationFrame(function requestId2() {\n                updateLayoutPosition(data, workerData.currentTickData);\n                graph.refreshPositions();\n                workerData.requestId2 = null;\n                onTick();\n                reslove();\n              });\n            }\n\n            workerData.requestId = null;\n          });\n        }\n\n        break;\n\n      case LAYOUT_MESSAGE.END:\n        // 如果没有tick消息（非力导布局）\n        if (workerData.currentTick == null) {\n          updateLayoutPosition(data, eventData);\n          reslove();\n        }\n\n        break;\n\n      case LAYOUT_MESSAGE.GPUEND:\n        // 如果没有tick消息（非力导布局）\n        if (workerData.currentTick == null) {\n          updateGPUWorkerLayoutPosition(data, eventData);\n          reslove();\n        }\n\n        break;\n\n      case LAYOUT_MESSAGE.ERROR:\n        console.warn('Web-Worker layout error!', eventData.message);\n        reject();\n        break;\n\n      default:\n        reject();\n        break;\n    }\n  }; // 更新布局参数\n\n\n  LayoutController.prototype.updateLayoutCfg = function (cfg) {\n    var _this = this;\n\n    var _a = this,\n        graph = _a.graph,\n        layoutMethods = _a.layoutMethods;\n\n    var layoutCfg = mix({}, this.layoutCfg, cfg);\n    this.layoutCfg = layoutCfg;\n\n    if (!(layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length)) {\n      this.layout();\n      return;\n    }\n\n    this.data = this.setDataFromGraph();\n    this.stopWorker();\n\n    if (cfg.workerEnabled && this.layoutWithWorker(this.data)) {\n      // 如果启用布局web worker并且浏览器支持web worker，用web worker布局。否则回退到不用web worker布局。\n      return;\n    }\n\n    graph.emit('beforelayout');\n    var start = Promise.resolve();\n\n    if (layoutMethods.length === 1) {\n      start = start.then(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , this.updateLayoutMethod(layoutMethods[0], layoutCfg)];\n\n              case 1:\n                return [2\n                /*return*/\n                , _a.sent()];\n            }\n          });\n        });\n      });\n    } else {\n      layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function (layoutMethod, index) {\n        var currentCfg = layoutCfg.pipes[index];\n        start = start.then(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/\n                  , this.updateLayoutMethod(layoutMethod, currentCfg)];\n\n                case 1:\n                  return [2\n                  /*return*/\n                  , _a.sent()];\n              }\n            });\n          });\n        });\n      });\n    }\n\n    start.then(function () {\n      if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd();\n    }).catch(function (error) {\n      console.warn('layout failed', error);\n    });\n  };\n\n  LayoutController.prototype.adjustPipesBox = function (data, adjust) {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      var nodes = data.nodes;\n\n      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {\n        resolve();\n      }\n\n      if (!LAYOUT_PIPES_ADJUST_NAMES.includes(adjust)) {\n        console.warn(\"The adjust type \".concat(adjust, \" is not supported yet, please assign it with 'force', 'grid', or 'circular'.\"));\n        resolve();\n      }\n\n      var layoutCfg = {\n        center: _this.layoutCfg.center,\n        nodeSize: function nodeSize(d) {\n          return Math.max(d.height, d.width);\n        },\n        preventOverlap: true,\n        onLayoutEnd: function onLayoutEnd() {}\n      }; // 计算出大单元\n\n      var _a = _this.getLayoutBBox(nodes),\n          groupNodes = _a.groupNodes,\n          layoutNodes = _a.layoutNodes;\n\n      var preNodes = clone(layoutNodes); // 根据大单元坐标的变化，调整这里面每个小单元nodes\n\n      layoutCfg.onLayoutEnd = function () {\n        layoutNodes === null || layoutNodes === void 0 ? void 0 : layoutNodes.forEach(function (ele, index) {\n          var _a, _b, _c;\n\n          var dx = ele.x - ((_a = preNodes[index]) === null || _a === void 0 ? void 0 : _a.x);\n          var dy = ele.y - ((_b = preNodes[index]) === null || _b === void 0 ? void 0 : _b.y);\n          (_c = groupNodes[index]) === null || _c === void 0 ? void 0 : _c.forEach(function (n) {\n            n.x += dx;\n            n.y += dy;\n          });\n        });\n        resolve();\n      };\n\n      var layoutMethod = new Layout[adjust](layoutCfg);\n      layoutMethod.layout({\n        nodes: layoutNodes\n      });\n    });\n  };\n\n  LayoutController.prototype.hasGPUVersion = function (layoutName) {\n    return GPU_LAYOUT_NAMES.includes(layoutName);\n  };\n\n  LayoutController.prototype.destroy = function () {\n    this.destoryLayoutMethods();\n    var worker = this.worker;\n\n    if (worker) {\n      worker.terminate();\n      this.worker = null;\n    }\n\n    this.destroyed = true;\n    this.graph.set('layout', undefined);\n    this.layoutCfg = undefined;\n    this.layoutType = undefined;\n    this.layoutMethods = undefined;\n    this.graph = null;\n  };\n\n  return LayoutController;\n}(AbstractLayout);\n\nexport default LayoutController;\n\nfunction updateLayoutPosition(data, layoutData) {\n  var nodes = data.nodes;\n  var layoutNodes = layoutData.nodes;\n  var nodeLength = nodes.length;\n\n  for (var i = 0; i < nodeLength; i++) {\n    var node = nodes[i];\n    node.x = layoutNodes[i].x;\n    node.y = layoutNodes[i].y;\n  }\n}\n\nfunction filterObject(collection, callback) {\n  var result = {};\n\n  if (collection && _typeof(collection) === 'object') {\n    Object.keys(collection).forEach(function (key) {\n      if (collection.hasOwnProperty(key) && callback(collection[key])) {\n        result[key] = collection[key];\n      }\n    });\n    return result;\n  }\n\n  return collection;\n}\n\nfunction updateGPUWorkerLayoutPosition(data, layoutData) {\n  var nodes = data.nodes;\n  var vertexEdgeData = layoutData.vertexEdgeData;\n  var nodeLength = nodes.length;\n\n  for (var i = 0; i < nodeLength; i++) {\n    var node = nodes[i];\n    var x = vertexEdgeData[4 * i];\n    var y = vertexEdgeData[4 * i + 1];\n    node.x = x;\n    node.y = y;\n  }\n}\n\nfunction addLayoutOrder(data, order) {\n  var _a;\n\n  if (!((_a = data === null || data === void 0 ? void 0 : data.nodes) === null || _a === void 0 ? void 0 : _a.length)) {\n    return;\n  }\n\n  var nodes = data.nodes;\n  nodes.forEach(function (node) {\n    node.layoutOrder = order;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}