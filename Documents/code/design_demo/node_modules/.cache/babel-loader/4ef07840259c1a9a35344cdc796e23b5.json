{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport { Chart } from '@antv/g2';\nimport { each } from '@antv/util';\nimport EE from '@antv/event-emitter';\nimport { bind } from 'size-sensor';\nimport { getContainerSize, getAllElementsRecursively, deepAssign, pick } from '../utils';\nvar SOURCE_ATTRIBUTE_NAME = 'data-chart-source-type';\n/** plot 图表容器的配置 */\n\nexport var PLOT_CONTAINER_OPTIONS = ['padding', 'appendPadding', 'renderer', 'pixelRatio', 'syncViewPadding', 'supportCSSTransform', 'limitInPlot'];\n/**\n * 所有 plot 的基类\n */\n\nvar Plot =\n/** @class */\nfunction (_super) {\n  __extends(Plot, _super);\n\n  function Plot(container, options) {\n    var _this = _super.call(this) || this;\n\n    _this.container = typeof container === 'string' ? document.getElementById(container) : container;\n    _this.options = deepAssign({}, _this.getDefaultOptions(), options);\n\n    _this.createG2();\n\n    _this.bindEvents();\n\n    return _this;\n  }\n  /**\n   * 获取默认的 options 配置项\n   * 每个组件都可以复写\n   */\n\n\n  Plot.getDefaultOptions = function () {\n    return {\n      renderer: 'canvas',\n      xAxis: {\n        nice: true,\n        label: {\n          autoRotate: false,\n          autoHide: {\n            type: 'equidistance',\n            cfg: {\n              minGap: 6\n            }\n          }\n        }\n      },\n      yAxis: {\n        nice: true,\n        label: {\n          autoHide: true,\n          autoRotate: false\n        }\n      },\n      animation: true\n    };\n  };\n  /**\n   * 创建 G2 实例\n   */\n\n\n  Plot.prototype.createG2 = function () {\n    var _a = this.options,\n        width = _a.width,\n        height = _a.height,\n        defaultInteractions = _a.defaultInteractions;\n    this.chart = new Chart(__assign(__assign(__assign(__assign({\n      container: this.container,\n      autoFit: false\n    }, this.getChartSize(width, height)), {\n      localRefresh: false\n    }), pick(this.options, PLOT_CONTAINER_OPTIONS)), {\n      defaultInteractions: defaultInteractions\n    })); // 给容器增加标识，知道图表的来源区别于 G2\n\n    this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, 'G2Plot');\n  };\n  /**\n   * 计算默认的 chart 大小。逻辑简化：如果存在 width 或 height，则直接使用，否则使用容器大小\n   * @param width\n   * @param height\n   */\n\n\n  Plot.prototype.getChartSize = function (width, height) {\n    var chartSize = getContainerSize(this.container);\n    return {\n      width: width || chartSize.width || 400,\n      height: height || chartSize.height || 400\n    };\n  };\n  /**\n   * 绑定代理所有 G2 的事件\n   */\n\n\n  Plot.prototype.bindEvents = function () {\n    var _this = this;\n\n    if (this.chart) {\n      this.chart.on('*', function (e) {\n        if (e === null || e === void 0 ? void 0 : e.type) {\n          _this.emit(e.type, e);\n        }\n      });\n    }\n  };\n  /**\n   * 获取默认的 options 配置项\n   * 每个组件都可以复写\n   */\n\n\n  Plot.prototype.getDefaultOptions = function () {\n    return Plot.getDefaultOptions();\n  };\n  /**\n   * 绘制\n   */\n\n\n  Plot.prototype.render = function () {\n    // 暴力处理，先清空再渲染，需要 G2 层自行做好更新渲染\n    this.chart.clear(); // 因为子 view 会继承父 view 的 options 配置（包括 legend，所以会导致 legend 重复创建）\n    // 所以这里给 chart 实例的 options 配置清空\n    // 最好的解法是在 G2 view.clear 方法的时候，重置 options 配置。或者提供方法去 resetOptions\n    // #1684 理论上在多 view 图形上，只要存在 custom legend，都存在类似问题（子弹图、双轴图）\n    // @ts-ignore\n\n    this.chart.options = {\n      data: [],\n      animate: true\n    };\n    this.chart.views = []; // 删除已有的 views\n    // 执行 adaptor\n\n    this.execAdaptor(); // 渲染\n\n    this.chart.render(); // 绑定\n\n    this.bindSizeSensor();\n  };\n  /**\n   * 更新: 更新配置且重新渲染\n   * @param options\n   */\n\n\n  Plot.prototype.update = function (options) {\n    this.updateOption(options);\n    this.render();\n  };\n  /**\n   * 更新配置\n   * @param options\n   */\n\n\n  Plot.prototype.updateOption = function (options) {\n    this.options = deepAssign({}, this.options, options);\n  };\n  /**\n   * 设置状态\n   * @param type 状态类型，支持 'active' | 'inactive' | 'selected' 三种\n   * @param conditions 条件，支持数组\n   * @param status 是否激活，默认 true\n   */\n\n\n  Plot.prototype.setState = function (type, condition, status) {\n    if (status === void 0) {\n      status = true;\n    }\n\n    var elements = getAllElementsRecursively(this.chart);\n    each(elements, function (ele) {\n      if (condition(ele.getData())) {\n        ele.setState(type, status);\n      }\n    });\n  };\n  /**\n   * 获取状态\n   */\n\n\n  Plot.prototype.getStates = function () {\n    var elements = getAllElementsRecursively(this.chart);\n    var stateObjects = [];\n    each(elements, function (element) {\n      var data = element.getData();\n      var states = element.getStates();\n      each(states, function (state) {\n        stateObjects.push({\n          data: data,\n          state: state,\n          geometry: element.geometry,\n          element: element\n        });\n      });\n    });\n    return stateObjects;\n  };\n  /**\n   * 更新数据\n   * @override\n   * @param options\n   */\n\n\n  Plot.prototype.changeData = function (data) {\n    // @ts-ignore\n    this.update({\n      data: data\n    }); // TODO: 临时方案，最好使用下面的方式去更新数据\n    // this.chart.changeData(data);\n  };\n  /**\n   * 修改画布大小\n   * @param width\n   * @param height\n   */\n\n\n  Plot.prototype.changeSize = function (width, height) {\n    this.chart.changeSize(width, height);\n  };\n  /**\n   * 增加图表标注。通过 id 标识，如果匹配到，就做更新\n   */\n\n\n  Plot.prototype.addAnnotations = function (annotations) {\n    var incoming = __spreadArrays(annotations);\n\n    var controller = this.chart.getController('annotation');\n    var current = controller.getComponents().map(function (co) {\n      return co.extra;\n    });\n    controller.clear(true);\n\n    var _loop_1 = function (i) {\n      var annotation = current[i];\n      var findIndex = incoming.findIndex(function (item) {\n        return item.id && item.id === annotation.id;\n      });\n\n      if (findIndex !== -1) {\n        annotation = deepAssign({}, annotation, incoming[findIndex]);\n        incoming.splice(findIndex, 1);\n      }\n\n      controller.annotation(annotation);\n    };\n\n    for (var i = 0; i < current.length; i++) {\n      _loop_1(i);\n    }\n\n    incoming.forEach(function (annotation) {\n      return controller.annotation(annotation);\n    });\n    this.chart.render(true);\n  };\n  /**\n   * 删除图表标注。通过 id 标识，如果匹配到，就做删除\n   */\n\n\n  Plot.prototype.removeAnnotations = function (annotations) {\n    var controller = this.chart.getController('annotation');\n    var current = controller.getComponents().map(function (co) {\n      return co.extra;\n    });\n    controller.clear(true);\n\n    var _loop_2 = function (i) {\n      var annotation = current[i];\n\n      if (!annotations.find(function (item) {\n        return item.id && item.id === annotation.id;\n      })) {\n        controller.annotation(annotation);\n      }\n    };\n\n    for (var i = 0; i < current.length; i++) {\n      _loop_2(i);\n    }\n\n    this.chart.render(true);\n  };\n  /**\n   * 销毁\n   */\n\n\n  Plot.prototype.destroy = function () {\n    // 取消 size-sensor 的绑定\n    this.unbindSizeSensor(); // G2 的销毁\n\n    this.chart.destroy(); // 清空已经绑定的事件\n\n    this.off();\n    this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);\n  };\n  /**\n   * 执行 adaptor 操作\n   */\n\n\n  Plot.prototype.execAdaptor = function () {\n    var adaptor = this.getSchemaAdaptor();\n    var _a = this.options,\n        padding = _a.padding,\n        appendPadding = _a.appendPadding; // 更新 padding\n\n    this.chart.padding = padding; // 更新 appendPadding\n\n    this.chart.appendPadding = appendPadding; // 转化成 G2 API\n\n    adaptor({\n      chart: this.chart,\n      options: this.options\n    });\n  };\n  /**\n   * 当图表容器大小变化的时候，执行的函数\n   */\n\n\n  Plot.prototype.triggerResize = function () {\n    this.chart.forceFit();\n  };\n  /**\n   * 绑定 dom 容器大小变化的事件\n   */\n\n\n  Plot.prototype.bindSizeSensor = function () {\n    var _this = this;\n\n    if (this.unbind) {\n      return;\n    }\n\n    var _a = this.options.autoFit,\n        autoFit = _a === void 0 ? true : _a;\n\n    if (autoFit) {\n      this.unbind = bind(this.container, function () {\n        // 获取最新的宽高信息\n        var _a = getContainerSize(_this.container),\n            width = _a.width,\n            height = _a.height; // 主要是防止绑定的时候触发 resize 回调\n\n\n        if (width !== _this.chart.width || height !== _this.chart.height) {\n          _this.triggerResize();\n        }\n      });\n    }\n  };\n  /**\n   * 取消绑定\n   */\n\n\n  Plot.prototype.unbindSizeSensor = function () {\n    if (this.unbind) {\n      this.unbind();\n      this.unbind = undefined;\n    }\n  };\n\n  return Plot;\n}(EE);\n\nexport { Plot };","map":null,"metadata":{},"sourceType":"module"}