{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { earthTriangulation } from '../../core/triangulation';\nvar baseFrag = \"\\nuniform sampler2D u_texture;\\n\\nvarying vec2 v_texCoord;\\nvarying float v_lightWeight;\\n\\n\\nvoid main() {\\n\\n    vec4 color = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y));\\n    color.xyz = color.xyz * v_lightWeight;\\n    gl_FragColor = color;\\n}\\n\";\nvar baseVert = \"// attribute vec4 a_Color;\\nattribute vec3 a_Position;\\nattribute vec3 a_Normal;\\nattribute vec2 a_Uv;\\nvarying vec2 v_texCoord;\\n\\n// attribute vec2 a_Extrude;\\n// attribute float a_Size;\\n// attribute float a_Shape;\\n\\nuniform vec3 u_CameraPosition;\\nuniform mat4 u_ViewProjectionMatrix;\\nuniform mat4 u_ModelMatrix;\\nuniform float u_ambientRatio : 0.5;\\nuniform float u_diffuseRatio : 0.3;\\nuniform float u_specularRatio : 0.2;\\nuniform vec3 u_sunLight: [1.0, -10.5, 12.0];\\n\\n\\n\\nfloat calc_lighting(vec4 pos) {\\n\\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\\n\\n    vec3 worldNormal = a_Normal;\\n\\n    // cal light weight\\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\\n\\n    vec3 lightDir = normalize(u_sunLight);\\n\\n    vec3 halfDir = normalize(viewDir+lightDir);\\n    // lambert\\n    float lambert = dot(worldNormal, lightDir);\\n    // specular\\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\\n    //sum to light weight\\n    float lightWeight = u_ambientRatio + u_diffuseRatio * lambert + u_specularRatio * specular;\\n\\n    return lightWeight;\\n}\\n\\nvarying float v_lightWeight;\\nvoid main() {\\n\\n    v_texCoord = a_Uv;\\n\\n    float lightWeight = calc_lighting(vec4(a_Position, 1.0));\\n    v_lightWeight = lightWeight;\\n\\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\\n}\\n\";\n\nvar BaseEarthModel = function (_BaseModel) {\n  _inherits(BaseEarthModel, _BaseModel);\n\n  var _super = _createSuper(BaseEarthModel);\n\n  function BaseEarthModel() {\n    var _this;\n\n    _classCallCheck(this, BaseEarthModel);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"texture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"earthTime\", 3.4);\n\n    _defineProperty(_assertThisInitialized(_this), \"sunX\", 1000);\n\n    _defineProperty(_assertThisInitialized(_this), \"sunY\", 1000);\n\n    _defineProperty(_assertThisInitialized(_this), \"sunZ\", 1000);\n\n    _defineProperty(_assertThisInitialized(_this), \"sunRadius\", Math.sqrt(_this.sunX * _this.sunX + _this.sunY * _this.sunY + _this.sunZ * _this.sunZ));\n\n    return _this;\n  }\n\n  _createClass(BaseEarthModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _this$layer$getLayerC = this.layer.getLayerConfig(),\n          animateOption = _this$layer$getLayerC.animateOption,\n          globelOtions = _this$layer$getLayerC.globelOtions;\n\n      if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {\n        this.mapService.rotateY({\n          reg: 0.002\n        });\n        this.earthTime += 0.02;\n        this.sunY = 10;\n        this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);\n        this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);\n      }\n\n      return {\n        u_ambientRatio: (globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.ambientRatio) || 0.6,\n        u_diffuseRatio: (globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.diffuseRatio) || 0.4,\n        u_specularRatio: (globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.specularRatio) || 0.1,\n        u_sunLight: [this.sunX, this.sunY, this.sunZ],\n        u_texture: this.texture\n      };\n    }\n  }, {\n    key: \"setEarthTime\",\n    value: function setEarthTime(time) {\n      this.earthTime = time;\n      this.sunY = 10;\n      this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);\n      this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);\n      this.layerService.renderLayers();\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      var _this2 = this;\n\n      var _this$layer$getLayerC2 = this.layer.getLayerConfig(),\n          globelOtions = _this$layer$getLayerC2.globelOtions;\n\n      if ((globelOtions === null || globelOtions === void 0 ? void 0 : globelOtions.earthTime) !== undefined) {\n        this.setEarthTime(globelOtions.earthTime);\n      }\n\n      var source = this.layer.getSource();\n      var createTexture2D = this.rendererService.createTexture2D;\n      this.texture = createTexture2D({\n        height: 0,\n        width: 0\n      });\n      source.data.images.then(function (imageData) {\n        _this2.texture = createTexture2D({\n          data: imageData[0],\n          width: imageData[0].width,\n          height: imageData[0].height\n        });\n\n        _this2.layerService.updateLayerRenderList();\n\n        _this2.layerService.renderLayers();\n      });\n      return this.buildModels();\n    }\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      return '';\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      this.layer.zIndex = -998;\n      return [this.layer.buildLayerModel({\n        moduleName: 'baseEarth',\n        vertexShader: baseVert,\n        fragmentShader: baseFrag,\n        triangulation: earthTriangulation,\n        depth: {\n          enable: true\n        },\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$size = feature.size,\n                size = _feature$size === void 0 ? 1 : _feature$size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'normal',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Normal',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {\n            return normal;\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'uv',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Uv',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return BaseEarthModel;\n}(BaseModel);\n\nexport { BaseEarthModel as default };","map":null,"metadata":{},"sourceType":"module"}