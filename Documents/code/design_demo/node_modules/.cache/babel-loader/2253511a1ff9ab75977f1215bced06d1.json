{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"buffer\", \"update\", \"name\"];\n\nvar _bytesPerElementMap, _dec, _dec2, _class, _class2, _descriptor;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { TYPES } from '../../types';\nimport { gl } from '../renderer/gl';\nimport StyleAttribute from './StyleAttribute';\n\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n\nvar bytesPerElementMap = (_bytesPerElementMap = {}, _defineProperty(_bytesPerElementMap, gl.FLOAT, 4), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_BYTE, 1), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_SHORT, 2), _bytesPerElementMap);\nvar StyleAttributeService = (_dec = injectable(), _dec2 = inject(TYPES.IRendererService), _dec(_class = (_class2 = function () {\n  function StyleAttributeService() {\n    _classCallCheck(this, StyleAttributeService);\n\n    _defineProperty(this, \"attributesAndIndices\", void 0);\n\n    _initializerDefineProperty(this, \"rendererService\", _descriptor, this);\n\n    _defineProperty(this, \"attributes\", []);\n\n    _defineProperty(this, \"triangulation\", void 0);\n\n    _defineProperty(this, \"featureLayout\", {\n      sizePerElement: 0,\n      elements: []\n    });\n  }\n\n  _createClass(StyleAttributeService, [{\n    key: \"registerStyleAttribute\",\n    value: function registerStyleAttribute(options) {\n      var attributeToUpdate = this.getLayerStyleAttribute(options.name || '');\n\n      if (attributeToUpdate) {\n        attributeToUpdate.setProps(options);\n      } else {\n        attributeToUpdate = new StyleAttribute(options);\n        this.attributes.push(attributeToUpdate);\n      }\n\n      return attributeToUpdate;\n    }\n  }, {\n    key: \"updateStyleAttribute\",\n    value: function updateStyleAttribute(attributeName, options, updateOptions) {\n      var attributeToUpdate = this.getLayerStyleAttribute(attributeName);\n\n      if (!attributeToUpdate) {\n        attributeToUpdate = this.registerStyleAttribute(_objectSpread(_objectSpread({}, options), {}, {\n          name: attributeName\n        }));\n      }\n\n      var scale = options.scale;\n\n      if (scale && attributeToUpdate) {\n        attributeToUpdate.scale = scale;\n        attributeToUpdate.needRescale = true;\n        attributeToUpdate.needRemapping = true;\n        attributeToUpdate.needRegenerateVertices = true;\n\n        if (updateOptions && updateOptions.featureRange) {\n          attributeToUpdate.featureRange = updateOptions.featureRange;\n        }\n      }\n    }\n  }, {\n    key: \"getLayerStyleAttributes\",\n    value: function getLayerStyleAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getLayerStyleAttribute\",\n    value: function getLayerStyleAttribute(attributeName) {\n      return this.attributes.find(function (attribute) {\n        return attribute.name === attributeName;\n      });\n    }\n  }, {\n    key: \"getLayerAttributeScale\",\n    value: function getLayerAttributeScale(name) {\n      var _attribute$scale;\n\n      var attribute = this.getLayerStyleAttribute(name);\n      var scale = attribute === null || attribute === void 0 ? void 0 : (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers;\n\n      if (scale && scale[0]) {\n        return scale[0].func;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"updateAttributeByFeatureRange\",\n    value: function updateAttributeByFeatureRange(attributeName, features) {\n      var startFeatureIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var endFeatureIdx = arguments.length > 3 ? arguments[3] : undefined;\n      var attributeToUpdate = this.attributes.find(function (attribute) {\n        return attribute.name === attributeName;\n      });\n\n      if (attributeToUpdate && attributeToUpdate.descriptor) {\n        var descriptor = attributeToUpdate.descriptor;\n        var update = descriptor.update,\n            buffer = descriptor.buffer,\n            _descriptor$size = descriptor.size,\n            size = _descriptor$size === void 0 ? 0 : _descriptor$size;\n        var bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];\n\n        if (update) {\n          var _this$featureLayout = this.featureLayout,\n              elements = _this$featureLayout.elements,\n              sizePerElement = _this$featureLayout.sizePerElement;\n          var featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);\n\n          if (!featuresToUpdate.length) {\n            return;\n          }\n\n          var offset = featuresToUpdate[0].offset;\n          var bufferOffsetInBytes = offset * size * bytesPerElement;\n          var updatedBufferData = featuresToUpdate.map(function (_ref, attributeIdx) {\n            var featureIdx = _ref.featureIdx,\n                vertices = _ref.vertices,\n                normals = _ref.normals;\n            var verticesNumForCurrentFeature = vertices.length / sizePerElement;\n            var featureData = [];\n\n            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n              var normal = normals ? normals.slice(vertexIdx * 3, vertexIdx * 3 + 3) : [];\n              featureData.push.apply(featureData, _toConsumableArray(update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal)));\n            }\n\n            return featureData;\n          }).reduce(function (prev, cur) {\n            prev.push.apply(prev, _toConsumableArray(cur));\n            return prev;\n          }, []);\n          attributeToUpdate.vertexAttribute.updateBuffer({\n            data: updatedBufferData,\n            offset: bufferOffsetInBytes\n          });\n        }\n      }\n    }\n  }, {\n    key: \"createAttributesAndIndices\",\n    value: function createAttributesAndIndices(features, triangulation, segmentNumber) {\n      var _this = this;\n\n      this.featureLayout = {\n        sizePerElement: 0,\n        elements: []\n      };\n\n      if (triangulation) {\n        this.triangulation = triangulation;\n      }\n\n      var descriptors = this.attributes.map(function (attr) {\n        attr.resetDescriptor();\n        return attr.descriptor;\n      });\n      var verticesNum = 0;\n      var vertices = [];\n      var indices = [];\n      var normals = [];\n      var size = 3;\n      features.forEach(function (feature, featureIdx) {\n        var _this$triangulation = _this.triangulation(feature, segmentNumber),\n            indicesForCurrentFeature = _this$triangulation.indices,\n            verticesForCurrentFeature = _this$triangulation.vertices,\n            normalsForCurrentFeature = _this$triangulation.normals,\n            vertexSize = _this$triangulation.size;\n\n        indicesForCurrentFeature.forEach(function (i) {\n          indices.push(i + verticesNum);\n        });\n        size = vertexSize;\n        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;\n        _this.featureLayout.sizePerElement = size;\n\n        _this.featureLayout.elements.push({\n          featureIdx: featureIdx,\n          vertices: verticesForCurrentFeature,\n          normals: normalsForCurrentFeature,\n          offset: verticesNum\n        });\n\n        verticesNum += verticesNumForCurrentFeature;\n\n        var _loop = function _loop(vertexIdx) {\n          var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];\n          var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);\n          descriptors.forEach(function (descriptor, attributeIdx) {\n            if (descriptor && descriptor.update) {\n              var _ref2;\n\n              (_ref2 = descriptor.buffer.data).push.apply(_ref2, _toConsumableArray(descriptor.update(feature, featureIdx, vertice, vertexIdx, normal)));\n            }\n          });\n        };\n\n        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n          _loop(vertexIdx);\n        }\n      });\n      var _this$rendererService = this.rendererService,\n          createAttribute = _this$rendererService.createAttribute,\n          createBuffer = _this$rendererService.createBuffer,\n          createElements = _this$rendererService.createElements;\n      var attributes = {};\n      descriptors.forEach(function (descriptor, attributeIdx) {\n        if (descriptor) {\n          var buffer = descriptor.buffer,\n              update = descriptor.update,\n              name = descriptor.name,\n              rest = _objectWithoutProperties(descriptor, _excluded);\n\n          var vertexAttribute = createAttribute(_objectSpread({\n            buffer: createBuffer(buffer)\n          }, rest));\n          attributes[descriptor.name || ''] = vertexAttribute;\n          _this.attributes[attributeIdx].vertexAttribute = vertexAttribute;\n        }\n      });\n      var elements = createElements({\n        data: indices,\n        type: gl.UNSIGNED_INT,\n        count: indices.length\n      });\n      this.attributesAndIndices = {\n        attributes: attributes,\n        elements: elements\n      };\n      return this.attributesAndIndices;\n    }\n  }, {\n    key: \"clearAllAttributes\",\n    value: function clearAllAttributes() {\n      var _this$attributesAndIn;\n\n      this.attributes.forEach(function (attribute) {\n        if (attribute.vertexAttribute) {\n          attribute.vertexAttribute.destroy();\n        }\n      });\n      (_this$attributesAndIn = this.attributesAndIndices) === null || _this$attributesAndIn === void 0 ? void 0 : _this$attributesAndIn.elements.destroy();\n      this.attributes = [];\n    }\n  }]);\n\n  return StyleAttributeService;\n}(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"rendererService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { StyleAttributeService as default };","map":null,"metadata":{},"sourceType":"module"}