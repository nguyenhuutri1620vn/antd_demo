{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { isFunction } from '@antv/util';\nvar DEFAULT_TRIGGER = 'click';\nvar ALLOW_EVENTS = ['click', 'drag'];\nvar DEFAULT_KEY = undefined;\nvar ALLOW_KEYS = ['shift', 'ctrl', 'control', 'alt', 'meta', undefined];\nexport default {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      trigger: DEFAULT_TRIGGER,\n      key: DEFAULT_KEY,\n      edgeConfig: {},\n      getEdgeConfig: undefined\n    };\n  },\n  getEvents: function getEvents() {\n    var self = this; // 检测输入是否合法\n\n    if (!(ALLOW_EVENTS.indexOf(self.trigger.toLowerCase()) > -1)) {\n      self.trigger = DEFAULT_TRIGGER; // eslint-disable-next-line no-console\n\n      console.warn(\"Behavior create-edge 的 trigger 参数不合法，请输入 'click'，'drag'\");\n    }\n\n    if (self.key && ALLOW_KEYS.indexOf(self.key.toLowerCase()) === -1) {\n      self.trigger = DEFAULT_KEY; // eslint-disable-next-line no-console\n\n      console.warn(\"Behavior create-edge 的 key 参数不合法，请输入 'shift'，'ctrl'，'alt'，'control'，或 undefined\");\n    }\n\n    var events;\n\n    if (self.trigger === 'drag') {\n      events = {\n        'node:dragstart': 'onClick',\n        'combo:dragstart': 'onClick',\n        drag: 'updateEndPoint',\n        'node:drop': 'onClick',\n        'combo:drop': 'onClick',\n        dragend: 'onDragEnd'\n      };\n    } else if (self.trigger === 'click') {\n      events = {\n        'node:click': 'onClick',\n        mousemove: 'updateEndPoint',\n        'edge:click': 'cancelCreating',\n        'canvas:click': 'cancelCreating',\n        'combo:click': 'onClick'\n      };\n    }\n\n    if (self.key) {\n      events.keydown = 'onKeyDown';\n      events.keyup = 'onKeyUp';\n    }\n\n    return events;\n  },\n  onDragEnd: function onDragEnd(ev) {\n    var self = this;\n    if (self.key && !self.keydown) return;\n    var item = ev.item;\n    if (!item || item.getID() === self.source || item.getType() !== 'node') self.cancelCreating({\n      item: self.edge,\n      x: ev.x,\n      y: ev.y\n    });\n  },\n  // 如果边的起点没有指定，则根据起点创建新边；如果起点已经指定而终点未指定，则指定终点\n  onClick: function onClick(ev) {\n    var self = this;\n    if (self.key && !self.keydown) return;\n    var node = ev.item;\n    var graph = self.graph;\n    var model = node.getModel();\n    var getEdgeConfig = self.getEdgeConfig; // 如果起点已经指定而终点未指定，则指定终点\n\n    if (self.addingEdge && self.edge) {\n      if (!self.shouldEnd.call(self, ev)) return;\n      var edgeConfig = void 0;\n\n      if (getEdgeConfig && isFunction(getEdgeConfig)) {\n        edgeConfig = getEdgeConfig({\n          source: self.source,\n          target: model.id\n        });\n      } else {\n        edgeConfig = self.edgeConfig;\n      }\n\n      var updateCfg = __assign({\n        target: model.id\n      }, edgeConfig);\n\n      if (self.source === model.id) {\n        updateCfg.type = 'loop';\n      }\n\n      graph.emit('beforecreateedge', {});\n      graph.updateItem(self.edge, updateCfg, false);\n\n      if (graph.get('enabledStack')) {\n        var addedModel = __assign(__assign({}, self.edge.getModel()), {\n          itemType: 'edge'\n        });\n\n        var after = {};\n        after.edges = [addedModel];\n        graph.pushStack('add', {\n          before: {},\n          after: after\n        });\n      }\n\n      graph.emit('aftercreateedge', {\n        edge: self.edge\n      }); // 暂时将该边的 capture 恢复为 true\n\n      self.edge.getKeyShape().set('capture', true);\n      self.edge = null;\n      self.addingEdge = false;\n    } else {\n      // 如果边的起点没有指定，则根据起点创建新边\n      if (!self.shouldBegin.call(self, ev)) return; // 获取自定义 edge 配置\n\n      var edgeConfig = void 0;\n\n      if (getEdgeConfig && isFunction(getEdgeConfig)) {\n        edgeConfig = getEdgeConfig({\n          source: model.id,\n          target: model.id\n        });\n      } else {\n        edgeConfig = self.edgeConfig;\n      }\n\n      self.edge = graph.addItem('edge', __assign({\n        source: model.id,\n        target: model.id\n      }, edgeConfig), false);\n      self.source = model.id;\n      self.addingEdge = true; // 暂时将该边的 capture 设置为 false，这样可以拾取到后面的元素\n\n      self.edge.getKeyShape().set('capture', false);\n    }\n  },\n  // 边的起点已经确定，边的末端跟随鼠标移动\n  updateEndPoint: function updateEndPoint(ev) {\n    var self = this;\n    if (self.key && !self.keydown) return;\n    if (self.edge && self.edge.destroyed) self.cancelCreating({\n      item: self.edge\n    });\n    var point = {\n      x: ev.x,\n      y: ev.y\n    }; // 若此时 source 节点已经被移除，结束添加边\n\n    if (!self.graph.findById(self.source)) {\n      self.addingEdge = false;\n      return;\n    }\n\n    if (self.addingEdge && self.edge) {\n      // 更新边的终点为鼠标位置\n      self.graph.updateItem(self.edge, {\n        target: point\n      }, false);\n    }\n  },\n  // 取消增加边，删除该边；或指定终点\n  cancelCreating: function cancelCreating(ev) {\n    var _a, _b;\n\n    var self = this;\n    if (self.key && !self.keydown) return;\n    var graph = self.graph;\n    var currentEdge = ev.item;\n\n    if (self.addingEdge && (self.edge === currentEdge || ((_b = (_a = ev.target) === null || _a === void 0 ? void 0 : _a.isCanvas) === null || _b === void 0 ? void 0 : _b.call(_a)))) {\n      if (self.edge && !self.edge.destroyed) graph.removeItem(self.edge, false);\n      self.edge = null;\n      self.addingEdge = false;\n      return;\n    }\n  },\n  onKeyDown: function onKeyDown(e) {\n    var self = this;\n    var code = e.key;\n\n    if (!code) {\n      return;\n    }\n\n    if (code.toLowerCase() === self.key.toLowerCase()) {\n      self.keydown = true;\n    } else {\n      self.keydown = false;\n    }\n  },\n  onKeyUp: function onKeyUp() {\n    var self = this;\n\n    if (self.addingEdge && self.edge) {\n      // 清除正在增加的边\n      self.graph.removeItem(self.edge, false);\n      self.addingEdge = false;\n      self.edge = null;\n    }\n\n    this.keydown = false;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}