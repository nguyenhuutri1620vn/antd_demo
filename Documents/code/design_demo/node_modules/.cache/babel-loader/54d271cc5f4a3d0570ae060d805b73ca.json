{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-unused-vars */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Rectangle, Point } from '../geometry';\nimport { ArrayExt, ObjectExt, Dom, FunctionExt, Vector } from '../util';\nimport { Registry } from '../registry/registry';\nimport { ConnectionStrategy } from '../registry/connection-strategy';\nimport { View } from './view';\nimport { Cache } from './cache';\nimport { Markup } from './markup';\nimport { ToolsView } from './tool';\nimport { AttrManager } from './attr';\nimport { FlagManager } from './flag';\nexport class CellView extends View {\n  constructor(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.cell = cell;\n    this.options = this.ensureOptions(options);\n    this.graph = this.options.graph;\n    this.attr = new AttrManager(this);\n    this.flag = new FlagManager(this, this.options.actions, this.options.bootstrap);\n    this.cache = new Cache(this);\n    this.setContainer(this.ensureContainer());\n    this.setup();\n    this.$(this.container).data('view', this);\n    this.init();\n  }\n\n  static getDefaults() {\n    return this.defaults;\n  }\n\n  static config(options) {\n    this.defaults = this.getOptions(options);\n  }\n\n  static getOptions(options) {\n    const mergeActions = (arr1, arr2) => {\n      if (arr2 != null) {\n        return ArrayExt.uniq([...(Array.isArray(arr1) ? arr1 : [arr1]), ...(Array.isArray(arr2) ? arr2 : [arr2])]);\n      }\n\n      return Array.isArray(arr1) ? [...arr1] : [arr1];\n    };\n\n    const ret = ObjectExt.cloneDeep(this.getDefaults());\n\n    const {\n      bootstrap,\n      actions,\n      events,\n      documentEvents\n    } = options,\n          others = __rest(options, [\"bootstrap\", \"actions\", \"events\", \"documentEvents\"]);\n\n    if (bootstrap) {\n      ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);\n    }\n\n    if (actions) {\n      Object.keys(actions).forEach(key => {\n        const val = actions[key];\n        const raw = ret.actions[key];\n\n        if (val && raw) {\n          ret.actions[key] = mergeActions(raw, val);\n        } else if (val) {\n          ret.actions[key] = mergeActions(val);\n        }\n      });\n    }\n\n    if (events) {\n      ret.events = Object.assign(Object.assign({}, ret.events), events);\n    }\n\n    if (options.documentEvents) {\n      ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);\n    }\n\n    return ObjectExt.merge(ret, others);\n  }\n\n  get [Symbol.toStringTag]() {\n    return CellView.toStringTag;\n  }\n\n  init() {}\n\n  onRemove() {\n    this.removeTools();\n  }\n\n  get priority() {\n    return this.options.priority;\n  }\n\n  get rootSelector() {\n    return this.options.rootSelector;\n  }\n\n  getConstructor() {\n    return this.constructor;\n  }\n\n  ensureOptions(options) {\n    return this.getConstructor().getOptions(options);\n  }\n\n  getContainerTagName() {\n    return this.options.isSvgElement ? 'g' : 'div';\n  }\n\n  getContainerStyle() {}\n\n  getContainerAttrs() {\n    return {\n      'data-cell-id': this.cell.id,\n      'data-shape': this.cell.shape\n    };\n  }\n\n  getContainerClassName() {\n    return this.prefixClassName('cell');\n  }\n\n  ensureContainer() {\n    return View.createElement(this.getContainerTagName(), this.options.isSvgElement);\n  }\n\n  setContainer(container) {\n    if (this.container !== container) {\n      this.undelegateEvents();\n      this.container = container;\n\n      if (this.options.events != null) {\n        this.delegateEvents(this.options.events);\n      }\n\n      const attrs = this.getContainerAttrs();\n\n      if (attrs != null) {\n        this.setAttrs(attrs, container);\n      }\n\n      const style = this.getContainerStyle();\n\n      if (style != null) {\n        this.setStyle(style, container);\n      }\n\n      const className = this.getContainerClassName();\n\n      if (className != null) {\n        this.addClass(className, container);\n      }\n    }\n\n    return this;\n  }\n\n  isNodeView() {\n    return false;\n  }\n\n  isEdgeView() {\n    return false;\n  }\n\n  render() {\n    return this;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  confirmUpdate(flag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return 0;\n  }\n\n  getBootstrapFlag() {\n    return this.flag.getBootstrapFlag();\n  }\n\n  getFlag(actions) {\n    return this.flag.getFlag(actions);\n  }\n\n  hasAction(flag, actions) {\n    return this.flag.hasAction(flag, actions);\n  }\n\n  removeAction(flag, actions) {\n    return this.flag.removeAction(flag, actions);\n  }\n\n  handleAction(flag, action, handle, additionalRemovedActions) {\n    if (this.hasAction(flag, action)) {\n      handle();\n      const removedFlags = [action];\n\n      if (additionalRemovedActions) {\n        if (typeof additionalRemovedActions === 'string') {\n          removedFlags.push(additionalRemovedActions);\n        } else {\n          removedFlags.push(...additionalRemovedActions);\n        }\n      }\n\n      return this.removeAction(flag, removedFlags);\n    }\n\n    return flag;\n  }\n\n  setup() {\n    this.cell.on('changed', _ref => {\n      let {\n        options\n      } = _ref;\n      return this.onAttrsChange(options);\n    });\n  }\n\n  onAttrsChange(options) {\n    let flag = this.flag.getChangedFlag();\n\n    if (options.updated || !flag) {\n      return;\n    }\n\n    if (options.dirty && this.hasAction(flag, 'update')) {\n      flag |= this.getFlag('render'); // eslint-disable-line no-bitwise\n    } // tool changes should be sync render\n\n\n    if (options.toolId) {\n      options.async = false;\n    }\n\n    if (this.graph != null) {\n      this.graph.renderer.requestViewUpdate(this, flag, this.priority, options);\n    }\n  }\n\n  parseJSONMarkup(markup, rootElem) {\n    const result = Markup.parseJSONMarkup(markup);\n    const selectors = result.selectors;\n    const rootSelector = this.rootSelector;\n\n    if (rootElem && rootSelector) {\n      if (selectors[rootSelector]) {\n        throw new Error('Invalid root selector');\n      }\n\n      selectors[rootSelector] = rootElem;\n    }\n\n    return result;\n  }\n\n  can(feature) {\n    let interacting = this.graph.options.interacting;\n\n    if (typeof interacting === 'function') {\n      interacting = FunctionExt.call(interacting, this.graph, this);\n    }\n\n    if (typeof interacting === 'object') {\n      let val = interacting[feature];\n\n      if (typeof val === 'function') {\n        val = FunctionExt.call(val, this.graph, this);\n      }\n\n      return val !== false;\n    }\n\n    if (typeof interacting === 'boolean') {\n      return interacting;\n    }\n\n    return false;\n  }\n\n  cleanCache() {\n    this.cache.clean();\n    return this;\n  }\n\n  getCache(elem) {\n    return this.cache.get(elem);\n  }\n\n  getDataOfElement(elem) {\n    return this.cache.getData(elem);\n  }\n\n  getMatrixOfElement(elem) {\n    return this.cache.getMatrix(elem);\n  }\n\n  getShapeOfElement(elem) {\n    return this.cache.getShape(elem);\n  }\n\n  getScaleOfElement(node, scalableNode) {\n    let sx;\n    let sy;\n\n    if (scalableNode && scalableNode.contains(node)) {\n      const scale = Dom.scale(scalableNode);\n      sx = 1 / scale.sx;\n      sy = 1 / scale.sy;\n    } else {\n      sx = 1;\n      sy = 1;\n    }\n\n    return {\n      sx,\n      sy\n    };\n  }\n\n  getBoundingRectOfElement(elem) {\n    return this.cache.getBoundingRect(elem);\n  }\n\n  getBBoxOfElement(elem) {\n    const rect = this.getBoundingRectOfElement(elem);\n    const matrix = this.getMatrixOfElement(elem);\n    const rm = this.getRootRotatedMatrix();\n    const tm = this.getRootTranslatedMatrix();\n    return Dom.transformRectangle(rect, tm.multiply(rm).multiply(matrix));\n  }\n\n  getUnrotatedBBoxOfElement(elem) {\n    const rect = this.getBoundingRectOfElement(elem);\n    const matrix = this.getMatrixOfElement(elem);\n    const tm = this.getRootTranslatedMatrix();\n    return Dom.transformRectangle(rect, tm.multiply(matrix));\n  }\n\n  getBBox() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let bbox;\n\n    if (options.useCellGeometry) {\n      const cell = this.cell;\n      const angle = cell.isNode() ? cell.getAngle() : 0;\n      bbox = cell.getBBox().bbox(angle);\n    } else {\n      bbox = this.getBBoxOfElement(this.container);\n    }\n\n    return this.graph.localToGraph(bbox);\n  }\n\n  getRootTranslatedMatrix() {\n    const cell = this.cell;\n    const pos = cell.isNode() ? cell.getPosition() : {\n      x: 0,\n      y: 0\n    };\n    return Dom.createSVGMatrix().translate(pos.x, pos.y);\n  }\n\n  getRootRotatedMatrix() {\n    let matrix = Dom.createSVGMatrix();\n    const cell = this.cell;\n    const angle = cell.isNode() ? cell.getAngle() : 0;\n\n    if (angle) {\n      const bbox = cell.getBBox();\n      const cx = bbox.width / 2;\n      const cy = bbox.height / 2;\n      matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n    }\n\n    return matrix;\n  }\n\n  findMagnet() {\n    let elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;\n    // If the overall cell has set `magnet === false`, then returns\n    // `undefined` to announce there is no magnet found for this cell.\n    // This is especially useful to set on cells that have 'ports'.\n    // In this case, only the ports have set `magnet === true` and the\n    // overall element has `magnet === false`.\n    return this.findByAttr('magnet', elem);\n  }\n\n  updateAttrs(rootNode, attrs) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (options.rootBBox == null) {\n      options.rootBBox = new Rectangle();\n    }\n\n    if (options.selectors == null) {\n      options.selectors = this.selectors;\n    }\n\n    this.attr.update(rootNode, attrs, options);\n  }\n\n  isEdgeElement(magnet) {\n    return this.cell.isEdge() && (magnet == null || magnet === this.container);\n  } // #region highlight\n\n\n  prepareHighlight(elem) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const magnet = elem && this.$(elem)[0] || this.container;\n    options.partial = magnet === this.container;\n    return magnet;\n  }\n\n  highlight(elem) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const magnet = this.prepareHighlight(elem, options);\n    this.notify('cell:highlight', {\n      magnet,\n      options,\n      view: this,\n      cell: this.cell\n    });\n\n    if (this.isEdgeView()) {\n      this.notify('edge:highlight', {\n        magnet,\n        options,\n        view: this,\n        edge: this.cell,\n        cell: this.cell\n      });\n    } else if (this.isNodeView()) {\n      this.notify('node:highlight', {\n        magnet,\n        options,\n        view: this,\n        node: this.cell,\n        cell: this.cell\n      });\n    }\n\n    return this;\n  }\n\n  unhighlight(elem) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const magnet = this.prepareHighlight(elem, options);\n    this.notify('cell:unhighlight', {\n      magnet,\n      options,\n      view: this,\n      cell: this.cell\n    });\n\n    if (this.isNodeView()) {\n      this.notify('node:unhighlight', {\n        magnet,\n        options,\n        view: this,\n        node: this.cell,\n        cell: this.cell\n      });\n    } else if (this.isEdgeView()) {\n      this.notify('edge:unhighlight', {\n        magnet,\n        options,\n        view: this,\n        edge: this.cell,\n        cell: this.cell\n      });\n    }\n\n    return this;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  notifyUnhighlight(magnet, options) {} // #endregion\n\n\n  getEdgeTerminal(magnet, x, y, edge, type) {\n    const cell = this.cell;\n    const portId = this.findAttr('port', magnet);\n    const selector = magnet.getAttribute('data-selector');\n    const terminal = {\n      cell: cell.id\n    };\n\n    if (selector != null) {\n      terminal.magnet = selector;\n    }\n\n    if (portId != null) {\n      terminal.port = portId;\n\n      if (cell.isNode()) {\n        if (!cell.hasPort(portId) && selector == null) {\n          // port created via the `port` attribute (not API)\n          terminal.selector = this.getSelector(magnet);\n        }\n      }\n    } else if (selector == null && this.container !== magnet) {\n      terminal.selector = this.getSelector(magnet);\n    }\n\n    return this.customizeEdgeTerminal(terminal, magnet, x, y, edge, type);\n  }\n\n  customizeEdgeTerminal(terminal, magnet, x, y, edge, type) {\n    const raw = edge.getStrategy() || this.graph.options.connecting.strategy;\n\n    if (raw) {\n      const name = typeof raw === 'string' ? raw : raw.name;\n      const args = typeof raw === 'string' ? {} : raw.args || {};\n      const registry = ConnectionStrategy.registry;\n\n      if (name) {\n        const fn = registry.get(name);\n\n        if (fn == null) {\n          return registry.onNotFound(name);\n        }\n\n        const result = FunctionExt.call(fn, this.graph, terminal, this, magnet, new Point(x, y), edge, type, args);\n\n        if (result) {\n          return result;\n        }\n      }\n    }\n\n    return terminal;\n  }\n\n  getMagnetFromEdgeTerminal(terminal) {\n    const cell = this.cell;\n    const root = this.container;\n    const portId = terminal.port;\n    let selector = terminal.magnet;\n    let magnet;\n\n    if (portId != null && cell.isNode() && cell.hasPort(portId)) {\n      magnet = this.findPortElem(portId, selector) || root;\n    } else {\n      if (!selector) {\n        selector = terminal.selector;\n      }\n\n      if (!selector && portId != null) {\n        selector = `[port=\"${portId}\"]`;\n      }\n\n      magnet = this.findOne(selector, root, this.selectors);\n    }\n\n    return magnet;\n  } // #region animate\n\n\n  animate(elem, options) {\n    const target = typeof elem === 'string' ? this.findOne(elem) : elem;\n\n    if (target == null) {\n      throw new Error('Invalid animation element.');\n    }\n\n    const parent = target.parentNode;\n\n    const revert = () => {\n      if (!parent) {\n        Dom.remove(target);\n      }\n    };\n\n    const vTarget = Vector.create(target);\n\n    if (!parent) {\n      vTarget.appendTo(this.graph.view.stage);\n    }\n\n    const onComplete = options.complete;\n\n    options.complete = e => {\n      revert();\n\n      if (onComplete) {\n        onComplete(e);\n      }\n    };\n\n    return vTarget.animate(options);\n  }\n\n  animateTransform(elem, options) {\n    const target = typeof elem === 'string' ? this.findOne(elem) : elem;\n\n    if (target == null) {\n      throw new Error('Invalid animation element.');\n    }\n\n    const parent = target.parentNode;\n\n    const revert = () => {\n      if (!parent) {\n        Dom.remove(target);\n      }\n    };\n\n    const vTarget = Vector.create(target);\n\n    if (!parent) {\n      vTarget.appendTo(this.graph.view.stage);\n    }\n\n    const onComplete = options.complete;\n\n    options.complete = e => {\n      revert();\n\n      if (onComplete) {\n        onComplete(e);\n      }\n    };\n\n    return vTarget.animateTransform(options);\n  }\n\n  hasTools(name) {\n    const tools = this.tools;\n\n    if (tools == null) {\n      return false;\n    }\n\n    if (name == null) {\n      return true;\n    }\n\n    return tools.name === name;\n  }\n\n  addTools(config) {\n    if (!this.can('toolsAddable')) {\n      return this;\n    }\n\n    this.removeTools();\n\n    if (config) {\n      const tools = ToolsView.isToolsView(config) ? config : new ToolsView(config);\n      this.tools = tools;\n      this.graph.on('tools:hide', this.hideTools, this);\n      this.graph.on('tools:show', this.showTools, this);\n      this.graph.on('tools:remove', this.removeTools, this);\n      tools.config({\n        view: this\n      });\n      tools.mount();\n    }\n\n    return this;\n  }\n\n  updateTools() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.tools) {\n      this.tools.update(options);\n    }\n\n    return this;\n  }\n\n  removeTools() {\n    if (this.tools) {\n      this.tools.remove();\n      this.graph.off('tools:hide', this.hideTools, this);\n      this.graph.off('tools:show', this.showTools, this);\n      this.graph.off('tools:remove', this.removeTools, this);\n      this.tools = null;\n    }\n\n    return this;\n  }\n\n  hideTools() {\n    if (this.tools) {\n      this.tools.hide();\n    }\n\n    return this;\n  }\n\n  showTools() {\n    if (this.tools) {\n      this.tools.show();\n    }\n\n    return this;\n  }\n\n  renderTools() {\n    const tools = this.cell.getTools();\n    this.addTools(tools);\n    return this;\n  }\n\n  notify(name, args) {\n    this.trigger(name, args);\n    this.graph.trigger(name, args);\n    return this;\n  }\n\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    const cell = view.cell;\n\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        cell\n      };\n    }\n\n    return {\n      e,\n      x,\n      y,\n      view,\n      cell\n    };\n  }\n\n  onClick(e, x, y) {\n    this.notify('cell:click', this.getEventArgs(e, x, y));\n  }\n\n  onDblClick(e, x, y) {\n    this.notify('cell:dblclick', this.getEventArgs(e, x, y));\n  }\n\n  onContextMenu(e, x, y) {\n    this.notify('cell:contextmenu', this.getEventArgs(e, x, y));\n  }\n\n  onMouseDown(e, x, y) {\n    if (this.cell.model) {\n      this.cachedModelForMouseEvent = this.cell.model;\n      this.cachedModelForMouseEvent.startBatch('mouse');\n    }\n\n    this.notify('cell:mousedown', this.getEventArgs(e, x, y));\n  }\n\n  onMouseUp(e, x, y) {\n    this.notify('cell:mouseup', this.getEventArgs(e, x, y));\n\n    if (this.cachedModelForMouseEvent) {\n      this.cachedModelForMouseEvent.stopBatch('mouse', {\n        cell: this.cell\n      });\n      this.cachedModelForMouseEvent = null;\n    }\n  }\n\n  onMouseMove(e, x, y) {\n    this.notify('cell:mousemove', this.getEventArgs(e, x, y));\n  }\n\n  onMouseOver(e) {\n    this.notify('cell:mouseover', this.getEventArgs(e));\n  }\n\n  onMouseOut(e) {\n    this.notify('cell:mouseout', this.getEventArgs(e));\n  }\n\n  onMouseEnter(e) {\n    this.notify('cell:mouseenter', this.getEventArgs(e));\n  }\n\n  onMouseLeave(e) {\n    this.notify('cell:mouseleave', this.getEventArgs(e));\n  }\n\n  onMouseWheel(e, x, y, delta) {\n    this.notify('cell:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n\n  onCustomEvent(e, name, x, y) {\n    this.notify('cell:customevent', Object.assign({\n      name\n    }, this.getEventArgs(e, x, y)));\n    this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));\n  }\n\n  onMagnetMouseDown(e, magnet, x, y) {}\n\n  onMagnetDblClick(e, magnet, x, y) {}\n\n  onMagnetContextMenu(e, magnet, x, y) {}\n\n  onLabelMouseDown(e, x, y) {}\n\n  checkMouseleave(e) {\n    const graph = this.graph;\n\n    if (graph.renderer.isAsync()) {\n      // Do the updates of the current view synchronously now\n      graph.renderer.dumpView(this);\n    }\n\n    const target = this.getEventTarget(e, {\n      fromPoint: true\n    });\n    const view = graph.renderer.findViewByElem(target);\n\n    if (view === this) {\n      return;\n    } // Leaving the current view\n\n\n    this.onMouseLeave(e);\n\n    if (!view) {\n      return;\n    } // Entering another view\n\n\n    view.onMouseEnter(e);\n  }\n\n}\nCellView.defaults = {\n  isSvgElement: true,\n  rootSelector: 'root',\n  priority: 0,\n  bootstrap: [],\n  actions: {}\n};\n\n(function (CellView) {\n  CellView.Flag = FlagManager;\n  CellView.Attr = AttrManager;\n})(CellView || (CellView = {}));\n\n(function (CellView) {\n  CellView.toStringTag = `X6.${CellView.name}`;\n\n  function isCellView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof CellView) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n\n    if ((tag == null || tag === CellView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  CellView.isCellView = isCellView;\n})(CellView || (CellView = {})); // decorators\n// ----\n\n\n(function (CellView) {\n  function priority(value) {\n    return function (ctor) {\n      ctor.config({\n        priority: value\n      });\n    };\n  }\n\n  CellView.priority = priority;\n\n  function bootstrap(actions) {\n    return function (ctor) {\n      ctor.config({\n        bootstrap: actions\n      });\n    };\n  }\n\n  CellView.bootstrap = bootstrap;\n})(CellView || (CellView = {}));\n\n(function (CellView) {\n  CellView.registry = Registry.create({\n    type: 'view'\n  });\n})(CellView || (CellView = {}));","map":null,"metadata":{},"sourceType":"module"}