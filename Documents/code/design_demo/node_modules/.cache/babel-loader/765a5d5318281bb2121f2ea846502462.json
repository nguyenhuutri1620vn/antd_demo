{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Point, Line, Rectangle, Polyline, Ellipse, Path } from '../../geometry';\nimport { attr } from './attr';\nimport { sample, toPath, getPointsFromSvgElement } from './path';\nimport { ensureId, isSVGGraphicsElement, createSvgElement, isHTMLElement } from './elem';\nimport { getComputedStyle } from './style';\nimport { createSVGPoint, createSVGMatrix, decomposeMatrix, transformRectangle, transformStringToMatrix } from './matrix';\n/**\n * Returns the bounding box of the element after transformations are\n * applied. If `withoutTransformations` is `true`, transformations of\n * the element will not be considered when computing the bounding box.\n * If `target` is specified, bounding box will be computed relatively\n * to the `target` element.\n */\n\nexport function bbox(elem, withoutTransformations, target) {\n  let box;\n  const ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding\n  // box defined and so fall back to 'zero' dimension element.\n\n  if (!ownerSVGElement) {\n    return new Rectangle(0, 0, 0, 0);\n  }\n\n  try {\n    box = elem.getBBox();\n  } catch (e) {\n    // Fallback for IE.\n    box = {\n      x: elem.clientLeft,\n      y: elem.clientTop,\n      width: elem.clientWidth,\n      height: elem.clientHeight\n    };\n  }\n\n  if (withoutTransformations) {\n    return Rectangle.create(box);\n  }\n\n  const matrix = getTransformToElement(elem, target || ownerSVGElement);\n  return transformRectangle(box, matrix);\n}\n/**\n * Returns the bounding box of the element after transformations are\n * applied. Unlike `bbox()`, this function fixes a browser implementation\n * bug to return the correct bounding box if this elemenent is a group of\n * svg elements (if `options.recursive` is specified).\n */\n\nexport function getBBox(elem) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let outputBBox;\n  const ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding box\n  // defined and so fall back to 'zero' dimension element.\n  // If the element is not an SVGGraphicsElement, we could not measure the\n  // bounding box either\n\n  if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {\n    if (isHTMLElement(elem)) {\n      // If the element is a HTMLElement, return the position relative to the body\n      const {\n        left,\n        top,\n        width,\n        height\n      } = getBoundingOffsetRect(elem);\n      return new Rectangle(left, top, width, height);\n    }\n\n    return new Rectangle(0, 0, 0, 0);\n  }\n\n  let target = options.target;\n  const recursive = options.recursive;\n\n  if (!recursive) {\n    try {\n      outputBBox = elem.getBBox();\n    } catch (e) {\n      outputBBox = {\n        x: elem.clientLeft,\n        y: elem.clientTop,\n        width: elem.clientWidth,\n        height: elem.clientHeight\n      };\n    }\n\n    if (!target) {\n      return Rectangle.create(outputBBox);\n    } // transform like target\n\n\n    const matrix = getTransformToElement(elem, target);\n    return transformRectangle(outputBBox, matrix);\n  } // recursive\n\n\n  {\n    const children = elem.childNodes;\n    const n = children.length;\n\n    if (n === 0) {\n      return getBBox(elem, {\n        target\n      });\n    }\n\n    if (!target) {\n      target = elem; // eslint-disable-line\n    }\n\n    for (let i = 0; i < n; i += 1) {\n      const child = children[i];\n      let childBBox;\n\n      if (child.childNodes.length === 0) {\n        childBBox = getBBox(child, {\n          target\n        });\n      } else {\n        // if child is a group element, enter it with a recursive call\n        childBBox = getBBox(child, {\n          target,\n          recursive: true\n        });\n      }\n\n      if (!outputBBox) {\n        outputBBox = childBBox;\n      } else {\n        outputBBox = outputBBox.union(childBBox);\n      }\n    }\n\n    return outputBBox;\n  }\n} // BBox is calculated by the attribute on the node\n\nexport function getBBoxByElementAttr(elem) {\n  let node = elem;\n  let tagName = node ? node.tagName.toLowerCase() : ''; // find shape node\n\n  while (tagName === 'g') {\n    node = node.firstElementChild;\n    tagName = node ? node.tagName.toLowerCase() : '';\n  }\n\n  const attr = name => {\n    const s = node.getAttribute(name);\n    const v = s ? parseFloat(s) : 0;\n    return Number.isNaN(v) ? 0 : v;\n  };\n\n  let r;\n  let bbox;\n\n  switch (tagName) {\n    case 'rect':\n      bbox = new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n      break;\n\n    case 'circle':\n      r = attr('r');\n      bbox = new Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r);\n      break;\n\n    default:\n      break;\n  }\n\n  return bbox;\n} // Matrix is calculated by the transform attribute on the node\n\nexport function getMatrixByElementAttr(elem, target) {\n  let matrix = createSVGMatrix();\n\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    let node = elem;\n    const matrixList = [];\n\n    while (node && node !== target) {\n      const transform = node.getAttribute('transform') || null;\n      const nodeMatrix = transformStringToMatrix(transform);\n      matrixList.push(nodeMatrix);\n      node = node.parentNode;\n    }\n\n    matrixList.reverse().forEach(m => {\n      matrix = matrix.multiply(m);\n    });\n  }\n\n  return matrix;\n}\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\n\nexport function getTransformToElement(elem, target) {\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    const targetCTM = target.getScreenCTM();\n    const nodeCTM = elem.getScreenCTM();\n\n    if (targetCTM && nodeCTM) {\n      return targetCTM.inverse().multiply(nodeCTM);\n    }\n  } // Could not get actual transformation matrix\n\n\n  return createSVGMatrix();\n}\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\n\nexport function toLocalPoint(elem, x, y) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n  const p = svg.createSVGPoint();\n  p.x = x;\n  p.y = y;\n\n  try {\n    const ctm = svg.getScreenCTM();\n    const globalPoint = p.matrixTransform(ctm.inverse());\n    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();\n    return globalPoint.matrixTransform(globalToLocalMatrix);\n  } catch (e) {\n    return p;\n  }\n}\n/**\n * Convert the SVGElement to an equivalent geometric shape. The element's\n * transformations are not taken into account.\n *\n * SVGRectElement      => Rectangle\n *\n * SVGLineElement      => Line\n *\n * SVGCircleElement    => Ellipse\n *\n * SVGEllipseElement   => Ellipse\n *\n * SVGPolygonElement   => Polyline\n *\n * SVGPolylineElement  => Polyline\n *\n * SVGPathElement      => Path\n *\n * others              => Rectangle\n */\n\nexport function toGeometryShape(elem) {\n  const attr = name => {\n    const s = elem.getAttribute(name);\n    const v = s ? parseFloat(s) : 0;\n    return Number.isNaN(v) ? 0 : v;\n  };\n\n  switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n    case 'rect':\n      return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n\n    case 'circle':\n      return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));\n\n    case 'ellipse':\n      return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));\n\n    case 'polyline':\n      {\n        const points = getPointsFromSvgElement(elem);\n        return new Polyline(points);\n      }\n\n    case 'polygon':\n      {\n        const points = getPointsFromSvgElement(elem);\n\n        if (points.length > 1) {\n          points.push(points[0]);\n        }\n\n        return new Polyline(points);\n      }\n\n    case 'path':\n      {\n        let d = elem.getAttribute('d');\n\n        if (!Path.isValid(d)) {\n          d = Path.normalize(d);\n        }\n\n        return Path.parse(d);\n      }\n\n    case 'line':\n      {\n        return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));\n      }\n\n    default:\n      break;\n  } // Anything else is a rectangle\n\n\n  return getBBox(elem);\n}\nexport function getIntersection(elem, ref, target) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n  target = target || svg; // eslint-disable-line\n\n  const bbox = getBBox(target);\n  const center = bbox.getCenter();\n\n  if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {\n    return null;\n  }\n\n  let spot = null;\n  const tagName = elem.tagName.toLowerCase(); // Little speed up optimization for `<rect>` element. We do not do convert\n  // to path element and sampling but directly calculate the intersection\n  // through a transformed geometrical rectangle.\n\n  if (tagName === 'rect') {\n    const gRect = new Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0')); // Get the rect transformation matrix with regards to the SVG document.\n\n    const rectMatrix = getTransformToElement(elem, target);\n    const rectMatrixComponents = decomposeMatrix(rectMatrix); // Rotate the rectangle back so that we can use\n    // `intersectsWithLineFromCenterToPoint()`.\n\n    const reseted = svg.createSVGTransform();\n    reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n    const rect = transformRectangle(gRect, reseted.matrix.multiply(rectMatrix));\n    spot = Rectangle.create(rect).intersectsWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n  } else if (tagName === 'path' || tagName === 'polygon' || tagName === 'polyline' || tagName === 'circle' || tagName === 'ellipse') {\n    const pathNode = tagName === 'path' ? elem : toPath(elem);\n    const samples = sample(pathNode);\n    let minDistance = Infinity;\n    let closestSamples = [];\n\n    for (let i = 0, ii = samples.length; i < ii; i += 1) {\n      const sample = samples[i]; // Convert the sample point in the local coordinate system\n      // to the global coordinate system.\n\n      let gp = createSVGPoint(sample.x, sample.y);\n      gp = gp.matrixTransform(getTransformToElement(elem, target));\n      const ggp = Point.create(gp);\n      const centerDistance = ggp.distance(center); // Penalize a higher distance to the reference point by 10%.\n      // This gives better results. This is due to\n      // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n\n      const refDistance = ggp.distance(ref) * 1.1;\n      const distance = centerDistance + refDistance;\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestSamples = [{\n          sample,\n          refDistance\n        }];\n      } else if (distance < minDistance + 1) {\n        closestSamples.push({\n          sample,\n          refDistance\n        });\n      }\n    }\n\n    closestSamples.sort((a, b) => a.refDistance - b.refDistance);\n\n    if (closestSamples[0]) {\n      spot = Point.create(closestSamples[0].sample);\n    }\n  }\n\n  return spot;\n}\nexport function animate(elem, options) {\n  return createAnimation(elem, options, 'animate');\n}\nexport function animateTransform(elem, options) {\n  return createAnimation(elem, options, 'animateTransform');\n}\n\nfunction createAnimation(elem, options, type) {\n  // @see\n  // https://www.w3.org/TR/SVG11/animate.html#AnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement\n  const animate = createSvgElement(type);\n  elem.appendChild(animate);\n\n  try {\n    return setupAnimation(animate, options);\n  } catch (error) {// pass\n  }\n\n  return () => {};\n}\n\nfunction setupAnimation(animate, options) {\n  const {\n    start,\n    complete,\n    repeat\n  } = options,\n        attrs = __rest(options, [\"start\", \"complete\", \"repeat\"]);\n\n  attr(animate, attrs);\n  start && animate.addEventListener('beginEvent', start);\n  complete && animate.addEventListener('endEvent', complete);\n  repeat && animate.addEventListener('repeatEvent', repeat);\n  const ani = animate;\n  ani.beginElement();\n  return () => ani.endElement();\n}\n/**\n * Animate the element along the path SVG element (or Vector object).\n * `attrs` contain Animation Timing attributes describing the animation.\n */\n\n\nexport function animateAlongPath(elem, options, path) {\n  const id = ensureId(path); // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement\n\n  const animate = createSvgElement('animateMotion');\n  const mpath = createSvgElement('mpath');\n  attr(mpath, {\n    'xlink:href': `#${id}`\n  });\n  animate.appendChild(mpath);\n  elem.appendChild(animate);\n\n  try {\n    return setupAnimation(animate, options);\n  } catch (e) {\n    // Fallback for IE 9.\n    if (document.documentElement.getAttribute('smiling') === 'fake') {\n      // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n      const ani = animate;\n      ani.animators = [];\n      const win = window;\n      const animationID = ani.getAttribute('id');\n\n      if (animationID) {\n        win.id2anim[animationID] = ani;\n      }\n\n      const targets = win.getTargets(ani);\n\n      for (let i = 0, ii = targets.length; i < ii; i += 1) {\n        const target = targets[i];\n        const animator = new win.Animator(ani, target, i);\n        win.animators.push(animator);\n        ani.animators[i] = animator;\n        animator.register();\n      }\n    }\n  }\n\n  return () => {};\n}\nexport function getBoundingOffsetRect(elem) {\n  let left = 0;\n  let top = 0;\n  let width = 0;\n  let height = 0;\n\n  if (elem) {\n    let current = elem;\n\n    while (current) {\n      left += current.offsetLeft;\n      top += current.offsetTop;\n      current = current.offsetParent;\n\n      if (current) {\n        left += parseInt(getComputedStyle(current, 'borderLeft'), 10);\n        top += parseInt(getComputedStyle(current, 'borderTop'), 10);\n      }\n    }\n\n    width = elem.offsetWidth;\n    height = elem.offsetHeight;\n  }\n\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n}","map":null,"metadata":{},"sourceType":"module"}