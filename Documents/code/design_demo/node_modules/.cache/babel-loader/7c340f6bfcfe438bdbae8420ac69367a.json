{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { Bounds, GeoCoordinates, Point, toLngLat } from '@antv/geo-coord';\nimport { createLayerContainer } from '@antv/l7-core';\nimport ImageTile from './ImageTile';\nimport TileCache from './tileCache';\nvar CacheLimit = 30;\n\nvar Tile = function () {\n  function Tile(props) {\n    _classCallCheck(this, Tile);\n\n    _defineProperty(this, \"tileList\", {});\n\n    _defineProperty(this, \"tileCache\", void 0);\n\n    _defineProperty(this, \"updateTileList\", void 0);\n\n    _defineProperty(this, \"tileZoom\", void 0);\n\n    _defineProperty(this, \"noPruneRange\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"resolution\", void 0);\n\n    _defineProperty(this, \"maxSourceZoom\", void 0);\n\n    _defineProperty(this, \"crstype\", void 0);\n\n    _defineProperty(this, \"currentCrs\", void 0);\n\n    _defineProperty(this, \"layerService\", void 0);\n\n    _defineProperty(this, \"layer\", void 0);\n\n    this.layerService = props.layerService;\n    this.layer = props.layer;\n    this.url = props.url;\n    this.resolution = props.resolution === 'low' ? -1 : 0;\n    this.maxSourceZoom = props.maxSourceZoom;\n    this.crstype = props.crstype;\n    this.currentCrs = new GeoCoordinates.default({\n      start: {\n        x: 0,\n        y: 0\n      },\n      end: {\n        x: 0,\n        y: 0\n      },\n      projection: this.crstype\n    }).crs;\n    this.destroyTile = this.destroyTile.bind(this);\n    this.tileCache = new TileCache(CacheLimit, this.destroyTile);\n    this.updateTileList = [];\n    this.removeTiles = this.removeTiles.bind(this);\n  }\n\n  _createClass(Tile, [{\n    key: \"calCurrentTiles\",\n    value: function calCurrentTiles(oprions) {\n      var _this = this;\n\n      var NE = oprions.NE,\n          SW = oprions.SW,\n          tileCenter = oprions.tileCenter,\n          currentZoom = oprions.currentZoom,\n          minSourceZoom = oprions.minSourceZoom,\n          minZoom = oprions.minZoom,\n          maxZoom = oprions.maxZoom;\n\n      if (currentZoom >= this.maxSourceZoom) {\n        return;\n      }\n\n      var zoom = Math.floor(currentZoom) + this.resolution;\n      this.tileZoom = zoom > this.maxSourceZoom ? this.maxSourceZoom : zoom;\n\n      if (currentZoom < minZoom || currentZoom >= maxZoom || currentZoom < minSourceZoom) {\n        this.removeTiles();\n        return;\n      }\n\n      this.updateTileList = [];\n      var centerPoint = this.currentCrs.lngLatToPoint(toLngLat(tileCenter.lng, tileCenter.lat), this.tileZoom);\n      var centerXY = centerPoint.divideBy(256).floor();\n      var pixelBounds = this.getPixelBounds(NE, SW, tileCenter, this.tileZoom, this.currentCrs);\n      var tileRange = this.pxBoundsToTileRange(pixelBounds);\n      var margin = 4;\n      this.noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));\n\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = [i, j, this.tileZoom];\n          var tile = this.tileList[coords.join('_')];\n\n          if (tile) {\n            tile.current = true;\n          } else {\n            this.tileList[coords.join('_')] = {\n              current: true,\n              coords: coords\n            };\n            this.updateTileList.push(coords);\n          }\n        }\n      }\n\n      this.updateTileList.sort(function (a, b) {\n        var tile1 = a;\n        var tile2 = b;\n        var d1 = Math.pow(tile1[0] * 1 - centerXY.x, 2) + Math.pow(tile1[1] * 1 - centerXY.y, 2);\n        var d2 = Math.pow(tile2[0] * 1 - centerXY.x, 2) + Math.pow(tile2[1] * 1 - centerXY.y, 2);\n        return d1 - d2;\n      });\n      this.pruneTiles();\n      this.updateTileList.forEach(function (coords) {\n        var key = coords.join('_');\n\n        if (_this.tileList[key].current) {\n          _this.requestTile(key);\n        }\n      });\n    }\n  }, {\n    key: \"pxBoundsToTileRange\",\n    value: function pxBoundsToTileRange(pixelBounds) {\n      return new Bounds(pixelBounds.min.divideBy(256).floor(), pixelBounds.max.divideBy(256).ceil().subtract([1, 1]));\n    }\n  }, {\n    key: \"getPixelBounds\",\n    value: function getPixelBounds(NE, SW, tileCenter, tileZoom, crs) {\n      var zoom = tileZoom;\n      var NEPoint = crs.lngLatToPoint(toLngLat(NE.lng, NE.lat), zoom);\n      var SWPoint = crs.lngLatToPoint(toLngLat(SW.lng, SW.lat), zoom);\n      var centerPoint = crs.lngLatToPoint(toLngLat(tileCenter.lng, tileCenter.lat), zoom);\n      var topHeight = centerPoint.y - NEPoint.y;\n      var bottomHeight = SWPoint.y - centerPoint.y;\n      var leftWidth;\n      var rightWidth;\n\n      if (tileCenter.lng - NE.lng > 0 || tileCenter.lng - SW.lng < 0) {\n        var width = Math.pow(2, zoom) * 256 / 360 * (180 - NE.lng) + Math.pow(2, zoom) * 256 / 360 * (SW.lng + 180);\n\n        if (tileCenter.lng - NE.lng > 0) {\n          leftWidth = Math.pow(2, zoom) * 256 / 360 * (tileCenter.lng - NE.lng);\n          rightWidth = width - leftWidth;\n        } else {\n          rightWidth = Math.pow(2, zoom) * 256 / 360 * (SW.lng - tileCenter.lng);\n          leftWidth = width - rightWidth;\n        }\n      } else {\n        leftWidth = Math.pow(2, zoom) * 256 / 360 * (tileCenter.lng - SW.lng);\n        rightWidth = Math.pow(2, zoom) * 256 / 360 * (NE.lng - tileCenter.lng);\n      }\n\n      var pixelBounds = new Bounds(centerPoint.subtract(leftWidth, topHeight), centerPoint.add(rightWidth, bottomHeight));\n      return pixelBounds;\n    }\n  }, {\n    key: \"pruneTiles\",\n    value: function pruneTiles() {\n      var _this2 = this;\n\n      Object.keys(this.tileList).map(function (key) {\n        var c = _this2.tileList[key].coords;\n\n        if (c[2] !== _this2.tileZoom || !_this2.noPruneRange.contains(new Point(c[0], c[1]))) {\n          _this2.tileList[key].current = false;\n        }\n      });\n      Object.keys(this.tileList).map(function (key) {\n        var tile = _this2.tileList[key];\n        tile.retain = tile.current;\n      });\n      Object.keys(this.tileList).map(function (key) {\n        var tile = _this2.tileList[key];\n\n        if (tile.current && !tile.active) {\n          var _key$split$map = key.split('_').map(function (v) {\n            return Number(v);\n          }),\n              _key$split$map2 = _slicedToArray(_key$split$map, 3),\n              x = _key$split$map2[0],\n              y = _key$split$map2[1],\n              z = _key$split$map2[2];\n\n          if (!_this2.retainParent(x, y, z, z - 5)) {\n            _this2.retainChildren(x, y, z, z + 2);\n          }\n        }\n      });\n      this.removeOutTiles();\n    }\n  }, {\n    key: \"requestTile\",\n    value: function requestTile(key) {\n      var t = this.tileList[key];\n\n      if (!t) {\n        return;\n      }\n\n      var tile = this.tileCache.getTile(key);\n\n      if (!tile) {\n        var container = createLayerContainer(this.layer.sceneContainer);\n        tile = new ImageTile(key, this.url, container, this.layer.sceneContainer);\n        tile.name = key;\n        t.current = true;\n        t.retain = true;\n        t.active = true;\n        this.layer.layerChildren.push(tile.imageLayer);\n        this.tileCache.setTile(tile, key);\n        this.pruneTiles();\n        this.layerService.updateLayerRenderList();\n        this.layerService.renderLayers();\n      } else {\n        tile.imageLayer.show();\n        t.current = true;\n        t.retain = true;\n        t.active = true;\n        this.pruneTiles();\n      }\n    }\n  }, {\n    key: \"retainParent\",\n    value: function retainParent(x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2);\n      var y2 = Math.floor(y / 2);\n      var z2 = z - 1;\n      var tile = this.tileList[[x2, y2, z2].join('_')];\n\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n\n      if (z2 > minZoom) {\n        return this.retainParent(x2, y2, z2, minZoom);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"retainChildren\",\n    value: function retainChildren(x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var key = [i, j, z + 1].join('_');\n          var tile = this.tileList[key];\n\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n\n          if (z + 1 < maxZoom) {\n            this.retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"destroyTile\",\n    value: function destroyTile(tile) {\n      var layerIndex = this.layer.layerChildren.indexOf(tile.imageLayer);\n\n      if (layerIndex > -1) {\n        this.layer.layerChildren.splice(layerIndex, 1);\n      }\n\n      tile.imageLayer.destroy();\n      this.layerService.updateLayerRenderList();\n      this.layerService.renderLayers();\n      tile = null;\n    }\n  }, {\n    key: \"removeOutTiles\",\n    value: function removeOutTiles() {\n      for (var key in this.tileList) {\n        if (!this.tileList[key].retain) {\n          var tile = this.tileCache.getTile(key);\n\n          if (tile) {\n            tile.imageLayer.hide();\n          }\n\n          delete this.tileList[key];\n        }\n      }\n    }\n  }, {\n    key: \"removeTiles\",\n    value: function removeTiles() {\n      this.layer.layerChildren.forEach(function (layer) {\n        layer.destroy();\n      });\n      this.layer.layerChildren = [];\n      this.layerService.updateLayerRenderList();\n      this.layerService.renderLayers();\n      this.tileList = {};\n      this.tileCache.destory();\n    }\n  }]);\n\n  return Tile;\n}();\n\nexport { Tile as default };","map":null,"metadata":{},"sourceType":"module"}