{"ast":null,"code":"import { Util, Config } from '../global';\nimport { ArrayExt, FunctionExt, Dom, Vector } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Cell } from '../model/cell';\nimport { CellView } from './cell';\nimport { Markup } from './markup';\nexport class NodeView extends CellView {\n  constructor() {\n    super(...arguments);\n    this.scalableNode = null;\n    this.rotatableNode = null;\n    this.scalableSelector = 'scalable';\n    this.rotatableSelector = 'rotatable';\n    this.defaultPortMarkup = Markup.getPortMarkup();\n    this.defaultPortLabelMarkup = Markup.getPortLabelMarkup();\n    this.defaultPortContainerMarkup = Markup.getPortContainerMarkup();\n    this.portsCache = {}; // #endregion\n  }\n\n  get [Symbol.toStringTag]() {\n    return NodeView.toStringTag;\n  }\n\n  getContainerClassName() {\n    const classList = [super.getContainerClassName(), this.prefixClassName('node')];\n\n    if (!this.can('nodeMovable')) {\n      classList.push(this.prefixClassName('node-immovable'));\n    }\n\n    return classList.join(' ');\n  }\n\n  updateClassName(e) {\n    const target = e.target;\n\n    if (target.hasAttribute('magnet')) {\n      // port\n      const className = this.prefixClassName('port-unconnectable');\n\n      if (this.can('magnetConnectable')) {\n        Dom.removeClass(target, className);\n      } else {\n        Dom.addClass(target, className);\n      }\n    } else {\n      // node\n      const className = this.prefixClassName('node-immovable');\n\n      if (this.can('nodeMovable')) {\n        this.removeClass(className);\n      } else {\n        this.addClass(className);\n      }\n    }\n  }\n\n  isNodeView() {\n    return true;\n  }\n\n  confirmUpdate(flag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let ret = flag;\n\n    if (this.hasAction(ret, 'ports')) {\n      this.removePorts();\n      this.cleanPortsCache();\n    }\n\n    if (this.hasAction(ret, 'render')) {\n      this.render();\n      ret = this.removeAction(ret, ['render', 'update', 'resize', 'translate', 'rotate', 'ports', 'tools']);\n    } else {\n      ret = this.handleAction(ret, 'resize', () => this.resize(options), 'update');\n      ret = this.handleAction(ret, 'update', () => this.update(), // `update()` will render ports when useCSSSelectors are enabled\n      Config.useCSSSelector ? 'ports' : null);\n      ret = this.handleAction(ret, 'translate', () => this.translate());\n      ret = this.handleAction(ret, 'rotate', () => this.rotate());\n      ret = this.handleAction(ret, 'ports', () => this.renderPorts());\n      ret = this.handleAction(ret, 'tools', () => this.renderTools());\n    }\n\n    return ret;\n  }\n\n  update(partialAttrs) {\n    this.cleanCache(); // When CSS selector strings are used, make sure no rule matches port nodes.\n\n    if (Config.useCSSSelector) {\n      this.removePorts();\n    }\n\n    const node = this.cell;\n    const size = node.getSize();\n    const attrs = node.getAttrs();\n    this.updateAttrs(this.container, attrs, {\n      attrs: partialAttrs === attrs ? null : partialAttrs,\n      rootBBox: new Rectangle(0, 0, size.width, size.height),\n      selectors: this.selectors,\n      scalableNode: this.scalableNode,\n      rotatableNode: this.rotatableNode\n    });\n\n    if (Config.useCSSSelector) {\n      this.renderPorts();\n    }\n  }\n\n  renderMarkup() {\n    const markup = this.cell.markup;\n\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.renderStringMarkup(markup);\n      }\n\n      return this.renderJSONMarkup(markup);\n    }\n\n    throw new TypeError('Invalid node markup.');\n  }\n\n  renderJSONMarkup(markup) {\n    const ret = this.parseJSONMarkup(markup, this.container);\n\n    const one = elems => Array.isArray(elems) ? elems[0] : elems;\n\n    this.selectors = ret.selectors;\n    this.rotatableNode = one(this.selectors[this.rotatableSelector]);\n    this.scalableNode = one(this.selectors[this.scalableSelector]);\n    this.container.appendChild(ret.fragment);\n  }\n\n  renderStringMarkup(markup) {\n    Dom.append(this.container, Vector.toNodes(Vector.createVectors(markup)));\n    this.rotatableNode = Dom.findOne(this.container, `.${this.rotatableSelector}`);\n    this.scalableNode = Dom.findOne(this.container, `.${this.scalableSelector}`);\n    this.selectors = {};\n\n    if (this.rootSelector) {\n      this.selectors[this.rootSelector] = this.container;\n    }\n  }\n\n  render() {\n    this.empty();\n    this.renderMarkup();\n\n    if (this.scalableNode) {\n      // Double update is necessary for elements with the scalable group only\n      // Note the `resize()` triggers the other `update`.\n      this.update();\n    }\n\n    this.resize();\n\n    if (this.rotatableNode) {\n      this.rotate();\n      this.translate();\n    } else {\n      this.updateTransform();\n    }\n\n    if (!Config.useCSSSelector) {\n      this.renderPorts();\n    }\n\n    this.renderTools();\n    return this;\n  }\n\n  resize() {\n    let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.scalableNode) {\n      return this.updateSize(opt);\n    }\n\n    if (this.cell.getAngle()) {\n      this.rotate();\n    }\n\n    this.update();\n  }\n\n  translate() {\n    if (this.rotatableNode) {\n      return this.updateTranslation();\n    }\n\n    this.updateTransform();\n  }\n\n  rotate() {\n    if (this.rotatableNode) {\n      this.updateRotation(); // It's necessary to call the update for the nodes outside\n      // the rotatable group referencing nodes inside the group\n\n      this.update();\n      return;\n    }\n\n    this.updateTransform();\n  }\n\n  getTranslationString() {\n    const position = this.cell.getPosition();\n    return `translate(${position.x},${position.y})`;\n  }\n\n  getRotationString() {\n    const angle = this.cell.getAngle();\n\n    if (angle) {\n      const size = this.cell.getSize();\n      return `rotate(${angle},${size.width / 2},${size.height / 2})`;\n    }\n  }\n\n  updateTransform() {\n    let transform = this.getTranslationString();\n    const rot = this.getRotationString();\n\n    if (rot) {\n      transform += ` ${rot}`;\n    }\n\n    this.container.setAttribute('transform', transform);\n  }\n\n  updateRotation() {\n    if (this.rotatableNode != null) {\n      const transform = this.getRotationString();\n\n      if (transform != null) {\n        this.rotatableNode.setAttribute('transform', transform);\n      } else {\n        this.rotatableNode.removeAttribute('transform');\n      }\n    }\n  }\n\n  updateTranslation() {\n    this.container.setAttribute('transform', this.getTranslationString());\n  }\n\n  updateSize() {\n    let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const cell = this.cell;\n    const size = cell.getSize();\n    const angle = cell.getAngle();\n    const scalableNode = this.scalableNode; // Getting scalable group's bbox.\n    // Due to a bug in webkit's native SVG .getBBox implementation, the\n    // bbox of groups with path children includes the paths' control points.\n    // To work around the issue, we need to check whether there are any path\n    // elements inside the scalable group.\n\n    let recursive = false;\n\n    if (scalableNode.getElementsByTagName('path').length > 0) {\n      // If scalable has at least one descendant that is a path, we need\n      // toswitch to recursive bbox calculation. Otherwise, group bbox\n      // calculation works and so we can use the (faster) native function.\n      recursive = true;\n    }\n\n    const scalableBBox = Dom.getBBox(scalableNode, {\n      recursive\n    }); // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero\n    // which can happen if the element does not have any content.\n\n    const sx = size.width / (scalableBBox.width || 1);\n    const sy = size.height / (scalableBBox.height || 1);\n    scalableNode.setAttribute('transform', `scale(${sx},${sy})`); // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n    // Order of transformations is significant but we want to reconstruct the object always in the order:\n    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\n    const rotatableNode = this.rotatableNode;\n\n    if (rotatableNode != null) {\n      const transform = rotatableNode.getAttribute('transform');\n\n      if (transform) {\n        rotatableNode.setAttribute('transform', `${transform} rotate(${-angle},${size.width / 2},${size.height / 2})`);\n        const rotatableBBox = Dom.getBBox(scalableNode, {\n          target: this.graph.view.stage\n        }); // Store new x, y and perform rotate() again against the new rotation origin.\n\n        cell.prop('position', {\n          x: rotatableBBox.x,\n          y: rotatableBBox.y\n        }, Object.assign({\n          updated: true\n        }, opt));\n        this.translate();\n        this.rotate();\n      }\n    } // Update must always be called on non-rotated element. Otherwise,\n    // relative positioning would work with wrong (rotated) bounding boxes.\n\n\n    this.update();\n  } // #region ports\n\n\n  findPortElem(portId, selector) {\n    const cache = portId ? this.portsCache[portId] : null;\n\n    if (!cache) {\n      return null;\n    }\n\n    const portRoot = cache.portContentElement;\n    const portSelectors = cache.portContentSelectors || {};\n    return this.findOne(selector, portRoot, portSelectors);\n  }\n\n  initializePorts() {\n    this.cleanPortsCache();\n  }\n\n  refreshPorts() {\n    this.removePorts();\n    this.cleanPortsCache();\n    this.renderPorts();\n  }\n\n  cleanPortsCache() {\n    this.portsCache = {};\n  }\n\n  removePorts() {\n    Object.keys(this.portsCache).forEach(portId => {\n      const cached = this.portsCache[portId];\n      Dom.remove(cached.portElement);\n    });\n  }\n\n  renderPorts() {\n    const container = this.getPortsContainer(); // References to rendered elements without z-index\n\n    const references = [];\n    container.childNodes.forEach(child => {\n      references.push(child);\n    });\n    const portsGropsByZ = ArrayExt.groupBy(this.cell.getParsedPorts(), 'zIndex');\n    const autoZIndexKey = 'auto'; // render non-z first\n\n    if (portsGropsByZ[autoZIndexKey]) {\n      portsGropsByZ[autoZIndexKey].forEach(port => {\n        const portElement = this.getPortElement(port);\n        container.append(portElement);\n        references.push(portElement);\n      });\n    }\n\n    Object.keys(portsGropsByZ).forEach(key => {\n      if (key !== autoZIndexKey) {\n        const zIndex = parseInt(key, 10);\n        this.appendPorts(portsGropsByZ[key], zIndex, references);\n      }\n    });\n    this.updatePorts();\n  }\n\n  getPortsContainer() {\n    return this.rotatableNode || this.container;\n  }\n\n  appendPorts(ports, zIndex, refs) {\n    const elems = ports.map(p => this.getPortElement(p));\n\n    if (refs[zIndex] || zIndex < 0) {\n      Dom.before(refs[Math.max(zIndex, 0)], elems);\n    } else {\n      Dom.append(this.getPortsContainer(), elems);\n    }\n  }\n\n  getPortElement(port) {\n    const cached = this.portsCache[port.id];\n\n    if (cached) {\n      return cached.portElement;\n    }\n\n    return this.createPortElement(port);\n  }\n\n  createPortElement(port) {\n    let renderResult = Markup.renderMarkup(this.getPortContainerMarkup());\n    const portElement = renderResult.elem;\n\n    if (portElement == null) {\n      throw new Error('Invalid port container markup.');\n    }\n\n    renderResult = Markup.renderMarkup(this.getPortMarkup(port));\n    const portContentElement = renderResult.elem;\n    const portContentSelectors = renderResult.selectors;\n\n    if (portContentElement == null) {\n      throw new Error('Invalid port markup.');\n    }\n\n    this.setAttrs({\n      port: port.id,\n      'port-group': port.group\n    }, portContentElement);\n    renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));\n    const portLabelElement = renderResult.elem;\n    const portLabelSelectors = renderResult.selectors;\n\n    if (portLabelElement == null) {\n      throw new Error('Invalid port label markup.');\n    }\n\n    let portSelectors;\n\n    if (portContentSelectors && portLabelSelectors) {\n      // eslint-disable-next-line\n      for (const key in portLabelSelectors) {\n        if (portContentSelectors[key] && key !== this.rootSelector) {\n          throw new Error('Selectors within port must be unique.');\n        }\n      }\n\n      portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);\n    } else {\n      portSelectors = portContentSelectors || portLabelSelectors;\n    }\n\n    Dom.addClass(portElement, 'x6-port');\n    Dom.addClass(portContentElement, 'x6-port-body');\n    Dom.addClass(portLabelElement, 'x6-port-label');\n    portElement.appendChild(portContentElement);\n    portElement.appendChild(portLabelElement);\n    this.portsCache[port.id] = {\n      portElement,\n      portSelectors,\n      portLabelElement,\n      portLabelSelectors,\n      portContentElement,\n      portContentSelectors\n    };\n    this.graph.hook.onPortRendered({\n      port,\n      node: this.cell,\n      container: portElement,\n      selectors: portSelectors,\n      labelContainer: portLabelElement,\n      labelSelectors: portLabelSelectors,\n      contentContainer: portContentElement,\n      contentSelectors: portContentSelectors\n    });\n    return portElement;\n  }\n\n  updatePorts() {\n    // Layout ports without group\n    this.updatePortGroup(); // Layout ports with explicit group\n\n    const groups = this.cell.getParsedGroups();\n    Object.keys(groups).forEach(groupName => this.updatePortGroup(groupName));\n  }\n\n  updatePortGroup(groupName) {\n    const bbox = Rectangle.fromSize(this.cell.getSize());\n    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);\n\n    for (let i = 0, n = metrics.length; i < n; i += 1) {\n      const metric = metrics[i];\n      const portId = metric.portId;\n      const cached = this.portsCache[portId] || {};\n      const portLayout = metric.portLayout;\n      this.applyPortTransform(cached.portElement, portLayout);\n\n      if (metric.portAttrs != null) {\n        const options = {\n          selectors: cached.portSelectors || {}\n        };\n\n        if (metric.portSize) {\n          options.rootBBox = Rectangle.fromSize(metric.portSize);\n        }\n\n        this.updateAttrs(cached.portElement, metric.portAttrs, options);\n      }\n\n      const labelLayout = metric.labelLayout;\n\n      if (labelLayout) {\n        this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));\n\n        if (labelLayout.attrs) {\n          const options = {\n            selectors: cached.portLabelSelectors || {}\n          };\n\n          if (metric.labelSize) {\n            options.rootBBox = Rectangle.fromSize(metric.labelSize);\n          }\n\n          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);\n        }\n      }\n    }\n  }\n\n  applyPortTransform(element, layout) {\n    let initialAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const angle = layout.angle;\n    const position = layout.position;\n    const matrix = Dom.createSVGMatrix().rotate(initialAngle).translate(position.x || 0, position.y || 0).rotate(angle || 0);\n    Dom.transform(element, matrix, {\n      absolute: true\n    });\n  }\n\n  getPortContainerMarkup() {\n    return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;\n  }\n\n  getPortMarkup(port) {\n    return port.markup || this.cell.portMarkup || this.defaultPortMarkup;\n  }\n\n  getPortLabelMarkup(label) {\n    return label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup;\n  }\n\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line\n\n    const node = view.cell;\n    const cell = node;\n\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        node,\n        cell\n      };\n    }\n\n    return {\n      e,\n      x,\n      y,\n      view,\n      node,\n      cell\n    };\n  }\n\n  notifyMouseDown(e, x, y) {\n    super.onMouseDown(e, x, y);\n    this.notify('node:mousedown', this.getEventArgs(e, x, y));\n  }\n\n  notifyMouseMove(e, x, y) {\n    super.onMouseMove(e, x, y);\n    this.notify('node:mousemove', this.getEventArgs(e, x, y));\n  }\n\n  notifyMouseUp(e, x, y) {\n    super.onMouseUp(e, x, y);\n    this.notify('node:mouseup', this.getEventArgs(e, x, y));\n  }\n\n  onClick(e, x, y) {\n    super.onClick(e, x, y);\n    this.notify('node:click', this.getEventArgs(e, x, y));\n  }\n\n  onDblClick(e, x, y) {\n    super.onDblClick(e, x, y);\n    this.notify('node:dblclick', this.getEventArgs(e, x, y));\n  }\n\n  onContextMenu(e, x, y) {\n    super.onContextMenu(e, x, y);\n    this.notify('node:contextmenu', this.getEventArgs(e, x, y));\n  }\n\n  onMouseDown(e, x, y) {\n    if (this.isPropagationStopped(e)) {\n      return;\n    }\n\n    this.notifyMouseDown(e, x, y);\n    this.startNodeDragging(e, x, y);\n  }\n\n  onMouseMove(e, x, y) {\n    const data = this.getEventData(e);\n    const action = data.action;\n\n    if (action === 'magnet') {\n      this.dragMagnet(e, x, y);\n    } else {\n      if (action === 'move') {\n        const meta = data;\n        const view = meta.targetView || this;\n        view.dragNode(e, x, y);\n        view.notify('node:moving', {\n          e,\n          x,\n          y,\n          view,\n          cell: view.cell,\n          node: view.cell\n        });\n      }\n\n      this.notifyMouseMove(e, x, y);\n    }\n\n    this.setEventData(e, data);\n  }\n\n  onMouseUp(e, x, y) {\n    const data = this.getEventData(e);\n    const action = data.action;\n\n    if (action === 'magnet') {\n      this.stopMagnetDragging(e, x, y);\n    } else {\n      this.notifyMouseUp(e, x, y);\n\n      if (action === 'move') {\n        const meta = data;\n        const view = meta.targetView || this;\n        view.stopNodeDragging(e, x, y);\n      }\n    }\n\n    const magnet = data.targetMagnet;\n\n    if (magnet) {\n      this.onMagnetClick(e, magnet, x, y);\n    }\n\n    this.checkMouseleave(e);\n  }\n\n  onMouseOver(e) {\n    super.onMouseOver(e);\n    this.notify('node:mouseover', this.getEventArgs(e));\n  }\n\n  onMouseOut(e) {\n    super.onMouseOut(e);\n    this.notify('node:mouseout', this.getEventArgs(e));\n  }\n\n  onMouseEnter(e) {\n    this.updateClassName(e);\n    super.onMouseEnter(e);\n    this.notify('node:mouseenter', this.getEventArgs(e));\n  }\n\n  onMouseLeave(e) {\n    super.onMouseLeave(e);\n    this.notify('node:mouseleave', this.getEventArgs(e));\n  }\n\n  onMouseWheel(e, x, y, delta) {\n    super.onMouseWheel(e, x, y, delta);\n    this.notify('node:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n\n  onMagnetClick(e, magnet, x, y) {\n    const count = this.graph.view.getMouseMovedCount(e);\n\n    if (count > this.graph.options.clickThreshold) {\n      return;\n    }\n\n    this.notify('node:magnet:click', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n\n  onMagnetDblClick(e, magnet, x, y) {\n    this.notify('node:magnet:dblclick', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n\n  onMagnetContextMenu(e, magnet, x, y) {\n    this.notify('node:magnet:contextmenu', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n\n  onMagnetMouseDown(e, magnet, x, y) {\n    this.startMagnetDragging(e, x, y);\n  }\n\n  onCustomEvent(e, name, x, y) {\n    this.notify('node:customevent', Object.assign({\n      name\n    }, this.getEventArgs(e, x, y)));\n    super.onCustomEvent(e, name, x, y);\n  }\n\n  prepareEmbedding(e) {\n    // const cell = data.cell || this.cell\n    // const graph = data.graph || this.graph\n    // const model = graph.model\n    // model.startBatch('to-front')\n    // // Bring the model to the front with all his embeds.\n    // cell.toFront({ deep: true, ui: true })\n    // const maxZ = model\n    //   .getNodes()\n    //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)\n    // const connectedEdges = model.getConnectedEdges(cell, {\n    //   deep: true,\n    //   enclosed: true,\n    // })\n    // connectedEdges.forEach((edge) => {\n    //   const zIndex = edge.getZIndex() || 0\n    //   if (zIndex <= maxZ) {\n    //     edge.setZIndex(maxZ + 1, { ui: true })\n    //   }\n    // })\n    // model.stopBatch('to-front')\n    // Before we start looking for suitable parent we remove the current one.\n    // const parent = cell.getParent()\n    // if (parent) {\n    //   parent.unembed(cell, { ui: true })\n    // }\n    const data = this.getEventData(e);\n    const node = data.cell || this.cell;\n    const view = this.graph.findViewByCell(node);\n    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);\n    this.notify('node:embed', {\n      e,\n      node,\n      view,\n      cell: node,\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: node.getParent()\n    });\n  }\n\n  processEmbedding(e, data) {\n    const cell = data.cell || this.cell;\n    const graph = data.graph || this.graph;\n    const options = graph.options.embedding;\n    const findParent = options.findParent;\n    let candidates = typeof findParent === 'function' ? FunctionExt.call(findParent, graph, {\n      view: this,\n      node: this.cell\n    }).filter(c => {\n      return Cell.isCell(c) && this.cell.id !== c.id && !c.isDescendantOf(this.cell);\n    }) : graph.model.getNodesUnderNode(cell, {\n      by: findParent\n    }); // Picks the node with the highest `z` index\n\n    if (options.frontOnly) {\n      candidates = candidates.slice(-1);\n    }\n\n    let newCandidateView = null;\n    const prevCandidateView = data.candidateEmbedView;\n    const validateEmbeding = options.validate;\n\n    for (let i = candidates.length - 1; i >= 0; i -= 1) {\n      const candidate = candidates[i];\n\n      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView;\n        break;\n      } else {\n        const view = candidate.findView(graph);\n\n        if (FunctionExt.call(validateEmbeding, graph, {\n          child: this.cell,\n          parent: view.cell,\n          childView: this,\n          parentView: view\n        })) {\n          // flip to the new candidate\n          newCandidateView = view;\n          break;\n        }\n      }\n    }\n\n    this.clearEmbedding(data);\n\n    if (newCandidateView) {\n      newCandidateView.highlight(null, {\n        type: 'embedding'\n      });\n    }\n\n    data.candidateEmbedView = newCandidateView;\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n    this.notify('node:embedding', {\n      e,\n      cell,\n      node: cell,\n      view: graph.findViewByCell(cell),\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: cell.getParent(),\n      candidateParent: newCandidateView ? newCandidateView.cell : null\n    });\n  }\n\n  clearEmbedding(data) {\n    const candidateView = data.candidateEmbedView;\n\n    if (candidateView) {\n      candidateView.unhighlight(null, {\n        type: 'embedding'\n      });\n      data.candidateEmbedView = null;\n    }\n  }\n\n  finalizeEmbedding(e, data) {\n    const cell = data.cell || this.cell;\n    const graph = data.graph || this.graph;\n    const view = graph.findViewByCell(cell);\n    const parent = cell.getParent();\n    const candidateView = data.candidateEmbedView;\n\n    if (candidateView) {\n      // Candidate view is chosen to become the parent of the node.\n      candidateView.unhighlight(null, {\n        type: 'embedding'\n      });\n      data.candidateEmbedView = null;\n\n      if (parent == null || parent.id !== candidateView.cell.id) {\n        candidateView.cell.insertChild(cell, undefined, {\n          ui: true\n        });\n      }\n    } else if (parent) {\n      parent.unembed(cell, {\n        ui: true\n      });\n    }\n\n    graph.model.getConnectedEdges(cell, {\n      deep: true\n    }).forEach(edge => {\n      edge.updateParent({\n        ui: true\n      });\n    });\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n\n    if (view) {\n      view.notify('node:embedded', {\n        e,\n        cell,\n        x: localPoint.x,\n        y: localPoint.y,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        previousParent: parent,\n        currentParent: cell.getParent()\n      });\n    }\n  }\n\n  getDelegatedView() {\n    let cell = this.cell;\n    let view = this; // eslint-disable-line\n\n    while (view) {\n      if (cell.isEdge()) {\n        break;\n      }\n\n      if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n        return view;\n      }\n\n      cell = cell.getParent();\n      view = this.graph.renderer.findViewByCell(cell);\n    }\n\n    return null;\n  }\n\n  startMagnetDragging(e, x, y) {\n    if (!this.can('magnetConnectable')) {\n      return;\n    }\n\n    e.stopPropagation();\n    const magnet = e.currentTarget;\n    const graph = this.graph;\n    this.setEventData(e, {\n      targetMagnet: magnet\n    });\n\n    if (graph.hook.validateMagnet(this, magnet, e)) {\n      if (graph.options.magnetThreshold <= 0) {\n        this.startConnectting(e, magnet, x, y);\n      }\n\n      this.setEventData(e, {\n        action: 'magnet'\n      });\n      this.stopPropagation(e);\n    } else {\n      this.onMouseDown(e, x, y);\n    }\n\n    graph.view.delegateDragEvents(e, this);\n  }\n\n  startConnectting(e, magnet, x, y) {\n    this.graph.model.startBatch('add-edge');\n    const edgeView = this.createEdgeFromMagnet(magnet, x, y);\n    edgeView.notifyMouseDown(e, x, y); // backwards compatibility events\n\n    edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {\n      x,\n      y,\n      isNewEdge: true,\n      fallbackAction: 'remove'\n    }));\n    this.setEventData(e, {\n      edgeView\n    });\n  }\n\n  createEdgeFromMagnet(magnet, x, y) {\n    const graph = this.graph;\n    const model = graph.model;\n    const edge = graph.hook.getDefaultEdge(this, magnet);\n    edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));\n    edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n      x,\n      y\n    }));\n    edge.addTo(model, {\n      async: false,\n      ui: true\n    });\n    return edge.findView(graph);\n  }\n\n  dragMagnet(e, x, y) {\n    const data = this.getEventData(e);\n    const edgeView = data.edgeView;\n\n    if (edgeView) {\n      edgeView.onMouseMove(e, x, y);\n      this.autoScrollGraph(e.clientX, e.clientY);\n    } else {\n      const graph = this.graph;\n      const magnetThreshold = graph.options.magnetThreshold;\n      const currentTarget = this.getEventTarget(e);\n      const targetMagnet = data.targetMagnet; // magnetThreshold when the pointer leaves the magnet\n\n      if (magnetThreshold === 'onleave') {\n        if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {\n          return;\n        } // eslint-disable-next-line no-lonely-if\n\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n          return;\n        }\n      }\n\n      this.startConnectting(e, targetMagnet, x, y);\n    }\n  }\n\n  stopMagnetDragging(e, x, y) {\n    const data = this.eventData(e);\n    const edgeView = data.edgeView;\n\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y);\n      this.graph.model.stopBatch('add-edge');\n    }\n  }\n\n  notifyUnhandledMouseDown(e, x, y) {\n    this.notify('node:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      node: this.cell\n    });\n  }\n\n  notifyNodeMove(name, e, x, y, cell) {\n    let cells = [cell];\n    const selection = this.graph.selection.widget;\n\n    if (selection && selection.options.movable) {\n      const selectedCells = this.graph.getSelectedCells();\n\n      if (selectedCells.includes(cell)) {\n        cells = selectedCells.filter(c => c.isNode());\n      }\n    }\n\n    cells.forEach(c => {\n      this.notify(name, {\n        e,\n        x,\n        y,\n        cell: c,\n        node: c,\n        view: c.findView(this.graph)\n      });\n    });\n  }\n\n  startNodeDragging(e, x, y) {\n    const targetView = this.getDelegatedView();\n\n    if (targetView == null || !targetView.can('nodeMovable')) {\n      return this.notifyUnhandledMouseDown(e, x, y);\n    }\n\n    this.setEventData(e, {\n      targetView,\n      action: 'move'\n    });\n    const position = Point.create(targetView.cell.getPosition());\n    targetView.setEventData(e, {\n      moving: false,\n      offset: position.diff(x, y),\n      restrict: this.graph.hook.getRestrictArea(targetView)\n    });\n  }\n\n  dragNode(e, x, y) {\n    const node = this.cell;\n    const graph = this.graph;\n    const gridSize = graph.getGridSize();\n    const data = this.getEventData(e);\n    const offset = data.offset;\n    const restrict = data.restrict;\n\n    if (!data.moving) {\n      data.moving = true;\n      this.addClass('node-moving');\n      this.notifyNodeMove('node:move', e, x, y, this.cell);\n    }\n\n    this.autoScrollGraph(e.clientX, e.clientY);\n    const posX = Util.snapToGrid(x + offset.x, gridSize);\n    const posY = Util.snapToGrid(y + offset.y, gridSize);\n    node.setPosition(posX, posY, {\n      restrict,\n      deep: true,\n      ui: true\n    });\n\n    if (graph.options.embedding.enabled) {\n      if (!data.embedding) {\n        this.prepareEmbedding(e);\n        data.embedding = true;\n      }\n\n      this.processEmbedding(e, data);\n    }\n  }\n\n  stopNodeDragging(e, x, y) {\n    const data = this.getEventData(e);\n\n    if (data.embedding) {\n      this.finalizeEmbedding(e, data);\n    }\n\n    if (data.moving) {\n      this.removeClass('node-moving');\n      this.notifyNodeMove('node:moved', e, x, y, this.cell);\n    }\n\n    data.moving = false;\n    data.embedding = false;\n  }\n\n  autoScrollGraph(x, y) {\n    const scroller = this.graph.scroller.widget;\n\n    if (scroller) {\n      scroller.autoScroll(x, y);\n    }\n  }\n\n}\n\n(function (NodeView) {\n  NodeView.toStringTag = `X6.${NodeView.name}`;\n\n  function isNodeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof NodeView) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n\n    if ((tag == null || tag === NodeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.findPortElem === 'function' && typeof view.resize === 'function' && typeof view.rotate === 'function' && typeof view.translate === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  NodeView.isNodeView = isNodeView;\n})(NodeView || (NodeView = {}));\n\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools']\n  }\n});\nNodeView.registry.register('node', NodeView, true);","map":null,"metadata":{},"sourceType":"module"}