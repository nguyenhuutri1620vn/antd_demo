{"ast":null,"code":"import { Widget } from '../common';\nimport { Dom } from '../../util';\nimport { Angle, Point } from '../../geometry';\nexport class Knob extends Widget {\n  get node() {\n    return this.cell;\n  }\n\n  get metadata() {\n    const meta = this.cell.prop('knob');\n\n    if (Array.isArray(meta)) {\n      if (this.options.index != null) {\n        return meta[this.options.index];\n      }\n\n      return null;\n    }\n\n    return meta;\n  }\n\n  init(options) {\n    this.options = Object.assign({}, options);\n    this.render();\n    this.startListening();\n  }\n\n  startListening() {\n    this.delegateEvents({\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown'\n    });\n    this.model.on('*', this.update, this);\n    this.graph.on('scale', this.update, this);\n    this.graph.on('translate', this.update, this);\n    this.model.on('reseted', this.remove, this);\n    this.node.on('removed', this.remove, this);\n    this.view.on('node:resize:mousedown', this.onTransform, this);\n    this.view.on('node:rotate:mousedown', this.onTransform, this);\n    this.view.on('node:resize:mouseup', this.onTransformed, this);\n    this.view.on('node:rotate:mouseup', this.onTransformed, this);\n    this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);\n    this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);\n    super.startListening();\n  }\n\n  stopListening() {\n    this.undelegateEvents();\n    this.model.off('*', this.update, this);\n    this.graph.off('scale', this.update, this);\n    this.graph.off('translate', this.update, this);\n    this.model.off('reseted', this.remove, this);\n    this.node.off('removed', this.remove, this);\n    this.view.off('node:resize:mousedown', this.onTransform, this);\n    this.view.off('node:rotate:mousedown', this.onTransform, this);\n    this.view.off('node:resize:mouseup', this.onTransformed, this);\n    this.view.off('node:rotate:mouseup', this.onTransformed, this);\n    this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);\n    this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);\n    super.stopListening();\n  }\n\n  render() {\n    this.container = document.createElement('div');\n    Dom.addClass(this.container, this.prefixClassName('widget-knob'));\n\n    if (this.options.className) {\n      Dom.addClass(this.container, this.options.className);\n    }\n\n    this.view.addClass(Private.KNOB);\n    this.graph.container.appendChild(this.container);\n    this.update();\n    return this;\n  }\n\n  remove() {\n    this.view.removeClass(Private.KNOB);\n    return super.remove();\n  }\n\n  update() {\n    if (this.metadata) {\n      const {\n        update,\n        position\n      } = this.metadata;\n      const args = {\n        knob: this,\n        cell: this.cell,\n        node: this.node\n      };\n\n      if (position) {\n        const pos = position.call(this.graph, Object.assign({}, args));\n\n        if (pos) {\n          const ctm = this.graph.matrix();\n          const bbox = this.node.getBBox();\n          const angle = Angle.normalize(this.node.getAngle());\n          const local = Point.create(pos);\n\n          if (angle !== 0) {\n            local.rotate(-angle, {\n              x: bbox.width / 2,\n              y: bbox.height / 2\n            });\n          }\n\n          local.translate(bbox).scale(ctm.a, ctm.d).translate(ctm.e, ctm.f);\n          this.container.style.left = `${local.x}px`;\n          this.container.style.top = `${local.y}px`;\n        }\n      }\n\n      if (update) {\n        update.call(this.graph, Object.assign({}, args));\n      }\n    }\n  }\n\n  hide() {\n    this.container.style.display = 'none';\n  }\n\n  show() {\n    this.container.style.display = '';\n  }\n\n  onTransform() {\n    this.hide();\n  }\n\n  onTransformed() {\n    this.show();\n  }\n\n  onKnobMouseDown(_ref) {\n    let {\n      knob\n    } = _ref;\n\n    if (this.cid !== knob.cid) {\n      this.hide();\n    }\n  }\n\n  onKnobMouseUp() {\n    this.show();\n  }\n\n  notify(name, evt) {\n    if (this.view) {\n      const e = this.view.normalizeEvent(evt);\n      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);\n      this.view.notify(`cell:${name}`, {\n        e,\n        view: this.view,\n        node: this.node,\n        cell: this.cell,\n        x: localPoint.x,\n        y: localPoint.y,\n        knob: this\n      });\n\n      if (this.cell.isNode()) {\n        this.view.notify(`node:${name}`, {\n          e,\n          view: this.view,\n          node: this.node,\n          cell: this.cell,\n          x: localPoint.x,\n          y: localPoint.y,\n          knob: this\n        });\n      } else if (this.cell.isEdge()) {\n        this.view.notify(`edge:${name}`, {\n          e,\n          view: this.view,\n          edge: this.cell,\n          cell: this.cell,\n          x: localPoint.x,\n          y: localPoint.y,\n          knob: this\n        });\n      }\n    }\n  }\n\n  onMouseDown(e) {\n    e.stopPropagation();\n    this.setEventData(e, {\n      knobbing: false,\n      originX: e.clientX,\n      originY: e.clientY,\n      clientX: e.clientX,\n      clientY: e.clientY\n    });\n    this.graph.view.undelegateEvents();\n    this.delegateDocumentEvents(Private.documentEvents, e.data);\n\n    if (this.metadata && this.metadata.onMouseDown) {\n      this.metadata.onMouseDown.call(this.graph, {\n        e,\n        data: this.getEventData(e),\n        knob: this,\n        cell: this.cell,\n        node: this.node\n      });\n    }\n\n    this.notify('knob:mousedown', e);\n  }\n\n  onMouseMove(e) {\n    const data = this.getEventData(e);\n    const view = this.graph.findViewByCell(this.node);\n\n    if (!data.knobbing) {\n      data.knobbing = true;\n\n      if (view) {\n        view.addClass(Private.KNOBBING);\n        this.notify('knob', e);\n      }\n\n      this.model.startBatch('knob', {\n        cid: this.cid\n      });\n    }\n\n    data.clientX = e.clientX;\n    data.clientY = e.clientY;\n\n    if (this.metadata && this.metadata.onMouseMove) {\n      const ctm = this.graph.matrix();\n      const dx = (e.clientX - data.originX) / ctm.a;\n      const dy = (e.clientY - data.originY) / ctm.d;\n      const angle = this.node.getAngle();\n      const delta = new Point(dx, dy).rotate(angle);\n      this.metadata.onMouseMove.call(this.graph, {\n        e,\n        data,\n        deltaX: delta.x,\n        deltaY: delta.y,\n        knob: this,\n        cell: this.cell,\n        node: this.node\n      });\n    }\n\n    this.notify('knobbing', e);\n    this.notify('knob:mousemove', e);\n  }\n\n  onMouseUp(e) {\n    this.undelegateDocumentEvents();\n    this.graph.view.delegateEvents();\n    const data = this.getEventData(e);\n    const view = this.graph.findViewByCell(this.node);\n\n    if (data.knobbing) {\n      if (view) {\n        view.removeClass(Private.KNOBBING);\n      }\n\n      if (this.metadata && this.metadata.onMouseUp) {\n        this.metadata.onMouseUp.call(this.graph, {\n          e,\n          data,\n          knob: this,\n          cell: this.cell,\n          node: this.node\n        });\n      }\n\n      this.model.stopBatch('knob', {\n        cid: this.cid\n      });\n      this.notify('knobbed', e);\n    }\n\n    this.notify('knob:mouseup', e);\n  }\n\n}\nvar Private;\n\n(function (Private) {\n  Private.KNOB = 'has-widget-knob';\n  Private.KNOBBING = 'node-knobbing';\n  Private.documentEvents = {\n    mousemove: 'onMouseMove',\n    touchmove: 'onMouseMove',\n    mouseup: 'onMouseUp',\n    touchend: 'onMouseUp'\n  };\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}