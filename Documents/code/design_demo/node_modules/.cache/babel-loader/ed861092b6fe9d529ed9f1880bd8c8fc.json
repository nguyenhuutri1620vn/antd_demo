{"ast":null,"code":"import { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\nexport default class MDS {\n  constructor(params) {\n    this.distances = params.distances;\n    this.dimension = params.dimension || 2;\n    this.linkDistance = params.linkDistance;\n  }\n\n  layout() {\n    const self = this;\n    const {\n      dimension,\n      distances,\n      linkDistance\n    } = self;\n\n    try {\n      // square distances\n      const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n      const rowMeans = M.mean('row');\n      const colMeans = M.mean('column');\n      const totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n      // points from it\n\n      const ret = new SingularValueDecomposition(M);\n      const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map(row => {\n        return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n      });\n    } catch (_a) {\n      const res = [];\n\n      for (let i = 0; i < distances.length; i++) {\n        const x = Math.random() * linkDistance;\n        const y = Math.random() * linkDistance;\n        res.push([x, y]);\n      }\n\n      return res;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}