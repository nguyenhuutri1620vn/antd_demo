{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport class Ellipse extends Geometry {\n  constructor(x, y, a, b) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.a = a == null ? 0 : a;\n    this.b = b == null ? 0 : b;\n  }\n\n  get [Symbol.toStringTag]() {\n    return Ellipse.toStringTag;\n  }\n\n  get center() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the ellipse.\n   */\n\n\n  bbox() {\n    return Rectangle.fromEllipse(this);\n  }\n  /**\n   * Returns a point that is the center of the ellipse.\n   */\n\n\n  getCenter() {\n    return this.center;\n  }\n\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.a += 2 * w;\n    this.b += 2 * h;\n    return this;\n  }\n\n  normalizedDistance(x, y) {\n    const ref = Point.create(x, y);\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    const a = this.a;\n    const b = this.b;\n    return dx * dx / (a * a) + dy * dy / (b * b);\n  }\n\n  containsPoint(x, y) {\n    return this.normalizedDistance(x, y) <= 1;\n  }\n  /**\n   * Returns an array of the intersection points of the ellipse and the line.\n   * Returns `null` if no intersection exists.\n   */\n\n\n  intersectsWithLine(line) {\n    const intersections = [];\n    const rx = this.a;\n    const ry = this.b;\n    const a1 = line.start;\n    const a2 = line.end;\n    const dir = line.vector();\n    const diff = a1.diff(new Point(this.x, this.y));\n    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n    const a = dir.dot(mDir);\n    const b = dir.dot(mDiff);\n    const c = diff.dot(mDiff) - 1.0;\n    const d = b * b - a * c;\n\n    if (d < 0) {\n      return null;\n    }\n\n    if (d > 0) {\n      const root = Math.sqrt(d);\n      const ta = (-b - root) / a;\n      const tb = (-b + root) / a;\n\n      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n        // outside\n        return null;\n      }\n\n      if (ta >= 0 && ta <= 1) {\n        intersections.push(a1.lerp(a2, ta));\n      }\n\n      if (tb >= 0 && tb <= 1) {\n        intersections.push(a1.lerp(a2, tb));\n      }\n    } else {\n      const t = -b / a;\n\n      if (t >= 0 && t <= 1) {\n        intersections.push(a1.lerp(a2, t));\n      } else {\n        // outside\n        return null;\n      }\n    }\n\n    return intersections;\n  }\n  /**\n   * Returns the point on the boundary of the ellipse that is the\n   * intersection of the ellipse with a line starting in the center\n   * of the ellipse ending in the point `p`.\n   *\n   * If angle is specified, the intersection will take into account\n   * the rotation of the ellipse by angle degrees around its center.\n   */\n\n\n  intersectsWithLineFromCenterToPoint(p) {\n    let angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const ref = Point.clone(p);\n\n    if (angle) {\n      ref.rotate(angle, this.getCenter());\n    }\n\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    let result;\n\n    if (dx === 0) {\n      result = this.bbox().getNearestPointToPoint(ref);\n\n      if (angle) {\n        return result.rotate(-angle, this.getCenter());\n      }\n\n      return result;\n    }\n\n    const m = dy / dx;\n    const mSquared = m * m;\n    const aSquared = this.a * this.a;\n    const bSquared = this.b * this.b;\n    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n    x = dx < 0 ? -x : x;\n    const y = m * x;\n    result = new Point(this.x + x, this.y + y);\n\n    if (angle) {\n      return result.rotate(-angle, this.getCenter());\n    }\n\n    return result;\n  }\n  /**\n   * Returns the angle between the x-axis and the tangent from a point. It is\n   * valid for points lying on the ellipse boundary only.\n   */\n\n\n  tangentTheta(p) {\n    const ref = Point.clone(p);\n    const x0 = ref.x;\n    const y0 = ref.y;\n    const a = this.a;\n    const b = this.b;\n    const center = this.bbox().center;\n    const cx = center.x;\n    const cy = center.y;\n    const refPointDelta = 30;\n    const q1 = x0 > center.x + a / 2;\n    const q3 = x0 < center.x - a / 2;\n    let x;\n    let y;\n\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n      x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n      y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;\n    }\n\n    return new Point(x, y).theta(ref);\n  }\n\n  scale(sx, sy) {\n    this.a *= sx;\n    this.b *= sy;\n    return this;\n  }\n\n  rotate(angle, origin) {\n    const rect = Rectangle.fromEllipse(this);\n    rect.rotate(angle, origin);\n    const ellipse = Ellipse.fromRect(rect);\n    this.a = ellipse.a;\n    this.b = ellipse.b;\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    return this;\n  }\n\n  translate(dx, dy) {\n    const p = Point.create(dx, dy);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  equals(ellipse) {\n    return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n  }\n\n  clone() {\n    return new Ellipse(this.x, this.y, this.a, this.b);\n  }\n\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      a: this.a,\n      b: this.b\n    };\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.a} ${this.b}`;\n  }\n\n}\n\n(function (Ellipse) {\n  Ellipse.toStringTag = `X6.Geometry.${Ellipse.name}`;\n\n  function isEllipse(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Ellipse) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const ellipse = instance;\n\n    if ((tag == null || tag === Ellipse.toStringTag) && typeof ellipse.x === 'number' && typeof ellipse.y === 'number' && typeof ellipse.a === 'number' && typeof ellipse.b === 'number' && typeof ellipse.inflate === 'function' && typeof ellipse.normalizedDistance === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n\n(function (Ellipse) {\n  function create(x, y, a, b) {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b);\n    }\n\n    return parse(x);\n  }\n\n  Ellipse.create = create;\n\n  function parse(e) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone();\n    }\n\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3]);\n    }\n\n    return new Ellipse(e.x, e.y, e.a, e.b);\n  }\n\n  Ellipse.parse = parse;\n\n  function fromRect(rect) {\n    const center = rect.center;\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n  }\n\n  Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));","map":null,"metadata":{},"sourceType":"module"}