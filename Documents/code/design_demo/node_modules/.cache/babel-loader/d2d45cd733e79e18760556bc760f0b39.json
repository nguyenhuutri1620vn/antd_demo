{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { getDegree, clone, getEdgeTerminal } from \"../util\";\n\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n  nodes.forEach((_, i) => {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n\n  if (directed) {\n    edges.forEach(e => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      let sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      let targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      const child = nodes[sourceIdx].children;\n      const parent = nodes[targetIdx].parent;\n      child.push(nodes[targetIdx].id);\n      parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach(e => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      let sourceIdx = 0;\n\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n\n      let targetIdx = 0;\n\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n\n      const sourceChildren = nodes[sourceIdx].children;\n      const targetChildren = nodes[targetIdx].children;\n      sourceChildren.push(nodes[targetIdx].id);\n      targetChildren.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a, b, edges) {\n  const m = edges.length;\n\n  for (let i = 0; i < m; i++) {\n    const source = getEdgeTerminal(edges[i], 'source');\n    const target = getEdgeTerminal(edges[i], 'target');\n\n    if (a.id === source && b.id === target || b.id === source && a.id === target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction compareDegree(a, b) {\n  const aDegree = a.degree;\n  const bDegree = b.degree;\n\n  if (aDegree < bDegree) {\n    return -1;\n  }\n\n  if (aDegree > bDegree) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * 圆形布局\n */\n\n\nexport class CircularLayout extends Base {\n  constructor(options) {\n    super();\n    /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n\n    this.radius = null;\n    /** 起始半径 */\n\n    this.startRadius = null;\n    /** 终止半径 */\n\n    this.endRadius = null;\n    /** 起始角度 */\n\n    this.startAngle = 0;\n    /** 终止角度 */\n\n    this.endAngle = 2 * Math.PI;\n    /** 是否顺时针 */\n\n    this.clockwise = true;\n    /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n\n    this.divisions = 1;\n    /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n\n    this.ordering = null;\n    /** how many 2*pi from first to last nodes */\n\n    this.angleRatio = 1;\n    this.nodes = [];\n    this.edges = [];\n    this.nodeMap = {};\n    this.degrees = [];\n    this.width = 300;\n    this.height = 300;\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      radius: null,\n      startRadius: null,\n      endRadius: null,\n      startAngle: 0,\n      endAngle: 2 * Math.PI,\n      clockwise: true,\n      divisions: 1,\n      ordering: null,\n      angleRatio: 1\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const n = nodes.length;\n\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    const center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    let radius = self.radius;\n    let startRadius = self.startRadius;\n    let endRadius = self.endRadius;\n    const divisions = self.divisions;\n    const startAngle = self.startAngle;\n    const endAngle = self.endAngle;\n    const angleStep = (endAngle - startAngle) / n; // layout\n\n    const nodeMap = {};\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    const degrees = getDegree(nodes.length, nodeMap, edges);\n    self.degrees = degrees;\n\n    if (!radius && !startRadius && !endRadius) {\n      radius = self.height > self.width ? self.width / 2 : self.height / 2;\n    } else if (!startRadius && endRadius) {\n      startRadius = endRadius;\n    } else if (startRadius && !endRadius) {\n      endRadius = startRadius;\n    }\n\n    const angleRatio = self.angleRatio;\n    const astep = angleStep * angleRatio;\n    const ordering = self.ordering;\n    let layoutNodes = [];\n\n    if (ordering === \"topology\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering();\n    } else if (ordering === \"topology-directed\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering(true);\n    } else if (ordering === \"degree\") {\n      // layout according to the descent order of degrees\n      layoutNodes = self.degreeOrdering();\n    } else {\n      // layout according to the original order in the data.nodes\n      layoutNodes = nodes;\n    }\n\n    const clockwise = self.clockwise;\n    const divN = Math.ceil(n / divisions); // node number in each division\n\n    for (let i = 0; i < n; ++i) {\n      let r = radius;\n\n      if (!r && startRadius !== null && endRadius !== null) {\n        r = startRadius + i * (endRadius - startRadius) / (n - 1);\n      }\n\n      if (!r) {\n        r = 10 + i * 100 / (n - 1);\n      }\n\n      let angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n\n      if (!clockwise) {\n        angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n      }\n\n      layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n      layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n      layoutNodes[i].weight = degrees[i];\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: layoutNodes,\n      edges: this.edges\n    };\n  }\n  /**\n   * 根据节点的拓扑结构排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  topologyOrdering() {\n    let directed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const self = this;\n    const degrees = self.degrees;\n    const edges = self.edges;\n    const nodes = self.nodes;\n    const cnodes = clone(nodes);\n    const nodeMap = self.nodeMap;\n    const orderedCNodes = [cnodes[0]];\n    const resNodes = [nodes[0]];\n    const pickFlags = [];\n    const n = nodes.length;\n    pickFlags[0] = true;\n    initHierarchy(cnodes, edges, nodeMap, directed);\n    let k = 0;\n    cnodes.forEach((cnode, i) => {\n      if (i !== 0) {\n        if ((i === n - 1 || degrees[i] !== degrees[i + 1] || connect(orderedCNodes[k], cnode, edges)) && !pickFlags[i]) {\n          orderedCNodes.push(cnode);\n          resNodes.push(nodes[nodeMap[cnode.id]]);\n          pickFlags[i] = true;\n          k++;\n        } else {\n          const children = orderedCNodes[k].children;\n          let foundChild = false;\n\n          for (let j = 0; j < children.length; j++) {\n            const childIdx = nodeMap[children[j]];\n\n            if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\n              orderedCNodes.push(cnodes[childIdx]);\n              resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n              pickFlags[childIdx] = true;\n              foundChild = true;\n              break;\n            }\n          }\n\n          let ii = 0;\n\n          while (!foundChild) {\n            if (!pickFlags[ii]) {\n              orderedCNodes.push(cnodes[ii]);\n              resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n              pickFlags[ii] = true;\n              foundChild = true;\n            }\n\n            ii++;\n\n            if (ii === n) {\n              break;\n            }\n          }\n        }\n      }\n    });\n    return resNodes;\n  }\n  /**\n   * 根据节点度数大小排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  degreeOrdering() {\n    const self = this;\n    const nodes = self.nodes;\n    const orderedNodes = [];\n    const degrees = self.degrees;\n    nodes.forEach((node, i) => {\n      node.degree = degrees[i];\n      orderedNodes.push(node);\n    });\n    orderedNodes.sort(compareDegree);\n    return orderedNodes;\n  }\n\n  getType() {\n    return \"circular\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}