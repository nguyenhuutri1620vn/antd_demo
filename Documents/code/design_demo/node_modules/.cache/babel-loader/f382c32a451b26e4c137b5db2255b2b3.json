{"ast":null,"code":"import { zipObject } from '../util';\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\n\nconst twoLayerCrossCount = (g, northLayer, southLayer) => {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = zipObject(southLayer, southLayer.map((v, i) => i));\n  const unflat = northLayer.map(v => {\n    var _a;\n\n    const unsort = (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map(e => {\n      return {\n        pos: southPos[e.w] || 0,\n        weight: g.edge(e).weight\n      };\n    });\n    return unsort === null || unsort === void 0 ? void 0 : unsort.sort((a, b) => a.pos - b.pos);\n  }); // @ts-ignore\n\n  const southEntries = unflat.flat().filter(entry => entry !== undefined); // Build the accumulator tree\n\n  let firstIndex = 1;\n\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n\n  const treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  const tree = Array(treeSize).fill(0, 0, treeSize); // Calculate the weighted crossings\n\n  let cc = 0;\n  southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(entry => {\n    let index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    let weightSum = 0;\n\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n\n      index = index - 1 >> 1;\n      tree[index] += entry.weight;\n    }\n\n    cc += entry.weight * weightSum;\n  });\n  return cc;\n};\n\nconst crossCount = (g, layering) => {\n  let cc = 0;\n\n  for (let i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n\n  return cc;\n};\n\nexport default crossCount;","map":null,"metadata":{},"sourceType":"module"}