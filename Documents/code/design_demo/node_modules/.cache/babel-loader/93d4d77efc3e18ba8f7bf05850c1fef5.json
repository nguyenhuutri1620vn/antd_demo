{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { AST_TOKEN_TYPES, createEntity, isSafari, STORAGE_CLASS } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { isNumber } from '../utils/is-number';\nimport WebGPUBuffer from './WebGPUBuffer';\n\nvar WebGPUComputeModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n  function WebGPUComputeModel(engine, context) {\n    _classCallCheck(this, WebGPUComputeModel);\n\n    this.engine = engine;\n    this.context = context;\n    this.entity = createEntity();\n    this.uniformGPUBufferLayout = [];\n    this.uniformBuffer = void 0;\n    this.vertexBuffers = {};\n    this.outputBuffer = void 0;\n    this.bindGroupEntries = void 0;\n    this.bindGroup = void 0;\n    this.computePipeline = void 0;\n  }\n\n  _createClass(WebGPUComputeModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var _yield$this$compileCo, computeStage, buffers, uniforms, bufferBindingIndex, offset, mergedUniformData;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.compileComputePipelineStageDescriptor(this.context.shader);\n\n              case 2:\n                _yield$this$compileCo = _context.sent;\n                computeStage = _yield$this$compileCo.computeStage;\n                buffers = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.StorageBuffer;\n                });\n                uniforms = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.Uniform;\n                });\n                bufferBindingIndex = uniforms.length ? 1 : 0;\n                this.bindGroupEntries = [];\n\n                if (bufferBindingIndex) {\n                  offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n                  // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n\n                  mergedUniformData = [];\n                  uniforms.forEach(function (uniform) {\n                    if (isNumber(uniform.data)) {\n                      _this.uniformGPUBufferLayout.push({\n                        name: uniform.name,\n                        offset: offset\n                      });\n\n                      offset += 4; // @ts-ignore\n\n                      mergedUniformData.push(uniform.data);\n                    } else {\n                      var _uniform$data; // @ts-ignore\n\n\n                      var originDataLength = ((_uniform$data = uniform.data) === null || _uniform$data === void 0 ? void 0 : _uniform$data.length) || 1;\n\n                      if (originDataLength === 3) {\n                        // vec3 -> vec4\n                        // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n                        originDataLength = 4; // @ts-ignore\n\n                        uniform.data.push(0);\n                      } // 4 elements per block/line\n\n\n                      var padding = offset / 4 % 4;\n\n                      if (padding > 0) {\n                        var space = 4 - padding;\n\n                        if (originDataLength > 1 && originDataLength <= space) {\n                          if (originDataLength === 2) {\n                            if (space === 3) {\n                              offset += 4;\n                              mergedUniformData.push(0);\n                            } // @ts-ignore\n\n\n                            mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n\n                            _this.uniformGPUBufferLayout.push({\n                              name: uniform.name,\n                              offset: offset\n                            });\n                          }\n                        } else {\n                          for (var i = 0; i < space; i++) {\n                            offset += 4;\n                            mergedUniformData.push(0);\n                          } // @ts-ignore\n\n\n                          mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n\n                          _this.uniformGPUBufferLayout.push({\n                            name: uniform.name,\n                            offset: offset\n                          });\n                        }\n                      }\n\n                      offset += 4 * originDataLength;\n                    }\n                  });\n                  this.uniformBuffer = new WebGPUBuffer(this.engine, {\n                    // TODO: 处理 Struct 和 boolean\n                    // @ts-ignore\n                    data: mergedUniformData instanceof Array ? // @ts-ignore\n                    new Float32Array(mergedUniformData) : mergedUniformData,\n                    usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n                  });\n                  this.bindGroupEntries.push({\n                    binding: 0,\n                    resource: {\n                      buffer: this.uniformBuffer.get()\n                    }\n                  });\n                } // create GPUBuffers for storeage buffers\n\n\n                buffers.forEach(function (buffer) {\n                  if (buffer.data !== null) {\n                    if (buffer.type === AST_TOKEN_TYPES.Vector4FloatArray || buffer.type === AST_TOKEN_TYPES.FloatArray) {\n                      var gpuBuffer;\n\n                      if (buffer.name === _this.context.output.name) {\n                        gpuBuffer = new WebGPUBuffer(_this.engine, {\n                          // @ts-ignore\n                          data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                          usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                        });\n                        _this.outputBuffer = gpuBuffer;\n                        _this.context.output = {\n                          name: buffer.name,\n                          // @ts-ignore\n                          length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n                          typedArrayConstructor: Float32Array,\n                          gpuBuffer: gpuBuffer.get()\n                        };\n                      } else {\n                        if (buffer.isReferer) {\n                          // @ts-ignore\n                          if (buffer.data.model && buffer.data.model.outputBuffer) {\n                            // @ts-ignore\n                            gpuBuffer = buffer.data.model.outputBuffer;\n                          } else {// referred kernel haven't been executed\n                          }\n                        } else {\n                          gpuBuffer = new WebGPUBuffer(_this.engine, {\n                            // @ts-ignore\n                            data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                            usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                          });\n                        }\n                      } // @ts-ignore\n\n\n                      _this.vertexBuffers[buffer.name] = gpuBuffer;\n\n                      _this.bindGroupEntries.push({\n                        binding: bufferBindingIndex,\n                        resource: {\n                          name: buffer.name,\n                          refer: gpuBuffer ? undefined : buffer.data,\n                          // @ts-ignore\n                          buffer: gpuBuffer ? gpuBuffer.get() : undefined\n                        }\n                      });\n\n                      bufferBindingIndex++;\n                    }\n                  }\n                }); // create compute pipeline layout\n\n                this.computePipeline = this.engine.device.createComputePipeline({\n                  computeStage: computeStage\n                });\n                console.log(this.bindGroupEntries);\n                this.bindGroup = this.engine.device.createBindGroup({\n                  layout: this.computePipeline.getBindGroupLayout(0),\n                  entries: this.bindGroupEntries\n                });\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      if (this.uniformBuffer) {\n        this.uniformBuffer.destroy();\n      }\n\n      Object.keys(this.vertexBuffers).forEach(function (bufferName) {\n        return _this2.vertexBuffers[bufferName].destroy();\n      });\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var output, length, typedArrayConstructor, gpuBuffer, byteCount, gpuReadBuffer, encoder, queue, arraybuffer, typedArray;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                output = this.context.output;\n\n                if (!output) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                length = output.length, typedArrayConstructor = output.typedArrayConstructor, gpuBuffer = output.gpuBuffer;\n\n                if (!gpuBuffer) {\n                  _context2.next = 16;\n                  break;\n                } // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n                // const arraybuffer = gpuBuffer.getMappedRange();\n                // let arraybuffer;\n                // if (isSafari) {\n                //   arraybuffer = await gpuBuffer.mapReadAsync();\n                // } else {\n\n\n                byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT; // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n\n                gpuReadBuffer = this.engine.device.createBuffer({\n                  size: byteCount,\n                  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n                });\n                encoder = this.engine.device.createCommandEncoder();\n                encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n                queue = isSafari ? // @ts-ignore\n                this.engine.device.getQueue() : this.engine.device.defaultQueue;\n                queue.submit([encoder.finish()]);\n                _context2.next = 12;\n                return gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n\n              case 12:\n                arraybuffer = gpuReadBuffer.getMappedRange();\n                typedArray = new typedArrayConstructor(arraybuffer.slice(0));\n                gpuReadBuffer.unmap();\n                return _context2.abrupt(\"return\", typedArray);\n\n              case 16:\n                return _context2.abrupt(\"return\", new Float32Array());\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n\n      return readData;\n    }()\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this.engine.currentComputePass) {\n        var _this$engine$currentC;\n\n        this.engine.currentComputePass.setPipeline(this.computePipeline); // this.bindGroupEntries.forEach((entry) => {\n        //   if (!entry.resource.buffer) {\n        //     // get referred kernel's output\n        //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n        //       .outputBuffer;\n        //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n        //     entry.resource.buffer = gpuBuffer.get();\n        //   }\n        // });\n        // const bindGroup = this.engine.device.createBindGroup({\n        //   layout: this.computePipeline.getBindGroupLayout(0),\n        //   entries: this.bindGroupEntries,\n        // });\n\n        this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n\n        (_this$engine$currentC = this.engine.currentComputePass).dispatch.apply(_this$engine$currentC, _toConsumableArray(this.context.dispatch));\n      }\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var buffer = this.vertexBuffers[bufferName];\n\n      if (buffer) {\n        buffer.subData({\n          data: data,\n          offset: offset\n        });\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform(uniformName, data) {\n      var layout = this.uniformGPUBufferLayout.find(function (l) {\n        return l.name === uniformName;\n      });\n\n      if (layout) {\n        this.uniformBuffer.subData({\n          data: Number.isFinite(data) ? new Float32Array([data]) : new Float32Array(data),\n          offset: layout.offset\n        });\n      }\n    }\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      // copy output GPUBuffer of kernel\n      var inputBuffer = this.vertexBuffers[inputName];\n      var outputBuffer = model.outputBuffer;\n\n      if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n        var encoder = this.engine.device.createCommandEncoder();\n        var _context$output = model.context.output,\n            length = _context$output.length,\n            typedArrayConstructor = _context$output.typedArrayConstructor;\n        var byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT;\n        encoder.copyBufferToBuffer(outputBuffer.get(), 0, inputBuffer.get(), 0, byteCount);\n        var queue = isSafari ? // @ts-ignore\n        this.engine.device.getQueue() : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n      }\n    }\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"compileComputePipelineStageDescriptor\",\n    value: function () {\n      var _compileComputePipelineStageDescriptor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(computeCode) {\n        var computeShader, shaderVersion;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                computeShader = computeCode;\n                shaderVersion = '#version 450\\n';\n\n                if (this.engine.options.useWGSL) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 5;\n                return this.compileShaderToSpirV(computeCode, 'compute', shaderVersion);\n\n              case 5:\n                computeShader = _context3.sent;\n\n              case 6:\n                return _context3.abrupt(\"return\", {\n                  computeStage: {\n                    module: this.engine.device.createShaderModule({\n                      code: computeShader,\n                      // @ts-ignore\n                      isWHLSL: isSafari\n                    }),\n                    entryPoint: 'main'\n                  }\n                });\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function compileComputePipelineStageDescriptor(_x) {\n        return _compileComputePipelineStageDescriptor.apply(this, arguments);\n      }\n\n      return compileComputePipelineStageDescriptor;\n    }()\n  }]);\n\n  return WebGPUComputeModel;\n}();\n\nexport { WebGPUComputeModel as default };","map":null,"metadata":{},"sourceType":"module"}