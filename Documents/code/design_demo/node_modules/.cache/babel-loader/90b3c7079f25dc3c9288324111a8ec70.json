{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Supercluster = factory());\n})(this, function () {\n  'use strict';\n\n  function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) {\n      return;\n    }\n\n    var m = left + right >> 1;\n    select(ids, coords, m, left, right, depth % 2);\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n  }\n\n  function select(ids, coords, k, left, right, inc) {\n    while (right > left) {\n      if (right - left > 600) {\n        var n = right - left + 1;\n        var m = k - left + 1;\n        var z = Math.log(n);\n        var s = 0.5 * Math.exp(2 * z / 3);\n        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        select(ids, coords, k, newLeft, newRight, inc);\n      }\n\n      var t = coords[2 * k + inc];\n      var i = left;\n      var j = right;\n      swapItem(ids, coords, left, k);\n\n      if (coords[2 * right + inc] > t) {\n        swapItem(ids, coords, left, right);\n      }\n\n      while (i < j) {\n        swapItem(ids, coords, i, j);\n        i++;\n        j--;\n\n        while (coords[2 * i + inc] < t) {\n          i++;\n        }\n\n        while (coords[2 * j + inc] > t) {\n          j--;\n        }\n      }\n\n      if (coords[2 * left + inc] === t) {\n        swapItem(ids, coords, left, j);\n      } else {\n        j++;\n        swapItem(ids, coords, j, right);\n      }\n\n      if (j <= k) {\n        left = j + 1;\n      }\n\n      if (k <= j) {\n        right = j - 1;\n      }\n    }\n  }\n\n  function swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n  function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n      var axis = stack.pop();\n      var right = stack.pop();\n      var left = stack.pop();\n\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          x = coords[2 * i];\n          y = coords[2 * i + 1];\n\n          if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n            result.push(ids[i]);\n          }\n        }\n\n        continue;\n      }\n\n      var m = Math.floor((left + right) / 2);\n      x = coords[2 * m];\n      y = coords[2 * m + 1];\n\n      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n        result.push(ids[m]);\n      }\n\n      var nextAxis = (axis + 1) % 2;\n\n      if (axis === 0 ? minX <= x : minY <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(nextAxis);\n      }\n\n      if (axis === 0 ? maxX >= x : maxY >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(nextAxis);\n      }\n    }\n\n    return result;\n  }\n\n  function within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n      var axis = stack.pop();\n      var right = stack.pop();\n      var left = stack.pop();\n\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) {\n            result.push(ids[i]);\n          }\n        }\n\n        continue;\n      }\n\n      var m = Math.floor((left + right) / 2);\n      var x = coords[2 * m];\n      var y = coords[2 * m + 1];\n\n      if (sqDist(x, y, qx, qy) <= r2) {\n        result.push(ids[m]);\n      }\n\n      var nextAxis = (axis + 1) % 2;\n\n      if (axis === 0 ? qx - r <= x : qy - r <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(nextAxis);\n      }\n\n      if (axis === 0 ? qx + r >= x : qy + r >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(nextAxis);\n      }\n    }\n\n    return result;\n  }\n\n  function sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n  }\n\n  var defaultGetX = function (p) {\n    return p[0];\n  };\n\n  var defaultGetY = function (p) {\n    return p[1];\n  };\n\n  var KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {\n    if (getX === void 0) getX = defaultGetX;\n    if (getY === void 0) getY = defaultGetY;\n    if (nodeSize === void 0) nodeSize = 64;\n    if (ArrayType === void 0) ArrayType = Float64Array;\n    this.nodeSize = nodeSize;\n    this.points = points;\n    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n    var ids = this.ids = new IndexArrayType(points.length);\n    var coords = this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n      ids[i] = i;\n      coords[2 * i] = getX(points[i]);\n      coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\n  };\n\n  KDBush.prototype.range = function range$1(minX, minY, maxX, maxY) {\n    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n  };\n\n  KDBush.prototype.within = function within$1(x, y, r) {\n    return within(this.ids, this.coords, x, y, r, this.nodeSize);\n  };\n\n  var defaultOptions = {\n    minZoom: 0,\n    // min zoom to generate clusters on\n    maxZoom: 16,\n    // max zoom level to cluster the points on\n    minPoints: 2,\n    // minimum points to form a cluster\n    radius: 40,\n    // cluster radius in pixels\n    extent: 512,\n    // tile extent (radius is calculated relative to it)\n    nodeSize: 64,\n    // size of the KD-tree leaf node, affects performance\n    log: false,\n    // whether to log timing info\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n    // a reduce function for calculating custom cluster properties\n    reduce: null,\n    // (accumulated, props) => { accumulated.sum += props.sum; }\n    // properties to use for individual points when running the reducer\n    map: function (props) {\n      return props;\n    } // props => ({sum: props.my_value})\n\n  };\n\n  var fround = Math.fround || function (tmp) {\n    return function (x) {\n      tmp[0] = +x;\n      return tmp[0];\n    };\n  }(new Float32Array(1));\n\n  var Supercluster = function Supercluster(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  };\n\n  Supercluster.prototype.load = function load(points) {\n    var ref = this.options;\n    var log = ref.log;\n    var minZoom = ref.minZoom;\n    var maxZoom = ref.maxZoom;\n    var nodeSize = ref.nodeSize;\n\n    if (log) {\n      console.time('total time');\n    }\n\n    var timerId = \"prepare \" + points.length + \" points\";\n\n    if (log) {\n      console.time(timerId);\n    }\n\n    this.points = points; // generate a cluster object for each point and index input points into a KD-tree\n\n    var clusters = [];\n\n    for (var i = 0; i < points.length; i++) {\n      if (!points[i].geometry) {\n        continue;\n      }\n\n      clusters.push(createPointCluster(points[i], i));\n    }\n\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n    if (log) {\n      console.timeEnd(timerId);\n    } // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n\n\n    for (var z = maxZoom; z >= minZoom; z--) {\n      var now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree\n\n      clusters = this._cluster(clusters, z);\n      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n      if (log) {\n        console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n      }\n    }\n\n    if (log) {\n      console.timeEnd('total time');\n    }\n\n    return this;\n  };\n\n  Supercluster.prototype.getClusters = function getClusters(bbox, zoom) {\n    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    var minLat = Math.max(-90, Math.min(90, bbox[1]));\n    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n\n    var tree = this.trees[this._limitZoom(zoom)];\n\n    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    var clusters = [];\n\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n      var id = list[i];\n      var c = tree.points[id];\n      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n\n    return clusters;\n  };\n\n  Supercluster.prototype.getChildren = function getChildren(clusterId) {\n    var originId = this._getOriginId(clusterId);\n\n    var originZoom = this._getOriginZoom(clusterId);\n\n    var errorMsg = 'No cluster with the specified id.';\n    var index = this.trees[originZoom];\n\n    if (!index) {\n      throw new Error(errorMsg);\n    }\n\n    var origin = index.points[originId];\n\n    if (!origin) {\n      throw new Error(errorMsg);\n    }\n\n    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    var ids = index.within(origin.x, origin.y, r);\n    var children = [];\n\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n      var id = list[i];\n      var c = index.points[id];\n\n      if (c.parentId === clusterId) {\n        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n    }\n\n    if (children.length === 0) {\n      throw new Error(errorMsg);\n    }\n\n    return children;\n  };\n\n  Supercluster.prototype.getLeaves = function getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    var leaves = [];\n\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n  };\n\n  Supercluster.prototype.getTile = function getTile(z, x, y) {\n    var tree = this.trees[this._limitZoom(z)];\n\n    var z2 = Math.pow(2, z);\n    var ref = this.options;\n    var extent = ref.extent;\n    var radius = ref.radius;\n    var p = radius / extent;\n    var top = (y - p) / z2;\n    var bottom = (y + 1 + p) / z2;\n    var tile = {\n      features: []\n    };\n\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n    }\n\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n  };\n\n  Supercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom(clusterId) {\n    var expansionZoom = this._getOriginZoom(clusterId) - 1;\n\n    while (expansionZoom <= this.options.maxZoom) {\n      var children = this.getChildren(clusterId);\n      expansionZoom++;\n\n      if (children.length !== 1) {\n        break;\n      }\n\n      clusterId = children[0].properties.cluster_id;\n    }\n\n    return expansionZoom;\n  };\n\n  Supercluster.prototype._appendLeaves = function _appendLeaves(result, clusterId, limit, offset, skipped) {\n    var children = this.getChildren(clusterId);\n\n    for (var i = 0, list = children; i < list.length; i += 1) {\n      var child = list[i];\n      var props = child.properties;\n\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n\n      if (result.length === limit) {\n        break;\n      }\n    }\n\n    return skipped;\n  };\n\n  Supercluster.prototype._addTileFeatures = function _addTileFeatures(ids, points, x, y, z2, tile) {\n    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {\n      var i = list[i$1];\n      var c = points[i];\n      var isCluster = c.numPoints;\n      var tags = void 0,\n          px = void 0,\n          py = void 0;\n\n      if (isCluster) {\n        tags = getClusterProperties(c);\n        px = c.x;\n        py = c.y;\n      } else {\n        var p = this.points[c.index];\n        tags = p.properties;\n        px = lngX(p.geometry.coordinates[0]);\n        py = latY(p.geometry.coordinates[1]);\n      }\n\n      var f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n        tags: tags\n      }; // assign id\n\n      var id = void 0;\n\n      if (isCluster) {\n        id = c.id;\n      } else if (this.options.generateId) {\n        // optionally generate id\n        id = c.index;\n      } else if (this.points[c.index].id) {\n        // keep id if already assigned\n        id = this.points[c.index].id;\n      }\n\n      if (id !== undefined) {\n        f.id = id;\n      }\n\n      tile.features.push(f);\n    }\n  };\n\n  Supercluster.prototype._limitZoom = function _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n  };\n\n  Supercluster.prototype._cluster = function _cluster(points, zoom) {\n    var clusters = [];\n    var ref = this.options;\n    var radius = ref.radius;\n    var extent = ref.extent;\n    var reduce = ref.reduce;\n    var minPoints = ref.minPoints;\n    var r = radius / (extent * Math.pow(2, zoom)); // loop through each point\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i]; // if we've already visited the point at this zoom level, skip it\n\n      if (p.zoom <= zoom) {\n        continue;\n      }\n\n      p.zoom = zoom; // find all nearby points\n\n      var tree = this.trees[zoom + 1];\n      var neighborIds = tree.within(p.x, p.y, r);\n      var numPointsOrigin = p.numPoints || 1;\n      var numPoints = numPointsOrigin; // count the number of points in a potential cluster\n\n      for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {\n        var neighborId = list[i$1];\n        var b = tree.points[neighborId]; // filter out neighbors that are already processed\n\n        if (b.zoom > zoom) {\n          numPoints += b.numPoints || 1;\n        }\n      } // if there were neighbors to merge, and there are enough points to form a cluster\n\n\n      if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n        var wx = p.x * numPointsOrigin;\n        var wy = p.y * numPointsOrigin;\n        var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated -- offset by total length of features\n\n        var id = (i << 5) + (zoom + 1) + this.points.length;\n\n        for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {\n          var neighborId$1 = list$1[i$2];\n          var b$1 = tree.points[neighborId$1];\n\n          if (b$1.zoom <= zoom) {\n            continue;\n          }\n\n          b$1.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n          var numPoints2 = b$1.numPoints || 1;\n          wx += b$1.x * numPoints2; // accumulate coordinates for calculating weighted center\n\n          wy += b$1.y * numPoints2;\n          b$1.parentId = id;\n\n          if (reduce) {\n            if (!clusterProperties) {\n              clusterProperties = this._map(p, true);\n            }\n\n            reduce(clusterProperties, this._map(b$1));\n          }\n        }\n\n        p.parentId = id;\n        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n      } else {\n        // left points as unclustered\n        clusters.push(p);\n\n        if (numPoints > 1) {\n          for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {\n            var neighborId$2 = list$2[i$3];\n            var b$2 = tree.points[neighborId$2];\n\n            if (b$2.zoom <= zoom) {\n              continue;\n            }\n\n            b$2.zoom = zoom;\n            clusters.push(b$2);\n          }\n        }\n      }\n    }\n\n    return clusters;\n  }; // get index of the point from which the cluster originated\n\n\n  Supercluster.prototype._getOriginId = function _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  }; // get zoom of the point from which the cluster originated\n\n\n  Supercluster.prototype._getOriginZoom = function _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  };\n\n  Supercluster.prototype._map = function _map(point, clone) {\n    if (point.numPoints) {\n      return clone ? extend({}, point.properties) : point.properties;\n    }\n\n    var original = this.points[point.index].properties;\n    var result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n  };\n\n  function createCluster(x, y, id, numPoints, properties) {\n    return {\n      x: fround(x),\n      // weighted cluster center; round for consistency with Float32Array index\n      y: fround(y),\n      zoom: Infinity,\n      // the last zoom the cluster was processed at\n      id: id,\n      // encodes index of the first child of the cluster and its zoom level\n      parentId: -1,\n      // parent cluster id\n      numPoints: numPoints,\n      properties: properties\n    };\n  }\n\n  function createPointCluster(p, id) {\n    var ref = p.geometry.coordinates;\n    var x = ref[0];\n    var y = ref[1];\n    return {\n      x: fround(lngX(x)),\n      // projected point coordinates\n      y: fround(latY(y)),\n      zoom: Infinity,\n      // the last zoom the point was processed at\n      index: id,\n      // index of the source feature in the original input array,\n      parentId: -1 // parent cluster id\n\n    };\n  }\n\n  function getClusterJSON(cluster) {\n    return {\n      type: 'Feature',\n      id: cluster.id,\n      properties: getClusterProperties(cluster),\n      geometry: {\n        type: 'Point',\n        coordinates: [xLng(cluster.x), yLat(cluster.y)]\n      }\n    };\n  }\n\n  function getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev = count >= 10000 ? Math.round(count / 1000) + \"k\" : count >= 1000 ? Math.round(count / 100) / 10 + \"k\" : count;\n    return extend(extend({}, cluster.properties), {\n      cluster: true,\n      cluster_id: cluster.id,\n      point_count: count,\n      point_count_abbreviated: abbrev\n    });\n  } // longitude/latitude to spherical mercator in [0..1] range\n\n\n  function lngX(lng) {\n    return lng / 360 + 0.5;\n  }\n\n  function latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180);\n    var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n  } // spherical mercator to longitude/latitude\n\n\n  function xLng(x) {\n    return (x - 0.5) * 360;\n  }\n\n  function yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n  }\n\n  function extend(dest, src) {\n    for (var id in src) {\n      dest[id] = src[id];\n    }\n\n    return dest;\n  }\n\n  function getX(p) {\n    return p.x;\n  }\n\n  function getY(p) {\n    return p.y;\n  }\n\n  return Supercluster;\n});","map":null,"metadata":{},"sourceType":"script"}