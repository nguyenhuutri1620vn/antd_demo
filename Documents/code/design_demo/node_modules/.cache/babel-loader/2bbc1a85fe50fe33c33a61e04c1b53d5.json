{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { mat4, vec4 } from 'gl-matrix';\nimport GridIndex from './grid-index';\n\nvar CollisionIndex = function () {\n  function CollisionIndex(width, height) {\n    _classCallCheck(this, CollisionIndex);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"grid\", void 0);\n\n    _defineProperty(this, \"viewportPadding\", 100);\n\n    _defineProperty(this, \"screenRightBoundary\", void 0);\n\n    _defineProperty(this, \"screenBottomBoundary\", void 0);\n\n    _defineProperty(this, \"gridRightBoundary\", void 0);\n\n    _defineProperty(this, \"gridBottomBoundary\", void 0);\n\n    this.width = width;\n    this.height = height;\n    this.viewportPadding = Math.max(width, height);\n    this.grid = new GridIndex(width + this.viewportPadding, height + this.viewportPadding, 25);\n    this.screenRightBoundary = width + this.viewportPadding;\n    this.screenBottomBoundary = height + this.viewportPadding;\n    this.gridRightBoundary = width + 2 * this.viewportPadding;\n    this.gridBottomBoundary = height + 2 * this.viewportPadding;\n  }\n\n  _createClass(CollisionIndex, [{\n    key: \"placeCollisionBox\",\n    value: function placeCollisionBox(collisionBox) {\n      var tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;\n      var tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;\n      var brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;\n      var brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;\n\n      if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {\n        return {\n          box: []\n        };\n      }\n\n      return {\n        box: [tlX, tlY, brX, brY]\n      };\n    }\n  }, {\n    key: \"insertCollisionBox\",\n    value: function insertCollisionBox(box, featureIndex) {\n      var key = {\n        featureIndex: featureIndex\n      };\n      this.grid.insert(key, box[0], box[1], box[2], box[3]);\n    }\n  }, {\n    key: \"project\",\n    value: function project(mvpMatrix, x, y) {\n      var point = vec4.fromValues(x, y, 0, 1);\n      var out = vec4.create();\n      var mat = mat4.fromValues.apply(mat4, _toConsumableArray(mvpMatrix));\n      vec4.transformMat4(out, point, mat);\n      return {\n        x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,\n        y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding\n      };\n    }\n  }, {\n    key: \"isInsideGrid\",\n    value: function isInsideGrid(x1, y1, x2, y2) {\n      return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;\n    }\n  }]);\n\n  return CollisionIndex;\n}();\n\nexport { CollisionIndex as default };","map":null,"metadata":{},"sourceType":"module"}