{"ast":null,"code":"import { FunctionExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport { resolve } from './manhattan/options';\nimport { manhattan } from './manhattan/index';\nconst defaults = {\n  maxDirectionChange: 45,\n\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions() {\n    const step = resolve(this.step, this);\n    const cost = resolve(this.cost, this);\n    const diagonalCost = Math.ceil(Math.sqrt(step * step << 1)); // eslint-disable-line no-bitwise\n\n    return [{\n      cost,\n      offsetX: step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: step\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: step\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: step\n    }, {\n      cost,\n      offsetX: -step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: -step\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: -step\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: -step\n    }];\n  },\n\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute(from, to, options) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n    const theta = from.theta(to);\n    const route = [];\n    let a = {\n      x: to.x,\n      y: from.y\n    };\n    let b = {\n      x: from.x,\n      y: to.y\n    };\n\n    if (theta % 180 > 90) {\n      const t = a;\n      a = b;\n      b = t;\n    }\n\n    const p1 = theta % 90 < 45 ? a : b;\n    const l1 = new Line(from, p1);\n    const alpha = 90 * Math.ceil(theta / 90);\n    const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);\n    const l2 = new Line(to, p2);\n    const intersectionPoint = l1.intersectsWithLine(l2);\n    const point = intersectionPoint || to;\n    const directionFrom = intersectionPoint ? point : from;\n    const quadrant = 360 / options.directions.length;\n    const angleTheta = directionFrom.theta(to);\n    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n    options.previousDirectionAngle = directionAngle;\n    if (point) route.push(point.round());\n    route.push(to);\n    return route;\n  }\n\n};\nexport const metro = function (vertices, options, linkView) {\n  return FunctionExt.call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);\n};","map":null,"metadata":{},"sourceType":"module"}