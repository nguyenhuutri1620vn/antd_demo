{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { ext } from '@antv/matrix-util';\nimport { each, filter, get, isFunction, isNil, isNumberEqual, mix, size } from '@antv/util';\nimport GroupComponent from '../abstract/group-component';\nimport { getMatrixByAngle } from '../util/matrix';\nimport { getStatesStyle } from '../util/state';\nimport Theme from '../util/theme';\n\nvar AxisBase =\n/** @class */\nfunction (_super) {\n  __extends(AxisBase, _super);\n\n  function AxisBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AxisBase.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n\n    return __assign(__assign({}, cfg), {\n      name: 'axis',\n      ticks: [],\n      line: {},\n      tickLine: {},\n      subTickLine: null,\n      title: null,\n\n      /**\n       * 文本标签的配置项\n       */\n      label: {},\n\n      /**\n       * 垂直于坐标轴方向的因子，决定文本、title、tickLine 在坐标轴的哪一侧\n       */\n      verticalFactor: 1,\n      // 垂直方向限制的长度，对文本自适应有很大影响\n      verticalLimitLength: null,\n      overlapOrder: ['autoRotate', 'autoEllipsis', 'autoHide'],\n      tickStates: {},\n      optimize: {},\n      defaultCfg: {\n        line: {\n          // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor\n          }\n        },\n        tickLine: {\n          // @type {Attrs} 标注坐标线的图形属性\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor\n          },\n          alignTick: true,\n          length: 5,\n          displayWithLabel: true\n        },\n        subTickLine: {\n          // @type {Attrs} 标注坐标线的图形属性\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor\n          },\n          count: 4,\n          length: 2\n        },\n        label: {\n          autoRotate: true,\n          autoHide: false,\n          autoEllipsis: false,\n          style: {\n            fontSize: 12,\n            fill: Theme.textColor,\n            fontFamily: Theme.fontFamily,\n            fontWeight: 'normal'\n          },\n          offset: 10,\n          offsetX: 0,\n          offsetY: 0\n        },\n        title: {\n          autoRotate: true,\n          spacing: 5,\n          position: 'center',\n          style: {\n            fontSize: 12,\n            fill: Theme.textColor,\n            textBaseline: 'middle',\n            fontFamily: Theme.fontFamily,\n            textAlign: 'center'\n          }\n        },\n        tickStates: {\n          active: {\n            labelStyle: {\n              fontWeight: 500\n            },\n            tickLineStyle: {\n              lineWidth: 2\n            }\n          },\n          inactive: {\n            labelStyle: {\n              fill: Theme.uncheckedColor\n            }\n          }\n        },\n        // 针对大数据量进行优化配置\n        optimize: {\n          enable: true,\n          threshold: 400\n        }\n      },\n      theme: {}\n    });\n  };\n  /**\n   * 绘制组件\n   */\n\n\n  AxisBase.prototype.renderInner = function (group) {\n    if (this.get('line')) {\n      this.drawLine(group);\n    } // drawTicks 包括 drawLabels 和 drawTickLines\n\n\n    this.drawTicks(group);\n\n    if (this.get('title')) {\n      this.drawTitle(group);\n    }\n  }; // 实现 IList 接口\n\n\n  AxisBase.prototype.isList = function () {\n    return true;\n  };\n  /**\n   * 获取图例项\n   * @return {ListItem[]} 列表项集合\n   */\n\n\n  AxisBase.prototype.getItems = function () {\n    return this.get('ticks');\n  };\n  /**\n   * 设置列表项\n   * @param {ListItem[]} items 列表项集合\n   */\n\n\n  AxisBase.prototype.setItems = function (items) {\n    this.update({\n      ticks: items\n    });\n  };\n  /**\n   * 更新列表项\n   * @param {ListItem} item 列表项\n   * @param {object}   cfg  列表项\n   */\n\n\n  AxisBase.prototype.updateItem = function (item, cfg) {\n    mix(item, cfg);\n    this.clear(); // 由于单个图例项变化，会引起全局变化，所以全部更新\n\n    this.render();\n  };\n  /**\n   * 清空列表\n   */\n\n\n  AxisBase.prototype.clearItems = function () {\n    var itemGroup = this.getElementByLocalId('label-group');\n    itemGroup && itemGroup.clear();\n  };\n  /**\n   * 设置列表项的状态\n   * @param {ListItem} item  列表项\n   * @param {string}   state 状态名\n   * @param {boolean}  value 状态值, true, false\n   */\n\n\n  AxisBase.prototype.setItemState = function (item, state, value) {\n    item[state] = value;\n    this.updateTickStates(item); // 应用状态样式\n  };\n  /**\n   * 是否存在指定的状态\n   * @param {ListItem} item  列表项\n   * @param {boolean} state 状态名\n   */\n\n\n  AxisBase.prototype.hasState = function (item, state) {\n    return !!item[state];\n  };\n\n  AxisBase.prototype.getItemStates = function (item) {\n    var tickStates = this.get('tickStates');\n    var rst = [];\n    each(tickStates, function (v, k) {\n      if (item[k]) {\n        // item.selected\n        rst.push(k);\n      }\n    });\n    return rst;\n  };\n  /**\n   * 清楚所有列表项的状态\n   * @param {string} state 状态值\n   */\n\n\n  AxisBase.prototype.clearItemsState = function (state) {\n    var _this = this;\n\n    var items = this.getItemsByState(state);\n    each(items, function (item) {\n      _this.setItemState(item, state, false);\n    });\n  };\n  /**\n   * 根据状态获取图例项\n   * @param  {string}     state [description]\n   * @return {ListItem[]}       [description]\n   */\n\n\n  AxisBase.prototype.getItemsByState = function (state) {\n    var _this = this;\n\n    var items = this.getItems();\n    return filter(items, function (item) {\n      return _this.hasState(item, state);\n    });\n  };\n\n  AxisBase.prototype.getSidePoint = function (point, offset) {\n    var self = this;\n    var vector = self.getSideVector(offset, point);\n    return {\n      x: point.x + vector[0],\n      y: point.y + vector[1]\n    };\n  };\n\n  AxisBase.prototype.getTextAnchor = function (vector) {\n    var align;\n\n    if (isNumberEqual(vector[0], 0)) {\n      align = 'center';\n    } else if (vector[0] > 0) {\n      align = 'start';\n    } else if (vector[0] < 0) {\n      align = 'end';\n    }\n\n    return align;\n  };\n\n  AxisBase.prototype.getTextBaseline = function (vector) {\n    var base;\n\n    if (isNumberEqual(vector[1], 0)) {\n      base = 'middle';\n    } else if (vector[1] > 0) {\n      base = 'top';\n    } else if (vector[1] < 0) {\n      base = 'bottom';\n    }\n\n    return base;\n  };\n\n  AxisBase.prototype.processOverlap = function (labelGroup) {}; // 绘制坐标轴线\n\n\n  AxisBase.prototype.drawLine = function (group) {\n    var path = this.getLinePath();\n    var line = this.get('line'); // line 的判空在调用 drawLine 之前，不在这里判定\n\n    this.addShape(group, {\n      type: 'path',\n      id: this.getElementId('line'),\n      name: 'axis-line',\n      attrs: mix({\n        path: path\n      }, line.style)\n    });\n  };\n\n  AxisBase.prototype.getTickLineItems = function (ticks) {\n    var _this = this;\n\n    var tickLineItems = [];\n    var tickLine = this.get('tickLine');\n    var alignTick = tickLine.alignTick;\n    var tickLineLength = tickLine.length;\n    var tickSegment = 1;\n    var tickCount = ticks.length;\n\n    if (tickCount >= 2) {\n      tickSegment = ticks[1].value - ticks[0].value;\n    }\n\n    each(ticks, function (tick) {\n      var point = tick.point;\n\n      if (!alignTick) {\n        // tickLine 不同 tick 对齐时需要调整 point\n        point = _this.getTickPoint(tick.value - tickSegment / 2);\n      }\n\n      var endPoint = _this.getSidePoint(point, tickLineLength);\n\n      tickLineItems.push({\n        startPoint: point,\n        tickValue: tick.value,\n        endPoint: endPoint,\n        tickId: tick.id,\n        id: \"tickline-\" + tick.id\n      });\n    }); // 如果 tickLine 不居中对齐，则需要在最后面补充一个 tickLine\n    // if (!alignTick && tickCount > 0) {\n    //   const tick = ticks[tickCount - 1];\n    //   const point = this.getTickPoint(tick.value + tickSegment / 2);\n    // }\n\n    return tickLineItems;\n  };\n\n  AxisBase.prototype.getSubTickLineItems = function (tickLineItems) {\n    var subTickLineItems = [];\n    var subTickLine = this.get('subTickLine');\n    var subCount = subTickLine.count;\n    var tickLineCount = tickLineItems.length; // 刻度线的数量大于 2 时，才绘制子刻度\n\n    if (tickLineCount >= 2) {\n      for (var i = 0; i < tickLineCount - 1; i++) {\n        var pre = tickLineItems[i];\n        var next = tickLineItems[i + 1];\n\n        for (var j = 0; j < subCount; j++) {\n          var percent = (j + 1) / (subCount + 1);\n          var tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;\n          var point = this.getTickPoint(tickValue);\n          var endPoint = this.getSidePoint(point, subTickLine.length);\n          subTickLineItems.push({\n            startPoint: point,\n            endPoint: endPoint,\n            tickValue: tickValue,\n            id: \"sub-\" + pre.id + \"-\" + j\n          });\n        }\n      }\n    }\n\n    return subTickLineItems;\n  };\n\n  AxisBase.prototype.getTickLineAttrs = function (tickItem, type, index, tickItems) {\n    var style = this.get(type).style; // 保持和 grid 相同的数据结构\n\n    var item = {\n      points: [tickItem.startPoint, tickItem.endPoint]\n    };\n    var defaultTickLineStyle = get(this.get('theme'), ['tickLine', 'style'], {});\n    style = isFunction(style) ? mix({}, defaultTickLineStyle, style(item, index, tickItems)) : style;\n    var startPoint = tickItem.startPoint,\n        endPoint = tickItem.endPoint;\n    return __assign({\n      x1: startPoint.x,\n      y1: startPoint.y,\n      x2: endPoint.x,\n      y2: endPoint.y\n    }, style);\n  }; // 绘制坐标轴刻度线\n\n\n  AxisBase.prototype.drawTick = function (tickItem, tickLineGroup, type, index, tickItems) {\n    this.addShape(tickLineGroup, {\n      type: 'line',\n      id: this.getElementId(tickItem.id),\n      name: \"axis-\" + type,\n      attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)\n    });\n  }; // 绘制坐标轴刻度线，包括子刻度线\n\n\n  AxisBase.prototype.drawTickLines = function (group) {\n    var _this = this;\n\n    var ticks = this.get('ticks');\n    var subTickLine = this.get('subTickLine');\n    var tickLineItems = this.getTickLineItems(ticks);\n    var tickLineGroup = this.addGroup(group, {\n      name: 'axis-tickline-group',\n      id: this.getElementId('tickline-group')\n    });\n    var tickCfg = this.get('tickLine');\n    each(tickLineItems, function (item, index) {\n      if (tickCfg.displayWithLabel) {\n        // 如果跟随 label 显示，则检测是否存在对应的 label\n        var labelId = _this.getElementId(\"label-\" + item.tickId);\n\n        if (group.findById(labelId)) {\n          _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);\n        }\n      } else {\n        _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);\n      }\n    });\n\n    if (subTickLine) {\n      var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);\n      each(subTickLineItems_1, function (item, index) {\n        _this.drawTick(item, tickLineGroup, 'subTickLine', index, subTickLineItems_1);\n      });\n    }\n  }; // 预处理 ticks 确定位置和补充 id\n\n\n  AxisBase.prototype.processTicks = function () {\n    var _this = this;\n\n    var ticks = this.get('ticks');\n    each(ticks, function (tick) {\n      tick.point = _this.getTickPoint(tick.value); // 补充 tick 的 id，为动画和更新做准备\n\n      if (isNil(tick.id)) {\n        // 默认使用 tick.name 作为id\n        tick.id = tick.name;\n      }\n    });\n  }; // 绘制 ticks 包括文本和 tickLine\n\n\n  AxisBase.prototype.drawTicks = function (group) {\n    var _this = this;\n\n    this.optimizeTicks();\n    this.processTicks();\n\n    if (this.get('label')) {\n      this.drawLabels(group);\n    }\n\n    if (this.get('tickLine')) {\n      this.drawTickLines(group);\n    }\n\n    var ticks = this.get('ticks');\n    each(ticks, function (tick) {\n      _this.applyTickStates(tick, group);\n    });\n  };\n  /**\n   * 根据 optimize 配置对 ticks 进行抽样，对抽样过后的 ticks 才进行真实的渲染\n   */\n\n\n  AxisBase.prototype.optimizeTicks = function () {\n    var optimize = this.get('optimize');\n    var ticks = this.get('ticks');\n\n    if (optimize && optimize.enable && optimize.threshold > 0) {\n      var len = size(ticks);\n\n      if (len > optimize.threshold) {\n        var page_1 = Math.ceil(len / optimize.threshold);\n        var optimizedTicks = ticks.filter(function (tick, idx) {\n          return idx % page_1 === 0;\n        });\n        this.set('ticks', optimizedTicks);\n        this.set('originalTicks', ticks);\n      }\n    }\n  }; // 获取 label 的配置项\n\n\n  AxisBase.prototype.getLabelAttrs = function (tick, index, ticks) {\n    var labelCfg = this.get('label');\n    var offset = labelCfg.offset,\n        offsetX = labelCfg.offsetX,\n        offsetY = labelCfg.offsetY,\n        rotate = labelCfg.rotate,\n        formatter = labelCfg.formatter;\n    var point = this.getSidePoint(tick.point, offset);\n    var vector = this.getSideVector(offset, point);\n    var text = formatter ? formatter(tick.name, tick, index) : tick.name;\n    var style = labelCfg.style;\n    style = isFunction(style) ? get(this.get('theme'), ['label', 'style'], {}) : style;\n    var attrs = mix({\n      x: point.x + offsetX,\n      y: point.y + offsetY,\n      text: text,\n      textAlign: this.getTextAnchor(vector),\n      textBaseline: this.getTextBaseline(vector)\n    }, style);\n\n    if (rotate) {\n      attrs.matrix = getMatrixByAngle(point, rotate);\n    }\n\n    return attrs;\n  }; // 绘制文本\n\n\n  AxisBase.prototype.drawLabels = function (group) {\n    var _this = this;\n\n    var ticks = this.get('ticks');\n    var labelGroup = this.addGroup(group, {\n      name: 'axis-label-group',\n      id: this.getElementId('label-group')\n    });\n    each(ticks, function (tick, index) {\n      _this.addShape(labelGroup, {\n        type: 'text',\n        name: 'axis-label',\n        id: _this.getElementId(\"label-\" + tick.id),\n        attrs: _this.getLabelAttrs(tick, index, ticks),\n        delegateObject: {\n          tick: tick,\n          item: tick,\n          index: index\n        }\n      });\n    });\n    this.processOverlap(labelGroup); // 处理完后再进行 style 回调处理\n\n    var labels = labelGroup.getChildren();\n    var defaultLabelStyle = get(this.get('theme'), ['label', 'style'], {});\n\n    var _a = this.get('label'),\n        style = _a.style,\n        formatter = _a.formatter;\n\n    if (isFunction(style)) {\n      var afterProcessTicks_1 = labels.map(function (label) {\n        return get(label.get('delegateObject'), 'tick');\n      });\n      each(labels, function (label, index) {\n        var tick = label.get('delegateObject').tick;\n        var text = formatter ? formatter(tick.name, tick, index) : tick.name;\n        var newStyle = mix({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));\n        label.attr(newStyle);\n      });\n    }\n  }; // 标题的属性\n\n\n  AxisBase.prototype.getTitleAttrs = function () {\n    var titleCfg = this.get('title');\n    var style = titleCfg.style,\n        position = titleCfg.position,\n        offset = titleCfg.offset,\n        _a = titleCfg.spacing,\n        spacing = _a === void 0 ? 0 : _a,\n        autoRotate = titleCfg.autoRotate;\n    var titleHeight = style.fontSize;\n    var percent = 0.5;\n\n    if (position === 'start') {\n      percent = 0;\n    } else if (position === 'end') {\n      percent = 1;\n    }\n\n    var point = this.getTickPoint(percent); // 标题对应的坐标轴上的点\n    // 如果没有指定 titleOffset 也没有渲染 label，这里需要自动计算 offset\n\n    var titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2); // 标题的点\n\n    var attrs = mix({\n      x: titlePoint.x,\n      y: titlePoint.y,\n      text: titleCfg.text\n    }, style);\n    var rotate = titleCfg.rotate; // rotate 是角度值\n\n    var angle = rotate;\n\n    if (isNil(rotate) && autoRotate) {\n      // 用户没有设定旋转角度，同时设置自动旋转\n      var vector = this.getAxisVector(point);\n      var v1 = [1, 0]; // 水平方向的向量\n\n      angle = ext.angleTo(vector, v1, true);\n    }\n\n    if (angle) {\n      var matrix = getMatrixByAngle(titlePoint, angle);\n      attrs.matrix = matrix;\n    }\n\n    return attrs;\n  }; // 绘制标题\n\n\n  AxisBase.prototype.drawTitle = function (group) {\n    this.addShape(group, {\n      type: 'text',\n      id: this.getElementId('title'),\n      name: 'axis-title',\n      attrs: this.getTitleAttrs()\n    });\n  };\n\n  AxisBase.prototype.applyTickStates = function (tick, group) {\n    var states = this.getItemStates(tick);\n\n    if (states.length) {\n      var tickStates = this.get('tickStates'); // 分别更新 label 和 tickLine\n\n      var labelId = this.getElementId(\"label-\" + tick.id);\n      var labelShape = group.findById(labelId);\n\n      if (labelShape) {\n        var labelStateStyle = getStatesStyle(tick, 'label', tickStates);\n        labelStateStyle && labelShape.attr(labelStateStyle);\n      }\n\n      var tickLineId = this.getElementId(\"tickline-\" + tick.id);\n      var tickLineShape = group.findById(tickLineId);\n\n      if (tickLineShape) {\n        var tickLineStateStyle = getStatesStyle(tick, 'tickLine', tickStates);\n        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);\n      }\n    }\n  };\n\n  AxisBase.prototype.updateTickStates = function (tick) {\n    var states = this.getItemStates(tick);\n    var tickStates = this.get('tickStates');\n    var labelCfg = this.get('label');\n    var labelShape = this.getElementByLocalId(\"label-\" + tick.id);\n    var tickLineCfg = this.get('tickLine');\n    var tickLineShape = this.getElementByLocalId(\"tickline-\" + tick.id);\n\n    if (states.length) {\n      if (labelShape) {\n        var labelStateStyle = getStatesStyle(tick, 'label', tickStates);\n        labelStateStyle && labelShape.attr(labelStateStyle);\n      }\n\n      if (tickLineShape) {\n        var tickLineStateStyle = getStatesStyle(tick, 'tickLine', tickStates);\n        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);\n      }\n    } else {\n      if (labelShape) {\n        labelShape.attr(labelCfg.style);\n      }\n\n      if (tickLineShape) {\n        tickLineShape.attr(tickLineCfg.style);\n      }\n    }\n  };\n\n  return AxisBase;\n}(GroupComponent);\n\nexport default AxisBase;","map":null,"metadata":{},"sourceType":"module"}