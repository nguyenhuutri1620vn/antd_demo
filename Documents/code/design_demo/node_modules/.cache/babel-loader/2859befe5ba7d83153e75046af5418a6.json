{"ast":null,"code":"import initOrder from './init-order';\nimport crossCount from './cross-count';\nimport buildLayerGraph from './build-layer-graph';\nimport addSubgraphConstraints from './add-subgraph-constraints';\nimport sortSubgraph from './sort-subgraph';\nimport graphlib from '../graphlib';\nimport util from '../util';\nimport { clone } from '../../../../util';\nconst Graph = graphlib.Graph;\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\n\nconst order = g => {\n  const maxRank = util.maxRank(g);\n  const range1 = [];\n  const range2 = [];\n\n  for (let i = 1; i < maxRank + 1; i++) range1.push(i);\n\n  for (let i = maxRank - 1; i > -1; i--) range2.push(i);\n\n  const downLayerGraphs = buildLayerGraphs(g, range1, \"inEdges\");\n  const upLayerGraphs = buildLayerGraphs(g, range2, \"outEdges\");\n  let layering = initOrder(g);\n  assignOrder(g, layering);\n  let bestCC = Number.POSITIVE_INFINITY;\n  let best;\n\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n    layering = util.buildLayerMatrix(g);\n    const cc = crossCount(g, layering);\n\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = clone(layering);\n      bestCC = cc;\n    }\n  } // consider use previous result, maybe somewhat reduendant\n\n\n  layering = initOrder(g);\n  assignOrder(g, layering);\n\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, true);\n    layering = util.buildLayerMatrix(g);\n    const cc = crossCount(g, layering);\n\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = clone(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n};\n\nconst buildLayerGraphs = (g, ranks, relationship) => {\n  return ranks.map(rank => {\n    return buildLayerGraph(g, rank, relationship);\n  });\n};\n\nconst sweepLayerGraphs = (layerGraphs, biasRight, usePrev) => {\n  const cg = new Graph();\n  layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach(lg => {\n    var _a;\n\n    const root = lg.graph().root;\n    const sorted = sortSubgraph(lg, root, cg, biasRight, usePrev);\n\n    for (let i = 0; i < ((_a = sorted.vs) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {\n      lg.node(sorted.vs[i]).order = i;\n    }\n\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n};\n\nconst assignOrder = (g, layering) => {\n  layering === null || layering === void 0 ? void 0 : layering.forEach(layer => {\n    layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {\n      g.node(v).order = i;\n    });\n  });\n};\n\nexport default order;","map":null,"metadata":{},"sourceType":"module"}