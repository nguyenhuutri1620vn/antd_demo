{"ast":null,"code":"import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { getEdgesByNodeId } from './util';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new UnionFind(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nexport default minimumSpanningTree;","map":null,"metadata":{},"sourceType":"module"}