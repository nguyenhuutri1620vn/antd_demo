{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nvar _excluded = [\"type\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nvar lightTypeUniformMap = {\n  directional: {\n    lights: 'u_DirectionalLights',\n    num: 'u_NumOfDirectionalLights'\n  },\n  spot: {\n    lights: 'u_SpotLights',\n    num: 'u_NumOfSpotLights'\n  }\n};\nvar DEFAULT_LIGHT = {\n  type: 'directional',\n  direction: [1, 10.5, 12],\n  ambient: [0.2, 0.2, 0.2],\n  diffuse: [0.6, 0.6, 0.6],\n  specular: [0.1, 0.1, 0.1]\n};\nvar DEFAULT_DIRECTIONAL_LIGHT = {\n  direction: [0, 0, 0],\n  ambient: [0, 0, 0],\n  diffuse: [0, 0, 0],\n  specular: [0, 0, 0]\n};\nvar DEFAULT_SPOT_LIGHT = {\n  position: [0, 0, 0],\n  direction: [0, 0, 0],\n  ambient: [0, 0, 0],\n  diffuse: [0, 0, 0],\n  specular: [0, 0, 0],\n  constant: 1,\n  linear: 0,\n  quadratic: 0,\n  angle: 14,\n  exponent: 40,\n  blur: 5\n};\nvar COLOR_ATTRIBUTES = ['ambient', 'diffuse', 'specular'];\nexport function generateLightingUniforms(lights) {\n  var lightsMap = {\n    u_DirectionalLights: new Array(3).fill(_objectSpread({}, DEFAULT_DIRECTIONAL_LIGHT)),\n    u_NumOfDirectionalLights: 0,\n    u_SpotLights: new Array(3).fill(_objectSpread({}, DEFAULT_SPOT_LIGHT)),\n    u_NumOfSpotLights: 0\n  };\n\n  if (!lights || !lights.length) {\n    lights = [DEFAULT_LIGHT];\n  }\n\n  lights.forEach(function (_ref, i) {\n    var _ref$type = _ref.type,\n        type = _ref$type === void 0 ? 'directional' : _ref$type,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n    var lightsUniformName = lightTypeUniformMap[type].lights;\n    var lightsNumUniformName = lightTypeUniformMap[type].num;\n    var num = lightsMap[lightsNumUniformName];\n    lightsMap[lightsUniformName][num] = _objectSpread(_objectSpread({}, lightsMap[lightsUniformName][num]), rest);\n    lightsMap[lightsNumUniformName]++;\n  });\n  return lightsMap;\n}\nvar LightingPlugin = (_dec = injectable(), _dec(_class = function () {\n  function LightingPlugin() {\n    _classCallCheck(this, LightingPlugin);\n  }\n\n  _createClass(LightingPlugin, [{\n    key: \"apply\",\n    value: function apply(layer) {\n      layer.hooks.beforeRender.tap('LightingPlugin', function () {\n        var _layer$getLayerConfig = layer.getLayerConfig(),\n            enableLighting = _layer$getLayerConfig.enableLighting;\n\n        if (enableLighting) {\n          layer.models.forEach(function (model) {\n            return model.addUniforms(_objectSpread({}, generateLightingUniforms()));\n          });\n        }\n      });\n    }\n  }]);\n\n  return LightingPlugin;\n}()) || _class);\nexport { LightingPlugin as default };","map":null,"metadata":{},"sourceType":"module"}