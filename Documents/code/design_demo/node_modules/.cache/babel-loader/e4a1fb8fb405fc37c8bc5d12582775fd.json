{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { isString, isPlainObject, isNil, mix } from '@antv/util';\nimport Item from './item';\nvar END_MAP = {\n  source: 'start',\n  target: 'end'\n};\nvar ITEM_NAME_SUFFIX = 'Node'; // 端点的后缀，如 sourceNode, targetNode\n\nvar POINT_NAME_SUFFIX = 'Point'; // 起点或者结束点的后缀，如 startPoint, endPoint\n\nvar ANCHOR_NAME_SUFFIX = 'Anchor';\n\nvar Edge =\n/** @class */\nfunction (_super) {\n  __extends(Edge, _super);\n\n  function Edge() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Edge.prototype.getDefaultCfg = function () {\n    return {\n      type: 'edge',\n      sourceNode: null,\n      targetNode: null,\n      startPoint: null,\n      endPoint: null,\n      linkCenter: false\n    };\n  };\n\n  Edge.prototype.setEnd = function (name, value) {\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var preItem = this.get(itemName);\n\n    if (preItem && !preItem.destroyed) {\n      // 如果之前存在节点，则移除掉边\n      preItem.removeEdge(this);\n    }\n\n    if (isPlainObject(value)) {\n      // 如果设置成具体的点，则清理节点\n      this.set(pointName, value);\n      this.set(itemName, null);\n    } else if (value) {\n      value.addEdge(this);\n      this.set(itemName, value);\n      this.set(pointName, null);\n    }\n  };\n  /**\n   * 获取连接点的坐标\n   * @param name source | target\n   * @param model 边的数据模型\n   * @param controlPoints 控制点\n   */\n\n\n  Edge.prototype.getLinkPoint = function (name, model, controlPoints) {\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var point = this.get(pointName);\n\n    if (!point) {\n      var item = this.get(itemName);\n      var anchorName = name + ANCHOR_NAME_SUFFIX;\n      var prePoint = this.getPrePoint(name, controlPoints);\n      var anchorIndex = model[anchorName];\n\n      if (!isNil(anchorIndex)) {\n        // 如果有锚点，则使用锚点索引获取连接点\n        point = item.getLinkPointByAnchor(anchorIndex);\n      } // 如果锚点没有对应的点或者没有锚点，则直接计算连接点\n\n\n      point = point || item.getLinkPoint(prePoint);\n\n      if (!isNil(point.index)) {\n        this.set(\"\".concat(name, \"AnchorIndex\"), point.index);\n      }\n    }\n\n    return point;\n  };\n  /**\n   * 获取同端点进行连接的点，计算交汇点\n   * @param name\n   * @param controlPoints\n   */\n\n\n  Edge.prototype.getPrePoint = function (name, controlPoints) {\n    if (controlPoints && controlPoints.length) {\n      var index = name === 'source' ? 0 : controlPoints.length - 1;\n      return controlPoints[index];\n    }\n\n    var oppositeName = name === 'source' ? 'target' : 'source'; // 取另一个节点的位置\n\n    return this.getEndPoint(oppositeName);\n  };\n  /**\n   * 获取端点的位置\n   * @param name\n   */\n\n\n  Edge.prototype.getEndPoint = function (name) {\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var item = this.get(itemName); // 如果有端点，直接使用 model\n\n    if (item) {\n      return item.get('model');\n    } // 否则直接使用点\n\n\n    return this.get(pointName);\n  };\n  /**\n   * 通过端点的中心获取控制点\n   * @param model\n   */\n\n\n  Edge.prototype.getControlPointsByCenter = function (model) {\n    var sourcePoint = this.getEndPoint('source');\n    var targetPoint = this.getEndPoint('target');\n    var shapeFactory = this.get('shapeFactory');\n    var type = model.type;\n    return shapeFactory.getControlPoints(type, {\n      startPoint: sourcePoint,\n      endPoint: targetPoint\n    });\n  };\n\n  Edge.prototype.getEndCenter = function (name) {\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var item = this.get(itemName); // 如果有端点，直接使用 model\n\n    if (item) {\n      var bbox = item.getBBox();\n      return {\n        x: bbox.centerX,\n        y: bbox.centerY\n      };\n    } // 否则直接使用点\n\n\n    return this.get(pointName);\n  };\n\n  Edge.prototype.init = function () {\n    _super.prototype.init.call(this); // 初始化两个端点\n\n\n    this.setSource(this.get('source'));\n    this.setTarget(this.get('target'));\n  };\n\n  Edge.prototype.getShapeCfg = function (model, updateType) {\n    var self = this;\n    var linkCenter = self.get('linkCenter'); // 如果连接到中心，忽视锚点、忽视控制点\n\n    var cfg = (updateType === null || updateType === void 0 ? void 0 : updateType.includes('move')) ? model : _super.prototype.getShapeCfg.call(this, model);\n\n    if (linkCenter) {\n      cfg.startPoint = self.getEndCenter('source');\n      cfg.endPoint = self.getEndCenter('target');\n    } else {\n      var controlPoints = cfg.controlPoints || self.getControlPointsByCenter(cfg);\n      cfg.startPoint = self.getLinkPoint('source', model, controlPoints);\n      cfg.endPoint = self.getLinkPoint('target', model, controlPoints);\n    }\n\n    cfg.sourceNode = self.get('sourceNode');\n    cfg.targetNode = self.get('targetNode');\n    return cfg;\n  };\n  /**\n   * 获取边的数据模型\n   */\n\n\n  Edge.prototype.getModel = function () {\n    var out = this.get('model');\n    var sourceItem = this.get(\"source\".concat(ITEM_NAME_SUFFIX));\n    var targetItem = this.get(\"target\".concat(ITEM_NAME_SUFFIX));\n\n    if (sourceItem) {\n      delete out[\"source\".concat(ITEM_NAME_SUFFIX)];\n    } else {\n      out.source = this.get(\"start\".concat(POINT_NAME_SUFFIX));\n    }\n\n    if (targetItem) {\n      delete out[\"target\".concat(ITEM_NAME_SUFFIX)];\n    } else {\n      out.target = this.get(\"end\".concat(POINT_NAME_SUFFIX));\n    }\n\n    if (!isString(out.source) && !isPlainObject(out.source)) {\n      out.source = out.source.getID();\n    }\n\n    if (!isString(out.target) && !isPlainObject(out.target)) {\n      out.target = out.target.getID();\n    }\n\n    return out;\n  };\n\n  Edge.prototype.setSource = function (source) {\n    this.setEnd('source', source);\n    this.set('source', source);\n  };\n\n  Edge.prototype.setTarget = function (target) {\n    this.setEnd('target', target);\n    this.set('target', target);\n  };\n\n  Edge.prototype.getSource = function () {\n    return this.get('source');\n  };\n\n  Edge.prototype.getTarget = function () {\n    return this.get('target');\n  };\n\n  Edge.prototype.updatePosition = function () {\n    return false;\n  };\n  /**\n   * 边不需要重计算容器位置，直接重新计算 path 位置\n   * @param {object} cfg 待更新数据\n   */\n\n\n  Edge.prototype.update = function (cfg, updateType) {\n    if (updateType === void 0) {\n      updateType = undefined;\n    }\n\n    var model = this.get('model');\n    var oriVisible = model.visible;\n    var cfgVisible = cfg.visible;\n    if (oriVisible !== cfgVisible && cfgVisible !== undefined) this.changeVisibility(cfgVisible);\n    var styles = this.get('styles');\n\n    if (cfg.stateStyles) {\n      // 更新 item 时更新 this.get('styles') 中的值\n      var stateStyles = cfg.stateStyles;\n      mix(styles, stateStyles);\n      delete cfg.stateStyles;\n    }\n\n    Object.assign(model, cfg);\n    this.updateShape(updateType);\n    this.afterUpdate();\n    this.clearCache();\n  };\n\n  Edge.prototype.destroy = function () {\n    var sourceItem = this.get(\"source\".concat(ITEM_NAME_SUFFIX));\n    var targetItem = this.get(\"target\".concat(ITEM_NAME_SUFFIX));\n\n    if (sourceItem && !sourceItem.destroyed) {\n      sourceItem.removeEdge(this);\n    }\n\n    if (targetItem && !targetItem.destroyed) {\n      targetItem.removeEdge(this);\n    }\n\n    _super.prototype.destroy.call(this);\n  };\n\n  return Edge;\n}(Item);\n\nexport default Edge;","map":null,"metadata":{},"sourceType":"module"}