{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport Base from '../base';\nimport { isString, isNil } from '@antv/util';\nimport { modifyCSS, createDom } from '@antv/dom-util';\nimport { Util } from '@antv/g6-core';\nimport { mat3 } from '@antv/matrix-util';\nvar applyMatrix = Util.applyMatrix;\n\nfunction getImgNaturalDimension(img, callback) {\n  var nWidth, nHeight;\n\n  if (img.naturalWidth) {\n    // 现代浏览器\n    nWidth = img.naturalWidth;\n    nHeight = img.naturalHeight;\n  } else {\n    // IE6/7/8\n    var image_1 = new Image();\n    image_1.src = img.src;\n\n    image_1.onload = function () {\n      if (callback) callback(image_1.width, image_1.height);\n    };\n  }\n\n  return [nWidth, nHeight];\n}\n\nvar ImageMiniMap =\n/** @class */\nfunction (_super) {\n  __extends(ImageMiniMap, _super);\n\n  function ImageMiniMap(config) {\n    return _super.call(this, config) || this;\n  }\n\n  ImageMiniMap.prototype.getDefaultCfgs = function () {\n    return {\n      container: null,\n      className: 'g6-minimap',\n      viewportClassName: 'g6-minimap-viewport',\n      width: 200,\n      delegateStyle: {\n        fill: '#40a9ff',\n        stroke: '#096dd9'\n      },\n      refresh: true\n    };\n  };\n\n  ImageMiniMap.prototype.getEvents = function () {\n    return {\n      beforepaint: 'updateViewport',\n      beforeanimate: 'disableRefresh',\n      afteranimate: 'enableRefresh',\n      viewportchange: 'disableOneRefresh'\n    };\n  }; // 若是正在进行动画，不刷新缩略图\n\n\n  ImageMiniMap.prototype.disableRefresh = function () {\n    this.set('refresh', false);\n  };\n\n  ImageMiniMap.prototype.enableRefresh = function () {\n    this.set('refresh', true);\n    this.updateCanvas();\n  };\n\n  ImageMiniMap.prototype.disableOneRefresh = function () {\n    this.set('viewportChange', true);\n  };\n\n  ImageMiniMap.prototype.initViewport = function () {\n    var _this = this;\n\n    var cfgs = this._cfgs; // cWidth and cHeight are the width and height of the minimap's container\n\n    var graph = cfgs.graph;\n    if (this.destroyed) return;\n    var containerDOM = this.get('container');\n\n    if (isString(containerDOM)) {\n      containerDOM = document.getElementById(containerDOM);\n    }\n\n    var viewport = createDom(\"<div class=\".concat(cfgs.viewportClassName, \"\\n      style='position:absolute;\\n        left:0;\\n        top:0;\\n        box-sizing:border-box;\\n        border: 2px solid #1980ff'>\\n      </div>\")); // 计算拖拽水平方向距离\n\n    var x = 0; // 计算拖拽垂直方向距离\n\n    var y = 0; // 是否在拖拽minimap的视口\n\n    var dragging = false; // 缓存viewport当前对于画布的x\n\n    var left = 0; // 缓存viewport当前对于画布的y\n\n    var top = 0; // 缓存viewport当前宽度\n\n    var width = 0; // 缓存viewport当前高度\n\n    var height = 0;\n    var ratio = 0;\n    var zoom = 0;\n    containerDOM.addEventListener('mousedown', function (e) {\n      cfgs.refresh = false;\n\n      if (e.target !== viewport) {\n        return;\n      } // 如果视口已经最大了，不需要拖拽\n\n\n      var style = viewport.style;\n      width = parseInt(style.width, 10);\n      height = parseInt(style.height, 10);\n\n      var cWidth = _this.get('width');\n\n      var cHeight = _this.get('height');\n\n      if (width > cWidth || height > cHeight) {\n        return;\n      }\n\n      zoom = graph.getZoom();\n      ratio = _this.get('ratio');\n      dragging = true;\n      x = e.clientX;\n      y = e.clientY;\n    }, false);\n    containerDOM.addEventListener('mousemove', function (e) {\n      if (!dragging || isNil(e.clientX) || isNil(e.clientY)) {\n        return;\n      }\n\n      var cWidth = _this.get('width');\n\n      var cHeight = _this.get('height');\n\n      var style = viewport.style;\n      left = parseInt(style.left, 10);\n      top = parseInt(style.top, 10);\n      width = parseInt(style.width, 10);\n      height = parseInt(style.height, 10);\n      var dx = x - e.clientX;\n      var dy = y - e.clientY; // 若视口移动到最左边或最右边了,仅移动到边界\n\n      if (left - dx < 0) {\n        dx = left;\n      } else if (left - dx + width >= cWidth) {\n        dx = 0;\n      } // 若视口移动到最上或最下边了，仅移动到边界\n\n\n      if (top - dy < 0) {\n        dy = top;\n      } else if (top - dy + height >= cHeight) {\n        dy = 0;\n      }\n\n      left -= dx;\n      top -= dy; // 先移动视口，避免移动到边上以后出现视口闪烁\n\n      modifyCSS(viewport, {\n        left: \"\".concat(left, \"px\"),\n        top: \"\".concat(top, \"px\")\n      }); // graph 移动需要偏移量 dx/dy * 缩放比例才会得到正确的移动距离\n\n      graph.translate(dx * zoom / ratio, dy * zoom / ratio);\n      x = e.clientX;\n      y = e.clientY;\n    }, false);\n    containerDOM.addEventListener('mouseleave', function () {\n      dragging = false;\n      cfgs.refresh = true;\n    }, false);\n    containerDOM.addEventListener('mouseup', function () {\n      dragging = false;\n      cfgs.refresh = true;\n    }, false);\n    this.set('viewport', viewport);\n    containerDOM.appendChild(viewport);\n  };\n  /**\n   * 更新 viewport 视图\n   */\n\n\n  ImageMiniMap.prototype.updateViewport = function () {\n    if (this.destroyed) return;\n    var ratio = this.get('ratio');\n    var cWidth = this.get('width');\n    var cHeight = this.get('height');\n    var graph = this.get('graph');\n    var graphWidth = graph.get('width');\n    var graphHeight = graph.get('height');\n    var aspectRatio = graphWidth / graphHeight;\n    var graphGroup = graph.getGroup(); // 主图的 bbox（矩阵变换相关的 bbox）\n\n    var graphCanvasBBox = graphGroup.getCanvasBBox(); // 扩展 graphBBox 到和 graphWidth / graphHeight 等比\n\n    var graphCanvasBBoxMean = [(graphCanvasBBox.minX + graphCanvasBBox.maxX) / 2, (graphCanvasBBox.minY + graphCanvasBBox.maxY) / 2];\n    var graphCanvasBBoxSize = [graphCanvasBBox.maxX - graphCanvasBBox.minX, graphCanvasBBox.maxY - graphCanvasBBox.minY];\n    var expandedGraphCanvasBBox = {\n      centerX: graphCanvasBBoxMean[0],\n      centerY: graphCanvasBBoxMean[1],\n      width: 0,\n      height: 0,\n      minX: 0,\n      minY: 0\n    };\n\n    if (graphCanvasBBox[0] / graphCanvasBBox[1] > aspectRatio) {\n      expandedGraphCanvasBBox.width = graphCanvasBBoxSize[0];\n      expandedGraphCanvasBBox.height = expandedGraphCanvasBBox.width / aspectRatio;\n    } else {\n      expandedGraphCanvasBBox.height = graphCanvasBBoxSize[1];\n      expandedGraphCanvasBBox.width = expandedGraphCanvasBBox.height * aspectRatio;\n    }\n\n    expandedGraphCanvasBBox.minX = graphCanvasBBoxMean[0] - expandedGraphCanvasBBox.width / 2;\n    expandedGraphCanvasBBox.minY = graphCanvasBBoxMean[1] - expandedGraphCanvasBBox.height / 2;\n    var graphMatrix = graphGroup.getMatrix();\n    if (!graphMatrix) graphMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var invertGraphMatrix = mat3.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], graphMatrix);\n    var minXY = applyMatrix({\n      x: expandedGraphCanvasBBox.minX,\n      y: expandedGraphCanvasBBox.minY\n    }, invertGraphMatrix); // 扩展 graphBBox 后的 bbox 的左上角对应的 canvas container 坐标\n\n    var topLeft = graph.getCanvasByPoint(minXY.x, minXY.y);\n    var viewport = this.get('viewport');\n\n    if (!viewport) {\n      this.initViewport();\n    } // Viewport 与 minimap container 的比例 =  Graph container 与 expandedGraphBBox 比例\n\n\n    var vpToMc = graphWidth / expandedGraphCanvasBBox.width; // viewport 宽高 = vpToMc * minimap container 宽高\n\n    var width = vpToMc * cWidth;\n    var height = vpToMc * cHeight; // vierport 左上角到 minimap container 的距离 / minimap container 宽高\n    // = 主图 expandedBBox 左上角 canvas container 坐标距离 / expandedBBox 宽高\n\n    var left = cWidth * -topLeft.x / expandedGraphCanvasBBox.width;\n    var top = cHeight * -topLeft.y / expandedGraphCanvasBBox.height;\n    var right = left + width;\n    var bottom = top + height;\n\n    if (left < 0) {\n      width += left;\n      left = 0;\n    }\n\n    if (right > cWidth) {\n      width = width - (right - cWidth);\n    }\n\n    if (top < 0) {\n      height += top;\n      top = 0;\n    }\n\n    if (bottom > cHeight) {\n      height = height - (bottom - cHeight);\n    } // 缓存目前缩放比，在移动 minimap 视窗时就不用再计算大图的移动量\n\n\n    this.set('ratio', ratio);\n    var correctLeft = \"\".concat(left, \"px\");\n    var correctTop = \"\".concat(top, \"px\");\n    modifyCSS(viewport, {\n      left: correctLeft,\n      top: correctTop,\n      width: \"\".concat(width, \"px\"),\n      height: \"\".concat(height, \"px\")\n    });\n  };\n\n  ImageMiniMap.prototype.init = function () {\n    this.initContainer();\n  };\n  /**\n   * 初始化 Minimap 的容器\n   */\n\n\n  ImageMiniMap.prototype.initContainer = function () {\n    var self = this;\n    var graph = self.get('graph');\n    var graphWidth = graph.get('width');\n    var graphHeight = graph.get('height');\n    var aspectRatio = graphHeight / graphWidth;\n    var className = self.get('className');\n    var parentNode = self.get('container'); // size of the minimap's container\n\n    var cWidth = self.get('width');\n    var cHeight = self.get('height');\n\n    if (!cWidth && !cHeight) {\n      cWidth = 200;\n    }\n\n    if (cWidth) {\n      cHeight = aspectRatio * cWidth;\n      self.set('height', cHeight);\n    } else {\n      cWidth = 1 / aspectRatio * cHeight;\n      self.set('width', cWidth);\n    }\n\n    var container = createDom(\"<div class='\".concat(className, \"' style='width: \").concat(cWidth, \"px; height: \").concat(cHeight, \"px; overflow: hidden; position: relative;'></div>\"));\n\n    if (isString(parentNode)) {\n      parentNode = document.getElementById(parentNode);\n    }\n\n    if (parentNode) {\n      parentNode.appendChild(container);\n    } else {\n      graph.get('container').appendChild(container);\n    }\n\n    self.set('container', container);\n    var containerDOM = createDom(\"<div class=\\\"g6-minimap-container\\\" style=\\\"position: relative; width: 100%; height: 100%; text-align: center; display: table;\\\"></div>\");\n    container.appendChild(containerDOM);\n    var span = createDom(\"<span style=\\\"display: table-cell; vertical-align: middle; \\\"></span>\");\n    containerDOM.appendChild(span);\n    self.set('containerDOM', containerDOM);\n    self.set('containerSpan', span);\n    var img = createDom(\"<img alt=\\\"\\\" src=\\\"\".concat(this.get('graphImg'), \"\\\" style=\\\"display: inline-block; user-select: none;\\\" draggable=\\\"false\\\" />\"));\n    self.set('imgDOM', img);\n    self.updateImgSize();\n    span.appendChild(img);\n    self.updateCanvas();\n  };\n\n  ImageMiniMap.prototype.updateImgSize = function () {\n    var self = this;\n    var imgDOM = self.get('imgDOM');\n    var cWidth = self.get('width');\n    var cHeight = self.get('height');\n\n    imgDOM.onload = function () {\n      var naturalSize = getImgNaturalDimension(imgDOM);\n\n      if (naturalSize[0] > naturalSize[1]) {\n        imgDOM.width = cWidth;\n      } else {\n        imgDOM.height = cHeight;\n      }\n    };\n  };\n\n  ImageMiniMap.prototype.updateCanvas = function () {\n    // 如果是在动画，则不刷新视图\n    var isRefresh = this.get('refresh');\n\n    if (!isRefresh) {\n      return;\n    }\n\n    var graph = this.get('graph');\n\n    if (graph.get('destroyed')) {\n      return;\n    } // 如果是视口变换，也不刷新视图，但是需要重置视口大小和位置\n\n\n    if (this.get('viewportChange')) {\n      this.set('viewportChange', false);\n      this.updateViewport();\n    }\n\n    var cWidth = this.get('width');\n    var graphBBox = graph.get('canvas').getCanvasBBox();\n    var width = graphBBox.width;\n    var ratio = cWidth / width; // // 更新minimap视口\n\n    this.set('ratio', ratio);\n    this.updateViewport();\n  };\n  /**\n   * 获取minimap的窗口\n   * @return {HTMLElement} 窗口的dom实例\n   */\n\n\n  ImageMiniMap.prototype.getViewport = function () {\n    return this.get('viewport');\n  };\n  /**\n   * 获取minimap的容器dom\n   * @return {HTMLElement} dom\n   */\n\n\n  ImageMiniMap.prototype.getContainer = function () {\n    return this.get('container');\n  };\n\n  ImageMiniMap.prototype.updateGraphImg = function (img) {\n    var self = this;\n    var oriImgDOM = self.get('imgDOM');\n    oriImgDOM.remove();\n    self.set('graphImg', img);\n    var imgDOM = createDom(\"<img alt=\\\"\\\" src=\\\"\".concat(img, \"\\\" style=\\\"display: inline-block;\\\" ondragstart=\\\"return false;\\\" onselectstart=\\\"return false;\\\"/>\"));\n    self.set('imgDOM', imgDOM);\n    imgDOM.src = img;\n    self.updateImgSize();\n    var span = self.get('containerSpan');\n    span.appendChild(imgDOM);\n    self.updateCanvas();\n  };\n\n  ImageMiniMap.prototype.destroy = function () {\n    var container = this.get('container');\n    container.parentNode.removeChild(container);\n  };\n\n  return ImageMiniMap;\n}(Base);\n\nexport default ImageMiniMap;","map":null,"metadata":{},"sourceType":"module"}