{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Basecoat } from '../common';\nimport { Point, Rectangle } from '../geometry';\nimport { Cell } from '../model/cell';\nimport { Node } from '../model/node';\nimport { Edge } from '../model/edge';\nimport { CellView } from '../view/cell';\nimport * as Registry from '../registry';\nimport { HTML } from '../shape/standard/html';\nimport { Base } from './base';\nimport { GraphView } from './view';\nimport { Decorator } from './decorator';\nimport { CSSManager } from './css';\nimport { Hook as HookManager } from './hook';\nimport { Options as GraphOptions } from './options';\nimport { DefsManager as Defs } from './defs';\nimport { GridManager as Grid } from './grid';\nimport { CoordManager as Coord } from './coord';\nimport { Keyboard as Shortcut } from './keyboard';\nimport { PrintManager as Print } from './print';\nimport { MouseWheel as Wheel } from './mousewheel';\nimport { FormatManager as Format } from './format';\nimport { Renderer as ViewRenderer } from './renderer';\nimport { HistoryManager as History } from './history';\nimport { MiniMapManager as MiniMap } from './minimap';\nimport { SnaplineManager as Snapline } from './snapline';\nimport { ScrollerManager as Scroller } from './scroller';\nimport { SelectionManager as Selection } from './selection';\nimport { HighlightManager as Highlight } from './highlight';\nimport { TransformManager as Transform } from './transform';\nimport { ClipboardManager as Clipboard } from './clipboard';\nimport { BackgroundManager as Background } from './background';\nexport class Graph extends Basecoat {\n  constructor(options) {\n    super();\n    this.options = GraphOptions.get(options);\n    this.css = new CSSManager(this);\n    this.hook = new HookManager(this);\n    this.view = this.hook.createView();\n    this.defs = this.hook.createDefsManager();\n    this.coord = this.hook.createCoordManager();\n    this.transform = this.hook.createTransformManager();\n    this.knob = this.hook.createKnobManager();\n    this.highlight = this.hook.createHighlightManager();\n    this.grid = this.hook.createGridManager();\n    this.background = this.hook.createBackgroundManager();\n    this.model = this.hook.createModel();\n    this.renderer = this.hook.createRenderer();\n    this.clipboard = this.hook.createClipboardManager();\n    this.snapline = this.hook.createSnaplineManager();\n    this.selection = this.hook.createSelectionManager();\n    this.history = this.hook.createHistoryManager();\n    this.scroller = this.hook.createScrollerManager();\n    this.minimap = this.hook.createMiniMapManager();\n    this.keyboard = this.hook.createKeyboard();\n    this.mousewheel = this.hook.createMouseWheel();\n    this.print = this.hook.createPrintManager();\n    this.format = this.hook.createFormatManager();\n    this.panning = this.hook.createPanningManager();\n    this.size = this.hook.createSizeManager();\n  }\n\n  get container() {\n    return this.view.container;\n  }\n\n  get [Symbol.toStringTag]() {\n    return Graph.toStringTag;\n  } // #region model\n\n\n  isNode(cell) {\n    return cell.isNode();\n  }\n\n  isEdge(cell) {\n    return cell.isEdge();\n  }\n\n  resetCells(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.model.resetCells(cells, options);\n    return this;\n  }\n\n  clearCells() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.model.clear(options);\n    return this;\n  }\n\n  toJSON() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.model.toJSON(options);\n  }\n\n  parseJSON(data) {\n    return this.model.parseJSON(data);\n  }\n\n  fromJSON(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.model.fromJSON(data, options);\n    return this;\n  }\n\n  getCellById(id) {\n    return this.model.getCell(id);\n  }\n\n  addNode(node) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.addNode(node, options);\n  }\n\n  addNodes(nodes) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.addCell(nodes.map(node => Node.isNode(node) ? node : this.createNode(node)), options);\n  }\n\n  createNode(metadata) {\n    return this.model.createNode(metadata);\n  }\n\n  removeNode(node) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.removeCell(node, options);\n  }\n\n  addEdge(edge) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.addEdge(edge, options);\n  }\n\n  addEdges(edges) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.addCell(edges.map(edge => Edge.isEdge(edge) ? edge : this.createEdge(edge)), options);\n  }\n\n  removeEdge(edge) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.removeCell(edge, options);\n  }\n\n  createEdge(metadata) {\n    return this.model.createEdge(metadata);\n  }\n\n  addCell(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.model.addCell(cell, options);\n    return this;\n  }\n\n  removeCell(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.removeCell(cell, options);\n  }\n\n  removeCells(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.removeCells(cells, options);\n  }\n\n  removeConnectedEdges(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.removeConnectedEdges(cell, options);\n  }\n\n  disconnectConnectedEdges(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.model.disconnectConnectedEdges(cell, options);\n    return this;\n  }\n\n  hasCell(cell) {\n    return this.model.has(cell);\n  }\n  /**\n   * **Deprecation Notice:** `getCell` is deprecated and will be moved in next\n   * major release. Use `getCellById()` instead.\n   *\n   * @deprecated\n   */\n\n\n  getCell(id) {\n    return this.model.getCell(id);\n  }\n\n  getCells() {\n    return this.model.getCells();\n  }\n\n  getCellCount() {\n    return this.model.total();\n  }\n  /**\n   * Returns all the nodes in the graph.\n   */\n\n\n  getNodes() {\n    return this.model.getNodes();\n  }\n  /**\n   * Returns all the edges in the graph.\n   */\n\n\n  getEdges() {\n    return this.model.getEdges();\n  }\n  /**\n   * Returns all outgoing edges for the node.\n   */\n\n\n  getOutgoingEdges(cell) {\n    return this.model.getOutgoingEdges(cell);\n  }\n  /**\n   * Returns all incoming edges for the node.\n   */\n\n\n  getIncomingEdges(cell) {\n    return this.model.getIncomingEdges(cell);\n  }\n  /**\n   * Returns edges connected with cell.\n   */\n\n\n  getConnectedEdges(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.getConnectedEdges(cell, options);\n  }\n  /**\n   * Returns an array of all the roots of the graph.\n   */\n\n\n  getRootNodes() {\n    return this.model.getRoots();\n  }\n  /**\n   * Returns an array of all the leafs of the graph.\n   */\n\n\n  getLeafNodes() {\n    return this.model.getLeafs();\n  }\n  /**\n   * Returns `true` if the node is a root node, i.e.\n   * there is no  edges coming to the node.\n   */\n\n\n  isRootNode(cell) {\n    return this.model.isRoot(cell);\n  }\n  /**\n   * Returns `true` if the node is a leaf node, i.e.\n   * there is no edges going out from the node.\n   */\n\n\n  isLeafNode(cell) {\n    return this.model.isLeaf(cell);\n  }\n  /**\n   * Returns all the neighbors of node in the graph. Neighbors are all\n   * the nodes connected to node via either incoming or outgoing edge.\n   */\n\n\n  getNeighbors(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.getNeighbors(cell, options);\n  }\n  /**\n   * Returns `true` if `cell2` is a neighbor of `cell1`.\n   */\n\n\n  isNeighbor(cell1, cell2) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.model.isNeighbor(cell1, cell2, options);\n  }\n\n  getSuccessors(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.getSuccessors(cell, options);\n  }\n  /**\n   * Returns `true` if `cell2` is a successor of `cell1`.\n   */\n\n\n  isSuccessor(cell1, cell2) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.model.isSuccessor(cell1, cell2, options);\n  }\n\n  getPredecessors(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.getPredecessors(cell, options);\n  }\n  /**\n   * Returns `true` if `cell2` is a predecessor of `cell1`.\n   */\n\n\n  isPredecessor(cell1, cell2) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.model.isPredecessor(cell1, cell2, options);\n  }\n\n  getCommonAncestor() {\n    return this.model.getCommonAncestor(...arguments);\n  }\n  /**\n   * Returns an array of cells that result from finding nodes/edges that\n   * are connected to any of the cells in the cells array. This function\n   * loops over cells and if the current cell is a edge, it collects its\n   * source/target nodes; if it is an node, it collects its incoming and\n   * outgoing edges if both the edge terminal (source/target) are in the\n   * cells array.\n   */\n\n\n  getSubGraph(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.getSubGraph(cells, options);\n  }\n  /**\n   * Clones the whole subgraph (including all the connected links whose\n   * source/target is in the subgraph). If `options.deep` is `true`, also\n   * take into account all the embedded cells of all the subgraph cells.\n   *\n   * Returns a map of the form: { [original cell ID]: [clone] }.\n   */\n\n\n  cloneSubGraph(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.cloneSubGraph(cells, options);\n  }\n\n  cloneCells(cells) {\n    return this.model.cloneCells(cells);\n  }\n\n  getNodesFromPoint(x, y) {\n    return this.model.getNodesFromPoint(x, y);\n  }\n\n  getNodesInArea(x, y, w, h, options) {\n    return this.model.getNodesInArea(x, y, w, h, options);\n  }\n\n  getNodesUnderNode(node) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.getNodesUnderNode(node, options);\n  }\n\n  searchCell(cell, iterator) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.model.search(cell, iterator, options);\n    return this;\n  }\n  /** *\n   * Returns an array of IDs of nodes on the shortest\n   * path between source and target.\n   */\n\n\n  getShortestPath(source, target) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.model.getShortestPath(source, target, options);\n  }\n  /**\n   * Returns the bounding box that surrounds all cells in the graph.\n   */\n\n\n  getAllCellsBBox() {\n    return this.model.getAllCellsBBox();\n  }\n  /**\n   * Returns the bounding box that surrounds all the given cells.\n   */\n\n\n  getCellsBBox(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.model.getCellsBBox(cells, options);\n  }\n\n  startBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.model.startBatch(name, data);\n  }\n\n  stopBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.model.stopBatch(name, data);\n  }\n\n  batchUpdate(arg1, arg2, arg3) {\n    const name = typeof arg1 === 'string' ? arg1 : 'update';\n    const execute = typeof arg1 === 'string' ? arg2 : arg1;\n    const data = typeof arg2 === 'function' ? arg3 : arg2;\n    this.startBatch(name, data);\n    const result = execute();\n    this.stopBatch(name, data);\n    return result;\n  }\n\n  updateCellId(cell, newId) {\n    return this.model.updateCellId(cell, newId);\n  } // #endregion\n  // #region view\n\n\n  isFrozen() {\n    return this.renderer.isFrozen();\n  }\n\n  freeze() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.renderer.freeze(options);\n    return this;\n  }\n\n  unfreeze() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.renderer.unfreeze(options);\n    return this;\n  }\n\n  isAsync() {\n    return this.renderer.isAsync();\n  }\n\n  setAsync(async) {\n    this.renderer.setAsync(async);\n    return this;\n  }\n\n  findView(ref) {\n    if (Cell.isCell(ref)) {\n      return this.findViewByCell(ref);\n    }\n\n    return this.findViewByElem(ref);\n  }\n\n  findViews(ref) {\n    if (Rectangle.isRectangleLike(ref)) {\n      return this.findViewsInArea(ref);\n    }\n\n    if (Point.isPointLike(ref)) {\n      return this.findViewsFromPoint(ref);\n    }\n\n    return [];\n  }\n\n  findViewByCell(cell) {\n    return this.renderer.findViewByCell(cell);\n  }\n\n  findViewByElem(elem) {\n    return this.renderer.findViewByElem(elem);\n  }\n\n  findViewsFromPoint(x, y) {\n    const p = typeof x === 'number' ? {\n      x,\n      y: y\n    } : x;\n    return this.renderer.findViewsFromPoint(p);\n  }\n\n  findViewsInArea(x, y, width, height, options) {\n    const rect = typeof x === 'number' ? {\n      x,\n      y: y,\n      width: width,\n      height: height\n    } : x;\n    const localOptions = typeof x === 'number' ? options : y;\n    return this.renderer.findViewsInArea(rect, localOptions);\n  }\n\n  isViewMounted(view) {\n    return this.renderer.isViewMounted(view);\n  }\n\n  getMountedViews() {\n    return this.renderer.getMountedViews();\n  }\n\n  getUnmountedViews() {\n    return this.renderer.getUnmountedViews();\n  }\n\n  matrix(mat) {\n    if (typeof mat === 'undefined') {\n      return this.transform.getMatrix();\n    }\n\n    this.transform.setMatrix(mat);\n    return this;\n  }\n\n  resize(width, height) {\n    this.size.resize(width, height);\n    return this;\n  }\n\n  resizeGraph(width, height) {\n    this.size.resizeGraph(width, height);\n    return this;\n  }\n\n  resizeScroller(width, height) {\n    this.size.resizeScroller(width, height);\n    return this;\n  }\n\n  resizePage(width, height) {\n    this.size.resizePage(width, height);\n    return this;\n  }\n\n  scale(sx) {\n    let sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sx;\n    let cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    if (typeof sx === 'undefined') {\n      return this.transform.getScale();\n    }\n\n    this.transform.scale(sx, sy, cx, cy);\n    return this;\n  }\n\n  zoom(factor, options) {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      if (typeof factor === 'undefined') {\n        return scroller.zoom();\n      }\n\n      scroller.zoom(factor, options);\n    } else {\n      if (typeof factor === 'undefined') {\n        return this.transform.getZoom();\n      }\n\n      this.transform.zoom(factor, options);\n    }\n\n    return this;\n  }\n\n  zoomTo(factor) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.zoom(factor, Object.assign(Object.assign({}, options), {\n        absolute: true\n      }));\n    } else {\n      this.transform.zoom(factor, Object.assign(Object.assign({}, options), {\n        absolute: true\n      }));\n    }\n  }\n\n  zoomToRect(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.zoomToRect(rect, options);\n    } else {\n      this.transform.zoomToRect(rect, options);\n    }\n\n    return this;\n  }\n\n  zoomToFit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.zoomToFit(options);\n    } else {\n      this.transform.zoomToFit(options);\n    }\n\n    return this;\n  }\n\n  rotate(angle, cx, cy) {\n    if (typeof angle === 'undefined') {\n      return this.transform.getRotation();\n    }\n\n    this.transform.rotate(angle, cx, cy);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'undefined') {\n      return this.transform.getTranslation();\n    }\n\n    this.transform.translate(tx, ty);\n    return this;\n  }\n\n  translateBy(dx, dy) {\n    const ts = this.translate();\n    const tx = ts.tx + dx;\n    const ty = ts.ty + dy;\n    return this.translate(tx, ty);\n  }\n  /**\n   * **Deprecation Notice:** `getArea` is deprecated and will be moved in next\n   * major release. Use `getGraphArea()` instead.\n   *\n   * @deprecated\n   */\n\n\n  getArea() {\n    return this.transform.getGraphArea();\n  }\n\n  getGraphArea() {\n    return this.transform.getGraphArea();\n  }\n\n  getContentArea() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.transform.getContentArea(options);\n  }\n\n  getContentBBox() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.transform.getContentBBox(options);\n  }\n\n  fitToContent(gridWidth, gridHeight, padding, options) {\n    return this.transform.fitToContent(gridWidth, gridHeight, padding, options);\n  }\n\n  scaleContentToFit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.transform.scaleContentToFit(options);\n    return this;\n  }\n  /**\n   * Position the center of graph to the center of the viewport.\n   */\n\n\n  center(optons) {\n    return this.centerPoint(optons);\n  }\n\n  centerPoint(x, y, options) {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.centerPoint(x, y, options);\n    } else {\n      this.transform.centerPoint(x, y);\n    }\n\n    return this;\n  }\n\n  centerContent(options) {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.centerContent(options);\n    } else {\n      this.transform.centerContent(options);\n    }\n\n    return this;\n  }\n\n  centerCell(cell, options) {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.centerCell(cell, options);\n    } else {\n      this.transform.centerCell(cell);\n    }\n\n    return this;\n  }\n\n  positionPoint(point, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.positionPoint(point, x, y, options);\n    } else {\n      this.transform.positionPoint(point, x, y);\n    }\n\n    return this;\n  }\n\n  positionRect(rect, direction, options) {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.positionRect(rect, direction, options);\n    } else {\n      this.transform.positionRect(rect, direction);\n    }\n\n    return this;\n  }\n\n  positionCell(cell, direction, options) {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.positionCell(cell, direction, options);\n    } else {\n      this.transform.positionCell(cell, direction);\n    }\n\n    return this;\n  }\n\n  positionContent(pos, options) {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      scroller.positionContent(pos, options);\n    } else {\n      this.transform.positionContent(pos, options);\n    }\n\n    return this;\n  } // #endregion\n  // #region coord\n\n\n  getClientMatrix() {\n    return this.coord.getClientMatrix();\n  }\n  /**\n   * Returns coordinates of the graph viewport, relative to the window.\n   */\n\n\n  getClientOffset() {\n    return this.coord.getClientOffset();\n  }\n  /**\n   * Returns coordinates of the graph viewport, relative to the document.\n   */\n\n\n  getPageOffset() {\n    return this.coord.getPageOffset();\n  }\n\n  snapToGrid(x, y) {\n    return this.coord.snapToGrid(x, y);\n  }\n\n  pageToLocal(x, y, width, height) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.pageToLocalRect(x);\n    }\n\n    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {\n      return this.coord.pageToLocalRect(x, y, width, height);\n    }\n\n    return this.coord.pageToLocalPoint(x, y);\n  }\n\n  localToPage(x, y, width, height) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.localToPageRect(x);\n    }\n\n    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {\n      return this.coord.localToPageRect(x, y, width, height);\n    }\n\n    return this.coord.localToPagePoint(x, y);\n  }\n\n  clientToLocal(x, y, width, height) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.clientToLocalRect(x);\n    }\n\n    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {\n      return this.coord.clientToLocalRect(x, y, width, height);\n    }\n\n    return this.coord.clientToLocalPoint(x, y);\n  }\n\n  localToClient(x, y, width, height) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.localToClientRect(x);\n    }\n\n    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {\n      return this.coord.localToClientRect(x, y, width, height);\n    }\n\n    return this.coord.localToClientPoint(x, y);\n  }\n\n  localToGraph(x, y, width, height) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.localToGraphRect(x);\n    }\n\n    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {\n      return this.coord.localToGraphRect(x, y, width, height);\n    }\n\n    return this.coord.localToGraphPoint(x, y);\n  }\n\n  graphToLocal(x, y, width, height) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.graphToLocalRect(x);\n    }\n\n    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {\n      return this.coord.graphToLocalRect(x, y, width, height);\n    }\n\n    return this.coord.graphToLocalPoint(x, y);\n  }\n\n  clientToGraph(x, y, width, height) {\n    if (Rectangle.isRectangleLike(x)) {\n      return this.coord.clientToGraphRect(x);\n    }\n\n    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {\n      return this.coord.clientToGraphRect(x, y, width, height);\n    }\n\n    return this.coord.clientToGraphPoint(x, y);\n  } // #endregion\n  // #region defs\n\n\n  defineFilter(options) {\n    return this.defs.filter(options);\n  }\n\n  defineGradient(options) {\n    return this.defs.gradient(options);\n  }\n\n  defineMarker(options) {\n    return this.defs.marker(options);\n  } // #endregion\n  // #region grid\n\n\n  getGridSize() {\n    return this.grid.getGridSize();\n  }\n\n  setGridSize(gridSize) {\n    this.grid.setGridSize(gridSize);\n    return this;\n  }\n\n  showGrid() {\n    this.grid.show();\n    return this;\n  }\n\n  hideGrid() {\n    this.grid.hide();\n    return this;\n  }\n\n  clearGrid() {\n    this.grid.clear();\n    return this;\n  }\n\n  drawGrid(options) {\n    this.grid.draw(options);\n    return this;\n  } // #endregion\n  // #region background\n\n\n  updateBackground() {\n    this.background.update();\n    return this;\n  }\n\n  drawBackground(options, onGraph) {\n    const scroller = this.scroller.widget;\n\n    if (scroller != null && (this.options.background == null || !onGraph)) {\n      scroller.backgroundManager.draw(options);\n    } else {\n      this.background.draw(options);\n    }\n\n    return this;\n  }\n\n  clearBackground(onGraph) {\n    const scroller = this.scroller.widget;\n\n    if (scroller != null && (this.options.background == null || !onGraph)) {\n      scroller.backgroundManager.clear();\n    } else {\n      this.background.clear();\n    }\n\n    return this;\n  } // #endregion\n  // #region clipboard\n\n\n  isClipboardEnabled() {\n    return !this.clipboard.disabled;\n  }\n\n  enableClipboard() {\n    this.clipboard.enable();\n    return this;\n  }\n\n  disableClipboard() {\n    this.clipboard.disable();\n    return this;\n  }\n\n  toggleClipboard(enabled) {\n    if (enabled != null) {\n      if (enabled !== this.isClipboardEnabled()) {\n        if (enabled) {\n          this.enableClipboard();\n        } else {\n          this.disableClipboard();\n        }\n      }\n    } else if (this.isClipboardEnabled()) {\n      this.disableClipboard();\n    } else {\n      this.enableClipboard();\n    }\n\n    return this;\n  }\n\n  isClipboardEmpty() {\n    return this.clipboard.isEmpty();\n  }\n\n  getCellsInClipboard() {\n    return this.clipboard.cells;\n  }\n\n  cleanClipboard() {\n    this.clipboard.clean();\n    return this;\n  }\n\n  copy(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.clipboard.copy(cells, options);\n    return this;\n  }\n\n  cut(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.clipboard.cut(cells, options);\n    return this;\n  }\n\n  paste() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let graph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n    return this.clipboard.paste(options, graph);\n  } // #endregion\n  // #region redo/undo\n\n\n  isHistoryEnabled() {\n    return !this.history.disabled;\n  }\n\n  enableHistory() {\n    this.history.enable();\n    return this;\n  }\n\n  disableHistory() {\n    this.history.disable();\n    return this;\n  }\n\n  toggleHistory(enabled) {\n    if (enabled != null) {\n      if (enabled !== this.isHistoryEnabled()) {\n        if (enabled) {\n          this.enableHistory();\n        } else {\n          this.disableHistory();\n        }\n      }\n    } else if (this.isHistoryEnabled()) {\n      this.disableHistory();\n    } else {\n      this.enableHistory();\n    }\n\n    return this;\n  }\n\n  undo() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.history.undo(options);\n    return this;\n  }\n\n  undoAndCancel() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.history.cancel(options);\n    return this;\n  }\n\n  redo() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.history.redo(options);\n    return this;\n  }\n\n  canUndo() {\n    return this.history.canUndo();\n  }\n\n  canRedo() {\n    return this.history.canRedo();\n  }\n\n  cleanHistory() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.history.clean(options);\n  } // #endregion\n  // #region keyboard\n\n\n  isKeyboardEnabled() {\n    return !this.keyboard.disabled;\n  }\n\n  enableKeyboard() {\n    this.keyboard.enable();\n    return this;\n  }\n\n  disableKeyboard() {\n    this.keyboard.disable();\n    return this;\n  }\n\n  toggleKeyboard(enabled) {\n    if (enabled != null) {\n      if (enabled !== this.isKeyboardEnabled()) {\n        if (enabled) {\n          this.enableKeyboard();\n        } else {\n          this.disableKeyboard();\n        }\n      }\n    } else if (this.isKeyboardEnabled()) {\n      this.disableKeyboard();\n    } else {\n      this.enableKeyboard();\n    }\n\n    return this;\n  }\n\n  bindKey(keys, callback, action) {\n    this.keyboard.on(keys, callback, action);\n    return this;\n  }\n\n  unbindKey(keys, action) {\n    this.keyboard.off(keys, action);\n    return this;\n  } // #endregion\n  // #region mousewheel\n\n\n  isMouseWheelEnabled() {\n    return !this.mousewheel.disabled;\n  }\n\n  enableMouseWheel() {\n    this.mousewheel.enable();\n    return this;\n  }\n\n  disableMouseWheel() {\n    this.mousewheel.disable();\n    return this;\n  }\n\n  toggleMouseWheel(enabled) {\n    if (enabled == null) {\n      if (this.isMouseWheelEnabled()) {\n        this.disableMouseWheel();\n      } else {\n        this.enableMouseWheel();\n      }\n    } else if (enabled) {\n      this.enableMouseWheel();\n    } else {\n      this.disableMouseWheel();\n    }\n\n    return this;\n  } // #endregion\n  // #region panning\n\n\n  isPannable() {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      return this.scroller.pannable;\n    }\n\n    return this.panning.pannable;\n  }\n\n  enablePanning() {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      this.scroller.enablePanning();\n    } else {\n      this.panning.enablePanning();\n    }\n\n    return this;\n  }\n\n  disablePanning() {\n    const scroller = this.scroller.widget;\n\n    if (scroller) {\n      this.scroller.disablePanning();\n    } else {\n      this.panning.disablePanning();\n    }\n\n    return this;\n  }\n\n  togglePanning(pannable) {\n    if (pannable == null) {\n      if (this.isPannable()) {\n        this.disablePanning();\n      } else {\n        this.enablePanning();\n      }\n    } else if (pannable !== this.isPannable()) {\n      if (pannable) {\n        this.enablePanning();\n      } else {\n        this.disablePanning();\n      }\n    }\n\n    return this;\n  } // #endregion\n  // #region scroller\n\n\n  lockScroller() {\n    var _a;\n\n    (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.lock();\n  }\n\n  unlockScroller() {\n    var _a;\n\n    (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.unlock();\n  }\n\n  updateScroller() {\n    var _a;\n\n    (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.update();\n  }\n\n  getScrollbarPosition() {\n    const scroller = this.scroller.widget;\n    return scroller.scrollbarPosition();\n  }\n\n  setScrollbarPosition(left, top, options) {\n    const scroller = this.scroller.widget;\n    scroller.scrollbarPosition(left, top, options);\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the position (x,y) on the graph (in local\n   * coordinates) is at the center of the viewport. If only one of the\n   * coordinates is specified, only scroll in the specified dimension and\n   * keep the other coordinate unchanged.\n   */\n\n\n  scrollToPoint(x, y, options) {\n    const scroller = this.scroller.widget;\n    scroller.scrollToPoint(x, y, options);\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the center of graph content is at the\n   * center of the viewport.\n   */\n\n\n  scrollToContent(options) {\n    const scroller = this.scroller.widget;\n    scroller.scrollToContent(options);\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the center of cell is at the center of\n   * the viewport.\n   */\n\n\n  scrollToCell(cell, options) {\n    const scroller = this.scroller.widget;\n    scroller.scrollToCell(cell, options);\n    return this;\n  }\n\n  transitionToPoint(x, y, options) {\n    const scroller = this.scroller.widget;\n    scroller.transitionToPoint(x, y, options);\n    return this;\n  }\n\n  transitionToRect(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const scroller = this.scroller.widget;\n    scroller.transitionToRect(rect, options);\n    return this;\n  } // #endregion\n  // #region selection\n\n\n  isSelectionEnabled() {\n    return !this.selection.disabled;\n  }\n\n  enableSelection() {\n    this.selection.enable();\n    return this;\n  }\n\n  disableSelection() {\n    this.selection.disable();\n    return this;\n  }\n\n  toggleSelection(enabled) {\n    if (enabled != null) {\n      if (enabled !== this.isSelectionEnabled()) {\n        if (enabled) {\n          this.enableSelection();\n        } else {\n          this.disableSelection();\n        }\n      }\n    } else if (this.isSelectionEnabled()) {\n      this.disableSelection();\n    } else {\n      this.enableSelection();\n    }\n\n    return this;\n  }\n\n  isMultipleSelection() {\n    return this.selection.isMultiple();\n  }\n\n  enableMultipleSelection() {\n    this.selection.enableMultiple();\n    return this;\n  }\n\n  disableMultipleSelection() {\n    this.selection.disableMultiple();\n    return this;\n  }\n\n  toggleMultipleSelection(multiple) {\n    if (multiple != null) {\n      if (multiple !== this.isMultipleSelection()) {\n        if (multiple) {\n          this.enableMultipleSelection();\n        } else {\n          this.disableMultipleSelection();\n        }\n      }\n    } else if (this.isMultipleSelection()) {\n      this.disableMultipleSelection();\n    } else {\n      this.enableMultipleSelection();\n    }\n\n    return this;\n  }\n\n  isSelectionMovable() {\n    return this.selection.widget.options.movable !== false;\n  }\n\n  enableSelectionMovable() {\n    this.selection.widget.options.movable = true;\n    return this;\n  }\n\n  disableSelectionMovable() {\n    this.selection.widget.options.movable = false;\n    return this;\n  }\n\n  toggleSelectionMovable(movable) {\n    if (movable != null) {\n      if (movable !== this.isSelectionMovable()) {\n        if (movable) {\n          this.enableSelectionMovable();\n        } else {\n          this.disableSelectionMovable();\n        }\n      }\n    } else if (this.isSelectionMovable()) {\n      this.disableSelectionMovable();\n    } else {\n      this.enableSelectionMovable();\n    }\n\n    return this;\n  }\n\n  isRubberbandEnabled() {\n    return !this.selection.rubberbandDisabled;\n  }\n\n  enableRubberband() {\n    this.selection.enableRubberband();\n    return this;\n  }\n\n  disableRubberband() {\n    this.selection.disableRubberband();\n    return this;\n  }\n\n  toggleRubberband(enabled) {\n    if (enabled != null) {\n      if (enabled !== this.isRubberbandEnabled()) {\n        if (enabled) {\n          this.enableRubberband();\n        } else {\n          this.disableRubberband();\n        }\n      }\n    } else if (this.isRubberbandEnabled()) {\n      this.disableRubberband();\n    } else {\n      this.enableRubberband();\n    }\n\n    return this;\n  }\n\n  isStrictRubberband() {\n    return this.selection.widget.options.strict === true;\n  }\n\n  enableStrictRubberband() {\n    this.selection.widget.options.strict = true;\n    return this;\n  }\n\n  disableStrictRubberband() {\n    this.selection.widget.options.strict = false;\n    return this;\n  }\n\n  toggleStrictRubberband(strict) {\n    if (strict != null) {\n      if (strict !== this.isStrictRubberband()) {\n        if (strict) {\n          this.enableStrictRubberband();\n        } else {\n          this.disableStrictRubberband();\n        }\n      }\n    } else if (this.isStrictRubberband()) {\n      this.disableStrictRubberband();\n    } else {\n      this.enableStrictRubberband();\n    }\n\n    return this;\n  }\n\n  setRubberbandModifiers(modifiers) {\n    this.selection.setModifiers(modifiers);\n  }\n\n  setSelectionFilter(filter) {\n    this.selection.setFilter(filter);\n    return this;\n  }\n\n  setSelectionDisplayContent(content) {\n    this.selection.setContent(content);\n    return this;\n  }\n\n  isSelectionEmpty() {\n    return this.selection.isEmpty();\n  }\n\n  cleanSelection(options) {\n    this.selection.clean(options);\n    return this;\n  }\n\n  resetSelection(cells, options) {\n    this.selection.reset(cells, options);\n    return this;\n  }\n\n  getSelectedCells() {\n    return this.selection.cells;\n  }\n\n  getSelectedCellCount() {\n    return this.selection.length;\n  }\n\n  isSelected(cell) {\n    return this.selection.isSelected(cell);\n  }\n\n  select(cells, options) {\n    this.selection.select(cells, options);\n    return this;\n  }\n\n  unselect(cells, options) {\n    this.selection.unselect(cells, options);\n    return this;\n  } // #endregion\n  // #region snapline\n\n\n  isSnaplineEnabled() {\n    return !this.snapline.widget.disabled;\n  }\n\n  enableSnapline() {\n    this.snapline.widget.enable();\n    return this;\n  }\n\n  disableSnapline() {\n    this.snapline.widget.disable();\n    return this;\n  }\n\n  toggleSnapline(enabled) {\n    if (enabled != null) {\n      if (enabled !== this.isSnaplineEnabled()) {\n        if (enabled) {\n          this.enableSnapline();\n        } else {\n          this.disableSnapline();\n        }\n      }\n    } else {\n      if (this.isSnaplineEnabled()) {\n        this.disableSnapline();\n      } else {\n        this.enableSnapline();\n      }\n\n      return this;\n    }\n  }\n\n  hideSnapline() {\n    this.snapline.widget.hide();\n    return this;\n  }\n\n  setSnaplineFilter(filter) {\n    this.snapline.widget.setFilter(filter);\n    return this;\n  }\n\n  isSnaplineOnResizingEnabled() {\n    return this.snapline.widget.options.resizing === true;\n  }\n\n  enableSnaplineOnResizing() {\n    this.snapline.widget.options.resizing = true;\n    return this;\n  }\n\n  disableSnaplineOnResizing() {\n    this.snapline.widget.options.resizing = false;\n    return this;\n  }\n\n  toggleSnaplineOnResizing(enableOnResizing) {\n    if (enableOnResizing != null) {\n      if (enableOnResizing !== this.isSnaplineOnResizingEnabled()) {\n        if (enableOnResizing) {\n          this.enableSnaplineOnResizing();\n        } else {\n          this.disableSnaplineOnResizing();\n        }\n      }\n    } else if (this.isSnaplineOnResizingEnabled()) {\n      this.disableSnaplineOnResizing();\n    } else {\n      this.enableSnaplineOnResizing();\n    }\n\n    return this;\n  }\n\n  isSharpSnapline() {\n    return this.snapline.widget.options.sharp === true;\n  }\n\n  enableSharpSnapline() {\n    this.snapline.widget.options.sharp = true;\n    return this;\n  }\n\n  disableSharpSnapline() {\n    this.snapline.widget.options.sharp = false;\n    return this;\n  }\n\n  toggleSharpSnapline(sharp) {\n    if (sharp != null) {\n      if (sharp !== this.isSharpSnapline()) {\n        if (sharp) {\n          this.enableSharpSnapline();\n        } else {\n          this.disableSharpSnapline();\n        }\n      }\n    } else if (this.isSharpSnapline()) {\n      this.disableSharpSnapline();\n    } else {\n      this.enableSharpSnapline();\n    }\n\n    return this;\n  }\n\n  getSnaplineTolerance() {\n    return this.snapline.widget.options.tolerance;\n  }\n\n  setSnaplineTolerance(tolerance) {\n    this.snapline.widget.options.tolerance = tolerance;\n    return this;\n  } // #endregion\n  // #region tools\n\n\n  removeTools() {\n    this.emit('tools:remove');\n    return this;\n  }\n\n  hideTools() {\n    this.emit('tools:hide');\n    return this;\n  }\n\n  showTools() {\n    this.emit('tools:show');\n    return this;\n  } // #endregion\n  // #region format\n\n\n  toSVG(callback) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.format.toSVG(callback, options);\n  }\n\n  toDataURL(callback, options) {\n    this.format.toDataURL(callback, options);\n  }\n\n  toPNG(callback) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.format.toPNG(callback, options);\n  }\n\n  toJPEG(callback) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.format.toJPEG(callback, options);\n  } // #endregion\n  // #region print\n\n\n  printPreview(options) {\n    this.print.show(options);\n  } // #endregion\n  // #region dispose\n\n\n  dispose() {\n    this.clearCells();\n    this.off();\n    this.css.dispose();\n    this.hook.dispose();\n    this.defs.dispose();\n    this.grid.dispose();\n    this.coord.dispose();\n    this.transform.dispose();\n    this.knob.dispose();\n    this.highlight.dispose();\n    this.background.dispose();\n    this.clipboard.dispose();\n    this.snapline.dispose();\n    this.selection.dispose();\n    this.history.dispose();\n    this.keyboard.dispose();\n    this.mousewheel.dispose();\n    this.print.dispose();\n    this.format.dispose();\n    this.minimap.dispose();\n    this.panning.dispose();\n    this.scroller.dispose();\n    this.view.dispose();\n    this.renderer.dispose();\n    this.size.dispose();\n  }\n\n}\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"lockScroller\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"unlockScroller\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"updateScroller\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"getScrollbarPosition\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"setScrollbarPosition\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"scrollToPoint\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"scrollToContent\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"scrollToCell\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"transitionToPoint\", null);\n\n__decorate([Decorator.checkScroller()], Graph.prototype, \"transitionToRect\", null);\n\n__decorate([Basecoat.dispose()], Graph.prototype, \"dispose\", null);\n\n(function (Graph) {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  Graph.View = GraphView;\n  Graph.Hook = HookManager;\n  Graph.Renderer = ViewRenderer;\n  Graph.Keyboard = Shortcut;\n  Graph.MouseWheel = Wheel;\n  Graph.BaseManager = Base;\n  Graph.DefsManager = Defs;\n  Graph.GridManager = Grid;\n  Graph.CoordManager = Coord;\n  Graph.PrintManager = Print;\n  Graph.FormatManager = Format;\n  Graph.MiniMapManager = MiniMap;\n  Graph.HistoryManager = History;\n  Graph.SnaplineManager = Snapline;\n  Graph.ScrollerManager = Scroller;\n  Graph.ClipboardManager = Clipboard;\n  Graph.TransformManager = Transform;\n  Graph.HighlightManager = Highlight;\n  Graph.BackgroundManager = Background;\n  Graph.SelectionManager = Selection;\n})(Graph || (Graph = {}));\n\n(function (Graph) {\n  Graph.toStringTag = `X6.${Graph.name}`;\n\n  function isGraph(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Graph) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const graph = instance;\n\n    if ((tag == null || tag === Graph.toStringTag) && graph.hook != null && graph.view != null && graph.model != null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  Graph.isGraph = isGraph;\n})(Graph || (Graph = {}));\n\n(function (Graph) {\n  function render(options, data) {\n    const graph = options instanceof HTMLElement ? new Graph({\n      container: options\n    }) : new Graph(options);\n\n    if (data != null) {\n      graph.fromJSON(data);\n    }\n\n    return graph;\n  }\n\n  Graph.render = render;\n})(Graph || (Graph = {}));\n\n(function (Graph) {\n  Graph.registerNode = Node.registry.register;\n  Graph.registerEdge = Edge.registry.register;\n  Graph.registerView = CellView.registry.register;\n  Graph.registerAttr = Registry.Attr.registry.register;\n  Graph.registerGrid = Registry.Grid.registry.register;\n  Graph.registerFilter = Registry.Filter.registry.register;\n  Graph.registerNodeTool = Registry.NodeTool.registry.register;\n  Graph.registerEdgeTool = Registry.EdgeTool.registry.register;\n  Graph.registerBackground = Registry.Background.registry.register;\n  Graph.registerHighlighter = Registry.Highlighter.registry.register;\n  Graph.registerPortLayout = Registry.PortLayout.registry.register;\n  Graph.registerPortLabelLayout = Registry.PortLabelLayout.registry.register;\n  Graph.registerMarker = Registry.Marker.registry.register;\n  Graph.registerRouter = Registry.Router.registry.register;\n  Graph.registerConnector = Registry.Connector.registry.register;\n  Graph.registerAnchor = Registry.NodeAnchor.registry.register;\n  Graph.registerEdgeAnchor = Registry.EdgeAnchor.registry.register;\n  Graph.registerConnectionPoint = Registry.ConnectionPoint.registry.register;\n  Graph.registerConnectionStrategy = Registry.ConnectionStrategy.registry.register;\n  Graph.registerHTMLComponent = HTML.componentRegistry.register;\n})(Graph || (Graph = {}));\n\n(function (Graph) {\n  Graph.unregisterNode = Node.registry.unregister;\n  Graph.unregisterEdge = Edge.registry.unregister;\n  Graph.unregisterView = CellView.registry.unregister;\n  Graph.unregisterAttr = Registry.Attr.registry.unregister;\n  Graph.unregisterGrid = Registry.Grid.registry.unregister;\n  Graph.unregisterFilter = Registry.Filter.registry.unregister;\n  Graph.unregisterNodeTool = Registry.NodeTool.registry.unregister;\n  Graph.unregisterEdgeTool = Registry.EdgeTool.registry.unregister;\n  Graph.unregisterBackground = Registry.Background.registry.unregister;\n  Graph.unregisterHighlighter = Registry.Highlighter.registry.unregister;\n  Graph.unregisterPortLayout = Registry.PortLayout.registry.unregister;\n  Graph.unregisterPortLabelLayout = Registry.PortLabelLayout.registry.unregister;\n  Graph.unregisterMarker = Registry.Marker.registry.unregister;\n  Graph.unregisterRouter = Registry.Router.registry.unregister;\n  Graph.unregisterConnector = Registry.Connector.registry.unregister;\n  Graph.unregisterAnchor = Registry.NodeAnchor.registry.unregister;\n  Graph.unregisterEdgeAnchor = Registry.EdgeAnchor.registry.unregister;\n  Graph.unregisterConnectionPoint = Registry.ConnectionPoint.registry.unregister;\n  Graph.unregisterConnectionStrategy = Registry.ConnectionStrategy.registry.unregister;\n  Graph.unregisterHTMLComponent = HTML.componentRegistry.unregister;\n})(Graph || (Graph = {}));","map":null,"metadata":{},"sourceType":"module"}