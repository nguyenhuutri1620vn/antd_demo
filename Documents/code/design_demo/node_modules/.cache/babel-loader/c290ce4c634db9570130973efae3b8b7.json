{"ast":null,"code":"/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Matrix as MLMatrix, SingularValueDecomposition } from \"ml-matrix\";\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * mds 布局\n */\n\nexport class MDSLayout extends Base {\n  constructor(options) {\n    super();\n    /** 布局中心 */\n\n    this.center = [0, 0];\n    /** 边长度 */\n\n    this.linkDistance = 50;\n    this.nodes = [];\n    this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      center: [0, 0],\n      linkDistance: 50\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    const self = this;\n    const {\n      nodes,\n      edges = []\n    } = self;\n    const center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    const linkDistance = self.linkDistance; // the graph-theoretic distance (shortest path distance) matrix\n\n    const adjMatrix = getAdjMatrix({\n      nodes,\n      edges\n    }, false);\n    const distances = floydWarshall(adjMatrix);\n    self.handleInfinity(distances); // scale the ideal edge length acoording to linkDistance\n\n    const scaledD = scaleMatrix(distances, linkDistance);\n    self.scaledDistances = scaledD; // get positions by MDS\n\n    const positions = self.runMDS();\n    self.positions = positions;\n    positions.forEach((p, i) => {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges\n    };\n  }\n  /**\n   * mds 算法\n   * @return {array} positions 计算后的节点位置数组\n   */\n\n\n  runMDS() {\n    const self = this;\n    const dimension = 2;\n    const distances = self.scaledDistances; // square distances\n\n    const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n    const rowMeans = M.mean(\"row\");\n    const colMeans = M.mean(\"column\");\n    const totalMean = M.mean();\n    M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n    // points from it\n\n    const ret = new SingularValueDecomposition(M);\n    const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n    return ret.leftSingularVectors.toJSON().map(row => {\n      return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n    });\n  }\n\n  handleInfinity(distances) {\n    let maxDistance = -999999;\n    distances.forEach(row => {\n      row.forEach(value => {\n        if (value === Infinity) {\n          return;\n        }\n\n        if (maxDistance < value) {\n          maxDistance = value;\n        }\n      });\n    });\n    distances.forEach((row, i) => {\n      row.forEach((value, j) => {\n        if (value === Infinity) {\n          distances[i][j] = maxDistance;\n        }\n      });\n    });\n  }\n\n  getType() {\n    return \"mds\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}