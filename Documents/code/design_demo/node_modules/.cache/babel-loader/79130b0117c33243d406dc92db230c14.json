{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, FunctionExt } from '../util';\nimport { Basecoat } from '../common';\nimport { Model } from '../model/model';\nexport class HistoryManager extends Basecoat {\n  constructor(options) {\n    super();\n    this.batchCommands = null;\n    this.batchLevel = 0;\n    this.lastBatchIndex = -1;\n    this.freezed = false;\n    this.handlers = [];\n    this.graph = options.graph;\n    this.model = options.graph.model;\n    this.options = Util.getOptions(options);\n    this.validator = new HistoryManager.Validator({\n      history: this,\n      cancelInvalid: this.options.cancelInvalid\n    });\n    this.clean();\n    this.startListening();\n  }\n\n  get disabled() {\n    return this.options.enabled !== true;\n  }\n\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true;\n    }\n  }\n\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false;\n    }\n  }\n\n  undo() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop();\n\n      if (cmd) {\n        this.revertCommand(cmd, options);\n        this.redoStack.push(cmd);\n        this.notify('undo', cmd, options);\n      }\n    }\n\n    return this;\n  }\n\n  redo() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.disabled) {\n      const cmd = this.redoStack.pop();\n\n      if (cmd) {\n        this.applyCommand(cmd, options);\n        this.undoStack.push(cmd);\n        this.notify('redo', cmd, options);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Same as `undo()` but does not store the undo-ed command to the\n   * `redoStack`. Canceled command therefore cannot be redo-ed.\n   */\n\n\n  cancel() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop();\n\n      if (cmd) {\n        this.revertCommand(cmd, options);\n        this.redoStack = [];\n        this.notify('cancel', cmd, options);\n      }\n    }\n\n    return this;\n  }\n\n  clean() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.undoStack = [];\n    this.redoStack = [];\n    this.notify('clean', null, options);\n    return this;\n  }\n\n  canUndo() {\n    return !this.disabled && this.undoStack.length > 0;\n  }\n\n  canRedo() {\n    return !this.disabled && this.redoStack.length > 0;\n  }\n\n  validate(events) {\n    for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      callbacks[_key - 1] = arguments[_key];\n    }\n\n    this.validator.validate(events, ...callbacks);\n    return this;\n  }\n\n  dispose() {\n    this.validator.dispose();\n    this.clean();\n    this.stopListening();\n  }\n\n  startListening() {\n    this.model.on('batch:start', this.initBatchCommand, this);\n    this.model.on('batch:stop', this.storeBatchCommand, this);\n\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.handlers[index] = this.addCommand.bind(this, name);\n        this.model.on(name, this.handlers[index]);\n      });\n    }\n\n    this.validator.on('invalid', args => this.trigger('invalid', args));\n  }\n\n  stopListening() {\n    this.model.off('batch:start', this.initBatchCommand, this);\n    this.model.off('batch:stop', this.storeBatchCommand, this);\n\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.model.off(name, this.handlers[index]);\n      });\n      this.handlers.length = 0;\n    }\n\n    this.validator.off('invalid');\n  }\n\n  createCommand(options) {\n    return {\n      batch: options ? options.batch : false,\n      data: {}\n    };\n  }\n\n  revertCommand(cmd, options) {\n    this.freezed = true;\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n    for (let i = cmds.length - 1; i >= 0; i -= 1) {\n      const cmd = cmds[i];\n      const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.revertOptionsList || []));\n      this.executeCommand(cmd, true, localOptions);\n    }\n\n    this.freezed = false;\n  }\n\n  applyCommand(cmd, options) {\n    this.freezed = true;\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n    for (let i = 0; i < cmds.length; i += 1) {\n      const cmd = cmds[i];\n      const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.applyOptionsList || []));\n      this.executeCommand(cmd, false, localOptions);\n    }\n\n    this.freezed = false;\n  }\n\n  executeCommand(cmd, revert, options) {\n    const model = this.model; // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n\n    const cell = model.getCell(cmd.data.id);\n    const event = cmd.event;\n\n    if (Util.isAddEvent(event) && revert || Util.isRemoveEvent(event) && !revert) {\n      cell.remove(options);\n    } else if (Util.isAddEvent(event) && !revert || Util.isRemoveEvent(event) && revert) {\n      const data = cmd.data;\n\n      if (data.node) {\n        model.addNode(data.props, options);\n      } else if (data.edge) {\n        model.addEdge(data.props, options);\n      }\n    } else if (Util.isChangeEvent(event)) {\n      const data = cmd.data;\n      const key = data.key;\n\n      if (key) {\n        const value = revert ? data.prev[key] : data.next[key];\n        cell.prop(key, value, options);\n      }\n    } else {\n      const executeCommand = this.options.executeCommand;\n\n      if (executeCommand) {\n        FunctionExt.call(executeCommand, this, cmd, revert, options);\n      }\n    }\n  }\n\n  addCommand(event, args) {\n    if (this.freezed || this.disabled) {\n      return;\n    }\n\n    const eventArgs = args;\n    const options = eventArgs.options || {};\n\n    if (options.dryrun) {\n      return;\n    }\n\n    if (Util.isAddEvent(event) && this.options.ignoreAdd || Util.isRemoveEvent(event) && this.options.ignoreRemove || Util.isChangeEvent(event) && this.options.ignoreChange) {\n      return;\n    } // before\n    // ------\n\n\n    const before = this.options.beforeAddCommand;\n\n    if (before != null && FunctionExt.call(before, this, event, args) === false) {\n      return;\n    }\n\n    if (event === 'cell:change:*') {\n      // eslint-disable-next-line\n      event = `cell:change:${eventArgs.key}`;\n    }\n\n    const cell = eventArgs.cell;\n    const isModelChange = Model.isModel(cell);\n    let cmd;\n\n    if (this.batchCommands) {\n      // In most cases we are working with same object, doing\n      // same action etc. translate an object piece by piece.\n      cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)]; // Check if we are start working with new object or performing different\n      // action with it. Note, that command is uninitialized when lastCmdIndex\n      // equals -1. In that case we are done, command we were looking for is\n      // already set\n\n      const diffId = isModelChange && !cmd.modelChange || cmd.data.id !== cell.id;\n      const diffName = cmd.event !== event;\n\n      if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n        // Trying to find command first, which was performing same\n        // action with the object as we are doing now with cell.\n        const index = this.batchCommands.findIndex(cmd => (isModelChange && cmd.modelChange || cmd.data.id === cell.id) && cmd.event === event);\n\n        if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n          cmd = this.createCommand({\n            batch: true\n          });\n        } else {\n          cmd = this.batchCommands[index];\n          this.batchCommands.splice(index, 1);\n        }\n\n        this.batchCommands.push(cmd);\n        this.lastBatchIndex = this.batchCommands.length - 1;\n      }\n    } else {\n      cmd = this.createCommand({\n        batch: false\n      });\n    } // add & remove\n    // ------------\n\n\n    if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n      const data = cmd.data;\n      cmd.event = event;\n      cmd.options = options;\n      data.id = cell.id;\n      data.props = ObjectExt.cloneDeep(cell.toJSON());\n\n      if (cell.isEdge()) {\n        data.edge = true;\n      } else if (cell.isNode()) {\n        data.node = true;\n      }\n\n      return this.push(cmd, options);\n    } // change:*\n    // --------\n\n\n    if (Util.isChangeEvent(event)) {\n      const key = args.key;\n      const data = cmd.data;\n\n      if (!cmd.batch || !cmd.event) {\n        // Do this only once. Set previous data and action (also\n        // serves as a flag so that we don't repeat this branche).\n        cmd.event = event;\n        cmd.options = options;\n        data.key = key;\n\n        if (data.prev == null) {\n          data.prev = {};\n        }\n\n        data.prev[key] = ObjectExt.clone(cell.previous(key));\n\n        if (isModelChange) {\n          cmd.modelChange = true;\n        } else {\n          data.id = cell.id;\n        }\n      }\n\n      if (data.next == null) {\n        data.next = {};\n      }\n\n      data.next[key] = ObjectExt.clone(cell.prop(key));\n      return this.push(cmd, options);\n    } // others\n    // ------\n\n\n    const afterAddCommand = this.options.afterAddCommand;\n\n    if (afterAddCommand) {\n      FunctionExt.call(afterAddCommand, this, event, args, cmd);\n    }\n\n    this.push(cmd, options);\n  }\n  /**\n   * Gather multiple changes into a single command. These commands could\n   * be reverted with single `undo()` call. From the moment the function\n   * is called every change made on model is not stored into the undoStack.\n   * Changes are temporarily kept until `storeBatchCommand()` is called.\n   */\n  // eslint-disable-next-line\n\n\n  initBatchCommand(options) {\n    if (this.freezed) {\n      return;\n    }\n\n    if (this.batchCommands) {\n      this.batchLevel += 1;\n    } else {\n      this.batchCommands = [this.createCommand({\n        batch: true\n      })];\n      this.batchLevel = 0;\n      this.lastBatchIndex = -1;\n    }\n  }\n  /**\n   * Store changes temporarily kept in the undoStack. You have to call this\n   * function as many times as `initBatchCommand()` been called.\n   */\n\n\n  storeBatchCommand(options) {\n    if (this.freezed) {\n      return;\n    }\n\n    if (this.batchCommands && this.batchLevel <= 0) {\n      const cmds = this.filterBatchCommand(this.batchCommands);\n\n      if (cmds.length > 0) {\n        this.redoStack = [];\n        this.undoStack.push(cmds);\n        this.notify('add', cmds, options);\n      }\n\n      this.batchCommands = null;\n      this.lastBatchIndex = -1;\n      this.batchLevel = 0;\n    } else if (this.batchCommands && this.batchLevel > 0) {\n      this.batchLevel -= 1;\n    }\n  }\n\n  filterBatchCommand(batchCommands) {\n    let cmds = batchCommands.slice();\n    const result = [];\n\n    while (cmds.length > 0) {\n      const cmd = cmds.shift();\n      const evt = cmd.event;\n      const id = cmd.data.id;\n\n      if (evt != null && (id != null || cmd.modelChange)) {\n        if (Util.isAddEvent(evt)) {\n          const index = cmds.findIndex(c => Util.isRemoveEvent(c.event) && c.data.id === id);\n\n          if (index >= 0) {\n            cmds = cmds.filter((c, i) => index < i || c.data.id !== id);\n            continue;\n          }\n        } else if (Util.isRemoveEvent(evt)) {\n          const index = cmds.findIndex(c => Util.isAddEvent(c.event) && c.data.id === id);\n\n          if (index >= 0) {\n            cmds.splice(index, 1);\n            continue;\n          }\n        } else if (Util.isChangeEvent(evt)) {\n          const data = cmd.data;\n\n          if (ObjectExt.isEqual(data.prev, data.next)) {\n            continue;\n          }\n        } else {// pass\n        }\n\n        result.push(cmd);\n      }\n    }\n\n    return result;\n  }\n\n  notify(event, cmd, options) {\n    const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];\n    this.emit(event, {\n      cmds,\n      options\n    });\n    this.emit('change', {\n      cmds,\n      options\n    });\n  }\n\n  push(cmd, options) {\n    this.redoStack = [];\n\n    if (cmd.batch) {\n      this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);\n      this.emit('batch', {\n        cmd,\n        options\n      });\n    } else {\n      this.undoStack.push(cmd);\n      this.notify('add', cmd, options);\n    }\n  }\n\n}\n\n__decorate([Basecoat.dispose()], HistoryManager.prototype, \"dispose\", null);\n\n(function (HistoryManager) {\n  /**\n   * Runs a set of callbacks to determine if a command is valid. This is\n   * useful for checking if a certain action in your application does\n   * lead to an invalid state of the graph.\n   */\n  class Validator extends Basecoat {\n    constructor(options) {\n      super();\n      this.map = {};\n      this.command = options.history;\n      this.cancelInvalid = options.cancelInvalid !== false;\n      this.command.on('add', this.onCommandAdded, this);\n    }\n\n    onCommandAdded(_ref) {\n      let {\n        cmds\n      } = _ref;\n      return Array.isArray(cmds) ? cmds.every(cmd => this.isValidCommand(cmd)) : this.isValidCommand(cmds);\n    }\n\n    isValidCommand(cmd) {\n      if (cmd.options && cmd.options.validation === false) {\n        return true;\n      }\n\n      const callbacks = cmd.event && this.map[cmd.event] || [];\n      let handoverErr = null;\n      callbacks.forEach(routes => {\n        let i = 0;\n\n        const rollup = err => {\n          const fn = routes[i];\n          i += 1;\n\n          try {\n            if (fn) {\n              fn(err, cmd, rollup);\n            } else {\n              handoverErr = err;\n              return;\n            }\n          } catch (err) {\n            rollup(err);\n          }\n        };\n\n        rollup(handoverErr);\n      });\n\n      if (handoverErr) {\n        if (this.cancelInvalid) {\n          this.command.cancel();\n        }\n\n        this.emit('invalid', {\n          err: handoverErr\n        });\n        return false;\n      }\n\n      return true;\n    }\n\n    validate(events) {\n      for (var _len2 = arguments.length, callbacks = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        callbacks[_key2 - 1] = arguments[_key2];\n      }\n\n      const evts = Array.isArray(events) ? events : events.split(/\\s+/);\n      callbacks.forEach(callback => {\n        if (typeof callback !== 'function') {\n          throw new Error(`${evts.join(' ')} requires callback functions.`);\n        }\n      });\n      evts.forEach(event => {\n        if (this.map[event] == null) {\n          this.map[event] = [];\n        }\n\n        this.map[event].push(callbacks);\n      });\n      return this;\n    }\n\n    dispose() {\n      this.command.off('add', this.onCommandAdded, this);\n    }\n\n  }\n\n  __decorate([Basecoat.dispose()], Validator.prototype, \"dispose\", null);\n\n  HistoryManager.Validator = Validator;\n})(HistoryManager || (HistoryManager = {}));\n\nvar Util;\n\n(function (Util) {\n  function isAddEvent(event) {\n    return event === 'cell:added';\n  }\n\n  Util.isAddEvent = isAddEvent;\n\n  function isRemoveEvent(event) {\n    return event === 'cell:removed';\n  }\n\n  Util.isRemoveEvent = isRemoveEvent;\n\n  function isChangeEvent(event) {\n    return event != null && event.startsWith('cell:change:');\n  }\n\n  Util.isChangeEvent = isChangeEvent;\n\n  function getOptions(options) {\n    const {\n      graph\n    } = options,\n          others = __rest(options, [\"graph\"]);\n\n    const reservedNames = ['cell:added', 'cell:removed', 'cell:change:*'];\n    const batchEvents = ['batch:start', 'batch:stop'];\n    const eventNames = options.eventNames ? options.eventNames.filter(event => !(Util.isChangeEvent(event) || reservedNames.includes(event) || batchEvents.includes(event))) : reservedNames;\n    return Object.assign(Object.assign({}, others), {\n      eventNames,\n      applyOptionsList: options.applyOptionsList || ['propertyPath'],\n      revertOptionsList: options.revertOptionsList || ['propertyPath']\n    });\n  }\n\n  Util.getOptions = getOptions;\n\n  function sortBatchCommands(cmds) {\n    const results = [];\n\n    for (let i = 0, ii = cmds.length; i < ii; i += 1) {\n      const cmd = cmds[i];\n      let index = null;\n\n      if (Util.isAddEvent(cmd.event)) {\n        const id = cmd.data.id;\n\n        for (let j = 0; j < i; j += 1) {\n          if (cmds[j].data.id === id) {\n            index = j;\n            break;\n          }\n        }\n      }\n\n      if (index !== null) {\n        results.splice(index, 0, cmd);\n      } else {\n        results.push(cmd);\n      }\n    }\n\n    return results;\n  }\n\n  Util.sortBatchCommands = sortBatchCommands;\n})(Util || (Util = {}));","map":null,"metadata":{},"sourceType":"module"}