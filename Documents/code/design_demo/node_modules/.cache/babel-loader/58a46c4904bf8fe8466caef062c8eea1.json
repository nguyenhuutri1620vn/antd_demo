{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nexport var\n/**\n * borrow from playcanvas\n */\nPlane = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Plane, _Geometry);\n\n  var _super = _createSuper(Plane);\n\n  function Plane() {\n    _classCallCheck(this, Plane);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Plane, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config = this.config,\n          _this$config$halfExte = _this$config.halfExtents,\n          halfExtents = _this$config$halfExte === void 0 ? [0.5, 0.5] : _this$config$halfExte,\n          _this$config$widthSeg = _this$config.widthSegments,\n          widthSegments = _this$config$widthSeg === void 0 ? 5 : _this$config$widthSeg,\n          _this$config$lengthSe = _this$config.lengthSegments,\n          lengthSegments = _this$config$lengthSe === void 0 ? 5 : _this$config$lengthSe;\n      var positions = [];\n      var normals = [];\n      var uvs = [];\n      var indices = [];\n      var vcounter = 0;\n\n      for (var i = 0; i <= widthSegments; i++) {\n        for (var j = 0; j <= lengthSegments; j++) {\n          var x = -halfExtents[0] + 2.0 * halfExtents[0] * i / widthSegments;\n          var y = 0.0;\n          var z = -(-halfExtents[1] + 2.0 * halfExtents[1] * j / lengthSegments);\n          var u = i / widthSegments;\n          var v = j / lengthSegments;\n          positions.push(x, y, z);\n          normals.push(0.0, 1.0, 0.0);\n          uvs.push(u, v);\n\n          if (i < widthSegments && j < lengthSegments) {\n            indices.push(vcounter + lengthSegments + 1, vcounter + 1, vcounter);\n            indices.push(vcounter + lengthSegments + 1, vcounter + lengthSegments + 2, vcounter + 1);\n          }\n\n          vcounter++;\n        }\n      } // generate AABB\n\n\n      var aabb = generateAABBFromVertices(positions);\n      var component = this.getComponent();\n      component.indices = Uint32Array.from(indices);\n      component.aabb = aabb;\n      component.vertexCount = vcounter;\n      component.attributes = [{\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float2'\n        }]\n      }]; // TODO: barycentric & tangent\n    }\n  }]);\n\n  return Plane;\n}(Geometry)) || _class);","map":null,"metadata":{},"sourceType":"module"}