{"ast":null,"code":"/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isNumber, isFunction, isArray, getDegree, isObject, getEdgeTerminal } from \"../util\";\n\nconst proccessToFunc = (value, defaultV) => {\n  let func;\n\n  if (!value) {\n    func = d => {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = d => {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * graphin 中的 force 布局\n */\n\n\nexport class GForceLayout extends Base {\n  constructor(options) {\n    super();\n    /** 停止迭代的最大迭代数 */\n\n    this.maxIteration = 1000;\n    /** 是否启动 worker */\n\n    this.workerEnabled = false;\n    /** 弹簧引力系数 */\n\n    this.edgeStrength = 200;\n    /** 斥力系数 */\n\n    this.nodeStrength = 1000;\n    /** 库伦系数 */\n\n    this.coulombDisScale = 0.005;\n    /** 阻尼系数 */\n\n    this.damping = 0.9;\n    /** 最大速度 */\n\n    this.maxSpeed = 1000;\n    /** 一次迭代的平均移动距离小于该值时停止迭代 */\n\n    this.minMovement = 0.5;\n    /** 迭代中衰减 */\n\n    this.interval = 0.02;\n    /** 斥力的一个系数 */\n\n    this.factor = 1;\n    /** 理想边长 */\n\n    this.linkDistance = 1;\n    /** 重力大小 */\n\n    this.gravity = 10;\n    /** 是否防止重叠 */\n\n    this.preventOverlap = true;\n    /** 每次迭代结束的回调函数 */\n\n    this.tick = () => {};\n\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.nodeMap = {};\n    this.nodeIdxMap = {};\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      maxIteration: 500,\n      gravity: 10,\n      enableTick: true\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    var _a, _b;\n\n    const self = this;\n    const nodes = self.nodes;\n\n    if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n      window.clearInterval(self.timeInterval);\n    }\n\n    if (!nodes || nodes.length === 0) {\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    const center = self.center;\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n      return;\n    }\n\n    const nodeMap = {};\n    const nodeIdxMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * self.width;\n      if (!isNumber(node.y)) node.y = Math.random() * self.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    self.linkDistance = proccessToFunc(self.linkDistance, 1);\n    self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n    self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // node size function\n\n    const nodeSize = self.nodeSize;\n    let nodeSizeFunc;\n\n    if (self.preventOverlap) {\n      const nodeSpacing = self.nodeSpacing;\n      let nodeSpacingFunc;\n\n      if (isNumber(nodeSpacing)) {\n        nodeSpacingFunc = () => nodeSpacing;\n      } else if (isFunction(nodeSpacing)) {\n        nodeSpacingFunc = nodeSpacing;\n      } else {\n        nodeSpacingFunc = () => 0;\n      }\n\n      if (!nodeSize) {\n        nodeSizeFunc = d => {\n          if (d.size) {\n            if (isArray(d.size)) {\n              const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n              return res + nodeSpacingFunc(d);\n            }\n\n            if (isObject(d.size)) {\n              const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n              return res + nodeSpacingFunc(d);\n            }\n\n            return d.size + nodeSpacingFunc(d);\n          }\n\n          return 10 + nodeSpacingFunc(d);\n        };\n      } else if (isArray(nodeSize)) {\n        nodeSizeFunc = d => {\n          const res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n          return res + nodeSpacingFunc(d);\n        };\n      } else {\n        nodeSizeFunc = d => nodeSize + nodeSpacingFunc(d);\n      }\n    }\n\n    self.nodeSize = nodeSizeFunc;\n    const edges = self.edges;\n    self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n\n    if (!self.getMass) {\n      self.getMass = d => {\n        const mass = self.degrees[self.nodeIdxMap[d.id]] || 1;\n        return mass;\n      };\n    } // layout\n\n\n    self.run();\n  }\n\n  run() {\n    var _a;\n\n    const self = this;\n    const {\n      maxIteration,\n      nodes,\n      workerEnabled,\n      minMovement\n    } = self;\n    if (!nodes) return;\n\n    if (workerEnabled) {\n      for (let i = 0; i < maxIteration; i++) {\n        const previousPos = self.runOneStep(i);\n\n        if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {\n          break;\n        }\n      }\n\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n    } else {\n      if (typeof window === \"undefined\") return;\n      let iter = 0; // interval for render the result after each iteration\n\n      this.timeInterval = window.setInterval(() => {\n        var _a, _b;\n\n        if (!nodes) return;\n        const previousPos = self.runOneStep(iter) || [];\n\n        if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {\n          (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n          window.clearInterval(self.timeInterval);\n        }\n\n        iter++;\n\n        if (iter >= maxIteration) {\n          (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n          window.clearInterval(self.timeInterval);\n        }\n      }, 0);\n    }\n  }\n\n  reachMoveThreshold(nodes, previousPos, minMovement) {\n    // whether to stop the iteration\n    let movement = 0;\n    nodes.forEach((node, j) => {\n      const vx = node.x - previousPos[j].x;\n      const vy = node.y - previousPos[j].y;\n      movement += Math.sqrt(vx * vx + vy * vy);\n    });\n    movement /= nodes.length;\n    return movement < minMovement;\n  }\n\n  runOneStep(iter) {\n    var _a;\n\n    const self = this;\n    const {\n      nodes,\n      edges\n    } = self;\n    const accArray = [];\n    const velArray = [];\n    if (!nodes) return;\n    nodes.forEach((_, i) => {\n      accArray[2 * i] = 0;\n      accArray[2 * i + 1] = 0;\n      velArray[2 * i] = 0;\n      velArray[2 * i + 1] = 0;\n    });\n    self.calRepulsive(accArray, nodes);\n    if (edges) self.calAttractive(accArray, edges);\n    self.calGravity(accArray, nodes);\n    const stepInterval = Math.max(0.02, self.interval - iter * 0.002);\n    self.updateVelocity(accArray, velArray, stepInterval, nodes);\n    const previousPos = [];\n    nodes.forEach(node => {\n      previousPos.push({\n        x: node.x,\n        y: node.y\n      });\n    });\n    self.updatePosition(velArray, stepInterval, nodes);\n    (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);\n    return previousPos;\n  }\n\n  calRepulsive(accArray, nodes) {\n    const self = this; // const nodes = self.nodes;\n\n    const getMass = self.getMass;\n    const nodeStrength = self.nodeStrength;\n    const factor = self.factor;\n    const coulombDisScale = self.coulombDisScale;\n    const preventOverlap = self.preventOverlap;\n    const nodeSize = self.nodeSize;\n    nodes.forEach((ni, i) => {\n      const massi = getMass ? getMass(ni) : 1;\n      nodes.forEach((nj, j) => {\n        if (i >= j) return; // if (!accArray[j]) accArray[j] = 0;\n\n        const vecX = ni.x - nj.x;\n        const vecY = ni.y - nj.y;\n        const vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n        const nVecLength = (vecLength + 0.1) * coulombDisScale;\n        const direX = vecX / vecLength;\n        const direY = vecY / vecLength;\n        const param = (nodeStrength(ni) + nodeStrength(nj)) / 2 * factor / (nVecLength * nVecLength);\n        const massj = getMass ? getMass(nj) : 1;\n        accArray[2 * i] += direX * param;\n        accArray[2 * i + 1] += direY * param;\n        accArray[2 * j] -= direX * param;\n        accArray[2 * j + 1] -= direY * param;\n\n        if (preventOverlap && vecLength < (nodeSize(ni) + nodeSize(nj)) / 2) {\n          const paramOverlap = (nodeStrength(ni) + nodeStrength(nj)) / 2 / (vecLength * vecLength);\n          accArray[2 * i] += direX * paramOverlap / massi;\n          accArray[2 * i + 1] += direY * paramOverlap / massi;\n          accArray[2 * j] -= direX * paramOverlap / massj;\n          accArray[2 * j + 1] -= direY * paramOverlap / massj;\n        }\n      });\n    });\n  }\n\n  calAttractive(accArray, edges) {\n    const self = this; // const edges = self.edges;\n\n    const nodeMap = self.nodeMap;\n    const nodeIdxMap = self.nodeIdxMap;\n    const linkDistance = self.linkDistance;\n    const edgeStrength = self.edgeStrength;\n    const getMass = self.getMass;\n    edges.forEach((edge, i) => {\n      const source = getEdgeTerminal(edge, 'source');\n      const target = getEdgeTerminal(edge, 'target');\n      const sourceNode = nodeMap[source];\n      const targetNode = nodeMap[target];\n      const vecX = targetNode.x - sourceNode.x;\n      const vecY = targetNode.y - sourceNode.y;\n      const vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n      const direX = vecX / vecLength;\n      const direY = vecY / vecLength;\n      const length = linkDistance(edge) || 1;\n      const diff = length - vecLength;\n      const param = diff * edgeStrength(edge);\n      const sourceIdx = nodeIdxMap[source];\n      const targetIdx = nodeIdxMap[target];\n      const massSource = getMass ? getMass(sourceNode) : 1;\n      const massTarget = getMass ? getMass(targetNode) : 1;\n      accArray[2 * sourceIdx] -= direX * param / massSource;\n      accArray[2 * sourceIdx + 1] -= direY * param / massSource;\n      accArray[2 * targetIdx] += direX * param / massTarget;\n      accArray[2 * targetIdx + 1] += direY * param / massTarget;\n    });\n  }\n\n  calGravity(accArray, nodes) {\n    const self = this; // const nodes = self.nodes;\n\n    const center = self.center;\n    const defaultGravity = self.gravity;\n    const degrees = self.degrees;\n    const nodeLength = nodes.length;\n\n    for (let i = 0; i < nodeLength; i++) {\n      const node = nodes[i];\n      let vecX = node.x - center[0];\n      let vecY = node.y - center[1];\n      let gravity = defaultGravity;\n\n      if (self.getCenter) {\n        const customCenterOpt = self.getCenter(node, degrees[i]);\n\n        if (customCenterOpt && isNumber(customCenterOpt[0]) && isNumber(customCenterOpt[1]) && isNumber(customCenterOpt[2])) {\n          vecX = node.x - customCenterOpt[0];\n          vecY = node.y - customCenterOpt[1];\n          gravity = customCenterOpt[2];\n        }\n      }\n\n      if (!gravity) continue;\n      accArray[2 * i] -= gravity * vecX;\n      accArray[2 * i + 1] -= gravity * vecY;\n    }\n  }\n\n  updateVelocity(accArray, velArray, stepInterval, nodes) {\n    const self = this;\n    const param = stepInterval * self.damping; // const nodes = self.nodes;\n\n    nodes.forEach((node, i) => {\n      let vx = accArray[2 * i] * param || 0.01;\n      let vy = accArray[2 * i + 1] * param || 0.01;\n      const vLength = Math.sqrt(vx * vx + vy * vy);\n\n      if (vLength > self.maxSpeed) {\n        const param2 = self.maxSpeed / vLength;\n        vx = param2 * vx;\n        vy = param2 * vy;\n      }\n\n      velArray[2 * i] = vx;\n      velArray[2 * i + 1] = vy;\n    });\n  }\n\n  updatePosition(velArray, stepInterval, nodes) {\n    nodes.forEach((node, i) => {\n      if (isNumber(node.fx) && isNumber(node.fy)) {\n        node.x = node.fx;\n        node.y = node.fy;\n        return;\n      }\n\n      const distX = velArray[2 * i] * stepInterval;\n      const distY = velArray[2 * i + 1] * stepInterval;\n      node.x += distX;\n      node.y += distY;\n    });\n  }\n\n  stop() {\n    if (this.timeInterval && typeof window !== \"undefined\") {\n      window.clearInterval(this.timeInterval);\n    }\n  }\n\n  destroy() {\n    const self = this;\n    self.stop();\n    self.tick = null;\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  }\n\n  getType() {\n    return \"gForce\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}