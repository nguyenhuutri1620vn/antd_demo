{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { lngLatToMeters } from '@antv/l7-utils';\nimport earcut from 'earcut';\nimport { vec3 } from 'gl-matrix';\nexport default function extrudePolygon(path) {\n  var p1 = path[0][0];\n  var p2 = path[0][path[0].length - 1];\n\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    path[0] = path[0].slice(0, path[0].length - 1);\n  }\n\n  var n = path[0].length;\n  var flattengeo = earcut.flatten(path);\n  var vertices = flattengeo.vertices,\n      dimensions = flattengeo.dimensions;\n  var positions = [];\n  var indexArray = [];\n\n  for (var j = 0; j < vertices.length / dimensions; j++) {\n    if (dimensions === 2) {\n      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1);\n    } else {\n      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1);\n    }\n  }\n\n  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);\n  indexArray.push.apply(indexArray, _toConsumableArray(triangles));\n\n  var _loop = function _loop(i) {\n    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);\n    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);\n\n    if (nextPoint.length === 0) {\n      nextPoint = flattengeo.vertices.slice(0, dimensions);\n    }\n\n    var indexOffset = positions.length / 3;\n    positions.push(prePoint[0], prePoint[1], 1, nextPoint[0], nextPoint[1], 1, prePoint[0], prePoint[1], 0, nextPoint[0], nextPoint[1], 0);\n    indexArray.push.apply(indexArray, _toConsumableArray([0, 2, 1, 2, 3, 1].map(function (v) {\n      return v + indexOffset;\n    })));\n  };\n\n  for (var i = 0; i < n; i++) {\n    _loop(i);\n  }\n\n  return {\n    positions: positions,\n    index: indexArray\n  };\n}\nexport function fillPolygon(points) {\n  var flattengeo = earcut.flatten(points);\n  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);\n  return {\n    positions: flattengeo.vertices,\n    index: triangles\n  };\n}\nexport function extrude_PolygonNormal(path) {\n  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var p1 = path[0][0];\n  var p2 = path[0][path[0].length - 1];\n\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    path[0] = path[0].slice(0, path[0].length - 1);\n  }\n\n  var n = path[0].length;\n  var flattengeo = earcut.flatten(path);\n  var vertices = flattengeo.vertices,\n      dimensions = flattengeo.dimensions;\n  var positions = [];\n  var indexArray = [];\n  var normals = [];\n\n  for (var j = 0; j < vertices.length / dimensions; j++) {\n    if (dimensions === 2) {\n      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1, -1, -1);\n    } else {\n      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1, -1, -1);\n    }\n\n    normals.push(0, 0, 1);\n  }\n\n  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);\n  indexArray.push.apply(indexArray, _toConsumableArray(triangles));\n\n  var _loop2 = function _loop2(i) {\n    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);\n    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);\n\n    if (nextPoint.length === 0) {\n      nextPoint = flattengeo.vertices.slice(0, dimensions);\n    }\n\n    var indexOffset = positions.length / 5;\n    positions.push(prePoint[0], prePoint[1], 1, 0, 0, nextPoint[0], nextPoint[1], 1, 0.1, 0, prePoint[0], prePoint[1], 0, 0, 0.8, nextPoint[0], nextPoint[1], 0, 0.1, 0.8);\n    var normal = computeVertexNormals([nextPoint[0], nextPoint[1], 1], [prePoint[0], prePoint[1], 0], [prePoint[0], prePoint[1], 1], needFlat);\n    normals.push.apply(normals, _toConsumableArray(normal).concat(_toConsumableArray(normal), _toConsumableArray(normal), _toConsumableArray(normal)));\n    indexArray.push.apply(indexArray, _toConsumableArray([1, 2, 0, 3, 2, 1].map(function (v) {\n      return v + indexOffset;\n    })));\n  };\n\n  for (var i = 0; i < n; i++) {\n    _loop2(i);\n  }\n\n  return {\n    positions: positions,\n    index: indexArray,\n    normals: normals\n  };\n}\n\nfunction computeVertexNormals(p1, p2, p3) {\n  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var cb = vec3.create();\n  var ab = vec3.create();\n  var normal = vec3.create();\n\n  if (needFlat) {\n    p1 = lngLatToMeters(p1);\n    p2 = lngLatToMeters(p2);\n    p3 = lngLatToMeters(p3);\n  }\n\n  var pA = vec3.fromValues.apply(vec3, _toConsumableArray(p1));\n  var pB = vec3.fromValues.apply(vec3, _toConsumableArray(p2));\n  var pC = vec3.fromValues.apply(vec3, _toConsumableArray(p3));\n  vec3.sub(cb, pC, pB);\n  vec3.sub(ab, pA, pB);\n  vec3.cross(normal, cb, ab);\n  var newNormal = vec3.create();\n  vec3.normalize(newNormal, normal);\n  return newNormal;\n}","map":null,"metadata":{},"sourceType":"module"}