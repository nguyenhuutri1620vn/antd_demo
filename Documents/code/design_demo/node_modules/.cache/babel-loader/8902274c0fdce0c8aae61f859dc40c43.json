{"ast":null,"code":"import { ObjectExt, ArrayExt, Dom, FunctionExt, StringExt, Scheduler } from '../util';\nimport { Point } from '../geometry';\nimport { Dictionary } from '../common';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nexport class AttrManager {\n  constructor(view) {\n    this.view = view;\n  }\n\n  get cell() {\n    return this.view.cell;\n  }\n\n  getDefinition(attrName) {\n    return this.cell.getAttrDefinition(attrName);\n  }\n\n  processAttrs(elem, raw) {\n    let normal;\n    let set;\n    let offset;\n    let position;\n    let delay;\n    const specials = []; // divide the attributes between normal and special\n\n    Object.keys(raw).forEach(name => {\n      const val = raw[name];\n      const definition = this.getDefinition(name);\n      const isValid = FunctionExt.call(Attr.isValidDefinition, this.view, definition, val, {\n        elem,\n        attrs: raw,\n        cell: this.cell,\n        view: this.view\n      });\n\n      if (definition && isValid) {\n        if (typeof definition === 'string') {\n          if (normal == null) {\n            normal = {};\n          }\n\n          normal[definition] = val;\n        } else if (val !== null) {\n          specials.push({\n            name,\n            definition\n          });\n        }\n      } else {\n        if (normal == null) {\n          normal = {};\n        }\n\n        const normalName = AttrManager.CASE_SENSITIVE_ATTR.includes(name) ? name : StringExt.kebabCase(name);\n        normal[normalName] = val;\n      }\n    });\n    specials.forEach(_ref => {\n      let {\n        name,\n        definition\n      } = _ref;\n      const val = raw[name];\n      const setDefine = definition;\n\n      if (typeof setDefine.set === 'function') {\n        if (!Dom.isHTMLElement(elem) && AttrManager.DELAY_ATTRS.includes(name)) {\n          if (delay == null) {\n            delay = {};\n          }\n\n          delay[name] = val;\n        } else {\n          if (set == null) {\n            set = {};\n          }\n\n          set[name] = val;\n        }\n      }\n\n      const offsetDefine = definition;\n\n      if (typeof offsetDefine.offset === 'function') {\n        if (offset == null) {\n          offset = {};\n        }\n\n        offset[name] = val;\n      }\n\n      const positionDefine = definition;\n\n      if (typeof positionDefine.position === 'function') {\n        if (position == null) {\n          position = {};\n        }\n\n        position[name] = val;\n      }\n    });\n    return {\n      raw,\n      normal,\n      set,\n      offset,\n      position,\n      delay\n    };\n  }\n\n  mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n    allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n    allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n    allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset); // Handle also the special transform property.\n\n    const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n\n    if (transform != null && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n\n    allProcessedAttrs.normal = roProcessedAttrs.normal;\n  }\n\n  findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n    const merge = [];\n    const result = new Dictionary();\n    Object.keys(cellAttrs).forEach(selector => {\n      const attrs = cellAttrs[selector];\n\n      if (!ObjectExt.isPlainObject(attrs)) {\n        return;\n      }\n\n      const {\n        isCSSSelector,\n        elems\n      } = View.find(selector, rootNode, selectors);\n      selectorCache[selector] = elems;\n\n      for (let i = 0, l = elems.length; i < l; i += 1) {\n        const elem = elems[i];\n        const unique = selectors && selectors[selector] === elem;\n        const prev = result.get(elem);\n\n        if (prev) {\n          if (!prev.array) {\n            merge.push(elem);\n            prev.array = true;\n            prev.attrs = [prev.attrs];\n            prev.priority = [prev.priority];\n          }\n\n          const attributes = prev.attrs;\n          const selectedLength = prev.priority;\n\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(attrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector` or CSSSelector\n            const sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n            attributes.splice(sortIndex, 0, attrs);\n            selectedLength.splice(sortIndex, 0, l);\n          }\n        } else {\n          result.set(elem, {\n            elem,\n            attrs,\n            priority: unique ? -1 : l,\n            array: false\n          });\n        }\n      }\n    });\n    merge.forEach(node => {\n      const item = result.get(node);\n      const arr = item.attrs;\n      item.attrs = arr.reduceRight((memo, attrs) => ObjectExt.merge(memo, attrs), {});\n    });\n    return result;\n  }\n\n  updateRelativeAttrs(elem, processedAttrs, refBBox, options) {\n    const rawAttrs = processedAttrs.raw || {};\n    let nodeAttrs = processedAttrs.normal || {};\n    const setAttrs = processedAttrs.set;\n    const positionAttrs = processedAttrs.position;\n    const offsetAttrs = processedAttrs.offset;\n    const delayAttrs = processedAttrs.delay;\n\n    const getOptions = () => ({\n      elem,\n      cell: this.cell,\n      view: this.view,\n      attrs: rawAttrs,\n      refBBox: refBBox.clone()\n    });\n\n    if (setAttrs != null) {\n      Object.keys(setAttrs).forEach(name => {\n        const val = setAttrs[name];\n        const def = this.getDefinition(name);\n\n        if (def != null) {\n          const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n\n          if (typeof ret === 'object') {\n            nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n          } else if (ret != null) {\n            nodeAttrs[name] = ret;\n          }\n        }\n      });\n    }\n\n    if (Dom.isHTMLElement(elem)) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.view.setAttrs(nodeAttrs, elem);\n      return;\n    } // The final translation of the subelement.\n\n\n    const nodeTransform = nodeAttrs.transform;\n    const transform = nodeTransform ? `${nodeTransform}` : null;\n    const nodeMatrix = Dom.transformStringToMatrix(transform);\n    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n\n    if (nodeTransform) {\n      delete nodeAttrs.transform;\n      nodeMatrix.e = 0;\n      nodeMatrix.f = 0;\n    } // Calculates node scale determined by the scalable group.\n\n\n    let sx = 1;\n    let sy = 1;\n\n    if (positionAttrs || offsetAttrs) {\n      const scale = this.view.getScaleOfElement(elem, options.scalableNode);\n      sx = scale.sx;\n      sy = scale.sy;\n    }\n\n    let positioned = false;\n\n    if (positionAttrs != null) {\n      Object.keys(positionAttrs).forEach(name => {\n        const val = positionAttrs[name];\n        const def = this.getDefinition(name);\n\n        if (def != null) {\n          const ts = FunctionExt.call(def.position, this.view, val, getOptions());\n\n          if (ts != null) {\n            positioned = true;\n            nodePosition.translate(Point.create(ts).scale(sx, sy));\n          }\n        }\n      });\n    } // The node bounding box could depend on the `size`\n    // set from the previous loop.\n\n\n    this.view.setAttrs(nodeAttrs, elem);\n    let offseted = false;\n\n    if (offsetAttrs != null) {\n      // Check if the node is visible\n      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        const nodeBBox = Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n        Object.keys(offsetAttrs).forEach(name => {\n          const val = offsetAttrs[name];\n          const def = this.getDefinition(name);\n\n          if (def != null) {\n            const ts = FunctionExt.call(def.offset, this.view, val, {\n              elem,\n              cell: this.cell,\n              view: this.view,\n              attrs: rawAttrs,\n              refBBox: nodeBBox\n            });\n\n            if (ts != null) {\n              offseted = true;\n              nodePosition.translate(Point.create(ts).scale(sx, sy));\n            }\n          }\n        });\n      }\n    }\n\n    if (nodeTransform != null || positioned || offseted) {\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n    } // delay render\n\n\n    const updateDelayAttrs = () => {\n      if (delayAttrs != null) {\n        Object.keys(delayAttrs).forEach(name => {\n          const val = delayAttrs[name];\n          const def = this.getDefinition(name);\n\n          if (def != null) {\n            const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n\n            if (typeof ret === 'object') {\n              this.view.setAttrs(ret, elem);\n            } else if (ret != null) {\n              this.view.setAttrs({\n                [name]: ret\n              }, elem);\n            }\n          }\n        });\n      }\n    };\n\n    if (options.forceSync) {\n      updateDelayAttrs();\n    } else {\n      Scheduler.scheduleTask(updateDelayAttrs);\n    }\n  }\n\n  update(rootNode, attrs, options) {\n    const selectorCache = {};\n    const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors); // `nodesAttrs` are different from all attributes, when\n    // rendering only attributes sent to this method.\n\n    const nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;\n    const specialItems = [];\n    nodesAttrs.each(data => {\n      const node = data.elem;\n      const nodeAttrs = data.attrs;\n      const processed = this.processAttrs(node, nodeAttrs);\n\n      if (processed.set == null && processed.position == null && processed.offset == null && processed.delay == null) {\n        this.view.setAttrs(processed.normal, node);\n      } else {\n        const data = nodesAllAttrs.get(node);\n        const nodeAllAttrs = data ? data.attrs : null;\n        const refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;\n        let refNode;\n\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.view.find(refSelector, rootNode, options.selectors))[0];\n\n          if (!refNode) {\n            throw new Error(`\"${refSelector}\" reference does not exist.`);\n          }\n        } else {\n          refNode = null;\n        }\n\n        const item = {\n          node,\n          refNode,\n          attributes: nodeAllAttrs,\n          processedAttributes: processed\n        }; // If an element in the list is positioned relative to this one, then\n        // we want to insert this one before it in the list.\n\n        const index = specialItems.findIndex(item => item.refNode === node);\n\n        if (index > -1) {\n          specialItems.splice(index, 0, item);\n        } else {\n          specialItems.push(item);\n        }\n      }\n    });\n    const bboxCache = new Dictionary();\n    let rotatableMatrix;\n    specialItems.forEach(item => {\n      const node = item.node;\n      const refNode = item.refNode;\n      let unrotatedRefBBox;\n      const isRefNodeRotatable = refNode != null && options.rotatableNode != null && Dom.contains(options.rotatableNode, refNode); // Find the reference element bounding box. If no reference was\n      // provided, we use the optional bounding box.\n\n      if (refNode) {\n        unrotatedRefBBox = bboxCache.get(refNode);\n      }\n\n      if (!unrotatedRefBBox) {\n        const target = isRefNodeRotatable ? options.rotatableNode : rootNode;\n        unrotatedRefBBox = refNode ? Dom.getBBox(refNode, {\n          target\n        }) : options.rootBBox;\n\n        if (refNode) {\n          bboxCache.set(refNode, unrotatedRefBBox);\n        }\n      }\n\n      let processedAttrs;\n\n      if (options.attrs && item.attributes) {\n        // If there was a special attribute affecting the position amongst\n        // passed-in attributes we have to merge it with the rest of the\n        // element's attributes as they are necessary to update the position\n        // relatively (i.e `ref-x` && 'ref-dx').\n        processedAttrs = this.processAttrs(node, item.attributes);\n        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n\n      let refBBox = unrotatedRefBBox;\n\n      if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {\n        // If the referenced node is inside the rotatable group while the\n        // updated node is outside, we need to take the rotatable node\n        // transformation into account.\n        if (!rotatableMatrix) {\n          rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n        }\n\n        refBBox = Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n      }\n\n      const caller = specialItems.find(item => item.refNode === node);\n\n      if (caller) {\n        options.forceSync = true;\n      }\n\n      this.updateRelativeAttrs(node, processedAttrs, refBBox, options);\n    });\n  }\n\n}\n\n(function (AttrManager) {\n  AttrManager.CASE_SENSITIVE_ATTR = ['viewBox'];\n  AttrManager.DELAY_ATTRS = ['text', 'textWrap', 'sourceMarker', 'targetMarker'];\n})(AttrManager || (AttrManager = {}));","map":null,"metadata":{},"sourceType":"module"}