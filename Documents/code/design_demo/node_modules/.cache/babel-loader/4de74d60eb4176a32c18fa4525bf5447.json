{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _class3, _temp;\n\nimport { inject, injectable } from 'inversify';\nimport { IDENTIFIER } from '../../../identifier';\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgl.copy.frag.glsl' */\n\nvar copyFrag = \"varying vec2 v_UV;\\n\\nuniform sampler2D u_Texture;\\n\\nvoid main() {\\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\\n}\";\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgl.copy.vert.glsl' */\n\nvar copyVert = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgpu.copy.frag.glsl' */\n\nvar copyFragWebGPU = \"layout(set = 0, binding = 0) uniform sampler u_TextureSampler;\\nlayout(set = 0, binding = 1) uniform texture2D u_Texture;\\n\\nlayout(location = 0) in vec2 v_UV;\\nlayout(location = 0) out vec4 outColor;\\n\\nvoid main() {\\n  outColor = texture(sampler2D(u_Texture, u_TextureSampler), v_UV);\\n}\";\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgpu.copy.vert.glsl' */\n\nvar copyVertWebGPU = \"layout(location = 0) in vec2 a_Position;\\nlayout(location = 0) out vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport { gl } from '../gl';\nimport { RenderPass } from './RenderPass';\nexport var CopyPass = (_dec = injectable(), _dec2 = inject(IDENTIFIER.RenderEngine), _dec3 = inject(IDENTIFIER.ResourcePool), _dec(_class = (_class2 = (_temp = _class3 = function CopyPass() {\n  var _this = this;\n\n  _classCallCheck(this, CopyPass);\n\n  _initializerDefineProperty(this, \"engine\", _descriptor, this);\n\n  _initializerDefineProperty(this, \"resourcePool\", _descriptor2, this);\n\n  this.model = void 0;\n\n  this.setup = function (fg, passNode, pass) {\n    var renderPass = fg.getPass(RenderPass.IDENTIFIER);\n\n    if (renderPass) {\n      var output = fg.createRenderTarget(passNode, 'render to screen', {\n        width: 1,\n        height: 1\n      });\n      pass.data = {\n        input: passNode.read(renderPass.data.output),\n        output: passNode.write(fg, output)\n      };\n    }\n  };\n\n  this.execute = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fg, pass) {\n      var _this$engine, createModel, createAttribute, createBuffer, model, resourceNode, framebuffer;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$engine = _this.engine, createModel = _this$engine.createModel, createAttribute = _this$engine.createAttribute, createBuffer = _this$engine.createBuffer;\n\n              if (_this.model) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 4;\n              return createModel({\n                vs: _this.engine.supportWebGPU ? copyVertWebGPU : copyVert,\n                fs: _this.engine.supportWebGPU ? copyFragWebGPU : copyFrag,\n                attributes: {\n                  // rendering a fullscreen triangle instead of quad\n                  // @see https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/\n                  a_Position: createAttribute({\n                    buffer: createBuffer({\n                      data: [-4, -4, 4, -4, 0, 4],\n                      type: gl.FLOAT\n                    }),\n                    size: 2,\n                    arrayStride: 2 * 4,\n                    stepMode: 'vertex',\n                    attributes: [{\n                      shaderLocation: 0,\n                      offset: 0,\n                      format: 'float2'\n                    }]\n                  })\n                },\n                uniforms: {\n                  // @ts-ignore\n                  u_Texture: null\n                },\n                depth: {\n                  enable: false\n                },\n                count: 3,\n                blend: {\n                  // copy pass 需要混合\n                  // enable: this.getName() === 'copy',\n                  enable: true\n                }\n              });\n\n            case 4:\n              model = _context.sent;\n              _this.model = model;\n\n            case 6:\n              // 实例化资源\n              resourceNode = fg.getResourceNode(pass.data.input);\n              framebuffer = _this.resourcePool.getOrCreateResource(resourceNode.resource);\n\n              _this.engine.useFramebuffer(null, function () {\n                _this.engine.clear({\n                  framebuffer: null,\n                  color: [0, 0, 0, 0],\n                  depth: 1,\n                  stencil: 0\n                });\n\n                _this.model.draw({\n                  uniforms: {\n                    u_Texture: framebuffer // u_ViewportSize: [width, height],\n\n                  }\n                });\n              });\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  this.tearDown = function () {\n    _this.model = undefined;\n  };\n}, _class3.IDENTIFIER = 'Copy Pass', _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"engine\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"resourcePool\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":null,"metadata":{},"sourceType":"module"}