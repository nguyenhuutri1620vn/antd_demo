{"ast":null,"code":"import JQuery from 'jquery';\nimport { DataUri, NumberExt, FunctionExt, Vector } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Base } from './base';\nexport class FormatManager extends Base {\n  toSVG(callback) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.graph.trigger('before:export', options);\n    const rawSVG = this.view.svg;\n    const vSVG = Vector.create(rawSVG).clone();\n    let clonedSVG = vSVG.node;\n    const vStage = vSVG.findOne(`.${this.view.prefixClassName('graph-svg-stage')}`);\n    const viewBox = options.viewBox || this.graph.graphToLocal(this.graph.getContentBBox());\n    const dimension = options.preserveDimensions;\n\n    if (dimension) {\n      const size = typeof dimension === 'boolean' ? viewBox : dimension;\n      vSVG.attr({\n        width: size.width,\n        height: size.height\n      });\n    }\n\n    vSVG.removeAttribute('style').attr('viewBox', [viewBox.x, viewBox.y, viewBox.width, viewBox.height].join(' '));\n    vStage.removeAttribute('transform'); // Stores all the CSS declarations from external stylesheets to the\n    // `style` attribute of the SVG document nodes.\n    // This is achieved in three steps.\n    // -----------------------------------\n    // 1. Disabling all the stylesheets in the page and therefore collecting\n    //    only default style values. This, together with the step 2, makes it\n    //    possible to discard default CSS property values and store only those\n    //    that differ.\n    //\n    // 2. Enabling back all the stylesheets in the page and collecting styles\n    //    that differ from the default values.\n    //\n    // 3. Applying the difference between default values and the ones set by\n    //    custom stylesheets onto the `style` attribute of each of the nodes\n    //    in SVG.\n\n    if (options.copyStyles !== false) {\n      const document = rawSVG.ownerDocument;\n      const raws = Array.from(rawSVG.querySelectorAll('*'));\n      const clones = Array.from(clonedSVG.querySelectorAll('*'));\n      const styleSheetCount = document.styleSheets.length;\n      const styleSheetsCopy = [];\n\n      for (let k = styleSheetCount - 1; k >= 0; k -= 1) {\n        // There is a bug (bugSS) in Chrome 14 and Safari. When you set\n        // `stylesheet.disable = true` it will also remove it from\n        // `document.styleSheets`. So we need to store all stylesheets before\n        // we disable them. Later on we put them back to `document.styleSheets`\n        // if needed.\n        // See the bug `https://code.google.com/p/chromium/issues/detail?id=88310`.\n        styleSheetsCopy[k] = document.styleSheets[k];\n        document.styleSheets[k].disabled = true;\n      }\n\n      const defaultComputedStyles = {};\n      raws.forEach((elem, index) => {\n        const computedStyle = window.getComputedStyle(elem, null); // We're making a deep copy of the `computedStyle` so that it's not affected\n        // by that next step when all the stylesheets are re-enabled again.\n\n        const defaultComputedStyle = {};\n        Object.keys(computedStyle).forEach(property => {\n          defaultComputedStyle[property] = computedStyle.getPropertyValue(property);\n        });\n        defaultComputedStyles[index] = defaultComputedStyle;\n      }); // Copy all stylesheets back\n\n      if (styleSheetCount !== document.styleSheets.length) {\n        styleSheetsCopy.forEach((copy, index) => {\n          document.styleSheets[index] = copy;\n        });\n      }\n\n      for (let i = 0; i < styleSheetCount; i += 1) {\n        document.styleSheets[i].disabled = false;\n      }\n\n      const customStyles = {};\n      raws.forEach((elem, index) => {\n        const computedStyle = window.getComputedStyle(elem, null);\n        const defaultComputedStyle = defaultComputedStyles[index];\n        const customStyle = {};\n        Object.keys(computedStyle).forEach(property => {\n          if (computedStyle.getPropertyValue(property) !== defaultComputedStyle[property]) {\n            customStyle[property] = computedStyle.getPropertyValue(property);\n          }\n        });\n        customStyles[index] = customStyle;\n      });\n      clones.forEach((elem, index) => {\n        JQuery(elem).css(customStyles[index]);\n      });\n    }\n\n    const stylesheet = options.stylesheet;\n\n    if (typeof stylesheet === 'string') {\n      const cDATASection = rawSVG.ownerDocument.implementation.createDocument(null, 'xml', null).createCDATASection(stylesheet);\n      vSVG.prepend(Vector.create('style', {\n        type: 'text/css'\n      }, [cDATASection]));\n    }\n\n    const format = () => {\n      const beforeSerialize = options.beforeSerialize;\n\n      if (typeof beforeSerialize === 'function') {\n        const ret = FunctionExt.call(beforeSerialize, this.graph, clonedSVG);\n\n        if (ret instanceof SVGSVGElement) {\n          clonedSVG = ret;\n        }\n      }\n\n      const dataUri = new XMLSerializer().serializeToString(clonedSVG).replace(/&nbsp;/g, '\\u00a0');\n      this.graph.trigger('after:export', options);\n      callback(dataUri);\n    };\n\n    if (options.serializeImages) {\n      const deferrals = vSVG.find('image').map(vImage => {\n        return new Promise(resolve => {\n          const url = vImage.attr('xlink:href') || vImage.attr('href');\n          DataUri.imageToDataUri(url, (err, dataUri) => {\n            if (!err && dataUri) {\n              vImage.attr('xlink:href', dataUri);\n            }\n\n            resolve();\n          });\n        });\n      });\n      Promise.all(deferrals).then(format);\n    } else {\n      format();\n    }\n  }\n\n  toDataURL(callback, options) {\n    let viewBox = options.viewBox || this.graph.getContentBBox();\n    const padding = NumberExt.normalizeSides(options.padding);\n\n    if (options.width && options.height) {\n      if (padding.left + padding.right >= options.width) {\n        padding.left = padding.right = 0;\n      }\n\n      if (padding.top + padding.bottom >= options.height) {\n        padding.top = padding.bottom = 0;\n      }\n    }\n\n    const expanding = new Rectangle(-padding.left, -padding.top, padding.left + padding.right, padding.top + padding.bottom);\n\n    if (options.width && options.height) {\n      const width = viewBox.width + padding.left + padding.right;\n      const height = viewBox.height + padding.top + padding.bottom;\n      expanding.scale(width / options.width, height / options.height);\n    }\n\n    viewBox = Rectangle.create(viewBox).moveAndExpand(expanding);\n    const rawSize = typeof options.width === 'number' && typeof options.height === 'number' ? {\n      width: options.width,\n      height: options.height\n    } : viewBox;\n    let scale = options.ratio ? parseFloat(options.ratio) : 1;\n\n    if (!Number.isFinite(scale) || scale === 0) {\n      scale = 1;\n    }\n\n    const size = {\n      width: Math.max(Math.round(rawSize.width * scale), 1),\n      height: Math.max(Math.round(rawSize.height * scale), 1)\n    };\n    {\n      const imgDataCanvas = document.createElement('canvas');\n      const context2D = imgDataCanvas.getContext('2d');\n      imgDataCanvas.width = size.width;\n      imgDataCanvas.height = size.height;\n      const x = size.width - 1;\n      const y = size.height - 1;\n      context2D.fillStyle = 'rgb(1,1,1)';\n      context2D.fillRect(x, y, 1, 1);\n      const data = context2D.getImageData(x, y, 1, 1).data;\n\n      if (data[0] !== 1 || data[1] !== 1 || data[2] !== 1) {\n        throw new Error('size exceeded');\n      }\n    }\n    const img = new Image();\n\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = size.width;\n      canvas.height = size.height;\n      const context = canvas.getContext('2d');\n      context.fillStyle = options.backgroundColor || 'white';\n      context.fillRect(0, 0, size.width, size.height);\n\n      try {\n        context.drawImage(img, 0, 0, size.width, size.height);\n        const dataUri = canvas.toDataURL(options.type, options.quality);\n        callback(dataUri);\n      } catch (error) {// pass\n      }\n    };\n\n    this.toSVG(dataUri => {\n      img.src = `data:image/svg+xml,${encodeURIComponent(dataUri)}`;\n    }, Object.assign(Object.assign({}, options), {\n      viewBox,\n      serializeImages: true,\n      preserveDimensions: Object.assign({}, size)\n    }));\n  }\n\n  toPNG(callback) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.toDataURL(callback, Object.assign(Object.assign({}, options), {\n      type: 'image/png'\n    }));\n  }\n\n  toJPEG(callback) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.toDataURL(callback, Object.assign(Object.assign({}, options), {\n      type: 'image/jpeg'\n    }));\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}