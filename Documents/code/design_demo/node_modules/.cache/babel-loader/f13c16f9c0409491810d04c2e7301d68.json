{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { $window } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { buildIconMaping } from '../../utils/font_util';\nvar BUFFER = 3;\nvar MAX_CANVAS_WIDTH = 1024;\nvar imageSize = 64;\nvar IconService = (_dec = injectable(), _dec(_class = function (_EventEmitter) {\n  _inherits(IconService, _EventEmitter);\n\n  var _super = _createSuper(IconService);\n\n  function IconService() {\n    var _this;\n\n    _classCallCheck(this, IconService);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"canvasHeight\", 128);\n\n    _defineProperty(_assertThisInitialized(_this), \"texture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"canvas\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"iconData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"iconMap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"ctx\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"loadingImageCount\", 0);\n\n    return _this;\n  }\n\n  _createClass(IconService, [{\n    key: \"isLoading\",\n    value: function isLoading() {\n      return this.loadingImageCount === 0;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.iconData = [];\n      this.iconMap = {};\n      this.canvas = $window.document.createElement('canvas');\n      this.canvas.width = 128;\n      this.canvas.height = 128;\n      this.ctx = this.canvas.getContext('2d');\n    }\n  }, {\n    key: \"addImage\",\n    value: function addImage(id, image) {\n      var _this2 = this;\n\n      var imagedata = new Image();\n      this.loadingImageCount++;\n\n      if (this.hasImage(id)) {\n        throw new Error('Image Id already exists');\n      }\n\n      this.iconData.push({\n        id: id,\n        size: imageSize\n      });\n      this.updateIconMap();\n      this.loadImage(image).then(function (img) {\n        imagedata = img;\n\n        var iconImage = _this2.iconData.find(function (icon) {\n          return icon.id === id;\n        });\n\n        if (iconImage) {\n          iconImage.image = imagedata;\n          iconImage.width = imagedata.width;\n          iconImage.height = imagedata.height;\n        }\n\n        _this2.update();\n      });\n    }\n  }, {\n    key: \"addImageMini\",\n    value: function addImageMini(id, image, sceneService) {\n      var _this3 = this;\n\n      var canvas = sceneService.getSceneConfig().canvas;\n      var imagedata = canvas.createImage();\n      this.loadingImageCount++;\n\n      if (this.hasImage(id)) {\n        throw new Error('Image Id already exists');\n      }\n\n      this.iconData.push({\n        id: id,\n        size: imageSize\n      });\n      this.updateIconMap();\n      this.loadImageMini(image, canvas).then(function (img) {\n        imagedata = img;\n\n        var iconImage = _this3.iconData.find(function (icon) {\n          return icon.id === id;\n        });\n\n        if (iconImage) {\n          iconImage.image = imagedata;\n          iconImage.width = imagedata.width;\n          iconImage.height = imagedata.height;\n        }\n\n        _this3.update();\n      });\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this.texture;\n    }\n  }, {\n    key: \"getIconMap\",\n    value: function getIconMap() {\n      return this.iconMap;\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: \"hasImage\",\n    value: function hasImage(id) {\n      return this.iconMap.hasOwnProperty(id);\n    }\n  }, {\n    key: \"removeImage\",\n    value: function removeImage(id) {\n      if (this.hasImage(id)) {\n        this.iconData = this.iconData.filter(function (icon) {\n          return icon.id !== id;\n        });\n        delete this.iconMap[id];\n        this.update();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.removeAllListeners('imageUpdate');\n      this.iconData = [];\n      this.iconMap = {};\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.updateIconMap();\n      this.updateIconAtlas();\n      this.loadingImageCount--;\n\n      if (this.loadingImageCount === 0) {\n        this.emit('imageUpdate');\n      }\n    }\n  }, {\n    key: \"updateIconAtlas\",\n    value: function updateIconAtlas() {\n      var _this4 = this;\n\n      this.canvas.width = MAX_CANVAS_WIDTH;\n      this.canvas.height = this.canvasHeight;\n      Object.keys(this.iconMap).forEach(function (item) {\n        var _this4$iconMap$item = _this4.iconMap[item],\n            x = _this4$iconMap$item.x,\n            y = _this4$iconMap$item.y,\n            image = _this4$iconMap$item.image,\n            _this4$iconMap$item$w = _this4$iconMap$item.width,\n            width = _this4$iconMap$item$w === void 0 ? 64 : _this4$iconMap$item$w,\n            _this4$iconMap$item$h = _this4$iconMap$item.height,\n            height = _this4$iconMap$item$h === void 0 ? 64 : _this4$iconMap$item$h;\n        var max = Math.max(width, height);\n        var ratio = max / imageSize;\n        var drawHeight = height / ratio;\n        var drawWidth = width / ratio;\n\n        if (image) {\n          _this4.ctx.drawImage(image, x + (imageSize - drawWidth) / 2, y + (imageSize - drawHeight) / 2, drawWidth, drawHeight);\n        }\n      });\n    }\n  }, {\n    key: \"updateIconMap\",\n    value: function updateIconMap() {\n      var _buildIconMaping = buildIconMaping(this.iconData, BUFFER, MAX_CANVAS_WIDTH),\n          mapping = _buildIconMaping.mapping,\n          canvasHeight = _buildIconMaping.canvasHeight;\n\n      this.iconMap = mapping;\n      this.canvasHeight = canvasHeight;\n    }\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(url) {\n      return new Promise(function (resolve, reject) {\n        if (url instanceof HTMLImageElement) {\n          resolve(url);\n          return;\n        }\n\n        var image = new Image();\n        image.crossOrigin = 'anonymous';\n\n        image.onload = function () {\n          resolve(image);\n        };\n\n        image.onerror = function () {\n          reject(new Error('Could not load image at ' + url));\n        };\n\n        image.src = url instanceof File ? URL.createObjectURL(url) : url;\n      });\n    }\n  }, {\n    key: \"loadImageMini\",\n    value: function loadImageMini(url, canvas) {\n      return new Promise(function (resolve, reject) {\n        var image = canvas.createImage();\n        image.crossOrigin = 'anonymous';\n\n        image.onload = function () {\n          resolve(image);\n        };\n\n        image.onerror = function () {\n          reject(new Error('Could not load image at ' + url));\n        };\n\n        image.src = url;\n      });\n    }\n  }]);\n\n  return IconService;\n}(EventEmitter)) || _class);\nexport { IconService as default };","map":null,"metadata":{},"sourceType":"module"}