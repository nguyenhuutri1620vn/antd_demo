{"ast":null,"code":"/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport class PriorityQueue {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.comparator = options.comparator || PriorityQueue.defaultComparator;\n    this.index = {};\n    this.data = options.data || [];\n    this.heapify();\n  }\n  /**\n   * Returns `true` if the priority queue is empty, `false` otherwise.\n   */\n\n\n  isEmpty() {\n    return this.data.length === 0;\n  }\n  /**\n   * Inserts a value with priority to the queue. Optionally pass a unique\n   * id of this item. Passing unique IDs for each item you insert allows\n   * you to use the `updatePriority()` operation.\n   * @param priority\n   * @param value\n   * @param id\n   */\n\n\n  insert(priority, value, id) {\n    const item = {\n      priority,\n      value\n    };\n    const index = this.data.length - 1;\n\n    if (id) {\n      item.id = id;\n      this.index[id] = index;\n    }\n\n    this.data.push(item);\n    this.bubbleUp(index);\n    return this;\n  }\n  /**\n   * Returns the value of an item with the highest priority.\n   */\n\n\n  peek() {\n    return this.data[0] ? this.data[0].value : null;\n  }\n  /**\n   * Returns the highest priority in the queue.\n   */\n\n\n  peekPriority() {\n    return this.data[0] ? this.data[0].priority : null;\n  }\n\n  updatePriority(id, priority) {\n    const index = this.index[id];\n\n    if (typeof index === 'undefined') {\n      throw new Error(`Node with id '${id}' was not found in the heap.`);\n    }\n\n    const data = this.data;\n    const oldPriority = data[index].priority;\n    const comp = this.comparator(priority, oldPriority);\n\n    if (comp < 0) {\n      data[index].priority = priority;\n      this.bubbleUp(index);\n    } else if (comp > 0) {\n      data[index].priority = priority;\n      this.bubbleDown(index);\n    }\n  }\n  /**\n   * Removes the item with the highest priority from the queue\n   *\n   * @returns The value of the removed item.\n   */\n\n\n  remove() {\n    const data = this.data;\n    const peek = data[0];\n    const last = data.pop();\n    delete this.index[data.length];\n\n    if (data.length > 0) {\n      data[0] = last;\n\n      if (last.id) {\n        this.index[last.id] = 0;\n      }\n\n      this.bubbleDown(0);\n    }\n\n    return peek ? peek.value : null;\n  }\n\n  heapify() {\n    for (let i = 0; i < this.data.length; i += 1) {\n      this.bubbleUp(i);\n    }\n  }\n\n  bubbleUp(index) {\n    const data = this.data;\n    let tmp;\n    let parent;\n    let current = index;\n\n    while (current > 0) {\n      parent = current - 1 >>> 1;\n\n      if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n        tmp = data[parent];\n        data[parent] = data[current];\n        let id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = parent;\n        }\n\n        data[current] = tmp;\n        id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = current;\n        }\n\n        current = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  bubbleDown(index) {\n    const data = this.data;\n    const last = data.length - 1;\n    let current = index; // eslint-disable-next-line\n\n    while (true) {\n      const left = (current << 1) + 1;\n      const right = left + 1;\n      let minIndex = current;\n\n      if (left <= last && this.comparator(data[left].priority, data[minIndex].priority) < 0) {\n        minIndex = left;\n      }\n\n      if (right <= last && this.comparator(data[right].priority, data[minIndex].priority) < 0) {\n        minIndex = right;\n      }\n\n      if (minIndex !== current) {\n        const tmp = data[minIndex];\n        data[minIndex] = data[current];\n        let id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = minIndex;\n        }\n\n        data[current] = tmp;\n        id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = current;\n        }\n\n        current = minIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n}\n\n(function (PriorityQueue) {\n  PriorityQueue.defaultComparator = (a, b) => a - b;\n})(PriorityQueue || (PriorityQueue = {}));","map":null,"metadata":{},"sourceType":"module"}