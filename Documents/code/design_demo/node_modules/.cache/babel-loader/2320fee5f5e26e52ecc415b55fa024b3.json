{"ast":null,"code":"import { Curve } from '../curve';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class CurveTo extends Segment {\n  constructor(arg0, arg1, arg2, arg3, arg4, arg5) {\n    super();\n\n    if (Curve.isCurve(arg0)) {\n      this.controlPoint1 = arg0.controlPoint1.clone().round(2);\n      this.controlPoint2 = arg0.controlPoint2.clone().round(2);\n      this.endPoint = arg0.end.clone().round(2);\n    } else if (typeof arg0 === 'number') {\n      this.controlPoint1 = new Point(arg0, arg1).round(2);\n      this.controlPoint2 = new Point(arg2, arg3).round(2);\n      this.endPoint = new Point(arg4, arg5).round(2);\n    } else {\n      this.controlPoint1 = Point.create(arg0).round(2);\n      this.controlPoint2 = Point.create(arg1).round(2);\n      this.endPoint = Point.create(arg2).round(2);\n    }\n  }\n\n  get type() {\n    return 'C';\n  }\n\n  get curve() {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  }\n\n  bbox() {\n    return this.curve.bbox();\n  }\n\n  closestPoint(p) {\n    return this.curve.closestPoint(p);\n  }\n\n  closestPointLength(p) {\n    return this.curve.closestPointLength(p);\n  }\n\n  closestPointNormalizedLength(p) {\n    return this.curve.closestPointNormalizedLength(p);\n  }\n\n  closestPointTangent(p) {\n    return this.curve.closestPointTangent(p);\n  }\n\n  length() {\n    return this.curve.length();\n  }\n\n  divideAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // TODO: fix options\n    const divided = this.curve.divideAt(ratio, options);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n\n  divideAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // TODO: fix options\n    const divided = this.curve.divideAtLength(length, options);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n\n  divideAtT(t) {\n    const divided = this.curve.divideAtT(t);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n\n  getSubdivisions() {\n    return [];\n  }\n\n  pointAt(ratio) {\n    return this.curve.pointAt(ratio);\n  }\n\n  pointAtLength(length) {\n    return this.curve.pointAtLength(length);\n  }\n\n  tangentAt(ratio) {\n    return this.curve.tangentAt(ratio);\n  }\n\n  tangentAtLength(length) {\n    return this.curve.tangentAtLength(length);\n  }\n\n  isDifferentiable() {\n    if (!this.previousSegment) {\n      return false;\n    }\n\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  }\n\n  scale(sx, sy, origin) {\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.controlPoint1.rotate(angle, origin);\n    this.controlPoint2.rotate(angle, origin);\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.controlPoint1.translate(tx, ty);\n      this.controlPoint2.translate(tx, ty);\n      this.end.translate(tx, ty);\n    } else {\n      this.controlPoint1.translate(tx);\n      this.controlPoint2.translate(tx);\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  equals(s) {\n    return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);\n  }\n\n  clone() {\n    return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    const c1 = this.controlPoint1;\n    const c2 = this.controlPoint2;\n    const end = this.end;\n    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');\n  }\n\n}\n\n(function (CurveTo) {\n  function create() {\n    const len = arguments.length;\n    const arg0 = arguments.length <= 0 ? undefined : arguments[0]; // curve provided\n\n    if (Curve.isCurve(arg0)) {\n      return new CurveTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 3) {\n        return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      } // this is a poly-bezier segment\n\n\n      const segments = [];\n\n      for (let i = 0; i < len; i += 3) {\n        segments.push(new CurveTo(i < 0 || arguments.length <= i ? undefined : arguments[i], i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1], i + 2 < 0 || arguments.length <= i + 2 ? undefined : arguments[i + 2]));\n      }\n\n      return segments;\n    } // coordinates provided\n\n\n    if (len === 6) {\n      return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2], arguments.length <= 3 ? undefined : arguments[3], arguments.length <= 4 ? undefined : arguments[4], arguments.length <= 5 ? undefined : arguments[5]);\n    } // this is a poly-bezier segment\n\n\n    const segments = [];\n\n    for (let i = 0; i < len; i += 6) {\n      segments.push(new CurveTo(i < 0 || arguments.length <= i ? undefined : arguments[i], i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1], i + 2 < 0 || arguments.length <= i + 2 ? undefined : arguments[i + 2], i + 3 < 0 || arguments.length <= i + 3 ? undefined : arguments[i + 3], i + 4 < 0 || arguments.length <= i + 4 ? undefined : arguments[i + 4], i + 5 < 0 || arguments.length <= i + 5 ? undefined : arguments[i + 5]));\n    }\n\n    return segments;\n  }\n\n  CurveTo.create = create;\n})(CurveTo || (CurveTo = {}));","map":null,"metadata":{},"sourceType":"module"}