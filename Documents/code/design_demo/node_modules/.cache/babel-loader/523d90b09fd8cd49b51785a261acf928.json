{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { get, size, assign, each, isNumber } from '@antv/util';\nimport { ext } from '@antv/matrix-util';\nimport Trend from './trend';\nimport Handler from './handler';\nimport { isString } from '@antv/util';\nimport ControllerBtn from './controllerBtn';\nimport { VALUE_CHANGE, TIMELINE_START, TIMEBAR_CONFIG_CHANGE, PLAY_PAUSE_BTN, NEXT_STEP_BTN, PRE_STEP_BTN, TIMELINE_END } from './constant';\nvar transform = ext.transform;\n/**\n * 一些默认的样式配置\n */\n\nexport var BACKGROUND_STYLE = {\n  fill: '#416180',\n  opacity: 0.05\n};\nvar SIMPLE_BACKGROUND_STYLE = {\n  fill: '#416180',\n  opacity: 0.15,\n  radius: 5\n};\nexport var FOREGROUND_STYLE = {\n  fill: '#5B8FF9',\n  opacity: 0.3,\n  cursor: 'grab'\n};\nexport var DEFAULT_HANDLER_WIDTH = 2;\nexport var HANDLER_STYLE = {\n  width: DEFAULT_HANDLER_WIDTH,\n  height: 24\n};\nexport var TEXT_STYLE = {\n  textBaseline: 'middle',\n  fill: '#000',\n  opacity: 0.45\n};\nexport var TICK_LABEL_STYLE = {\n  textAlign: 'center',\n  textBaseline: 'top',\n  fill: '#607889',\n  opacity: 0.35\n};\nexport var TICK_LINE_STYLE = {\n  lineWidth: 1,\n  stroke: '#ccc'\n};\n\nvar TrendTimeBar =\n/** @class */\nfunction () {\n  function TrendTimeBar(cfg) {\n    var _this = this;\n\n    this.prevX = 0;\n\n    this.onMouseDown = function (handler) {\n      return function (e) {\n        // 1. 记录点击的滑块\n        _this.currentHandler = handler;\n        var event = e.originalEvent; // 2. 存储当前点击位置\n\n        event.stopPropagation();\n        event.preventDefault(); // 兼容移动端获取数据\n\n        _this.prevX = get(event, 'touches.0.pageX', event.pageX); // 3. 开始滑动的时候，绑定 move 和 up 事件\n\n        var containerDOM = _this.canvas.get('container');\n\n        containerDOM.addEventListener('mousemove', _this.onMouseMove);\n        containerDOM.addEventListener('mouseup', _this.onMouseUp);\n        containerDOM.addEventListener('mouseleave', _this.onMouseUp); // 移动端事件\n\n        containerDOM.addEventListener('touchmove', _this.onMouseMove);\n        containerDOM.addEventListener('touchend', _this.onMouseUp);\n        containerDOM.addEventListener('touchcancel', _this.onMouseUp);\n      };\n    };\n\n    this.onMouseMove = function (e) {\n      // 滑动过程中，计算偏移，更新滑块，然后 emit 数据出去\n      e.stopPropagation();\n      e.preventDefault();\n      var x = get(e, 'touches.0.pageX', e.pageX); // 横向的 slider 只处理 x\n\n      var offsetX = x - _this.prevX;\n\n      var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width); // 更新 start end range 范围\n\n\n      _this.updateStartEnd(offsetXRange); // 更新 ui\n\n\n      _this.updateUI();\n\n      _this.prevX = x;\n    };\n\n    this.onMouseUp = function () {\n      // 结束之后，取消绑定的事件\n      if (_this.currentHandler) {\n        _this.currentHandler = undefined;\n      }\n\n      var containerDOM = _this.canvas.get('container');\n\n      if (containerDOM) {\n        containerDOM.removeEventListener('mousemove', _this.onMouseMove);\n        containerDOM.removeEventListener('mouseup', _this.onMouseUp); // 防止滑动到 canvas 外部之后，状态丢失\n\n        containerDOM.removeEventListener('mouseleave', _this.onMouseUp); // 移动端事件\n\n        containerDOM.removeEventListener('touchmove', _this.onMouseMove);\n        containerDOM.removeEventListener('touchend', _this.onMouseUp);\n        containerDOM.removeEventListener('touchcancel', _this.onMouseUp);\n      }\n    };\n\n    var _a = cfg.x,\n        x = _a === void 0 ? 0 : _a,\n        _b = cfg.y,\n        y = _b === void 0 ? 0 : _b,\n        _c = cfg.width,\n        width = _c === void 0 ? 100 : _c,\n        height = cfg.height,\n        _d = cfg.padding,\n        padding = _d === void 0 ? 10 : _d,\n        trendCfg = cfg.trendCfg,\n        _e = cfg.controllerCfg,\n        controllerCfg = _e === void 0 ? {\n      speed: 1\n    } : _e,\n        _f = cfg.backgroundStyle,\n        backgroundStyle = _f === void 0 ? {} : _f,\n        _g = cfg.foregroundStyle,\n        foregroundStyle = _g === void 0 ? {} : _g,\n        _h = cfg.handlerStyle,\n        handlerStyle = _h === void 0 ? {} : _h,\n        _j = cfg.textStyle,\n        textStyle = _j === void 0 ? {} : _j,\n        // 缩略轴的初始位置\n    _k = cfg.start,\n        // 缩略轴的初始位置\n    start = _k === void 0 ? 0 : _k,\n        _l = cfg.end,\n        end = _l === void 0 ? 1 : _l,\n        _m = cfg.minText,\n        minText = _m === void 0 ? '' : _m,\n        _o = cfg.maxText,\n        maxText = _o === void 0 ? '' : _o,\n        group = cfg.group,\n        graph = cfg.graph,\n        canvas = cfg.canvas,\n        _p = cfg.tick,\n        tick = _p === void 0 ? {\n      tickLabelStyle: {},\n      tickLineStyle: {},\n      tickLabelFormatter: function tickLabelFormatter(d) {\n        return d;\n      },\n      ticks: []\n    } : _p,\n        type = cfg.type;\n    this.graph = graph;\n    this.canvas = canvas;\n    this.group = group;\n    this.timeBarType = type; // position size\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.padding = padding;\n    this.ticks = tick.ticks;\n    this.trendCfg = trendCfg;\n    this.controllerCfg = controllerCfg;\n    this.currentSpeed = controllerCfg.speed || 1;\n    this.tickLabelFormatter = tick.tickLabelFormatter; // style\n\n    if (type === 'trend') {\n      this.backgroundStyle = __assign(__assign({}, BACKGROUND_STYLE), backgroundStyle);\n    } else if (type === 'simple') {\n      this.backgroundStyle = __assign(__assign({}, SIMPLE_BACKGROUND_STYLE), backgroundStyle);\n    }\n\n    this.foregroundStyle = __assign(__assign({}, FOREGROUND_STYLE), foregroundStyle);\n    this.handlerStyle = __assign(__assign({}, HANDLER_STYLE), handlerStyle);\n    this.textStyle = __assign(__assign({}, TEXT_STYLE), textStyle);\n    this.tickLabelStyle = __assign(__assign({}, TICK_LABEL_STYLE), tick.tickLabelStyle);\n    this.tickLineStyle = __assign(__assign({}, TICK_LINE_STYLE), tick.tickLineStyle);\n    this.currentMode = 'range'; // 初始信息\n\n    this.start = start;\n    this.end = end;\n    this.minText = minText;\n    this.maxText = maxText; // 初始化 fontFamily，如果有浏览器，取 body 上的字体，防止文字更新时局部渲染造成的重影\n\n    this.fontFamily = typeof window !== 'undefined' ? window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif' : 'Arial, sans-serif';\n    this.renderSlider();\n  }\n  /**\n   * 更新配置\n   * @param cfg\n   */\n\n\n  TrendTimeBar.prototype.update = function (cfg) {\n    var x = cfg.x,\n        y = cfg.y,\n        width = cfg.width,\n        height = cfg.height,\n        minText = cfg.minText,\n        maxText = cfg.maxText,\n        start = cfg.start,\n        end = cfg.end; // start、end 只能是 0~1 范围\n\n    this.start = Math.min(1, Math.max(start, 0));\n    this.end = Math.min(1, Math.max(end, 0)); // 如果传了则更新，没有传则不更新\n    // @ts-ignore\n\n    assign(this, {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      minText: minText,\n      maxText: maxText\n    }); // 更新 ui，不自动绘制\n\n    this.updateUI();\n  };\n\n  TrendTimeBar.prototype.setText = function (minText, maxText) {\n    this.minTextShape.attr('text', minText);\n    this.maxTextShape.attr('text', maxText);\n  };\n  /**\n   * 初始化组件结构\n   * @private\n   */\n\n\n  TrendTimeBar.prototype.renderSlider = function () {\n    var _this = this;\n\n    var _a = this,\n        width = _a.width,\n        height = _a.height,\n        timeBarType = _a.timeBarType; // 趋势图数据\n\n\n    if (timeBarType === 'trend' && size(get(this.trendCfg, 'data'))) {\n      var trendComponent = new Trend(__assign(__assign({\n        x: this.x,\n        y: this.y,\n        width: width,\n        height: height\n      }, this.trendCfg), {\n        group: this.group\n      }));\n      this.trendComponent = trendComponent;\n    }\n\n    var sliderGroup = this.group.addGroup({\n      name: 'slider-group'\n    }); // 1. 背景\n\n    sliderGroup.addShape('rect', {\n      attrs: __assign({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }, this.backgroundStyle),\n      name: 'background'\n    });\n    var textGroup = this.group.addGroup(); // 2. 左右文字\n\n    if (timeBarType === 'trend') {\n      this.minTextShape = textGroup.addShape('text', {\n        attrs: __assign({\n          x: 0,\n          y: height / 2 + this.y,\n          textAlign: 'right',\n          text: this.minText,\n          silent: false,\n          fontFamily: this.fontFamily || 'Arial, sans-serif',\n          stroke: '#fff',\n          lineWidth: 5\n        }, this.textStyle),\n        capture: false,\n        name: 'min-text-shape'\n      });\n      this.maxTextShape = textGroup.addShape('text', {\n        attrs: __assign({\n          y: height / 2 + this.y,\n          textAlign: 'left',\n          text: this.maxText,\n          silent: false,\n          fontFamily: this.fontFamily || 'Arial, sans-serif',\n          stroke: '#fff',\n          lineWidth: 5\n        }, this.textStyle),\n        capture: false,\n        name: 'max-text-shape'\n      });\n    } else {\n      this.minTextShape = textGroup.addShape('text', {\n        attrs: __assign({\n          x: 0,\n          y: this.y - 10,\n          textAlign: 'center',\n          text: this.minText,\n          silent: false,\n          fontFamily: this.fontFamily || 'Arial, sans-serif',\n          stroke: '#fff',\n          lineWidth: 5\n        }, this.textStyle),\n        capture: false,\n        name: 'min-text-shape'\n      });\n      this.maxTextShape = textGroup.addShape('text', {\n        attrs: __assign({\n          y: this.y - 10,\n          textAlign: 'center',\n          text: this.maxText,\n          silent: false,\n          fontFamily: this.fontFamily || 'Arial, sans-serif',\n          stroke: '#fff',\n          lineWidth: 5\n        }, this.textStyle),\n        capture: false,\n        name: 'max-text-shape'\n      });\n    } // 3. 前景 选中背景框\n\n\n    this.foregroundShape = this.group.addGroup().addShape('rect', {\n      attrs: __assign({\n        x: 0,\n        y: this.y,\n        height: height\n      }, this.foregroundStyle),\n      name: 'foreground-shape'\n    });\n    this.foregroundShape.on('mousedown', function (e) {\n      e.target.attr('cursor', 'grabbing');\n    });\n    this.foregroundShape.on('mouseup', function (e) {\n      e.target.attr('cursor', _this.foregroundStyle.cursor || 'grab');\n    }); // 滑块相关的大小信息\n\n    var handlerWidth = get(this.handlerStyle, 'width', 2);\n    var handlerHeight = get(this.handlerStyle, 'height', 24);\n    var minHandleGroup = this.group.addGroup({\n      name: 'minHandlerShape'\n    }); // 4. 左右滑块\n\n    this.minHandlerShape = new Handler({\n      name: 'minHandlerShape',\n      group: minHandleGroup,\n      type: timeBarType,\n      x: this.x,\n      y: this.y,\n      width: handlerWidth,\n      height: handlerHeight,\n      style: this.handlerStyle\n    });\n    var maxHandleGroup = this.group.addGroup({\n      name: 'maxHandlerShape'\n    });\n    this.maxHandlerShape = new Handler({\n      name: 'maxHandlerShape',\n      group: maxHandleGroup,\n      type: timeBarType,\n      x: this.x,\n      y: this.y,\n      width: handlerWidth,\n      height: handlerHeight,\n      style: this.handlerStyle\n    }); // 缩略图下面的时间刻度\n\n    var tickData = this.ticks;\n    var interval = width / (tickData.length - 1);\n    this.tickPosList = [];\n\n    if (this.textList && this.textList.length) {\n      this.textList.forEach(function (text) {\n        text.destroy();\n      });\n    }\n\n    var lastX = -Infinity;\n    var rotate = this.tickLabelStyle.rotate;\n    delete this.tickLabelStyle.rotate;\n    this.textList = tickData.map(function (data, index) {\n      _this.tickPosList.push(_this.x + index * interval);\n\n      var label;\n\n      if (_this.tickLabelFormatter) {\n        label = _this.tickLabelFormatter(data);\n\n        if (!isString(label) && label) {\n          // return true\n          label = data.date;\n        }\n      } else {\n        label = data.date;\n      } // 文本刻度\n\n\n      var textX = _this.x + index * interval,\n          textY = _this.y + height + 5;\n\n      var text = _this.group.addShape('text', {\n        attrs: __assign({\n          x: textX,\n          y: textY,\n          text: label,\n          fontFamily: _this.fontFamily || 'Arial, sans-serif'\n        }, _this.tickLabelStyle),\n        name: 'tick-label'\n      });\n\n      if (isNumber(rotate) && index !== tickData.length - 1) {\n        var matrix = transform([1, 0, 0, 0, 1, 0, 0, 0, 1], [['t', -textX, -textY], ['r', rotate], ['t', textX - 5, textY + 2]]);\n        text.attr({\n          textAlign: 'left',\n          matrix: matrix\n        });\n      }\n\n      if (index === 0) {\n        text.attr({\n          textAlign: 'left'\n        });\n      } else if (index !== tickData.length - 1) {\n        text.attr({\n          textAlign: 'right'\n        });\n      } // 文本刻度上面的竖线\n\n\n      var line = _this.group.addShape('line', {\n        attrs: __assign({\n          x1: _this.x + index * interval,\n          y1: _this.y + height + 2,\n          x2: _this.x + index * interval,\n          y2: _this.y + height + 6\n        }, _this.tickLineStyle),\n        name: 'tick-line'\n      });\n\n      line.toBack();\n      var bbox = text.getBBox(); // 抽样，标签与标签间距不小于 10\n\n      if (bbox.minX > lastX) {\n        text.show();\n        line.show();\n        lastX = bbox.minX + bbox.width + 10;\n      } else {\n        text.hide();\n        line.hide();\n      }\n\n      return text;\n    }); // 渲染播放、快进和后退的控制按钮\n\n    this.controllerBtnGroup = new ControllerBtn(__assign({\n      group: this.group,\n      x: this.x,\n      y: this.y + height + 25,\n      width: width,\n      height: 35\n    }, this.controllerCfg)); // 初始化 minText 和 maxText，方便计算它们的 bbox\n\n    this.updateStartEnd(0); // 根据 start end 更新 ui 的位置信息\n\n    this.updateUI(); // 移动到对应的位置\n\n    sliderGroup.move(this.x, this.y); // 绑定事件鼠标事件\n\n    this.bindEvents();\n  };\n  /**\n   * 绑定事件：\n   *  - 点击\n   *  - 滑动\n   *  - 拖拽\n   *  - 滚动\n   * @private\n   */\n\n\n  TrendTimeBar.prototype.bindEvents = function () {\n    var _this = this; // 1. 左滑块的滑动\n\n\n    var minHandleShapeGroup = this.group.find(function (group) {\n      return group.get('name') === 'minHandlerShape';\n    });\n\n    if (minHandleShapeGroup) {\n      minHandleShapeGroup.on('minHandlerShape-handler:mousedown', this.onMouseDown(this.minHandlerShape));\n      minHandleShapeGroup.on('minHandlerShape-handler:touchstart', this.onMouseDown(this.minHandlerShape));\n    }\n\n    var maxHandleShapeGroup = this.group.find(function (group) {\n      return group.get('name') === 'maxHandlerShape';\n    }); // 2. 右滑块的滑动\n\n    if (maxHandleShapeGroup) {\n      maxHandleShapeGroup.on('maxHandlerShape-handler:mousedown', this.onMouseDown(this.maxHandlerShape));\n      maxHandleShapeGroup.on('maxHandlerShape-handler:touchstart', this.onMouseDown(this.maxHandlerShape));\n    } // 3. 前景选中区域\n\n\n    this.foregroundShape.on('mousedown', this.onMouseDown(this.foregroundShape));\n    this.foregroundShape.on('touchstart', this.onMouseDown(this.foregroundShape)); // 播放区按钮控制\n\n    /** 播放/暂停事件 */\n\n    this.group.on(\"\".concat(PLAY_PAUSE_BTN, \":click\"), function () {\n      _this.isPlay = !_this.isPlay;\n      _this.currentHandler = _this.maxHandlerShape;\n\n      _this.changePlayStatus();\n    }); // 处理前进一步的事件\n\n    this.group.on(\"\".concat(NEXT_STEP_BTN, \":click\"), function () {\n      _this.currentHandler = _this.maxHandlerShape;\n\n      _this.updateStartEnd(0.01);\n\n      _this.updateUI();\n    }); // 处理后退一步的事件\n\n    this.group.on(\"\".concat(PRE_STEP_BTN, \":click\"), function () {\n      _this.currentHandler = _this.maxHandlerShape;\n\n      _this.updateStartEnd(-0.01);\n\n      _this.updateUI();\n    });\n    this.group.on(TIMEBAR_CONFIG_CHANGE, function (_a) {\n      var type = _a.type,\n          speed = _a.speed;\n      _this.currentSpeed = speed;\n      _this.currentMode = type;\n\n      if (type === 'single') {\n        _this.minHandlerShape.hide();\n\n        _this.foregroundShape.hide();\n\n        _this.minTextShape.hide();\n      } else if (type === 'range') {\n        _this.minHandlerShape.show();\n\n        _this.foregroundShape.show();\n\n        _this.minTextShape.show();\n      }\n    });\n  };\n  /** 输入当前圆点位置，输出离哪个 tick 的位置最近 */\n\n\n  TrendTimeBar.prototype.adjustTickIndex = function (timeSelectX) {\n    for (var i = 0; i < this.tickPosList.length - 1; i++) {\n      if (this.tickPosList[i] <= timeSelectX && timeSelectX <= this.tickPosList[i + 1]) {\n        return Math.abs(this.tickPosList[i] - timeSelectX) < Math.abs(timeSelectX - this.tickPosList[i + 1]) ? i : i + 1;\n      }\n    }\n\n    return 0;\n  };\n  /**\n   * 调整 offsetRange，因为一些范围的限制\n   * @param offsetRange\n   */\n\n\n  TrendTimeBar.prototype.adjustOffsetRange = function (offsetRange) {\n    // 针对不同的滑动组件，处理的方式不同\n    switch (this.currentHandler) {\n      case this.minHandlerShape:\n        {\n          var min = 0 - this.start;\n          var max = 1 - this.start;\n          return Math.min(max, Math.max(min, offsetRange));\n        }\n\n      case this.maxHandlerShape:\n        {\n          var min = 0 - this.end;\n          var max = 1 - this.end;\n          return Math.min(max, Math.max(min, offsetRange));\n        }\n\n      case this.foregroundShape:\n        {\n          var min = 0 - this.start;\n          var max = 1 - this.end;\n          return Math.min(max, Math.max(min, offsetRange));\n        }\n\n      default:\n        return 0;\n    }\n  };\n  /**\n   * 更新起始、结束的控制块位置、文本、范围值（原始值）\n   * @param offsetRange\n   */\n\n\n  TrendTimeBar.prototype.updateStartEnd = function (offsetRange) {\n    var minData = this.ticks[this.adjustTickIndex(this.start * this.width)];\n    var maxData = this.ticks[this.adjustTickIndex(this.end * this.width)];\n\n    if (!this.currentHandler) {\n      this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData === null || minData === void 0 ? void 0 : minData.date;\n      this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData === null || maxData === void 0 ? void 0 : maxData.date;\n      return;\n    } // 操作不同的组件，反馈不一样\n\n\n    switch (this.currentHandler) {\n      case this.minHandlerShape:\n        // 拖动最小滑块时使用当前最大值设置最大值的文本，以便恢复到默认值\n        this.maxText = this.maxTextShape.attr('text');\n        this.start += offsetRange;\n        this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;\n        break;\n\n      case this.maxHandlerShape:\n        // 拖动最大滑块时使用当前最小值设置最小值的文本，以便恢复到默认值\n        this.minText = this.minTextShape.attr('text');\n        this.end += offsetRange;\n        this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;\n        break;\n\n      case this.foregroundShape:\n        this.start += offsetRange;\n        this.end += offsetRange;\n        this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;\n        this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;\n        break;\n\n      default:\n        break;\n    }\n  };\n  /**\n   * 根据移动的比例来更新 ui，更新范围（0-1 范围的比例值）\n   * @private\n   */\n\n\n  TrendTimeBar.prototype.updateUI = function () {\n    var _this = this;\n\n    if (this.start < 0) {\n      this.start = 0;\n    }\n\n    if (this.end > 1) {\n      this.end = 1;\n    }\n\n    var min = this.x + this.start * this.width;\n    var max = this.x + this.end * this.width; // 1. foreground\n\n    this.foregroundShape.attr('x', min);\n    this.foregroundShape.attr('width', max - min); // 滑块相关的大小信息\n\n    var handlerWidth = get(this.handlerStyle, 'width', DEFAULT_HANDLER_WIDTH); // 设置文本\n\n    this.setText(this.minText, this.maxText);\n\n    var _a = this.dodgeText([min, max]),\n        minAttrs = _a[0],\n        maxAttrs = _a[1]; // 2. 左侧滑块和文字位置\n\n\n    this.minHandlerShape.setX(min - handlerWidth / 2);\n    each(minAttrs, function (v, k) {\n      return _this.minTextShape.attr(k, v);\n    }); // 3. 右侧滑块和文字位置\n\n    this.maxHandlerShape.setX(max - handlerWidth / 2);\n    each(maxAttrs, function (v, k) {\n      return _this.maxTextShape.attr(k, v);\n    });\n\n    if (this.currentMode === 'range') {\n      // 因为存储的 start、end 可能不一定是按大小存储的，所以排序一下，对外是 end >= start\n      this.graph.emit(VALUE_CHANGE, {\n        value: [this.start, this.end].sort()\n      });\n    } else if (this.currentMode === 'single') {\n      this.graph.emit(VALUE_CHANGE, {\n        value: [this.end, this.end]\n      });\n    }\n  };\n  /**\n   * 调整 text 的位置，自动躲避\n   * 根据位置，调整返回新的位置\n   * @param range\n   */\n\n\n  TrendTimeBar.prototype.dodgeText = function (range) {\n    var _a, _b;\n\n    var TEXTPADDING = 2;\n    var handlerWidth = get(this.handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);\n    var minTextShape = this.minTextShape;\n    var maxTextShape = this.maxTextShape;\n    var min = range[0],\n        max = range[1];\n    var sorted = false; // 如果交换了位置，则对应的 min max 也交换\n\n    if (min > max) {\n      _a = [max, min], min = _a[0], max = _a[1];\n      _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];\n      sorted = true;\n    } // 避让规则，优先显示在两侧，只有显示不下的时候，才显示在中间\n\n\n    var minBBox = minTextShape.getBBox();\n    var maxBBox = maxTextShape.getBBox();\n    var minAttrs = null;\n    var maxAttrs = null;\n\n    if (this.timeBarType === 'trend') {\n      minAttrs = min - minBBox.width < this.x + TEXTPADDING ? {\n        x: min + handlerWidth / 2 + TEXTPADDING,\n        textAlign: 'left'\n      } : {\n        x: min - handlerWidth / 2 - TEXTPADDING,\n        textAlign: 'right'\n      };\n      maxAttrs = max + maxBBox.width > this.x + this.width ? {\n        x: max - handlerWidth / 2 - TEXTPADDING,\n        textAlign: 'right'\n      } : {\n        x: max + handlerWidth / 2 + TEXTPADDING,\n        textAlign: 'left'\n      };\n    } else if (this.timeBarType === 'simple') {\n      minAttrs = minTextShape.attr('x') > minBBox.width // 左边滑块文本位置小于其宽度代表文字超过左边届\n      ? {\n        x: min,\n        textAlign: 'center'\n      } : {\n        x: min,\n        textAlign: 'left'\n      };\n      maxAttrs = maxTextShape.attr('x') > this.width - maxBBox.width // 有边滑块文本位置大于宽度代表文字超过右边界\n      ? {\n        x: max,\n        textAlign: 'right'\n      } : {\n        x: max,\n        textAlign: 'center'\n      };\n    }\n\n    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];\n  };\n\n  TrendTimeBar.prototype.startPlay = function () {\n    var _this = this;\n\n    return typeof window !== 'undefined' ? window.requestAnimationFrame(function () {\n      var _a = _this,\n          ticks = _a.ticks,\n          width = _a.width;\n      var speed = _this.currentSpeed;\n      var tickInterval = width / ticks.length;\n      var offsetX = tickInterval / ((10 - speed) * 1000 / 60);\n\n      var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);\n\n      _this.updateStartEnd(offsetXRange);\n\n      _this.updateUI();\n\n      if (_this.isPlay) {\n        _this.playHandler = _this.startPlay();\n      }\n    }) : undefined;\n  };\n\n  TrendTimeBar.prototype.changePlayStatus = function (isSync) {\n    if (isSync === void 0) {\n      isSync = true;\n    }\n\n    this.controllerBtnGroup.playButton.update({\n      isPlay: this.isPlay\n    });\n\n    if (this.isPlay) {\n      // 开始播放\n      this.playHandler = this.startPlay();\n      this.graph.emit(TIMELINE_START, null);\n    } else {\n      // 结束播放\n      if (this.playHandler) {\n        if (typeof window !== 'undefined') window.cancelAnimationFrame(this.playHandler);\n\n        if (isSync) {\n          this.graph.emit(TIMELINE_END, null);\n        }\n      }\n    }\n  };\n\n  TrendTimeBar.prototype.destory = function () {\n    this.graph.off(VALUE_CHANGE);\n    var group = this.group;\n    var minHandleShapeGroup = group.find(function (g) {\n      return g.get('name') === 'minHandlerShape';\n    });\n\n    if (minHandleShapeGroup) {\n      minHandleShapeGroup.off('minHandlerShape-handler:mousedown');\n      minHandleShapeGroup.off('minHandlerShape-handler:touchstart');\n      minHandleShapeGroup.destroy();\n    }\n\n    var maxHandleShapeGroup = group.find(function (g) {\n      return g.get('name') === 'maxHandlerShape';\n    }); // 2. 右滑块的滑动\n\n    if (maxHandleShapeGroup) {\n      maxHandleShapeGroup.off('maxHandlerShape-handler:mousedown');\n      maxHandleShapeGroup.off('maxHandlerShape-handler:touchstart');\n      maxHandleShapeGroup.destroy();\n    } // 3. 前景选中区域\n\n\n    this.foregroundShape.off('mousedown');\n    this.foregroundShape.off('touchstart');\n    this.foregroundShape.destroy();\n    group.off(\"\".concat(PLAY_PAUSE_BTN, \":click\"));\n    group.off(\"\".concat(NEXT_STEP_BTN, \":click\"));\n    group.off(\"\".concat(PRE_STEP_BTN, \":click\"));\n    group.off(TIMEBAR_CONFIG_CHANGE);\n    group.destroy();\n\n    if (this.trendComponent) {\n      this.trendComponent.destory();\n    }\n  };\n\n  return TrendTimeBar;\n}();\n\nexport default TrendTimeBar;","map":null,"metadata":{},"sourceType":"module"}