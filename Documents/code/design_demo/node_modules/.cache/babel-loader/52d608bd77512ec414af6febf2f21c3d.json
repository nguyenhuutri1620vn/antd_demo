{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { isMini } from '@antv/l7-utils';\nimport { mat2, mat4, vec4 } from 'gl-matrix';\nimport Point from '../geo/point';\nimport { clamp, interpolate, wrap } from '../util';\nimport EdgeInsets from './edge_insets';\nimport LngLat from './lng_lat';\nimport LngLatBounds from './lng_lat_bounds';\nimport MercatorCoordinate, { mercatorXfromLng, mercatorYfromLat, mercatorZfromAltitude } from './mercator';\nexport var EXTENT = 8192;\n\nvar Transform = function () {\n  function Transform(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies) {\n    _classCallCheck(this, Transform);\n\n    _defineProperty(this, \"tileSize\", void 0);\n\n    _defineProperty(this, \"tileZoom\", void 0);\n\n    _defineProperty(this, \"lngRange\", void 0);\n\n    _defineProperty(this, \"latRange\", void 0);\n\n    _defineProperty(this, \"maxValidLatitude\", void 0);\n\n    _defineProperty(this, \"scale\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"angle\", void 0);\n\n    _defineProperty(this, \"rotationMatrix\", void 0);\n\n    _defineProperty(this, \"pixelsToGLUnits\", void 0);\n\n    _defineProperty(this, \"cameraToCenterDistance\", void 0);\n\n    _defineProperty(this, \"mercatorMatrix\", void 0);\n\n    _defineProperty(this, \"projMatrix\", void 0);\n\n    _defineProperty(this, \"invProjMatrix\", void 0);\n\n    _defineProperty(this, \"alignedProjMatrix\", void 0);\n\n    _defineProperty(this, \"pixelMatrix\", void 0);\n\n    _defineProperty(this, \"pixelMatrixInverse\", void 0);\n\n    _defineProperty(this, \"glCoordMatrix\", void 0);\n\n    _defineProperty(this, \"labelPlaneMatrix\", void 0);\n\n    _defineProperty(this, \"_fov\", void 0);\n\n    _defineProperty(this, \"_pitch\", void 0);\n\n    _defineProperty(this, \"_zoom\", void 0);\n\n    _defineProperty(this, \"_renderWorldCopies\", void 0);\n\n    _defineProperty(this, \"_minZoom\", void 0);\n\n    _defineProperty(this, \"_maxZoom\", void 0);\n\n    _defineProperty(this, \"_minPitch\", void 0);\n\n    _defineProperty(this, \"_maxPitch\", void 0);\n\n    _defineProperty(this, \"_center\", void 0);\n\n    _defineProperty(this, \"zoomFraction\", void 0);\n\n    _defineProperty(this, \"unmodified\", void 0);\n\n    _defineProperty(this, \"edgeInsets\", void 0);\n\n    _defineProperty(this, \"constraining\", void 0);\n\n    _defineProperty(this, \"posMatrixCache\", void 0);\n\n    _defineProperty(this, \"alignedPosMatrixCache\", void 0);\n\n    this.tileSize = 512;\n    this.maxValidLatitude = 85.051129;\n    this._renderWorldCopies = renderWorldCopies === undefined ? true : renderWorldCopies;\n    this._minZoom = minZoom || 0;\n    this._maxZoom = maxZoom || 22;\n    this._minPitch = minPitch === undefined || minPitch === null ? 0 : minPitch;\n    this._maxPitch = maxPitch === undefined || maxPitch === null ? 60 : maxPitch;\n    this.setMaxBounds();\n    this.width = 0;\n    this.height = 0;\n    this._center = new LngLat(0, 0);\n    this.zoom = 0;\n    this.angle = 0;\n    this._fov = 0.6435011087932844;\n    this._pitch = 0;\n    this.unmodified = true;\n    this.edgeInsets = new EdgeInsets();\n    this.posMatrixCache = {};\n    this.alignedPosMatrixCache = {};\n  }\n\n  _createClass(Transform, [{\n    key: \"minZoom\",\n    get: function get() {\n      return this._minZoom;\n    },\n    set: function set(zoom) {\n      if (this._minZoom === zoom) {\n        return;\n      }\n\n      this._minZoom = zoom;\n      this.zoom = Math.max(this.zoom, zoom);\n    }\n  }, {\n    key: \"maxZoom\",\n    get: function get() {\n      return this._maxZoom;\n    },\n    set: function set(zoom) {\n      if (this._maxZoom === zoom) {\n        return;\n      }\n\n      this._maxZoom = zoom;\n      this.zoom = Math.min(this.zoom, zoom);\n    }\n  }, {\n    key: \"minPitch\",\n    get: function get() {\n      return this._minPitch;\n    },\n    set: function set(pitch) {\n      if (this._minPitch === pitch) {\n        return;\n      }\n\n      this._minPitch = pitch;\n      this._pitch = Math.max(this._pitch, pitch);\n    }\n  }, {\n    key: \"maxPitch\",\n    get: function get() {\n      return this._maxPitch;\n    },\n    set: function set(pitch) {\n      if (this._maxPitch === pitch) {\n        return;\n      }\n\n      this._maxPitch = pitch;\n      this._pitch = Math.min(this._pitch, pitch);\n    }\n  }, {\n    key: \"renderWorldCopies\",\n    get: function get() {\n      return this._renderWorldCopies;\n    },\n    set: function set(renderWorldCopies) {\n      if (renderWorldCopies === undefined) {\n        renderWorldCopies = true;\n      } else if (renderWorldCopies === null) {\n        renderWorldCopies = false;\n      }\n\n      this._renderWorldCopies = renderWorldCopies;\n    }\n  }, {\n    key: \"worldSize\",\n    get: function get() {\n      return this.tileSize * this.scale;\n    }\n  }, {\n    key: \"centerOffset\",\n    get: function get() {\n      return this.centerPoint._sub(this.size._div(2));\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return new Point(this.width, this.height);\n    }\n  }, {\n    key: \"bearing\",\n    get: function get() {\n      return -this.angle / Math.PI * 180;\n    },\n    set: function set(bearing) {\n      var b = -wrap(bearing, -180, 180) * Math.PI / 180;\n\n      if (this.angle === b) {\n        return;\n      }\n\n      this.unmodified = false;\n      this.angle = b;\n      this.calcMatrices();\n      this.rotationMatrix = mat2.create();\n      mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      return this._pitch / Math.PI * 180;\n    },\n    set: function set(pitch) {\n      var p = clamp(pitch, this._minPitch, this._maxPitch) / 180 * Math.PI;\n\n      if (this._pitch === p) {\n        return;\n      }\n\n      this.unmodified = false;\n      this._pitch = p;\n      this.calcMatrices();\n    }\n  }, {\n    key: \"fov\",\n    get: function get() {\n      return this._fov / Math.PI * 180;\n    },\n    set: function set(fov) {\n      fov = Math.max(0.01, Math.min(60, fov));\n\n      if (this._fov === fov) {\n        return;\n      }\n\n      this.unmodified = false;\n      this._fov = fov / 180 * Math.PI;\n      this.calcMatrices();\n    }\n  }, {\n    key: \"zoom\",\n    get: function get() {\n      return this._zoom;\n    },\n    set: function set(zoom) {\n      var z = Math.min(Math.max(zoom, this._minZoom), this._maxZoom);\n\n      if (this._zoom === z) {\n        return;\n      }\n\n      this.unmodified = false;\n      this._zoom = z;\n      this.scale = this.zoomScale(z);\n      this.tileZoom = Math.floor(z);\n      this.zoomFraction = z - this.tileZoom;\n      this.constrain();\n      this.calcMatrices();\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return this._center;\n    },\n    set: function set(center) {\n      if (center.lat === this._center.lat && center.lng === this._center.lng) {\n        return;\n      }\n\n      this.unmodified = false;\n      this._center = center;\n      this.constrain();\n      this.calcMatrices();\n    }\n  }, {\n    key: \"padding\",\n    get: function get() {\n      return this.edgeInsets.toJSON();\n    },\n    set: function set(padding) {\n      if (this.edgeInsets.equals(padding)) {\n        return;\n      }\n\n      this.unmodified = false;\n      this.edgeInsets.interpolate(this.edgeInsets, padding, 1);\n      this.calcMatrices();\n    }\n  }, {\n    key: \"centerPoint\",\n    get: function get() {\n      return this.edgeInsets.getCenter(this.width, this.height);\n    }\n  }, {\n    key: \"point\",\n    get: function get() {\n      return this.project(this.center);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new Transform(this._minZoom, this._maxZoom, this._minPitch, this._maxPitch, this._renderWorldCopies);\n      clone.tileSize = this.tileSize;\n      clone.latRange = this.latRange;\n      clone.width = this.width;\n      clone.height = this.height;\n      clone.center = this._center;\n      clone.zoom = this.zoom;\n      clone.angle = this.angle;\n      clone.fov = this._fov;\n      clone.pitch = this._pitch;\n      clone.unmodified = this.unmodified;\n      clone.edgeInsets = this.edgeInsets.clone();\n      clone.calcMatrices();\n      return clone;\n    }\n  }, {\n    key: \"isPaddingEqual\",\n    value: function isPaddingEqual(padding) {\n      return this.edgeInsets.equals(padding);\n    }\n  }, {\n    key: \"interpolatePadding\",\n    value: function interpolatePadding(start, target, t) {\n      this.unmodified = false;\n      this.edgeInsets.interpolate(start, target, t);\n      this.constrain();\n      this.calcMatrices();\n    }\n  }, {\n    key: \"coveringZoomLevel\",\n    value: function coveringZoomLevel(options) {\n      var z = (options.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / options.tileSize));\n      return Math.max(0, z);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      this.width = width;\n      this.height = height;\n      this.pixelsToGLUnits = [2 / width, -2 / height];\n      this.constrain();\n      this.calcMatrices();\n    }\n  }, {\n    key: \"zoomScale\",\n    value: function zoomScale(zoom) {\n      return Math.pow(2, zoom);\n    }\n  }, {\n    key: \"scaleZoom\",\n    value: function scaleZoom(scale) {\n      return Math.log(scale) / Math.LN2;\n    }\n  }, {\n    key: \"project\",\n    value: function project(lnglat) {\n      var lat = clamp(lnglat.lat, -this.maxValidLatitude, this.maxValidLatitude);\n      return new Point(mercatorXfromLng(lnglat.lng) * this.worldSize, mercatorYfromLat(lat) * this.worldSize);\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(point) {\n      return new MercatorCoordinate(point.x / this.worldSize, point.y / this.worldSize).toLngLat();\n    }\n  }, {\n    key: \"setLocationAtPoint\",\n    value: function setLocationAtPoint(lnglat, point) {\n      var a = this.pointCoordinate(point);\n      var b = this.pointCoordinate(this.centerPoint);\n      var loc = this.locationCoordinate(lnglat);\n      var newCenter = new MercatorCoordinate(loc.x - (a.x - b.x), loc.y - (a.y - b.y));\n      this.center = this.coordinateLocation(newCenter);\n\n      if (this._renderWorldCopies) {\n        this.center = this.center.wrap();\n      }\n    }\n  }, {\n    key: \"pointCoordinate\",\n    value: function pointCoordinate(p) {\n      var targetZ = 0;\n      var coord0 = new Float64Array([p.x, p.y, 0, 1]);\n      var coord1 = new Float64Array([p.x, p.y, 1, 1]);\n      vec4.transformMat4(coord0, coord0, this.pixelMatrixInverse);\n      vec4.transformMat4(coord1, coord1, this.pixelMatrixInverse);\n      var w0 = coord0[3];\n      var w1 = coord1[3];\n      var x0 = coord0[0] / w0;\n      var x1 = coord1[0] / w1;\n      var y0 = coord0[1] / w0;\n      var y1 = coord1[1] / w1;\n      var z0 = coord0[2] / w0;\n      var z1 = coord1[2] / w1;\n      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);\n      return new MercatorCoordinate(interpolate(x0, x1, t) / this.worldSize, interpolate(y0, y1, t) / this.worldSize);\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      return new LngLatBounds().extend(this.pointLocation(new Point(0, 0))).extend(this.pointLocation(new Point(this.width, 0))).extend(this.pointLocation(new Point(this.width, this.height))).extend(this.pointLocation(new Point(0, this.height)));\n    }\n  }, {\n    key: \"getMaxBounds\",\n    value: function getMaxBounds() {\n      if (!this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2) {\n        return null;\n      }\n\n      return new LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);\n    }\n  }, {\n    key: \"setMaxBounds\",\n    value: function setMaxBounds(bounds) {\n      if (bounds) {\n        this.lngRange = [bounds.getWest(), bounds.getEast()];\n        this.latRange = [bounds.getSouth(), bounds.getNorth()];\n        this.constrain();\n      } else {\n        this.lngRange = undefined;\n        this.latRange = [-this.maxValidLatitude, this.maxValidLatitude];\n      }\n    }\n  }, {\n    key: \"customLayerMatrix\",\n    value: function customLayerMatrix() {\n      return this.mercatorMatrix.slice();\n    }\n  }, {\n    key: \"maxPitchScaleFactor\",\n    value: function maxPitchScaleFactor() {\n      if (!this.pixelMatrixInverse) {\n        return 1;\n      }\n\n      var coord = this.pointCoordinate(new Point(0, 0));\n      var p = new Float32Array([coord.x * this.worldSize, coord.y * this.worldSize, 0, 1]);\n      var topPoint = vec4.transformMat4(p, p, this.pixelMatrix);\n      return topPoint[3] / this.cameraToCenterDistance;\n    }\n  }, {\n    key: \"getCameraPoint\",\n    value: function getCameraPoint() {\n      var pitch = this._pitch;\n      var yOffset = Math.tan(pitch) * (this.cameraToCenterDistance || 1);\n      return this.centerPoint.add(new Point(0, yOffset));\n    }\n  }, {\n    key: \"getCameraQueryGeometry\",\n    value: function getCameraQueryGeometry(queryGeometry) {\n      var c = this.getCameraPoint();\n\n      if (queryGeometry.length === 1) {\n        return [queryGeometry[0], c];\n      } else {\n        var minX = c.x;\n        var minY = c.y;\n        var maxX = c.x;\n        var maxY = c.y;\n\n        var _iterator = _createForOfIteratorHelper(queryGeometry),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var p = _step.value;\n            minX = Math.min(minX, p.x);\n            minY = Math.min(minY, p.y);\n            maxX = Math.max(maxX, p.x);\n            maxY = Math.max(maxY, p.y);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return [new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY), new Point(minX, minY)];\n      }\n    }\n  }, {\n    key: \"coordinatePoint\",\n    value: function coordinatePoint(coord) {\n      var p = vec4.fromValues(coord.x * this.worldSize, coord.y * this.worldSize, 0, 1);\n      vec4.transformMat4(p, p, this.pixelMatrix);\n      return new Point(p[0] / p[3], p[1] / p[3]);\n    }\n  }, {\n    key: \"locationPoint\",\n    value: function locationPoint(lnglat) {\n      return this.coordinatePoint(this.locationCoordinate(lnglat));\n    }\n  }, {\n    key: \"pointLocation\",\n    value: function pointLocation(p) {\n      return this.coordinateLocation(this.pointCoordinate(p));\n    }\n  }, {\n    key: \"locationCoordinate\",\n    value: function locationCoordinate(lnglat) {\n      return MercatorCoordinate.fromLngLat(lnglat);\n    }\n  }, {\n    key: \"coordinateLocation\",\n    value: function coordinateLocation(coord) {\n      return coord.toLngLat();\n    }\n  }, {\n    key: \"getProjectionMatrix\",\n    value: function getProjectionMatrix() {\n      return this.projMatrix;\n    }\n  }, {\n    key: \"constrain\",\n    value: function constrain() {\n      if (!this.center || !this.width || !this.height || this.constraining) {\n        return;\n      }\n\n      this.constraining = true;\n      var minY = -90;\n      var maxY = 90;\n      var minX = -180;\n      var maxX = 180;\n      var sy;\n      var sx;\n      var x2;\n      var y2;\n      var size = this.size;\n      var unmodified = this.unmodified;\n\n      if (this.latRange) {\n        var latRange = this.latRange;\n        minY = mercatorYfromLat(latRange[1]) * this.worldSize;\n        maxY = mercatorYfromLat(latRange[0]) * this.worldSize;\n        sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;\n      }\n\n      if (this.lngRange) {\n        var lngRange = this.lngRange;\n        minX = mercatorXfromLng(lngRange[0]) * this.worldSize;\n        maxX = mercatorXfromLng(lngRange[1]) * this.worldSize;\n        sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;\n      }\n\n      var point = this.point;\n      var s = Math.max(sx || 0, sy || 0);\n\n      if (s) {\n        this.center = this.unproject(new Point(sx ? (maxX + minX) / 2 : point.x, sy ? (maxY + minY) / 2 : point.y));\n\n        if (isMini) {\n          this.zoom = Math.max(this.zoom, Math.max(-1, this.minZoom));\n        } else {\n          this.zoom += this.scaleZoom(s);\n        }\n\n        this.unmodified = unmodified;\n        this.constraining = false;\n        return;\n      }\n\n      if (this.latRange) {\n        var y = point.y;\n        var h2 = size.y / 2;\n\n        if (y - h2 < minY) {\n          y2 = minY + h2;\n        }\n\n        if (y + h2 > maxY) {\n          y2 = maxY - h2;\n        }\n      }\n\n      if (this.lngRange) {\n        var x = point.x;\n        var w2 = size.x / 2;\n\n        if (x - w2 < minX) {\n          x2 = minX + w2;\n        }\n\n        if (x + w2 > maxX) {\n          x2 = maxX - w2;\n        }\n      }\n\n      if (x2 !== undefined || y2 !== undefined) {\n        this.center = this.unproject(new Point(x2 !== undefined ? x2 : point.x, y2 !== undefined ? y2 : point.y));\n      }\n\n      this.unmodified = unmodified;\n      this.constraining = false;\n    }\n  }, {\n    key: \"calcMatrices\",\n    value: function calcMatrices() {\n      if (!this.height) {\n        return;\n      }\n\n      var halfFov = this._fov / 2;\n      var offset = this.centerOffset;\n      this.cameraToCenterDistance = 0.5 / Math.tan(halfFov) * this.height;\n      var groundAngle = Math.PI / 2 + this._pitch;\n      var fovAboveCenter = this._fov * (0.5 + offset.y / this.height);\n      var topHalfSurfaceDistance = Math.sin(fovAboveCenter) * this.cameraToCenterDistance / Math.sin(clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));\n      var point = this.point;\n      var x = point.x;\n      var y = point.y;\n      var furthestDistance = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.cameraToCenterDistance;\n      var farZ = furthestDistance * 1.01;\n      var nearZ = this.height / 50;\n      var m = new Float64Array(16);\n      mat4.perspective(m, this._fov, this.width / this.height, nearZ, farZ);\n      m[8] = -offset.x * 2 / this.width;\n      m[9] = offset.y * 2 / this.height;\n      mat4.scale(m, m, [1, -1, 1]);\n      mat4.translate(m, m, [0, 0, -this.cameraToCenterDistance]);\n      mat4.rotateX(m, m, this._pitch);\n      mat4.rotateZ(m, m, this.angle);\n      mat4.translate(m, m, [-x, -y, 0]);\n      this.mercatorMatrix = mat4.scale([], m, [this.worldSize, this.worldSize, this.worldSize]);\n      mat4.scale(m, m, [1, 1, mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]);\n      this.projMatrix = m;\n      this.invProjMatrix = mat4.invert([], this.projMatrix);\n      var xShift = this.width % 2 / 2;\n      var yShift = this.height % 2 / 2;\n      var angleCos = Math.cos(this.angle);\n      var angleSin = Math.sin(this.angle);\n      var dx = x - Math.round(x) + angleCos * xShift + angleSin * yShift;\n      var dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;\n      var alignedM = new Float64Array(m);\n      mat4.translate(alignedM, alignedM, [dx > 0.5 ? dx - 1 : dx, dy > 0.5 ? dy - 1 : dy, 0]);\n      this.alignedProjMatrix = alignedM;\n      m = mat4.create();\n      mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);\n      mat4.translate(m, m, [1, -1, 0]);\n      this.labelPlaneMatrix = m;\n      m = mat4.create();\n      mat4.scale(m, m, [1, -1, 1]);\n      mat4.translate(m, m, [-1, -1, 0]);\n      mat4.scale(m, m, [2 / this.width, 2 / this.height, 1]);\n      this.glCoordMatrix = m;\n      this.pixelMatrix = mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix);\n      m = mat4.invert(new Float64Array(16), this.pixelMatrix);\n\n      if (!m) {\n        throw new Error('failed to invert matrix');\n      }\n\n      this.pixelMatrixInverse = m;\n      this.posMatrixCache = {};\n      this.alignedPosMatrixCache = {};\n    }\n  }]);\n\n  return Transform;\n}();\n\nexport { Transform as default };","map":null,"metadata":{},"sourceType":"module"}