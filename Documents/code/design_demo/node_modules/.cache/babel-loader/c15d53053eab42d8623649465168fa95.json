{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { mat4, vec3 } from 'gl-matrix';\nexport var EARTH_RADIUS = 100;\nexport var EARTH_SEGMENTS = 36;\nexport var EARTH_RADIUS_OUTER = 40;\n\nfunction torad(deg) {\n  return deg / 180 * Math.acos(-1);\n}\n\nexport function lglt2xyz(lnglat) {\n  var lng = torad(lnglat[0]) + Math.PI / 2;\n  var lat = torad(lnglat[1]);\n  var radius = EARTH_RADIUS + Math.random() * 0.4;\n  var z = radius * Math.cos(lat) * Math.cos(lng);\n  var x = radius * Math.cos(lat) * Math.sin(lng);\n  var y = radius * Math.sin(lat);\n  return [x, y, z];\n}\nexport function primitiveSphere(radius, opt) {\n  var matRotY = mat4.create();\n  var matRotZ = mat4.create();\n  var up = vec3.fromValues(0, 1, 0);\n  var tmpVec3 = vec3.fromValues(0, 0, 0);\n  opt = opt || {};\n  radius = typeof radius !== 'undefined' ? radius : 1;\n  var segments = typeof opt.segments !== 'undefined' ? opt.segments : 32;\n  var totalZRotationSteps = 2 + segments;\n  var totalYRotationSteps = 2 * totalZRotationSteps;\n  var indices = [];\n  var indicesArr = [];\n  var positions = [];\n  var positionsArr = [];\n  var normalArr = [];\n  var uvs = [];\n\n  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n    var normalizedZ = zRotationStep / totalZRotationSteps;\n    var angleZ = normalizedZ * Math.PI;\n\n    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n      var normalizedY = yRotationStep / totalYRotationSteps;\n      var angleY = normalizedY * Math.PI * 2;\n      mat4.identity(matRotZ);\n      mat4.rotateZ(matRotZ, matRotZ, -angleZ);\n      mat4.identity(matRotY);\n      mat4.rotateY(matRotY, matRotY, angleY);\n      vec3.transformMat4(tmpVec3, up, matRotZ);\n      vec3.transformMat4(tmpVec3, tmpVec3, matRotY);\n      vec3.scale(tmpVec3, tmpVec3, -radius);\n      positions.push(tmpVec3.slice());\n      positionsArr.push.apply(positionsArr, _toConsumableArray(tmpVec3.slice()));\n      vec3.normalize(tmpVec3, tmpVec3);\n      normalArr.push.apply(normalArr, _toConsumableArray(tmpVec3.slice()));\n      uvs.push([normalizedY, 1 - normalizedZ]);\n      positionsArr.push(normalizedY, 1 - normalizedZ);\n    }\n\n    if (zRotationStep > 0) {\n      var verticesCount = positions.length;\n      var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1);\n\n      for (; firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n        indices.push([firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1]);\n        indicesArr.push(firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1);\n        indices.push([firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2]);\n        indicesArr.push(firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2);\n      }\n    }\n  }\n\n  return {\n    cells: indices,\n    positions: positions,\n    uvs: uvs,\n    positionsArr: positionsArr,\n    indicesArr: indicesArr,\n    normalArr: normalArr\n  };\n}","map":null,"metadata":{},"sourceType":"module"}