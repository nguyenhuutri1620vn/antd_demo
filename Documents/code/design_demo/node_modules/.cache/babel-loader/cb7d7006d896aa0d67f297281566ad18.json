{"ast":null,"code":"// @ts-nocheck\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\"; // @ts-ignore\n\nimport { World } from \"@antv/g-webgpu\";\nimport { proccessToFunc, buildTextureDataWithTwoEdgeAttr, arrayToTextureData } from \"../../util/gpu\";\nimport { getDegree } from \"../../util/math\";\nimport { gForceBundle, aveMovementBundle } from \"./gForceShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * graphin 中的 force 布局\n */\n\nexport class GForceGPULayout extends Base {\n  constructor(options) {\n    super();\n    /** 停止迭代的最大迭代数 */\n\n    this.maxIteration = 1000;\n    /** 弹簧引力系数 */\n\n    this.edgeStrength = 200;\n    /** 斥力系数 */\n\n    this.nodeStrength = 1000;\n    /** 库伦系数 */\n\n    this.coulombDisScale = 0.005;\n    /** 阻尼系数 */\n\n    this.damping = 0.9;\n    /** 最大速度 */\n\n    this.maxSpeed = 1000;\n    /** 一次迭代的平均移动距离小于该值时停止迭代 */\n\n    this.minMovement = 0.5;\n    /** 迭代中衰减 */\n\n    this.interval = 0.02;\n    /** 斥力的一个系数 */\n\n    this.factor = 1;\n    /** 理想边长 */\n\n    this.linkDistance = 1;\n    /** 重力大小 */\n\n    this.gravity = 10;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    this.workerEnabled = false;\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.nodeMap = {};\n    this.nodeIdxMap = {};\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      maxIteration: 2000,\n      gravity: 10,\n      clustering: false,\n      clusterGravity: 10\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      const center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      const nodeMap = {};\n      const nodeIdxMap = {};\n      nodes.forEach((node, i) => {\n        if (!isNumber(node.x)) node.x = Math.random() * self.width;\n        if (!isNumber(node.y)) node.y = Math.random() * self.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap;\n      self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n      self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // layout\n\n      yield self.run();\n    });\n  }\n\n  executeWithWorker(canvas, ctx) {\n    const self = this;\n    const nodes = self.nodes;\n    const center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    const nodeMap = {};\n    const nodeIdxMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * self.width;\n      if (!isNumber(node.y)) node.y = Math.random() * self.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n    self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // layout\n\n    self.run(canvas, ctx);\n  }\n\n  run(canvas, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n      const edges = self.edges;\n      const maxIteration = self.maxIteration;\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      const numParticles = nodes.length;\n      self.linkDistance = proccessToFunc(self.linkDistance);\n      self.edgeStrength = proccessToFunc(self.edgeStrength);\n      const {\n        maxEdgePerVetex,\n        array: nodesEdgesArray\n      } = buildTextureDataWithTwoEdgeAttr(nodes, edges, self.linkDistance, self.edgeStrength); // init degree for mass\n\n      self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n      const masses = [];\n      const nodeStrengths = [];\n      const centerXs = [];\n      const centerYs = [];\n      const centerGravities = [];\n      const fxs = [];\n      const fys = [];\n\n      if (!self.getMass) {\n        self.getMass = d => {\n          return self.degrees[self.nodeIdxMap[d.id]] || 1;\n        };\n      }\n\n      const gravity = self.gravity;\n      const center = self.center;\n      nodes.forEach((node, i) => {\n        masses.push(self.getMass(node));\n        nodeStrengths.push(self.nodeStrength(node));\n        if (!self.degrees[i]) self.degrees[i] = 0;\n        let nodeGravity = [center[0], center[1], gravity];\n\n        if (self.getCenter) {\n          const customCenter = self.getCenter(node, self.degrees[i]);\n\n          if (customCenter && isNumber(customCenter[0]) && isNumber(customCenter[1]) && isNumber(customCenter[2])) {\n            nodeGravity = customCenter;\n          }\n        }\n\n        centerXs.push(nodeGravity[0]);\n        centerYs.push(nodeGravity[1]);\n        centerGravities.push(nodeGravity[2]);\n\n        if (isNumber(node.fx) && isNumber(node.fy)) {\n          fxs.push(node.fx || 0.001);\n          fys.push(node.fy || 0.001);\n        } else {\n          fxs.push(0);\n          fys.push(0);\n        }\n      }); // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0\n\n      const nodeAttributeArray1 = arrayToTextureData([masses, self.degrees, nodeStrengths, fxs]); // nodeAttributeArray2 中是：centerX, centerY, gravity, 0,\n\n      const nodeAttributeArray2 = arrayToTextureData([centerXs, centerYs, centerGravities, fys]);\n      const workerEnabled = self.workerEnabled;\n      let world;\n\n      if (workerEnabled) {\n        world = World.create({\n          canvas,\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } else {\n        world = World.create({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行\n      // const compiler = new Compiler();\n      // const gForceBundle = compiler.compileBundle(gForceCode);\n      // console.log(gForceBundle.toString());\n\n\n      const onLayoutEnd = self.onLayoutEnd;\n      const initPreviousData = [];\n      nodesEdgesArray.forEach(value => {\n        initPreviousData.push(value);\n      });\n\n      for (let i = 0; i < 4; i++) {\n        initPreviousData.push(0);\n      }\n\n      const kernelGForce = world.createKernel(gForceBundle).setDispatch([numParticles, 1, 1]).setBinding({\n        u_Data: nodesEdgesArray,\n        u_damping: self.damping,\n        u_maxSpeed: self.maxSpeed,\n        u_minMovement: self.minMovement,\n        u_coulombDisScale: self.coulombDisScale,\n        u_factor: self.factor,\n        u_NodeAttributeArray1: nodeAttributeArray1,\n        u_NodeAttributeArray2: nodeAttributeArray2,\n        MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n        VERTEX_COUNT: numParticles,\n        u_AveMovement: initPreviousData,\n        u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n\n      }); // const aveMovementBundle = compiler.compileBundle(aveMovementCode);\n      // console.log(aveMovementBundle.toString());\n\n      const kernelAveMovement = world.createKernel(aveMovementBundle).setDispatch([1, 1, 1]).setBinding({\n        u_Data: nodesEdgesArray,\n        VERTEX_COUNT: numParticles,\n        u_AveMovement: [0, 0, 0, 0]\n      }); // 执行迭代\n      // let midRes = nodesEdgesArray;\n\n      const execute = () => __awaiter(this, void 0, void 0, function* () {\n        for (let i = 0; i < maxIteration; i++) {\n          // TODO: 似乎都来自 kernelGForce 是一个引用\n          // 当前坐标作为下一次迭代的 PreviousData\n          // if (i > 0) {\n          //   kernelAveMovement.setBinding({\n          //     u_PreviousData: kernelGForce\n          //   });\n          // }\n          // eslint-disable-next-line no-await-in-loop\n          yield kernelGForce.execute(); // midRes = await kernelGForce.getOutput();\n          // 每次迭代完成后\n          // 计算平均位移，用于提前终止迭代\n\n          kernelAveMovement.setBinding({\n            u_Data: kernelGForce\n          }); // eslint-disable-next-line no-await-in-loop\n\n          yield kernelAveMovement.execute(); // 更新衰减函数\n\n          const stepInterval = Math.max(0.02, self.interval - i * 0.002);\n          kernelGForce.setBinding({\n            u_interval: stepInterval,\n            u_AveMovement: kernelAveMovement\n          });\n        }\n\n        const finalParticleData = yield kernelGForce.getOutput(); // 所有迭代完成后\n\n        if (canvas) {\n          // 传递数据给主线程\n          ctx.postMessage({\n            type: LAYOUT_MESSAGE.GPUEND,\n            vertexEdgeData: finalParticleData // edgeIndexBufferData,\n\n          });\n        } else {\n          nodes.forEach((node, i) => {\n            const x = finalParticleData[4 * i];\n            const y = finalParticleData[4 * i + 1];\n            node.x = x;\n            node.y = y;\n          });\n        }\n\n        if (onLayoutEnd) onLayoutEnd();\n      });\n\n      yield execute();\n    });\n  }\n\n  getType() {\n    return \"gForce-gpu\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}