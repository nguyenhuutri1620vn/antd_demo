{"ast":null,"code":"import { ArrayExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport * as Util from './util';\n/**\n * Returns a route with orthogonal line segments.\n */\n\nexport const orth = function (vertices, options, edgeView) {\n  let sourceBBox = Util.getSourceBBox(edgeView, options);\n  let targetBBox = Util.getTargetBBox(edgeView, options);\n  const sourceAnchor = Util.getSourceAnchor(edgeView, options);\n  const targetAnchor = Util.getTargetAnchor(edgeView, options); // If anchor lies outside of bbox, the bbox expands to include it\n\n  sourceBBox = sourceBBox.union(Util.getPointBBox(sourceAnchor));\n  targetBBox = targetBBox.union(Util.getPointBBox(targetAnchor));\n  const points = vertices.map(p => Point.create(p));\n  points.unshift(sourceAnchor);\n  points.push(targetAnchor); // bearing of previous route segment\n\n  let bearing = null;\n  const result = [];\n\n  for (let i = 0, len = points.length - 1; i < len; i += 1) {\n    let route = null;\n    const from = points[i];\n    const to = points[i + 1];\n    const isOrthogonal = Private.getBearing(from, to) != null;\n\n    if (i === 0) {\n      // source\n      if (i + 1 === len) {\n        // source -> target\n        // Expand one of the nodes by 1px to detect situations when the two\n        // nodes are positioned next to each other with no gap in between.\n        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {\n          route = Private.insideNode(from, to, sourceBBox, targetBBox);\n        } else if (!isOrthogonal) {\n          route = Private.nodeToNode(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // source -> vertex\n        if (sourceBBox.containsPoint(to)) {\n          route = Private.insideNode(from, to, sourceBBox, Util.getPointBBox(to).moveAndExpand(Util.getPaddingBox(options)));\n        } else if (!isOrthogonal) {\n          route = Private.nodeToVertex(from, to, sourceBBox);\n        }\n      }\n    } else if (i + 1 === len) {\n      // vertex -> target\n      // prevent overlaps with previous line segment\n      const isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;\n\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = Private.insideNode(from, to, Util.getPointBBox(from).moveAndExpand(Util.getPaddingBox(options)), targetBBox, bearing);\n      } else if (!isOrthogonal) {\n        route = Private.vertexToNode(from, to, targetBBox, bearing);\n      }\n    } else if (!isOrthogonal) {\n      // vertex -> vertex\n      route = Private.vertexToVertex(from, to, bearing);\n    } // set bearing for next iteration\n\n\n    if (route) {\n      result.push(...route.points);\n      bearing = route.direction;\n    } else {\n      // orthogonal route and not looped\n      bearing = Private.getBearing(from, to);\n    } // push `to` point to identified orthogonal vertices array\n\n\n    if (i + 1 < len) {\n      result.push(to);\n    }\n  }\n\n  return result;\n};\nvar Private;\n\n(function (Private) {\n  /**\n   * Bearing to opposite bearing map\n   */\n  const opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n  };\n  /**\n   * Bearing to radians map\n   */\n\n  const radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n  };\n  /**\n   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular\n   * and p is not contained in the given box\n   */\n\n  function freeJoin(p1, p2, bbox) {\n    let p = new Point(p1.x, p2.y);\n\n    if (bbox.containsPoint(p)) {\n      p = new Point(p2.x, p1.y);\n    } // kept for reference\n    // if (bbox.containsPoint(p)) {\n    //   return null\n    // }\n\n\n    return p;\n  }\n  /**\n   * Returns either width or height of a bbox based on the given bearing.\n   */\n\n\n  function getBBoxSize(bbox, bearing) {\n    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n  }\n\n  Private.getBBoxSize = getBBoxSize;\n\n  function getBearing(from, to) {\n    if (from.x === to.x) {\n      return from.y > to.y ? 'N' : 'S';\n    }\n\n    if (from.y === to.y) {\n      return from.x > to.x ? 'W' : 'E';\n    }\n\n    return null;\n  }\n\n  Private.getBearing = getBearing;\n\n  function vertexToVertex(from, to, bearing) {\n    const p1 = new Point(from.x, to.y);\n    const p2 = new Point(to.x, from.y);\n    const d1 = getBearing(from, p1);\n    const d2 = getBearing(from, p2);\n    const opposite = bearing ? opposites[bearing] : null;\n    const p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n\n  Private.vertexToVertex = vertexToVertex;\n\n  function nodeToVertex(from, to, fromBBox) {\n    const p = freeJoin(from, to, fromBBox);\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n\n  Private.nodeToVertex = nodeToVertex;\n\n  function vertexToNode(from, to, toBBox, bearing) {\n    const points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n    const freePoints = points.filter(p => !toBBox.containsPoint(p));\n    const freeBearingPoints = freePoints.filter(p => getBearing(p, from) !== bearing);\n    let p;\n\n    if (freeBearingPoints.length > 0) {\n      // Try to pick a point which bears the same direction as the previous segment.\n      p = freeBearingPoints.filter(p => getBearing(from, p) === bearing).pop();\n      p = p || freeBearingPoints[0];\n      return {\n        points: [p],\n        direction: getBearing(p, to)\n      };\n    }\n\n    {\n      // Here we found only points which are either contained in the element or they would create\n      // a link segment going in opposite direction from the previous one.\n      // We take the point inside element and move it outside the element in the direction the\n      // route is going. Now we can join this point with the current end (using freeJoin).\n      p = ArrayExt.difference(points, freePoints)[0];\n      const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n      const p1 = freeJoin(p2, from, toBBox);\n      return {\n        points: [p1, p2],\n        direction: getBearing(p2, to)\n      };\n    }\n  }\n\n  Private.vertexToNode = vertexToNode;\n\n  function nodeToNode(from, to, fromBBox, toBBox) {\n    let route = nodeToVertex(to, from, toBBox);\n    const p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n      route = nodeToVertex(from, to, fromBBox);\n      const p2 = route.points[0];\n\n      if (toBBox.containsPoint(p2)) {\n        const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n        const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n        const mid = new Line(fromBorder, toBorder).getCenter();\n        const startRoute = nodeToVertex(from, mid, fromBBox);\n        const endRoute = vertexToVertex(mid, to, startRoute.direction);\n        route.points = [startRoute.points[0], endRoute.points[0]];\n        route.direction = endRoute.direction;\n      }\n    }\n\n    return route;\n  }\n\n  Private.nodeToNode = nodeToNode; // Finds route for situations where one node is inside the other.\n  // Typically the route is directed outside the outer node first and\n  // then back towards the inner node.\n\n  function insideNode(from, to, fromBBox, toBBox, bearing) {\n    const boundary = fromBBox.union(toBBox).inflate(1); // start from the point which is closer to the boundary\n\n    const center = boundary.getCenter();\n    const reversed = center.distance(to) > center.distance(from);\n    const start = reversed ? to : from;\n    const end = reversed ? from : to;\n    let p1;\n    let p2;\n    let p3;\n\n    if (bearing) {\n      // Points on circle with radius equals 'W + H` are always outside the rectangle\n      // with width W and height H if the center of that circle is the center of that rectangle.\n      p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n      p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);\n    } else {\n      p1 = boundary.getNearestPointToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n    let points;\n\n    if (p1.round().equals(p2.round())) {\n      p2 = Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);\n      p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();\n      p3 = freeJoin(p1, p2, boundary);\n      points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n    } else {\n      points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n    return {\n      points,\n      direction\n    };\n  }\n\n  Private.insideNode = insideNode;\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}