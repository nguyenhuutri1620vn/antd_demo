{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _class2, _descriptor;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { $window, isMini } from '@antv/l7-utils';\nimport EventEmitter from 'eventemitter3';\nimport { inject, injectable } from 'inversify';\nimport Hammer from 'l7hammerjs';\nimport 'reflect-metadata';\nimport { TYPES } from '../../types';\nimport { InteractionEvent } from './IInteractionService';\nvar DragEventMap = {\n  panstart: 'dragstart',\n  panmove: 'dragging',\n  panend: 'dragend',\n  pancancel: 'dragcancel'\n};\nvar InteractionService = (_dec = injectable(), _dec2 = inject(TYPES.IMapService), _dec(_class = (_class2 = function (_EventEmitter) {\n  _inherits(InteractionService, _EventEmitter);\n\n  var _super = _createSuper(InteractionService);\n\n  function InteractionService() {\n    var _this;\n\n    _classCallCheck(this, InteractionService);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"indragging\", false);\n\n    _initializerDefineProperty(_assertThisInitialized(_this), \"mapService\", _descriptor, _assertThisInitialized(_this));\n\n    _defineProperty(_assertThisInitialized(_this), \"hammertime\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"lastClickTime\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"lastClickXY\", [-1, -1]);\n\n    _defineProperty(_assertThisInitialized(_this), \"clickTimer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"$containter\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"onDrag\", function (target) {\n      var interactionTarget = _this.interactionEvent(target);\n\n      interactionTarget.type = DragEventMap[interactionTarget.type];\n      interactionTarget.type === 'dragging' ? _this.indragging = true : _this.indragging = false;\n\n      _this.emit(InteractionEvent.Drag, interactionTarget);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onHammer\", function (target) {\n      target.srcEvent.stopPropagation();\n\n      var interactionTarget = _this.interactionEvent(target);\n\n      _this.emit(InteractionEvent.Hover, interactionTarget);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onTouch\", function (target) {\n      var touch = target.touches[0];\n\n      _this.onHover({\n        x: touch.pageX,\n        y: touch.pageY,\n        type: 'touch'\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onHover\", function (event) {\n      var clientX = event.clientX,\n          clientY = event.clientY;\n      var x = clientX;\n      var y = clientY;\n      var type = event.type;\n\n      var $containter = _this.mapService.getMapContainer();\n\n      if ($containter) {\n        if (isMini) {\n          x = x - $containter.left - 0;\n          y = y - $containter.top - 0;\n        } else {\n          var _$containter$getBound = $containter.getBoundingClientRect(),\n              top = _$containter$getBound.top,\n              left = _$containter$getBound.left;\n\n          x = x - left - $containter.clientLeft;\n          y = y - top - $containter.clientTop;\n        }\n      }\n\n      var lngLat = _this.mapService.containerToLngLat([x, y]);\n\n      if (type === 'click') {\n        if (!isMini) {\n          if ('ontouchstart' in document.documentElement === true) {\n            return;\n          }\n        }\n\n        _this.isDoubleTap(x, y, lngLat);\n\n        return;\n      }\n\n      if (type === 'touch') {\n        _this.isDoubleTap(x, y, lngLat);\n\n        return;\n      }\n\n      if (type !== 'click' && type !== 'dblclick') {\n        _this.emit(InteractionEvent.Hover, {\n          x: x,\n          y: y,\n          lngLat: lngLat,\n          type: type,\n          target: event\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(InteractionService, [{\n    key: \"init\",\n    value: function init() {\n      this.addEventListenerOnMap();\n      this.$containter = this.mapService.getMapContainer();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.hammertime) {\n        this.hammertime.destroy();\n      }\n\n      this.removeEventListenerOnMap();\n      this.off(InteractionEvent.Hover);\n    }\n  }, {\n    key: \"triggerHover\",\n    value: function triggerHover(_ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      this.emit(InteractionEvent.Hover, {\n        x: x,\n        y: y\n      });\n    }\n  }, {\n    key: \"triggerSelect\",\n    value: function triggerSelect(id) {\n      this.emit(InteractionEvent.Select, {\n        featureId: id\n      });\n    }\n  }, {\n    key: \"triggerActive\",\n    value: function triggerActive(id) {\n      this.emit(InteractionEvent.Active, {\n        featureId: id\n      });\n    }\n  }, {\n    key: \"handleMiniEvent\",\n    value: function handleMiniEvent(e) {\n      this.onHover({\n        clientX: e.touches[0].pageX,\n        clientY: e.touches[0].pageY,\n        type: 'touch'\n      });\n    }\n  }, {\n    key: \"addEventListenerOnMap\",\n    value: function addEventListenerOnMap() {\n      var $containter = this.mapService.getMapContainer();\n\n      if ($containter) {\n        if (isMini) {\n          $window.document.addEventListener('touchstart', this.handleMiniEvent.bind(this));\n        } else {\n          var hammertime = new Hammer.Manager($containter);\n          hammertime.add(new Hammer.Tap({\n            event: 'dblclick',\n            taps: 2\n          }));\n          hammertime.add(new Hammer.Tap({\n            event: 'click'\n          }));\n          hammertime.add(new Hammer.Pan({\n            threshold: 0,\n            pointers: 0\n          }));\n          hammertime.add(new Hammer.Press({}));\n          hammertime.on('dblclick click', this.onHammer);\n          hammertime.on('panstart panmove panend pancancel', this.onDrag);\n          $containter.addEventListener('mousemove', this.onHover);\n          $containter.addEventListener('mousedown', this.onHover, true);\n          $containter.addEventListener('mouseup', this.onHover);\n          $containter.addEventListener('contextmenu', this.onHover);\n          this.hammertime = hammertime;\n        }\n      }\n    }\n  }, {\n    key: \"removeEventListenerOnMap\",\n    value: function removeEventListenerOnMap() {\n      if (isMini) {\n        $window.document.removeEventListener('touchstart', this.handleMiniEvent.bind(this));\n      } else {\n        var $containter = this.mapService.getMapContainer();\n\n        if ($containter) {\n          $containter.removeEventListener('mousemove', this.onHover);\n          this.hammertime.off('panstart panmove panend pancancel', this.onDrag);\n          $containter.removeEventListener('mousedown', this.onHover);\n          $containter.removeEventListener('mouseup', this.onHover);\n          $containter.removeEventListener('contextmenu', this.onHover);\n        }\n      }\n    }\n  }, {\n    key: \"interactionEvent\",\n    value: function interactionEvent(target) {\n      var type = target.type,\n          pointerType = target.pointerType;\n      var clientX;\n      var clientY;\n\n      if (pointerType === 'touch') {\n        clientY = Math.floor(target.pointers[0].clientY);\n        clientX = Math.floor(target.pointers[0].clientX);\n      } else {\n        clientY = Math.floor(target.srcEvent.y);\n        clientX = Math.floor(target.srcEvent.x);\n      }\n\n      var $containter = this.mapService.getMapContainer();\n\n      if ($containter) {\n        var _$containter$getBound2 = $containter.getBoundingClientRect(),\n            top = _$containter$getBound2.top,\n            left = _$containter$getBound2.left;\n\n        clientX -= left;\n        clientY -= top;\n      }\n\n      var lngLat = this.mapService.containerToLngLat([clientX, clientY]);\n      return {\n        x: clientX,\n        y: clientY,\n        lngLat: lngLat,\n        type: type,\n        target: target.srcEvent\n      };\n    }\n  }, {\n    key: \"isDoubleTap\",\n    value: function isDoubleTap(x, y, lngLat) {\n      var _this2 = this;\n\n      var nowTime = new Date().getTime();\n      var type = 'click';\n\n      if (nowTime - this.lastClickTime < 400 && Math.abs(this.lastClickXY[0] - x) < 10 && Math.abs(this.lastClickXY[1] - y) < 10) {\n        this.lastClickTime = 0;\n        this.lastClickXY = [-1, -1];\n\n        if (this.clickTimer) {\n          clearTimeout(this.clickTimer);\n        }\n\n        type = 'dblclick';\n        this.emit(InteractionEvent.Hover, {\n          x: x,\n          y: y,\n          lngLat: lngLat,\n          type: type\n        });\n      } else {\n        this.lastClickTime = nowTime;\n        this.lastClickXY = [x, y];\n        this.clickTimer = setTimeout(function () {\n          type = 'click';\n\n          _this2.emit(InteractionEvent.Hover, {\n            x: x,\n            y: y,\n            lngLat: lngLat,\n            type: type\n          });\n        }, 400);\n      }\n    }\n  }]);\n\n  return InteractionService;\n}(EventEmitter), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"mapService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { InteractionService as default };","map":null,"metadata":{},"sourceType":"module"}