{"ast":null,"code":"import { ObjectExt, Dom } from '../../util';\nimport { Path, Rectangle, Ellipse } from '../../geometry';\nimport { offset, getStrokeWidth, findShapeNode } from './util';\n/**\n * Places the connection point at the intersection between the\n * edge path end segment and the actual shape of the target magnet.\n */\n\nexport const boundary = function (line, view, magnet, options) {\n  let node;\n  let intersection;\n  const anchor = line.end;\n  const selector = options.selector;\n\n  if (typeof selector === 'string') {\n    node = view.findOne(selector);\n  } else if (Array.isArray(selector)) {\n    node = ObjectExt.getByPath(magnet, selector);\n  } else {\n    node = findShapeNode(magnet);\n  }\n\n  if (!Dom.isSVGGraphicsElement(node)) {\n    if (node === magnet || !Dom.isSVGGraphicsElement(magnet)) {\n      return anchor;\n    }\n\n    node = magnet;\n  }\n\n  const localShape = view.getShapeOfElement(node);\n  const magnetMatrix = view.getMatrixOfElement(node);\n  const translateMatrix = view.getRootTranslatedMatrix();\n  const rotateMatrix = view.getRootRotatedMatrix();\n  const targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n  const localMatrix = targetMatrix.inverse();\n  const localLine = Dom.transformLine(line, localMatrix);\n  const localRef = localLine.start.clone();\n  const data = view.getDataOfElement(node);\n\n  if (options.insideout === false) {\n    if (data.shapeBBox == null) {\n      data.shapeBBox = localShape.bbox();\n    }\n\n    const localBBox = data.shapeBBox;\n\n    if (localBBox != null && localBBox.containsPoint(localRef)) {\n      return anchor;\n    }\n  }\n\n  if (options.extrapolate === true) {\n    localLine.setLength(1e6);\n  } // Caching segment subdivisions for paths\n\n\n  let pathOptions;\n\n  if (Path.isPath(localShape)) {\n    const precision = options.precision || 2;\n\n    if (data.segmentSubdivisions == null) {\n      data.segmentSubdivisions = localShape.getSegmentSubdivisions({\n        precision\n      });\n    }\n\n    pathOptions = {\n      precision,\n      segmentSubdivisions: data.segmentSubdivisions\n    };\n    intersection = localLine.intersect(localShape, pathOptions);\n  } else {\n    intersection = localLine.intersect(localShape);\n  }\n\n  if (intersection) {\n    if (Array.isArray(intersection)) {\n      intersection = localRef.closest(intersection);\n    }\n  } else if (options.sticky === true) {\n    // No intersection, find the closest point instead\n    if (Rectangle.isRectangle(localShape)) {\n      intersection = localShape.getNearestPointToPoint(localRef);\n    } else if (Ellipse.isEllipse(localShape)) {\n      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOptions);\n    }\n  }\n\n  const cp = intersection ? Dom.transformPoint(intersection, targetMatrix) : anchor;\n  let cpOffset = options.offset || 0;\n\n  if (options.stroked !== false) {\n    if (typeof cpOffset === 'object') {\n      cpOffset = Object.assign({}, cpOffset);\n\n      if (cpOffset.x == null) {\n        cpOffset.x = 0;\n      }\n\n      cpOffset.x += getStrokeWidth(node) / 2;\n    } else {\n      cpOffset += getStrokeWidth(node) / 2;\n    }\n  }\n\n  return offset(cp, line.start, cpOffset);\n};","map":null,"metadata":{},"sourceType":"module"}