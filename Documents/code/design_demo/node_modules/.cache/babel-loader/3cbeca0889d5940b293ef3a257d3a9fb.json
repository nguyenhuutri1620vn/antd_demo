{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { modifyCSS, createDom } from '@antv/dom-util';\nimport Base from '../base';\nimport { isArray, isNumber, uniqueId } from '@antv/util';\nimport { Util } from '@antv/g6-core';\nimport { Canvas } from '@antv/g-canvas';\nvar ALLOW_EVENTS = ['click', 'mouseenter'];\n\nvar Legend =\n/** @class */\nfunction (_super) {\n  __extends(Legend, _super);\n\n  function Legend(config) {\n    return _super.call(this, config) || this;\n  }\n\n  Legend.prototype.getDefaultCfgs = function () {\n    return {\n      data: {},\n      position: 'top',\n      padding: 8,\n      margin: 8,\n      offsetX: 0,\n      offsetY: 0,\n      layout: 'horizontal',\n      flipPage: false,\n      containerStyle: {},\n      align: undefined,\n      horiSep: 8,\n      vertiSep: 8,\n      filter: {\n        enable: false,\n        trigger: 'click'\n      }\n    };\n  };\n\n  Legend.prototype.init = function () {\n    this.formatArray('padding');\n    this.formatArray('margin');\n    var filter = this.get('filter') || {};\n    var multiple = filter.multiple;\n    if (multiple && filter.trigger === 'mouseenter') this.set('multiple', false);\n    var align = this.get('align');\n\n    if (!align) {\n      var positions = this.get('position').split('-');\n      if (positions.includes('left')) align = 'left';\n      if (positions.includes('right')) align = 'right';else align = 'center';\n      this.set('align', align);\n    }\n\n    var graph = this.get('graph');\n    var graphContainer = graph.get('container');\n    var container = createDom(\"<div class='g6-legend-container' style=\\\"position: absolute;\\\"></div>\");\n    graphContainer.appendChild(container);\n    this.set('container', container);\n    var size = this.render();\n    modifyCSS(container, this.getContainerPos(size));\n    this.bindEvents();\n  };\n\n  Legend.prototype.getContainerPos = function (size) {\n    if (size === void 0) {\n      size = [0, 0];\n    }\n\n    var self = this;\n    var graph = self.get('graph');\n    var offsetX = this.get('offsetX');\n    var offsetY = this.get('offsetY');\n    var margin = this.get('margin');\n    var positions = this.get('position').split('-');\n    var posIdxMap = {\n      'top': 0,\n      'right': 1,\n      'bottom': 2,\n      'left': 3\n    };\n    var x = 0,\n        y = 0;\n    var containerCSS = {\n      left: (graph.getWidth() - size[0]) / 2 + x,\n      top: (graph.getHeight() - size[1]) / 2 + y\n    };\n    positions.forEach(function (pos) {\n      var marginValue = margin[posIdxMap[pos]];\n      var key = pos;\n\n      switch (pos) {\n        case 'top':\n          marginValue += y;\n          break;\n\n        case 'left':\n          marginValue += x;\n          break;\n\n        case 'bottom':\n          marginValue = graph.getHeight() - size[1] - marginValue + y;\n          key = 'top';\n          break;\n\n        default:\n          marginValue = graph.getWidth() - size[0] - marginValue + x;\n          key = 'left';\n          break;\n      }\n\n      containerCSS[key] = marginValue;\n    });\n    containerCSS.top += offsetY + graph.getContainer().offsetTop;\n    containerCSS.left += offsetX + graph.getContainer().offsetLeft;\n    Object.keys(containerCSS).forEach(function (key) {\n      containerCSS[key] = \"\".concat(containerCSS[key], \"px\");\n    });\n    return containerCSS;\n  }; // class-methods-use-this\n\n\n  Legend.prototype.bindEvents = function () {\n    var self = this;\n    var filter = self.get('filter');\n    if (!filter || !filter.enable) return;\n    var trigger = filter.trigger || 'click';\n\n    if (!ALLOW_EVENTS.includes(trigger)) {\n      console.warn('Trigger for legend filterling must be \\'click\\' or \\'mouseenter\\', \\'click\\' will take effect by default.');\n      trigger = 'click';\n    }\n\n    var lc = self.get('legendCanvas');\n\n    if (trigger === 'mouseenter') {\n      lc.on('node-container:mouseenter', function (e) {\n        return self.filterData(e);\n      });\n      lc.on('node-container:mouseleave', function (e) {\n        self.clearFilter();\n        self.clearActiveLegend();\n      });\n    } else {\n      lc.on('node-container:click', function (e) {\n        return self.filterData(e);\n      });\n      lc.on('click', function (e) {\n        if (e.target && e.target.isCanvas && e.target.isCanvas()) {\n          self.clearFilter();\n          self.clearActiveLegend();\n        }\n      });\n    }\n  };\n  /**\n   * 更新 legend 数据，开放给用户控制\n   * @param param\n   */\n\n\n  Legend.prototype.changeData = function (data) {\n    this.set('data', data);\n    var size = this.render();\n    modifyCSS(this.get('container'), this.getContainerPos(size));\n  };\n\n  Legend.prototype.activateLegend = function (shape) {\n    var filter = this.get('filter');\n    var multiple = filter === null || filter === void 0 ? void 0 : filter.multiple;\n    if (!multiple) this.clearActiveLegend();\n    var shapeGroup = shape.get('parent'); // 若被高亮元素已经处于 active 状态，则取消它的 active 状态\n    // 并根据目前是否有其他 active 状态的元素决定是否要设置为 inactive 状态\n\n    if (shapeGroup.get('active')) {\n      shapeGroup.set('active', false);\n      if (this.findLegendItemsByState('active').length) shapeGroup.set('inactive', true);\n    } else {\n      shapeGroup.set('inactive', false);\n      shapeGroup.set('active', true);\n    } // 当目前有元素为 active 状态时，将非 active 的元素设置为 inactive\n\n\n    if (this.findLegendItemsByState('active').length) {\n      this.findLegendItemsByState('active', 'all', false).forEach(function (subGroup) {\n        subGroup.set('inactive', true);\n      });\n    } else {\n      this.clearActiveLegend();\n    } // 设置样式\n\n\n    var stateStyles = (filter === null || filter === void 0 ? void 0 : filter.lengedStateStyles) || {};\n    var legendInactive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.inactive) || {\n      opacity: 0.5,\n      'text-shape': {\n        opacity: 0.5\n      }\n    };\n    var legendTextInactive = legendInactive['text-shape'] || {};\n    this.findLegendItemsByState('inactive').forEach(function (subGroup) {\n      var _a = subGroup.get('children'),\n          keyShape = _a[0],\n          text = _a[1];\n\n      keyShape.attr(__assign(__assign({}, keyShape.get('oriAttrs')), legendInactive));\n      text.attr(__assign(__assign({}, text.get('oriAttrs')), legendTextInactive));\n    });\n    var legendActive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.active) || {\n      stroke: '#000',\n      lineWidth: 2,\n      'text-shape': {\n        fontWeight: 'bold'\n      }\n    };\n    var legendTextActive = legendActive['text-shape'] || {};\n    this.findLegendItemsByState('active').forEach(function (subGroup) {\n      var _a = subGroup.get('children'),\n          keyShape = _a[0],\n          text = _a[1];\n\n      keyShape.attr(__assign(__assign({}, keyShape.get('oriAttrs')), legendActive));\n      text.attr(__assign(__assign({}, text.get('oriAttrs')), legendTextActive));\n    });\n  };\n\n  Legend.prototype.findLegendItemsByState = function (stateName, type, value) {\n    if (type === void 0) {\n      type = 'all';\n    }\n\n    if (value === void 0) {\n      value = true;\n    }\n\n    var group = this.get('legendCanvas').find(function (e) {\n      return e.get('name') === 'root';\n    });\n    var nodeGroup = group.find(function (e) {\n      return e.get('name') === 'node-group';\n    });\n    var edgeGroup = group.find(function (e) {\n      return e.get('name') === 'edge-group';\n    });\n    if (type === 'node') return nodeGroup.get('children').filter(function (g) {\n      return !!g.get(stateName) === value;\n    });\n    if (type === 'edge') return edgeGroup.get('children').filter(function (g) {\n      return !!g.get(stateName) === value;\n    });\n    return nodeGroup.get('children').filter(function (g) {\n      return !!g.get(stateName) === value;\n    }).concat(edgeGroup.get('children').filter(function (g) {\n      return !!g.get(stateName) === value;\n    }));\n  };\n\n  Legend.prototype.clearActiveLegend = function () {\n    var lg = this.get('legendCanvas');\n    var group = lg.find(function (e) {\n      return e.get('name') === 'root';\n    });\n    var groups = [group.find(function (e) {\n      return e.get('name') === 'node-group';\n    }), group.find(function (e) {\n      return e.get('name') === 'edge-group';\n    })];\n    groups.forEach(function (itemGroup) {\n      itemGroup.get('children').forEach(function (subGroup) {\n        subGroup.set('active', false);\n        subGroup.set('inactive', false);\n\n        var _a = subGroup.get('children'),\n            keyShape = _a[0],\n            text = _a[1];\n\n        keyShape.attr(keyShape.get('oriAttrs'));\n        text.attr(text.get('oriAttrs'));\n      });\n    });\n  };\n  /**\n   * 高亮和置灰图例，并过滤主图元素\n   * @param param\n   */\n\n\n  Legend.prototype.filterData = function (e) {\n    var filter = this.get('filter');\n    var filterFunctions = filter === null || filter === void 0 ? void 0 : filter.filterFunctions;\n    if (!filter || !filterFunctions) return;\n    var lc = this.get('legendCanvas');\n    var graph = this.get('graph');\n    var activeState = filter.graphActiveState || 'active';\n    var inactiveState = filter.graphInactiveState || 'inactive';\n    var multiple = filter.multiple;\n    this.clearFilter();\n    if (!multiple) this.clearActiveLegend(); // 设置 legend 的高亮状态\n\n    this.activateLegend(e.target);\n    var group = lc.find(function (e) {\n      return e.get('name') === 'root';\n    });\n    var nodeGroup = group.find(function (e) {\n      return e.get('name') === 'node-group';\n    });\n    var edgeGroup = group.find(function (e) {\n      return e.get('name') === 'edge-group';\n    });\n    var activeNodeLegend = nodeGroup.get('children').filter(function (e) {\n      return e.get('active');\n    });\n    var activeEdgeLegend = edgeGroup.get('children').filter(function (e) {\n      return e.get('active');\n    });\n    var activeCount = 0;\n    var typeFuncs = ['getNodes', 'getEdges'];\n    typeFuncs.forEach(function (typeFunc) {\n      graph[typeFunc]().forEach(function (graphItem) {\n        var active = false;\n        var activeLegend = typeFunc === 'getNodes' ? activeNodeLegend : activeEdgeLegend;\n        activeLegend.forEach(function (itemGroup) {\n          var func = filterFunctions[itemGroup.get('id')];\n          active = active || func(graphItem.getModel());\n        });\n\n        if (active) {\n          graph.setItemState(graphItem, inactiveState, false);\n          graph.setItemState(graphItem, activeState, true);\n          activeCount++;\n        } else {\n          graph.setItemState(graphItem, activeState, false);\n          graph.setItemState(graphItem, inactiveState, true);\n        }\n      });\n    });\n    if (!activeCount) typeFuncs.forEach(function (typeFunc) {\n      graph[typeFunc]().forEach(function (graphItem) {\n        graph.clearItemStates(graphItem, [inactiveState]);\n      });\n    });\n  };\n  /**\n   * 清除主图相关状态\n   * @param param\n   */\n\n\n  Legend.prototype.clearFilter = function () {\n    // 清除 legend 的高亮状态\n    var graph = this.get('graph');\n    var filter = this.get('filter');\n    if (!filter) return;\n    var activeState = filter.graphActiveState || 'active';\n    var inactiveState = filter.graphInactiveState || 'inactive';\n    graph.getNodes().forEach(function (node) {\n      graph.clearItemStates(node, [activeState, inactiveState]);\n    });\n    graph.getEdges().forEach(function (edge) {\n      graph.clearItemStates(edge, [activeState, inactiveState]);\n    });\n  };\n  /**\n   * 渲染 legend 图\n   * @param param\n   */\n\n\n  Legend.prototype.render = function () {\n    var _this = this;\n\n    this.processData();\n    var lc = this.get('legendCanvas');\n\n    if (!lc) {\n      lc = new Canvas({\n        container: this.get('container'),\n        width: 200,\n        height: 200\n      });\n      var rootGroup = lc.addGroup({\n        name: 'root'\n      });\n      rootGroup.addGroup({\n        name: 'node-group'\n      });\n      rootGroup.addGroup({\n        name: 'edge-group'\n      }); // nodeStateStyles: {\n      //   legendActive,\n      //   legendInactive\n      // }\n\n      this.set('legendCanvas', lc);\n    }\n\n    var group = lc.find(function (e) {\n      return e.get('name') === 'root';\n    });\n    var nodeGroup = group.find(function (e) {\n      return e.get('name') === 'node-group';\n    });\n    var edgeGroup = group.find(function (e) {\n      return e.get('name') === 'edge-group';\n    });\n    var itemsData = this.get('itemsData');\n    var itemTypes = ['nodes', 'edges'];\n    var itemGroup = [nodeGroup, edgeGroup];\n    itemTypes.forEach(function (itemType, i) {\n      itemsData[itemType].forEach(function (data) {\n        var _a;\n\n        var subGroup = itemGroup[i].addGroup({\n          id: data.id,\n          name: 'node-container'\n        });\n        var attrs;\n        var shapeType = data.type;\n\n        var _b = _this.getShapeSize(data),\n            width = _b.width,\n            height = _b.height,\n            r = _b.r;\n\n        var style = _this.getStyle(itemType.substr(0, 4), data);\n\n        switch (data.type) {\n          case 'circle':\n            attrs = {\n              r: r,\n              x: 0,\n              y: 0\n            };\n            break;\n\n          case 'rect':\n            attrs = {\n              width: width,\n              height: height,\n              x: -width / 2,\n              y: -height / 2\n            };\n            break;\n\n          case 'ellipse':\n            attrs = {\n              r1: width,\n              r2: height,\n              x: 0,\n              y: 0\n            };\n            break;\n\n          case 'line':\n            attrs = {\n              x1: -width / 2,\n              y1: 0,\n              x2: width / 2,\n              y2: 0\n            };\n            shapeType = 'line';\n            break;\n\n          case 'quadratic':\n            attrs = {\n              path: [['M', -width / 2, 0], ['Q', 0, width / 2, width / 2, 0]]\n            };\n            shapeType = 'path';\n            break;\n\n          case 'cubic':\n            attrs = {\n              path: [['M', -width / 2, 0], ['C', -width / 6, width / 2, width / 6, -width / 2, width / 2, 0]]\n            };\n            shapeType = 'path';\n            break;\n\n          default:\n            attrs = {\n              r: r,\n              x: 0,\n              y: 0\n            };\n            break;\n        }\n\n        var keyShape = subGroup.addShape(shapeType, {\n          attrs: __assign(__assign({}, attrs), style),\n          name: \"\".concat(data.type, \"-node-keyShape\"),\n          oriAttrs: __assign({\n            opacity: 1\n          }, style)\n        });\n\n        if (data.label) {\n          var keyShapeBBox = keyShape.getBBox();\n          var labelStyle = ((_a = data.labelCfg) === null || _a === void 0 ? void 0 : _a.style) || {};\n\n          var attrs_1 = __assign({\n            textAlign: 'begin',\n            fontSize: 12,\n            textBaseline: 'middle',\n            fill: '#000',\n            opacity: 1,\n            fontWeight: 'normal'\n          }, labelStyle);\n\n          subGroup.addShape('text', {\n            attrs: __assign({\n              x: keyShapeBBox.maxX + 4,\n              y: 0,\n              text: data.label\n            }, attrs_1),\n            className: 'legend-label',\n            name: \"\".concat(data.type, \"-node-text\"),\n            oriAttrs: attrs_1\n          });\n        }\n      });\n    });\n    var padding = this.get('padding');\n    var titleShape;\n    var titleGroup = group.find(function (e) {\n      return e.get('name') === 'title-container';\n    });\n    var titleGroupBBox = {\n      height: 0,\n      maxY: 0,\n      width: 0\n    };\n\n    if (this.get('title')) {\n      if (!titleGroup) {\n        titleGroup = group.addGroup({\n          name: 'title-container'\n        });\n      }\n\n      var defaultTitleStyle = {\n        fontSize: 20,\n        fontFamily: 'Arial',\n        fontWeight: 300,\n        textBaseline: 'top',\n        textAlign: 'center',\n        fill: \"#000\",\n        x: 0,\n        y: padding[0]\n      };\n      var titleConfig = this.get('titleConfig') || {};\n      var style = Object.assign(defaultTitleStyle, titleConfig.style || {});\n      titleShape = titleGroup.addShape('text', {\n        attrs: __assign({\n          text: this.get('title')\n        }, style)\n      });\n      titleGroupBBox = titleGroup.getCanvasBBox();\n      titleGroup.setMatrix([1, 0, 0, 0, 1, 0, titleConfig.offsetX, titleConfig.offsetY, 1]);\n    }\n\n    this.layoutItems();\n    var lcBBox = group.getCanvasBBox();\n    var nodeGroupBBox = nodeGroup.getCanvasBBox(); // 若有图形超过边界的情况，平移回来\n\n    var nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];\n    var nodeGroupBeginY = titleGroupBBox.maxY < nodeGroupBBox.minY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];\n    var nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];\n    nodeGroup.setMatrix(nodeGroupMatrix);\n    lcBBox = group.getCanvasBBox();\n    var size = [lcBBox.minX + lcBBox.width + padding[1], lcBBox.minY + lcBBox.height + padding[2]]; // 根据 size 和 titleConfig 调整 title 位置，再调整 nodeGroup 位置\n\n    if (titleShape) {\n      var titleConfig = __assign({\n        position: 'center',\n        offsetX: 0,\n        offsetY: 0\n      }, this.get('titleConfig'));\n\n      titleGroupBBox = titleGroup.getCanvasBBox();\n      var titleGroupMatrix = titleGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n      if (titleConfig.position === 'center') {\n        titleGroupMatrix[6] = size[0] / 2 + titleConfig.offsetX;\n      } else if (titleConfig.position === 'right') {\n        titleGroupMatrix[6] = size[0] - padding[3] + titleConfig.offsetX;\n        titleShape.attr({\n          textAlign: 'right'\n        });\n      } else {\n        titleGroupMatrix[6] = padding[3] + titleConfig.offsetX;\n        titleShape.attr({\n          textAlign: 'left'\n        });\n      }\n\n      titleGroup.setMatrix(titleGroupMatrix);\n      titleGroupBBox = titleGroup.getCanvasBBox(); // 若有图形超过边界的情况，平移回来\n\n      nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];\n      nodeGroupBeginY = nodeGroupBBox.minY < titleGroupBBox.maxY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];\n      nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];\n      nodeGroup.setMatrix(nodeGroupMatrix);\n      var edgeGroupMatrix_1 = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];\n      if (this.get('layout') === 'vertical') edgeGroupMatrix_1[6] += nodeGroupBBox.maxX + this.get('horiSep');else edgeGroupMatrix_1[7] += nodeGroupBBox.maxY + this.get('vertiSep');\n      edgeGroup.setMatrix(edgeGroupMatrix_1);\n    } else {\n      // 没有 title，也需要平移 edgeGroup\n      nodeGroupBBox = nodeGroup.getCanvasBBox();\n      var edgeGroupMatrix_2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (this.get('layout') === 'vertical') edgeGroupMatrix_2[6] += nodeGroupMatrix[6] + nodeGroupBBox.maxX + this.get('horiSep');else edgeGroupMatrix_2[7] += nodeGroupMatrix[7] + nodeGroupBBox.maxY + this.get('vertiSep');\n      edgeGroup.setMatrix(edgeGroupMatrix_2);\n    }\n\n    lcBBox = group.getCanvasBBox();\n    nodeGroupBBox = nodeGroup.getCanvasBBox();\n    nodeGroupMatrix = nodeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var edgeGroupMatrix = edgeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var edgeGroupBBox = edgeGroup.getCanvasBBox();\n    size = [Math.max(nodeGroupBBox.width + nodeGroupMatrix[6], edgeGroupBBox.width + edgeGroupMatrix[6]) + padding[1], Math.max(nodeGroupBBox.height + nodeGroupMatrix[7], edgeGroupBBox.height + edgeGroupMatrix[7]) + padding[2]];\n    lc.changeSize(size[0], size[1]); // 更新容器背景样式\n\n    var containerStyle = this.get('containerStyle');\n    var viewportMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var beginPos = Util.invertMatrix({\n      x: 0,\n      y: 0\n    }, viewportMatrix);\n    var backRect = group.addShape('rect', {\n      attrs: __assign({\n        x: beginPos.x + (containerStyle.lineWidth || 1),\n        y: beginPos.y + (containerStyle.lineWidth || 1),\n        width: size[0] - 2 * (containerStyle.lineWidth || 1),\n        height: size[1] - 2 * (containerStyle.lineWidth || 1),\n        fill: \"#f00\",\n        stroke: '#000',\n        lineWidth: 1,\n        opacity: 0.5\n      }, containerStyle),\n      name: 'legend-back-rect',\n      capture: false\n    });\n    backRect.toBack();\n    return size;\n  };\n\n  Legend.prototype.layoutItems = function () {\n    var lc = this.get('legendCanvas');\n    var horiSep = this.get('horiSep');\n    var vertiSep = this.get('vertiSep');\n    var layout = this.get('layout');\n    var align = this.get('align');\n    var begin = [0, 0];\n    var group = lc.find(function (e) {\n      return e.get('name') === 'root';\n    });\n    var nodeGroup = group.find(function (e) {\n      return e.get('name') === 'node-group';\n    });\n    var edgeGroup = group.find(function (e) {\n      return e.get('name') === 'edge-group';\n    });\n    var nodeLegendSize = {\n      min: 0,\n      max: -Infinity\n    };\n    var rowMaxY = -Infinity;\n    nodeGroup.get('children').forEach(function (cNodeGroup, i) {\n      if (i === 0) nodeLegendSize.min = begin[0];\n      var keyShape = cNodeGroup.get('children')[0];\n      var bbox = cNodeGroup.getCanvasBBox();\n\n      var _a = keyShape.getBBox(),\n          keyShapeWidth = _a.width,\n          keyShapeHeight = _a.height;\n\n      var curHeight = 0,\n          x = 0,\n          y = 0;\n\n      if (layout === 'vertical') {\n        x = begin[1];\n        y = begin[0] + keyShapeWidth / 2;\n        begin[0] = y + bbox.height + vertiSep;\n        curHeight = bbox.maxX + x + keyShapeWidth / 2;\n      } else {\n        x = begin[0] + keyShapeWidth / 2;\n        y = begin[1];\n        begin[0] = x + bbox.width + horiSep;\n        curHeight = bbox.maxY + y + keyShapeHeight / 2;\n      }\n\n      if (begin[0] > nodeLegendSize.max) nodeLegendSize.max = begin[0];\n      if (curHeight > rowMaxY) rowMaxY = curHeight;\n      cNodeGroup.setMatrix([1, 0, 0, 0, 1, 0, x, y, 1]);\n    });\n    var nw = nodeLegendSize.max - nodeLegendSize.min;\n    var edgeLegendSize = {\n      min: 0,\n      max: -Infinity\n    };\n    var nodeGroupBBox = nodeGroup.getCanvasBBox();\n    begin[0] = 0;\n    begin[1] = layout === 'vertical' ? nodeGroupBBox.maxX + horiSep : nodeGroupBBox.maxY + vertiSep;\n    edgeGroup.get('children').forEach(function (subGroup, i) {\n      if (i === 0) edgeLegendSize.min = begin[0];\n      var keyShape = subGroup.get('children')[0];\n      var bbox = subGroup.getCanvasBBox();\n\n      var _a = keyShape.getBBox(),\n          keyShapeWidth = _a.width,\n          keyShapeHeight = _a.height;\n\n      var x = 0,\n          y = 0;\n\n      if (layout === 'vertical') {\n        x = begin[1];\n        y = begin[0];\n        begin[0] = y + bbox.height + vertiSep;\n        subGroup.setMatrix([1, 0, 0, 0, 1, 0, 0, y + keyShapeHeight / 2, 1]);\n      } else {\n        x = begin[0];\n        y = begin[1];\n        begin[0] = x + bbox.width + horiSep;\n        subGroup.setMatrix([1, 0, 0, 0, 1, 0, x + keyShapeWidth / 2, 0, 1]);\n      }\n\n      if (begin[0] > edgeLegendSize.max) edgeLegendSize.max = begin[0];\n    });\n    var ew = edgeLegendSize.max - edgeLegendSize.min;\n\n    if (align && align !== '' && align !== 'left') {\n      var widthDiff = nw - ew;\n      var movement_1 = align === 'center' ? Math.abs(widthDiff) / 2 : Math.abs(widthDiff);\n      var shouldAdjustGroup = widthDiff < 0 ? nodeGroup : edgeGroup;\n      shouldAdjustGroup.get('children').forEach(function (subGroup) {\n        var matrix = subGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        if (layout === 'vertical') matrix[7] += movement_1;else matrix[6] += movement_1;\n        subGroup.setMatrix(matrix);\n      });\n    }\n  };\n\n  Legend.prototype.processData = function () {\n    var data = this.get('data');\n    var itemsData = {\n      nodes: [],\n      edges: []\n    };\n\n    if (data.nodes) {\n      data.nodes.sort(function (a, b) {\n        return a.order - b.order;\n      });\n      data.nodes.forEach(function (node) {\n        var _a, _b, _c, _d, _e;\n\n        var size = node.size || [((_a = node.style) === null || _a === void 0 ? void 0 : _a.width) || ((_b = node.style) === null || _b === void 0 ? void 0 : _b.r) || 8, ((_c = node.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = node.style) === null || _d === void 0 ? void 0 : _d.r) || 8];\n        var labelStyle = ((_e = node.labelCfg) === null || _e === void 0 ? void 0 : _e.style) || {};\n        itemsData.nodes.push({\n          id: node.id || uniqueId(),\n          type: node.type || 'circle',\n          style: __assign({}, node.style),\n          order: node.order,\n          label: node.label,\n          itemType: 'node',\n          size: size,\n          labelCfg: {\n            position: 'right',\n            style: __assign({\n              fontFamily: \"Arial\"\n            }, labelStyle)\n          }\n        });\n      });\n    }\n\n    if (data.edges) {\n      data.edges.sort(function (a, b) {\n        return a.order - b.order;\n      });\n      data.edges.forEach(function (edge) {\n        var _a, _b;\n\n        var type = edge.type || 'line';\n        if (edge.type === 'cubic-horizontal') type = 'cubic';\n        var labelStyle = ((_a = edge.labelCfg) === null || _a === void 0 ? void 0 : _a.style) || {};\n        var size = edge.size || [((_b = edge.style) === null || _b === void 0 ? void 0 : _b.width) || 8, 1];\n        itemsData.edges.push({\n          id: edge.id || uniqueId(),\n          type: type,\n          size: size,\n          style: __assign({\n            lineWidth: isArray(size) ? size[1] : 1\n          }, edge.style),\n          order: edge.order,\n          label: edge.label,\n          itemType: 'edge',\n          labelCfg: {\n            position: 'right',\n            style: __assign({\n              fontFamily: \"Arial\"\n            }, labelStyle)\n          }\n        });\n      });\n    }\n\n    this.set('itemsData', itemsData);\n  };\n\n  Legend.prototype.getContainer = function () {\n    return this.get('container');\n  };\n\n  Legend.prototype.formatArray = function (key) {\n    var value = this.get(key);\n    if (isNumber(value)) this.set(key, [value, value, value, value]);else if (isArray(value)) {\n      switch (value.length) {\n        case 0:\n          this.set(key, [0, 0, 0, 0]);\n          break;\n\n        case 1:\n          this.set(key, [value[0], value[0], value[0], value[0]]);\n          break;\n\n        case 2:\n          this.set(key, [value[0], value[1], value[0], value[1]]);\n          break;\n\n        case 3:\n          this.set(key, [value[0], value[1], value[2], value[1]]);\n          break;\n\n        default:\n          break;\n      }\n    }\n    return this.get(key);\n  };\n\n  Legend.prototype.getShapeSize = function (data) {\n    var width, height, r;\n\n    if (data.size) {\n      if (isArray(data.size)) {\n        width = data.size[0];\n        height = data.size[1] || data.size[0];\n        r = data.size[0] / 2;\n      } else if (isNumber(data.size)) {\n        width = data.size;\n        height = data.size;\n        r = data.size / 2;\n      }\n    }\n\n    if (data.style) {\n      if (data.style.width) width = data.style.width;\n      if (data.style.height) height = data.style.height;\n      if (data.style.r) r = data.style.r;\n    }\n\n    if (!r) r = 5;\n    if (!width) width = r;\n    if (!height) height = r;\n    return {\n      width: width,\n      height: height,\n      r: r\n    };\n  };\n\n  Legend.prototype.getStyle = function (type, data) {\n    var defaultStyle = type === 'node' ? {\n      fill: '#ccc',\n      lineWidth: 0\n    } : {\n      stroke: '#000',\n      lineWidth: 1\n    };\n    return __assign(__assign({}, defaultStyle), data.style || {});\n  };\n\n  Legend.prototype.destroy = function () {\n    var graph = this.get('graph');\n    var graphContainer = graph.get('container');\n    var container = this.get('container');\n    graphContainer.removeChild(container);\n  };\n\n  return Legend;\n}(Base);\n\nexport default Legend;","map":null,"metadata":{},"sourceType":"module"}