{"ast":null,"code":"import { FunctionExt } from '../util';\nimport { Basecoat, Dijkstra } from '../common';\nimport { Rectangle } from '../geometry';\nimport { Cell } from './cell';\nimport { Edge } from './edge';\nimport { Node } from './node';\nimport { Collection } from './collection';\nexport class Model extends Basecoat {\n  constructor() {\n    let cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.batches = {};\n    this.addings = new WeakMap();\n    this.nodes = {};\n    this.edges = {};\n    this.outgoings = {};\n    this.incomings = {};\n    this.collection = new Collection(cells);\n    this.setup();\n  }\n\n  get [Symbol.toStringTag]() {\n    return Model.toStringTag;\n  }\n\n  notify(name, args) {\n    this.trigger(name, args);\n    const graph = this.graph;\n\n    if (graph) {\n      if (name === 'sorted' || name === 'reseted' || name === 'updated') {\n        graph.trigger(`model:${name}`, args);\n      } else {\n        graph.trigger(name, args);\n      }\n    }\n\n    return this;\n  }\n\n  setup() {\n    const collection = this.collection;\n    collection.on('sorted', () => this.notify('sorted', null));\n    collection.on('updated', args => this.notify('updated', args));\n    collection.on('cell:change:zIndex', () => this.sortOnChangeZ());\n    collection.on('added', _ref => {\n      let {\n        cell\n      } = _ref;\n      this.onCellAdded(cell);\n    });\n    collection.on('removed', args => {\n      const cell = args.cell;\n      this.onCellRemoved(cell, args.options); // Should trigger remove-event manually after cell was removed.\n\n      this.notify('cell:removed', args);\n\n      if (cell.isNode()) {\n        this.notify('node:removed', Object.assign(Object.assign({}, args), {\n          node: cell\n        }));\n      } else if (cell.isEdge()) {\n        this.notify('edge:removed', Object.assign(Object.assign({}, args), {\n          edge: cell\n        }));\n      }\n    });\n    collection.on('reseted', args => {\n      this.onReset(args.current);\n      this.notify('reseted', args);\n    });\n    collection.on('edge:change:source', _ref2 => {\n      let {\n        edge\n      } = _ref2;\n      return this.onEdgeTerminalChanged(edge, 'source');\n    });\n    collection.on('edge:change:target', _ref3 => {\n      let {\n        edge\n      } = _ref3;\n      this.onEdgeTerminalChanged(edge, 'target');\n    });\n  }\n\n  sortOnChangeZ() {\n    this.collection.sort();\n  }\n\n  onCellAdded(cell) {\n    const cellId = cell.id;\n\n    if (cell.isEdge()) {\n      // Auto update edge's parent\n      cell.updateParent();\n      this.edges[cellId] = true;\n      this.onEdgeTerminalChanged(cell, 'source');\n      this.onEdgeTerminalChanged(cell, 'target');\n    } else {\n      this.nodes[cellId] = true;\n    }\n  }\n\n  onCellRemoved(cell, options) {\n    const cellId = cell.id;\n\n    if (cell.isEdge()) {\n      delete this.edges[cellId];\n      const source = cell.getSource();\n      const target = cell.getTarget();\n\n      if (source && source.cell) {\n        const cache = this.outgoings[source.cell];\n        const index = cache ? cache.indexOf(cellId) : -1;\n\n        if (index >= 0) {\n          cache.splice(index, 1);\n\n          if (cache.length === 0) {\n            delete this.outgoings[source.cell];\n          }\n        }\n      }\n\n      if (target && target.cell) {\n        const cache = this.incomings[target.cell];\n        const index = cache ? cache.indexOf(cellId) : -1;\n\n        if (index >= 0) {\n          cache.splice(index, 1);\n\n          if (cache.length === 0) {\n            delete this.incomings[target.cell];\n          }\n        }\n      }\n    } else {\n      delete this.nodes[cellId];\n    }\n\n    if (!options.clear) {\n      if (options.disconnectEdges) {\n        this.disconnectConnectedEdges(cell, options);\n      } else {\n        this.removeConnectedEdges(cell, options);\n      }\n    }\n\n    if (cell.model === this) {\n      cell.model = null;\n    }\n  }\n\n  onReset(cells) {\n    this.nodes = {};\n    this.edges = {};\n    this.outgoings = {};\n    this.incomings = {};\n    cells.forEach(cell => this.onCellAdded(cell));\n  }\n\n  onEdgeTerminalChanged(edge, type) {\n    const ref = type === 'source' ? this.outgoings : this.incomings;\n    const prev = edge.previous(type);\n\n    if (prev && prev.cell) {\n      const cache = ref[prev.cell];\n      const index = cache ? cache.indexOf(edge.id) : -1;\n\n      if (index >= 0) {\n        cache.splice(index, 1);\n\n        if (cache.length === 0) {\n          delete ref[prev.cell];\n        }\n      }\n    }\n\n    const terminal = edge.getTerminal(type);\n\n    if (terminal && terminal.cell) {\n      const cache = ref[terminal.cell] || [];\n      const index = cache.indexOf(edge.id);\n\n      if (index === -1) {\n        cache.push(edge.id);\n      }\n\n      ref[terminal.cell] = cache;\n    }\n  }\n\n  prepareCell(cell, options) {\n    if (!cell.model && (!options || !options.dryrun)) {\n      cell.model = this;\n    }\n\n    if (cell.zIndex == null) {\n      cell.setZIndex(this.getMaxZIndex() + 1, {\n        silent: true\n      });\n    }\n\n    return cell;\n  }\n\n  resetCells(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Do not update model at this time. Because if we just update the graph\n    // with the same json-data, the edge will reference to the old nodes.\n    cells.map(cell => this.prepareCell(cell, Object.assign(Object.assign({}, options), {\n      dryrun: true\n    })));\n    this.collection.reset(cells, options); // Update model and trigger edge update it's references\n\n    cells.map(cell => this.prepareCell(cell, {\n      options\n    }));\n    return this;\n  }\n\n  clear() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const raw = this.getCells();\n\n    if (raw.length === 0) {\n      return this;\n    }\n\n    const localOptions = Object.assign(Object.assign({}, options), {\n      clear: true\n    });\n    this.batchUpdate('clear', () => {\n      // The nodes come after the edges.\n      const cells = raw.sort((a, b) => {\n        const v1 = a.isEdge() ? 1 : 2;\n        const v2 = b.isEdge() ? 1 : 2;\n        return v1 - v2;\n      });\n\n      while (cells.length > 0) {\n        // Note that all the edges are removed first, so it's safe to\n        // remove the nodes without removing the connected edges first.\n        const cell = cells.shift();\n\n        if (cell) {\n          cell.remove(localOptions);\n        }\n      }\n    }, localOptions);\n    return this;\n  }\n\n  addNode(metadata) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const node = Node.isNode(metadata) ? metadata : this.createNode(metadata);\n    this.addCell(node, options);\n    return node;\n  }\n\n  createNode(metadata) {\n    return Node.create(metadata);\n  }\n\n  addEdge(metadata) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);\n    this.addCell(edge, options);\n    return edge;\n  }\n\n  createEdge(metadata) {\n    return Edge.create(metadata);\n  }\n\n  addCell(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, options);\n    }\n\n    if (!this.collection.has(cell) && !this.addings.has(cell)) {\n      this.addings.set(cell, true);\n      this.collection.add(this.prepareCell(cell, options), options);\n      cell.eachChild(child => this.addCell(child, options));\n      this.addings.delete(cell);\n    }\n\n    return this;\n  }\n\n  addCells(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const count = cells.length;\n\n    if (count === 0) {\n      return this;\n    }\n\n    const localOptions = Object.assign(Object.assign({}, options), {\n      position: count - 1,\n      maxPosition: count - 1\n    });\n    this.startBatch('add', Object.assign(Object.assign({}, localOptions), {\n      cells\n    }));\n    cells.forEach(cell => {\n      this.addCell(cell, localOptions);\n      localOptions.position -= 1;\n    });\n    this.stopBatch('add', Object.assign(Object.assign({}, localOptions), {\n      cells\n    }));\n    return this;\n  }\n\n  removeCell(obj) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const cell = typeof obj === 'string' ? this.getCell(obj) : obj;\n\n    if (cell && this.has(cell)) {\n      return this.collection.remove(cell, options);\n    }\n\n    return null;\n  }\n\n  updateCellId(cell, newId) {\n    this.startBatch('update', {\n      id: newId\n    });\n    cell.prop('id', newId);\n    const newCell = cell.clone({\n      keepId: true\n    });\n    this.addCell(newCell); // update connected edge terminal\n\n    const edges = this.getConnectedEdges(cell);\n    edges.forEach(edge => {\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n\n      if (sourceCell === cell) {\n        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), {\n          cell: newId\n        }));\n      }\n\n      if (targetCell === cell) {\n        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n          cell: newId\n        }));\n      }\n    });\n    this.removeCell(cell);\n    this.stopBatch('update', {\n      id: newId\n    });\n    return newCell;\n  }\n\n  removeCells(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (cells.length) {\n      return this.batchUpdate('remove', () => {\n        return cells.map(cell => this.removeCell(cell, options));\n      });\n    }\n\n    return [];\n  }\n\n  removeConnectedEdges(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const edges = this.getConnectedEdges(cell);\n    edges.forEach(edge => {\n      edge.remove(options);\n    });\n    return edges;\n  }\n\n  disconnectConnectedEdges(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const cellId = typeof cell === 'string' ? cell : cell.id;\n    this.getConnectedEdges(cell).forEach(edge => {\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n\n      if (sourceCell && sourceCell.id === cellId) {\n        edge.setSource({\n          x: 0,\n          y: 0\n        }, options);\n      }\n\n      if (targetCell && targetCell.id === cellId) {\n        edge.setTarget({\n          x: 0,\n          y: 0\n        }, options);\n      }\n    });\n  }\n\n  has(obj) {\n    return this.collection.has(obj);\n  }\n\n  total() {\n    return this.collection.length;\n  }\n\n  indexOf(cell) {\n    return this.collection.indexOf(cell);\n  }\n  /**\n   * Returns a cell from the graph by its id.\n   */\n\n\n  getCell(id) {\n    return this.collection.get(id);\n  }\n  /**\n   * Returns all the nodes and edges in the graph.\n   */\n\n\n  getCells() {\n    return this.collection.toArray();\n  }\n  /**\n   * Returns the first cell (node or edge) in the graph. The first cell is\n   * defined as the cell with the lowest `zIndex`.\n   */\n\n\n  getFirstCell() {\n    return this.collection.first();\n  }\n  /**\n   * Returns the last cell (node or edge) in the graph. The last cell is\n   * defined as the cell with the highest `zIndex`.\n   */\n\n\n  getLastCell() {\n    return this.collection.last();\n  }\n  /**\n   * Returns the lowest `zIndex` value in the graph.\n   */\n\n\n  getMinZIndex() {\n    const first = this.collection.first();\n    return first ? first.getZIndex() || 0 : 0;\n  }\n  /**\n   * Returns the highest `zIndex` value in the graph.\n   */\n\n\n  getMaxZIndex() {\n    const last = this.collection.last();\n    return last ? last.getZIndex() || 0 : 0;\n  }\n\n  getCellsFromCache(cache) {\n    return cache ? Object.keys(cache).map(id => this.getCell(id)).filter(cell => cell != null) : [];\n  }\n  /**\n   * Returns all the nodes in the graph.\n   */\n\n\n  getNodes() {\n    return this.getCellsFromCache(this.nodes);\n  }\n  /**\n   * Returns all the edges in the graph.\n   */\n\n\n  getEdges() {\n    return this.getCellsFromCache(this.edges);\n  }\n  /**\n   * Returns all outgoing edges for the node.\n   */\n\n\n  getOutgoingEdges(cell) {\n    const cellId = typeof cell === 'string' ? cell : cell.id;\n    const cellIds = this.outgoings[cellId];\n    return cellIds ? cellIds.map(id => this.getCell(id)).filter(cell => cell && cell.isEdge()) : null;\n  }\n  /**\n   * Returns all incoming edges for the node.\n   */\n\n\n  getIncomingEdges(cell) {\n    const cellId = typeof cell === 'string' ? cell : cell.id;\n    const cellIds = this.incomings[cellId];\n    return cellIds ? cellIds.map(id => this.getCell(id)).filter(cell => cell && cell.isEdge()) : null;\n  }\n  /**\n   * Returns edges connected with cell.\n   */\n\n\n  getConnectedEdges(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const result = [];\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell;\n\n    if (node == null) {\n      return result;\n    }\n\n    const cache = {};\n    const indirect = options.indirect;\n    let incoming = options.incoming;\n    let outgoing = options.outgoing;\n\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true;\n    }\n\n    const collect = (cell, isOutgoing) => {\n      const edges = isOutgoing ? this.getOutgoingEdges(cell) : this.getIncomingEdges(cell);\n\n      if (edges != null) {\n        edges.forEach(edge => {\n          if (cache[edge.id]) {\n            return;\n          }\n\n          result.push(edge);\n          cache[edge.id] = true;\n\n          if (indirect) {\n            if (incoming) {\n              collect(edge, false);\n            }\n\n            if (outgoing) {\n              collect(edge, true);\n            }\n          }\n        });\n      }\n\n      if (indirect && cell.isEdge()) {\n        const terminal = isOutgoing ? cell.getTargetCell() : cell.getSourceCell();\n\n        if (terminal && terminal.isEdge()) {\n          if (!cache[terminal.id]) {\n            result.push(terminal);\n            collect(terminal, isOutgoing);\n          }\n        }\n      }\n    };\n\n    if (outgoing) {\n      collect(node, true);\n    }\n\n    if (incoming) {\n      collect(node, false);\n    }\n\n    if (options.deep) {\n      const descendants = node.getDescendants({\n        deep: true\n      });\n      const embedsCache = {};\n      descendants.forEach(cell => {\n        if (cell.isNode()) {\n          embedsCache[cell.id] = true;\n        }\n      });\n\n      const collectSub = (cell, isOutgoing) => {\n        const edges = isOutgoing ? this.getOutgoingEdges(cell.id) : this.getIncomingEdges(cell.id);\n\n        if (edges != null) {\n          edges.forEach(edge => {\n            if (!cache[edge.id]) {\n              const sourceCell = edge.getSourceCell();\n              const targetCell = edge.getTargetCell();\n\n              if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {\n                return;\n              }\n\n              result.push(edge);\n              cache[edge.id] = true;\n            }\n          });\n        }\n      };\n\n      descendants.forEach(cell => {\n        if (cell.isEdge()) {\n          return;\n        }\n\n        if (outgoing) {\n          collectSub(cell, true);\n        }\n\n        if (incoming) {\n          collectSub(cell, false);\n        }\n      });\n    }\n\n    return result;\n  }\n\n  isBoundary(cell, isOrigin) {\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell;\n    const arr = isOrigin ? this.getIncomingEdges(node) : this.getOutgoingEdges(node);\n    return arr == null || arr.length === 0;\n  }\n\n  getBoundaryNodes(isOrigin) {\n    const result = [];\n    Object.keys(this.nodes).forEach(nodeId => {\n      if (this.isBoundary(nodeId, isOrigin)) {\n        const node = this.getCell(nodeId);\n\n        if (node) {\n          result.push(node);\n        }\n      }\n    });\n    return result;\n  }\n  /**\n   * Returns an array of all the roots of the graph.\n   */\n\n\n  getRoots() {\n    return this.getBoundaryNodes(true);\n  }\n  /**\n   * Returns an array of all the leafs of the graph.\n   */\n\n\n  getLeafs() {\n    return this.getBoundaryNodes(false);\n  }\n  /**\n   * Returns `true` if the node is a root node, i.e. there is no edges\n   * coming to the node.\n   */\n\n\n  isRoot(cell) {\n    return this.isBoundary(cell, true);\n  }\n  /**\n   * Returns `true` if the node is a leaf node, i.e. there is no edges\n   * going out from the node.\n   */\n\n\n  isLeaf(cell) {\n    return this.isBoundary(cell, false);\n  }\n  /**\n   * Returns all the neighbors of node in the graph. Neighbors are all\n   * the nodes connected to node via either incoming or outgoing edge.\n   */\n\n\n  getNeighbors(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let incoming = options.incoming;\n    let outgoing = options.outgoing;\n\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true;\n    }\n\n    const edges = this.getConnectedEdges(cell, options);\n    const map = edges.reduce((memo, edge) => {\n      const hasLoop = edge.hasLoop(options);\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n\n      if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {\n        if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {\n          memo[sourceCell.id] = sourceCell;\n        }\n      }\n\n      if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {\n        if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {\n          memo[targetCell.id] = targetCell;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    if (cell.isEdge()) {\n      if (incoming) {\n        const sourceCell = cell.getSourceCell();\n\n        if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {\n          map[sourceCell.id] = sourceCell;\n        }\n      }\n\n      if (outgoing) {\n        const targetCell = cell.getTargetCell();\n\n        if (targetCell && targetCell.isNode() && !map[targetCell.id]) {\n          map[targetCell.id] = targetCell;\n        }\n      }\n    }\n\n    return Object.keys(map).map(id => map[id]);\n  }\n  /**\n   * Returns `true` if `cell2` is a neighbor of `cell1`.\n   */\n\n\n  isNeighbor(cell1, cell2) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let incoming = options.incoming;\n    let outgoing = options.outgoing;\n\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true;\n    }\n\n    return this.getConnectedEdges(cell1, options).some(edge => {\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n\n      if (incoming && sourceCell && sourceCell.id === cell2.id) {\n        return true;\n      }\n\n      if (outgoing && targetCell && targetCell.id === cell2.id) {\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  getSuccessors(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const successors = [];\n    this.search(cell, (curr, distance) => {\n      if (curr !== cell && this.matchDistance(distance, options.distance)) {\n        successors.push(curr);\n      }\n    }, Object.assign(Object.assign({}, options), {\n      outgoing: true\n    }));\n    return successors;\n  }\n  /**\n   * Returns `true` if `cell2` is a successor of `cell1`.\n   */\n\n\n  isSuccessor(cell1, cell2) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let result = false;\n    this.search(cell1, (curr, distance) => {\n      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {\n        result = true;\n        return false;\n      }\n    }, Object.assign(Object.assign({}, options), {\n      outgoing: true\n    }));\n    return result;\n  }\n\n  getPredecessors(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const predecessors = [];\n    this.search(cell, (curr, distance) => {\n      if (curr !== cell && this.matchDistance(distance, options.distance)) {\n        predecessors.push(curr);\n      }\n    }, Object.assign(Object.assign({}, options), {\n      incoming: true\n    }));\n    return predecessors;\n  }\n  /**\n   * Returns `true` if `cell2` is a predecessor of `cell1`.\n   */\n\n\n  isPredecessor(cell1, cell2) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let result = false;\n    this.search(cell1, (curr, distance) => {\n      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {\n        result = true;\n        return false;\n      }\n    }, Object.assign(Object.assign({}, options), {\n      incoming: true\n    }));\n    return result;\n  }\n\n  matchDistance(distance, preset) {\n    if (preset == null) {\n      return true;\n    }\n\n    if (typeof preset === 'function') {\n      return preset(distance);\n    }\n\n    if (Array.isArray(preset) && preset.includes(distance)) {\n      return true;\n    }\n\n    return distance === preset;\n  }\n  /**\n   * Returns the common ancestor of the passed cells.\n   */\n\n\n  getCommonAncestor() {\n    const arr = [];\n\n    for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {\n      cells[_key] = arguments[_key];\n    }\n\n    cells.forEach(item => {\n      if (item) {\n        if (Array.isArray(item)) {\n          arr.push(...item);\n        } else {\n          arr.push(item);\n        }\n      }\n    });\n    return Cell.getCommonAncestor(...arr);\n  }\n  /**\n   * Returns an array of cells that result from finding nodes/edges that\n   * are connected to any of the cells in the cells array. This function\n   * loops over cells and if the current cell is a edge, it collects its\n   * source/target nodes; if it is an node, it collects its incoming and\n   * outgoing edges if both the edge terminal (source/target) are in the\n   * cells array.\n   */\n\n\n  getSubGraph(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const subgraph = [];\n    const cache = {};\n    const nodes = [];\n    const edges = [];\n\n    const collect = cell => {\n      if (!cache[cell.id]) {\n        subgraph.push(cell);\n        cache[cell.id] = cell;\n\n        if (cell.isEdge()) {\n          edges.push(cell);\n        }\n\n        if (cell.isNode()) {\n          nodes.push(cell);\n        }\n      }\n    };\n\n    cells.forEach(cell => {\n      collect(cell);\n\n      if (options.deep) {\n        const descendants = cell.getDescendants({\n          deep: true\n        });\n        descendants.forEach(descendant => collect(descendant));\n      }\n    });\n    edges.forEach(edge => {\n      // For edges, include their source & target\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n\n      if (sourceCell && !cache[sourceCell.id]) {\n        subgraph.push(sourceCell);\n        cache[sourceCell.id] = sourceCell;\n\n        if (sourceCell.isNode()) {\n          nodes.push(sourceCell);\n        }\n      }\n\n      if (targetCell && !cache[targetCell.id]) {\n        subgraph.push(targetCell);\n        cache[targetCell.id] = targetCell;\n\n        if (targetCell.isNode()) {\n          nodes.push(targetCell);\n        }\n      }\n    });\n    nodes.forEach(node => {\n      // For nodes, include their connected edges if their source/target\n      // is in the subgraph.\n      const edges = this.getConnectedEdges(node, options);\n      edges.forEach(edge => {\n        const sourceCell = edge.getSourceCell();\n        const targetCell = edge.getTargetCell();\n\n        if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {\n          subgraph.push(edge);\n          cache[edge.id] = edge;\n        }\n      });\n    });\n    return subgraph;\n  }\n  /**\n   * Clones the whole subgraph (including all the connected links whose\n   * source/target is in the subgraph). If `options.deep` is `true`, also\n   * take into account all the embedded cells of all the subgraph cells.\n   *\n   * Returns a map of the form: { [original cell ID]: [clone] }.\n   */\n\n\n  cloneSubGraph(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const subgraph = this.getSubGraph(cells, options);\n    return this.cloneCells(subgraph);\n  }\n\n  cloneCells(cells) {\n    return Cell.cloneCells(cells);\n  }\n\n  getNodesFromPoint(x, y) {\n    const p = typeof x === 'number' ? {\n      x,\n      y: y || 0\n    } : x;\n    return this.getNodes().filter(node => {\n      return node.getBBox().containsPoint(p);\n    });\n  }\n\n  getNodesInArea(x, y, w, h, options) {\n    const rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n    const opts = typeof x === 'number' ? options : y;\n    const strict = opts && opts.strict;\n    return this.getNodes().filter(node => {\n      const bbox = node.getBBox();\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n    });\n  }\n\n  getEdgesInArea(x, y, w, h, options) {\n    const rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n    const opts = typeof x === 'number' ? options : y;\n    const strict = opts && opts.strict;\n    return this.getEdges().filter(edge => {\n      const bbox = edge.getBBox();\n\n      if (bbox.width === 0) {\n        bbox.inflate(1, 0);\n      } else if (bbox.height === 0) {\n        bbox.inflate(0, 1);\n      }\n\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n    });\n  }\n\n  getNodesUnderNode(node) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const bbox = node.getBBox();\n    const nodes = options.by == null || options.by === 'bbox' ? this.getNodesInArea(bbox) : this.getNodesFromPoint(bbox[options.by]);\n    return nodes.filter(curr => node.id !== curr.id && !curr.isDescendantOf(node));\n  }\n  /**\n   * Returns the bounding box that surrounds all cells in the graph.\n   */\n\n\n  getAllCellsBBox() {\n    return this.getCellsBBox(this.getCells());\n  }\n  /**\n   * Returns the bounding box that surrounds all the given cells.\n   */\n\n\n  getCellsBBox(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Cell.getCellsBBox(cells, options);\n  } // #region search\n\n\n  search(cell, iterator) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (options.breadthFirst) {\n      this.breadthFirstSearch(cell, iterator, options);\n    } else {\n      this.depthFirstSearch(cell, iterator, options);\n    }\n  }\n\n  breadthFirstSearch(cell, iterator) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const queue = [];\n    const visited = {};\n    const distance = {};\n    queue.push(cell);\n    distance[cell.id] = 0;\n\n    while (queue.length > 0) {\n      const next = queue.shift();\n\n      if (next == null || visited[next.id]) {\n        continue;\n      }\n\n      visited[next.id] = true;\n\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue;\n      }\n\n      const neighbors = this.getNeighbors(next, options);\n      neighbors.forEach(neighbor => {\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.push(neighbor);\n      });\n    }\n  }\n\n  depthFirstSearch(cell, iterator) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const queue = [];\n    const visited = {};\n    const distance = {};\n    queue.push(cell);\n    distance[cell.id] = 0;\n\n    while (queue.length > 0) {\n      const next = queue.pop();\n\n      if (next == null || visited[next.id]) {\n        continue;\n      }\n\n      visited[next.id] = true;\n\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue;\n      }\n\n      const neighbors = this.getNeighbors(next, options);\n      const lastIndex = queue.length;\n      neighbors.forEach(neighbor => {\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.splice(lastIndex, 0, neighbor);\n      });\n    }\n  } // #endregion\n  // #region shortest path\n\n  /** *\n   * Returns an array of IDs of nodes on the shortest\n   * path between source and target.\n   */\n\n\n  getShortestPath(source, target) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const adjacencyList = {};\n    this.getEdges().forEach(edge => {\n      const sourceId = edge.getSourceCellId();\n      const targetId = edge.getTargetCellId();\n\n      if (sourceId && targetId) {\n        if (!adjacencyList[sourceId]) {\n          adjacencyList[sourceId] = [];\n        }\n\n        if (!adjacencyList[targetId]) {\n          adjacencyList[targetId] = [];\n        }\n\n        adjacencyList[sourceId].push(targetId);\n\n        if (!options.directed) {\n          adjacencyList[targetId].push(sourceId);\n        }\n      }\n    });\n    const sourceId = typeof source === 'string' ? source : source.id;\n    const previous = Dijkstra.run(adjacencyList, sourceId, options.weight);\n    const path = [];\n    let targetId = typeof target === 'string' ? target : target.id;\n\n    if (previous[targetId]) {\n      path.push(targetId);\n    }\n\n    while (targetId = previous[targetId]) {\n      path.unshift(targetId);\n    }\n\n    return path;\n  } // #endregion\n  // #region transform\n\n  /**\n   * Translate all cells in the graph by `tx` and `ty` pixels.\n   */\n\n\n  translate(tx, ty, options) {\n    this.getCells().filter(cell => !cell.hasParent()).forEach(cell => cell.translate(tx, ty, options));\n    return this;\n  }\n\n  resize(width, height, options) {\n    return this.resizeCells(width, height, this.getCells(), options);\n  }\n\n  resizeCells(width, height, cells) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const bbox = this.getCellsBBox(cells);\n\n    if (bbox) {\n      const sx = Math.max(width / bbox.width, 0);\n      const sy = Math.max(height / bbox.height, 0);\n      const origin = bbox.getOrigin();\n      cells.forEach(cell => cell.scale(sx, sy, origin, options));\n    }\n\n    return this;\n  } // #endregion\n  // #region serialize/deserialize\n\n\n  toJSON() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Model.toJSON(this.getCells(), options);\n  }\n\n  parseJSON(data) {\n    return Model.fromJSON(data);\n  }\n\n  fromJSON(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const cells = this.parseJSON(data);\n    this.resetCells(cells, options);\n    return this;\n  } // #endregion\n  // #region batch\n\n\n  startBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.batches[name] = (this.batches[name] || 0) + 1;\n    this.notify('batch:start', {\n      name,\n      data\n    });\n    return this;\n  }\n\n  stopBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.batches[name] = (this.batches[name] || 0) - 1;\n    this.notify('batch:stop', {\n      name,\n      data\n    });\n    return this;\n  }\n\n  batchUpdate(name, execute) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.startBatch(name, data);\n    const result = execute();\n    this.stopBatch(name, data);\n    return result;\n  }\n\n  hasActiveBatch() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(this.batches);\n    const names = Array.isArray(name) ? name : [name];\n    return names.some(batch => this.batches[batch] > 0);\n  }\n\n}\n\n(function (Model) {\n  Model.toStringTag = `X6.${Model.name}`;\n\n  function isModel(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Model) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const model = instance;\n\n    if ((tag == null || tag === Model.toStringTag) && typeof model.addNode === 'function' && typeof model.addEdge === 'function' && model.collection != null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  Model.isModel = isModel;\n})(Model || (Model = {}));\n\n(function (Model) {\n  function toJSON(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n      cells: cells.map(cell => cell.toJSON(options))\n    };\n  }\n\n  Model.toJSON = toJSON;\n\n  function fromJSON(data) {\n    const cells = [];\n\n    if (Array.isArray(data)) {\n      cells.push(...data);\n    } else {\n      if (data.cells) {\n        cells.push(...data.cells);\n      }\n\n      if (data.nodes) {\n        data.nodes.forEach(node => {\n          if (node.shape == null) {\n            node.shape = 'rect';\n          }\n\n          cells.push(node);\n        });\n      }\n\n      if (data.edges) {\n        data.edges.forEach(edge => {\n          if (edge.shape == null) {\n            edge.shape = 'edge';\n          }\n\n          cells.push(edge);\n        });\n      }\n    }\n\n    return cells.map(cell => {\n      const type = cell.shape;\n\n      if (type) {\n        if (Node.registry.exist(type)) {\n          return Node.create(cell);\n        }\n\n        if (Edge.registry.exist(type)) {\n          return Edge.create(cell);\n        }\n      }\n\n      throw new Error('The `shape` should be specified when creating a node/edge instance');\n    });\n  }\n\n  Model.fromJSON = fromJSON;\n})(Model || (Model = {}));","map":null,"metadata":{},"sourceType":"module"}