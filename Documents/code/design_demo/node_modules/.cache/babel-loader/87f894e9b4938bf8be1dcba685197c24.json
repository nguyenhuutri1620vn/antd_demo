{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt } from '../../util';\nimport { Marker } from '../marker';\n\nfunction qualify(value) {\n  return typeof value === 'string' || ObjectExt.isPlainObject(value);\n}\n\nexport const sourceMarker = {\n  qualify,\n\n  set(marker, _ref) {\n    let {\n      view,\n      attrs\n    } = _ref;\n    return createMarker('marker-start', marker, view, attrs);\n  }\n\n};\nexport const targetMarker = {\n  qualify,\n\n  set(marker, _ref2) {\n    let {\n      view,\n      attrs\n    } = _ref2;\n    return createMarker('marker-end', marker, view, attrs, {\n      transform: 'rotate(180)'\n    });\n  }\n\n};\nexport const vertexMarker = {\n  qualify,\n\n  set(marker, _ref3) {\n    let {\n      view,\n      attrs\n    } = _ref3;\n    return createMarker('marker-mid', marker, view, attrs);\n  }\n\n};\n\nfunction createMarker(type, marker, view, attrs) {\n  let manual = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const def = typeof marker === 'string' ? {\n    name: marker\n  } : marker;\n\n  const {\n    name,\n    args\n  } = def,\n        others = __rest(def, [\"name\", \"args\"]);\n\n  let preset = others;\n\n  if (name && typeof name === 'string') {\n    const fn = Marker.registry.get(name);\n\n    if (fn) {\n      preset = fn(Object.assign(Object.assign({}, others), args));\n    } else {\n      return Marker.registry.onNotFound(name);\n    }\n  }\n\n  const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);\n  return {\n    [type]: `url(#${view.graph.defineMarker(options)})`\n  };\n}\n\nfunction normalizeAttr(attr, type) {\n  const result = {}; // The context 'fill' is disregared here. The usual case is to use the\n  // marker with a connection(for which 'fill' attribute is set to 'none').\n\n  const stroke = attr.stroke;\n\n  if (typeof stroke === 'string') {\n    result.stroke = stroke;\n    result.fill = stroke;\n  } // Again the context 'fill-opacity' is ignored.\n\n\n  let strokeOpacity = attr.strokeOpacity;\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr['stroke-opacity'];\n  }\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr.opacity;\n  }\n\n  if (strokeOpacity != null) {\n    result['stroke-opacity'] = strokeOpacity;\n    result['fill-opacity'] = strokeOpacity;\n  }\n\n  if (type !== 'marker-mid') {\n    const strokeWidth = parseFloat(attr.strokeWidth || attr['stroke-width']);\n\n    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n      const offset = Math.ceil(strokeWidth / 2);\n      result.refX = type === 'marker-start' ? offset : -offset;\n    }\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}