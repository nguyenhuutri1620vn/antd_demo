{"ast":null,"code":"/* eslint-disable no-control-regex */\nimport { NumberExt } from '../number';\nimport { Text } from '../text';\nimport { attr } from './attr';\nimport { Vector } from '../vector';\nimport { createSvgElement, empty, remove } from './elem';\nimport { Platform } from '../platform';\n\nfunction createTextPathNode(attrs, elem) {\n  const vel = Vector.create(elem);\n  const textPath = Vector.create('textPath');\n  const d = attrs.d;\n\n  if (d && attrs['xlink:href'] === undefined) {\n    const path = Vector.create('path').attr('d', d).appendTo(vel.defs());\n    textPath.attr('xlink:href', `#${path.id}`);\n  }\n\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs);\n  }\n\n  return textPath.node;\n}\n\nfunction annotateTextLine(lineNode, lineAnnotations, options) {\n  const eol = options.eol;\n  const baseSize = options.baseSize;\n  const lineHeight = options.lineHeight;\n  let maxFontSize = 0;\n  let tspanNode;\n  const fontMetrics = {};\n  const lastJ = lineAnnotations.length - 1;\n\n  for (let j = 0; j <= lastJ; j += 1) {\n    let annotation = lineAnnotations[j];\n    let fontSize = null;\n\n    if (typeof annotation === 'object') {\n      const annotationAttrs = annotation.attrs;\n      const vTSpan = Vector.create('tspan', annotationAttrs);\n      tspanNode = vTSpan.node;\n      let t = annotation.t;\n\n      if (eol && j === lastJ) {\n        t += eol;\n      }\n\n      tspanNode.textContent = t; // Per annotation className\n\n      const annotationClass = annotationAttrs.class;\n\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass);\n      } // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n\n\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations.join(','));\n      } // Check for max font size\n\n\n      fontSize = parseFloat(annotationAttrs['font-size']);\n      if (fontSize === undefined) fontSize = baseSize;\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol;\n      }\n\n      tspanNode = document.createTextNode(annotation || ' ');\n\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize;\n      }\n    }\n\n    lineNode.appendChild(tspanNode);\n  }\n\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize;\n  }\n\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight;\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2;\n  }\n\n  return fontMetrics;\n}\n\nconst emRegex = /em$/;\n\nfunction emToPx(em, fontSize) {\n  const numerical = parseFloat(em);\n\n  if (emRegex.test(em)) {\n    return numerical * fontSize;\n  }\n\n  return numerical;\n}\n\nfunction calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0;\n  }\n\n  const n = linesMetrics.length;\n  if (!n) return 0;\n  let lineMetrics = linesMetrics[0];\n  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  let rLineHeights = 0;\n  const lineHeightPx = emToPx(lineHeight, baseSizePx);\n\n  for (let i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i];\n    const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n    rLineHeights += iLineHeight;\n  }\n\n  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  let dy;\n\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n      break;\n\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights;\n      break;\n\n    default:\n    case 'top':\n      dy = 0.8 * flMaxFont;\n      break;\n  }\n\n  return dy;\n}\n\nexport function text(elem, content) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  content = Text.sanitize(content); // eslint-disable-line\n\n  const eol = options.eol;\n  let textPath = options.textPath;\n  const verticalAnchor = options.textVerticalAnchor;\n  const namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top'; // Horizontal shift applied to all the lines but the first.\n\n  let x = options.x;\n\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0;\n  } // Annotations\n\n\n  const iai = options.includeAnnotationIndices;\n  let annotations = options.annotations;\n\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations];\n  } // Shift all the <tspan> but first by one line (`1em`)\n\n\n  const defaultLineHeight = options.lineHeight;\n  const autoLineHeight = defaultLineHeight === 'auto';\n  const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n  empty(elem);\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none'\n  }); // Set default font-size if none\n\n  const strFontSize = attr(elem, 'font-size');\n  let fontSize = parseFloat(strFontSize);\n\n  if (!fontSize) {\n    fontSize = 16;\n\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', `${fontSize}`);\n    }\n  }\n\n  let containerNode;\n\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = {\n        d: textPath\n      };\n    }\n\n    containerNode = createTextPathNode(textPath, elem);\n  } else {\n    containerNode = document.createDocumentFragment();\n  }\n\n  let dy;\n  let offset = 0;\n  let annotatedY;\n  const lines = content.split('\\n');\n  const linesMetrics = [];\n  const lastI = lines.length - 1;\n\n  for (let i = 0; i <= lastI; i += 1) {\n    dy = lineHeight;\n    let lineClassName = 'v-line';\n    const lineNode = createSvgElement('tspan');\n    let lineMetrics;\n    let line = lines[i];\n\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        const lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai\n        });\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai\n        }); // Get the line height based on the biggest font size\n        // in the annotations for this line.\n\n        const iLineHeight = lineMetrics.lineHeight;\n\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight;\n        }\n\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8;\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol;\n        }\n\n        lineNode.textContent = line;\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-';\n      lineClassName += ' v-empty-line';\n      const lineNodeStyle = lineNode.style;\n      lineNodeStyle.fillOpacity = 0;\n      lineNodeStyle.strokeOpacity = 0;\n\n      if (annotations) {\n        lineMetrics = {};\n      }\n    }\n\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics);\n    }\n\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy);\n    } // Firefox requires 'x' to be set on the first line\n\n\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x);\n    }\n\n    lineNode.className.baseVal = lineClassName;\n    containerNode.appendChild(lineNode);\n    offset += line.length + 1; // + 1 = newline character.\n  } // Y Alignment calculation\n\n\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em';\n    } else {\n      let rh; // remaining height\n\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1;\n        rh *= lastI;\n        if (!emRegex.test(lineHeight)) rh /= fontSize;\n      } else {\n        // Single-line text\n        rh = 0;\n      }\n\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = `${0.3 - rh / 2}em`;\n          break;\n\n        case 'bottom':\n          dy = `${-rh - 0.3}em`;\n          break;\n\n        default:\n          break;\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em';\n  } else if (verticalAnchor) {\n    dy = verticalAnchor;\n  } else {\n    // No vertical anchor is defined\n    dy = 0; // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', `${annotatedY || '0.8em'}`);\n    }\n  }\n\n  const firstLine = containerNode.firstChild;\n  firstLine.setAttribute('dy', dy);\n  elem.appendChild(containerNode);\n}\n\nfunction splitText(text, separator, eol, hyphen) {\n  const words = [];\n  const separators = [];\n\n  if (separator != null) {\n    const parts = text.split(separator);\n    words.push(...parts);\n\n    if (typeof separator === 'string') {\n      for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(separator);\n      }\n    } else {\n      const seps = text.match(new RegExp(separator, 'g'));\n\n      for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(seps ? seps[i] : '');\n      }\n    }\n  } else {\n    let word = '';\n\n    for (let i = 0, l = text.length; i < l; i += 1) {\n      const char = text[i];\n\n      if (char === ' ') {\n        words.push(word);\n        separators.push(' ');\n        word = '';\n      } else if (char.match(/[^\\x00-\\xff]/)) {\n        // split double byte character\n        if (word.length) {\n          words.push(word);\n          separators.push('');\n        }\n\n        words.push(char);\n        separators.push('');\n        word = '';\n      } else {\n        word += char;\n      }\n    }\n\n    if (word.length) {\n      words.push(word);\n    }\n  } // end-of-line\n\n\n  for (let i = 0; i < words.length; i += 1) {\n    const word = words[i];\n\n    if (word.indexOf(eol) >= 0 && word.length > 1) {\n      const parts = word.split(eol);\n\n      for (let j = 0, k = parts.length - 1; j < k; j += 1) {\n        parts.splice(2 * j + 1, 0, eol);\n      }\n\n      const valids = parts.filter(part => part !== '');\n      words.splice(i, 1, ...valids);\n      const seps = valids.map(() => '');\n      seps.pop();\n      separators.splice(i, 0, ...seps);\n    }\n  } // hyphen\n\n\n  for (let i = 0; i < words.length; i += 1) {\n    const word = words[i];\n    const index = word.search(hyphen);\n\n    if (index > 0 && index < word.length - 1) {\n      words.splice(i, 1, word.substring(0, index + 1), word.substring(index + 1));\n      separators.splice(i, 0, '');\n    }\n  }\n\n  return {\n    words,\n    separators\n  };\n}\n\nexport function breakText(text, size) {\n  let styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const width = size.width;\n  const height = size.height;\n  const svgDocument = options.svgDocument || createSvgElement('svg');\n  const telem = createSvgElement('text');\n  const tspan = createSvgElement('tspan');\n  const tnode = document.createTextNode('');\n  attr(telem, styles);\n  telem.appendChild(tspan); // Prevent flickering\n\n  telem.style.opacity = '0'; // Prevent FF from throwing an uncaught exception when `getBBox()`\n  // called on element that is not in the render tree (is not measurable).\n  // <tspan>.getComputedTextLength() returns always 0 in this case.\n  // Note that the `textElement` resp. `textSpan` can become hidden\n  // when it's appended to the DOM and a `display: none` CSS stylesheet\n  // rule gets applied.\n\n  telem.style.display = 'block';\n  tspan.style.display = 'block';\n  tspan.appendChild(tnode);\n  svgDocument.appendChild(telem);\n  const shouldAppend = svgDocument.parentNode == null;\n\n  if (shouldAppend) {\n    document.body.appendChild(svgDocument);\n  }\n\n  const eol = options.eol || '\\n';\n  const separator = options.separator || ' ';\n  const hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\\w\\d]/;\n  const breakWord = options.breakWord !== false;\n  const full = [];\n  const lineSeprators = {};\n  let lines = [];\n  let partIndex; // let hyphenIndex\n\n  let lineHeight;\n  let currentSeparator;\n  const {\n    words,\n    separators\n  } = splitText(text, options.separator, eol, hyphen);\n\n  for (let wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {\n    const word = words[wordIndex]; // empty word\n\n    if (!word) {\n      continue;\n    } // end of line\n\n\n    if (word === eol) {\n      full[lineIndex] = true; // start a new line\n\n      lineIndex += 1;\n      lines[lineIndex] = '';\n      continue;\n    }\n\n    if (lines[lineIndex] != null) {\n      currentSeparator = separators[wordIndex - 1] || '';\n      tnode.data = `${lines[lineIndex]}${currentSeparator}${word}`;\n    } else {\n      tnode.data = word;\n    }\n\n    if (tspan.getComputedTextLength() <= width) {\n      // update line\n      lines[lineIndex] = tnode.data;\n      lineSeprators[lineIndex] = separators[wordIndex]; // when is partitioning, put rest of the word onto next line\n\n      if (partIndex) {\n        full[lineIndex] = true;\n        lineIndex += 1;\n        partIndex = 0;\n      }\n    } else {\n      if (breakWord) {\n        // word is too long to put in one line or is partitioning\n        if (!lines[lineIndex] || partIndex) {\n          const isPartition = !!partIndex;\n          const isCharacter = word.length === 1;\n          partIndex = word.length - 1;\n\n          if (isPartition || isCharacter) {\n            // word has only one character.\n            if (isCharacter) {\n              if (!lines[lineIndex]) {\n                // can't fit this text within our rect\n                lines = [];\n                break;\n              } // partitioning didn't help on the non-empty line\n              // try again, but this time start with a new line\n              // cancel partitions created\n\n\n              words.splice(wordIndex, 2, word + words[wordIndex + 1]);\n              separators.splice(wordIndex + 1, 1);\n              full[lineIndex] = true;\n              lineIndex += 1;\n              wordCount -= 1;\n              wordIndex -= 1;\n              continue;\n            } // update the partitioning words\n\n\n            words[wordIndex] = word.substring(0, partIndex);\n            words[wordIndex + 1] = word.substring(partIndex) + words[wordIndex + 1];\n          } else {\n            // partitioning the long word into two words\n            words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));\n            separators.splice(wordIndex, 0, '');\n            wordCount += 1; // if the previous line is not full\n\n            if (lineIndex && !full[lineIndex - 1]) {\n              lineIndex -= 1;\n            }\n          }\n\n          wordIndex -= 1;\n          continue;\n        }\n      } else if (!lines[lineIndex]) {\n        lines[lineIndex] = word;\n        full[lineIndex] = true;\n        lineIndex += 1;\n        continue;\n      }\n\n      lineIndex += 1;\n      wordIndex -= 1;\n    } // check whether the height of the entire text exceeds the rect height\n\n\n    if (height != null) {\n      // ensure line height\n      if (lineHeight == null) {\n        let heightValue; // use the same defaults as in V.prototype.text\n\n        if (styles.lineHeight === 'auto') {\n          heightValue = {\n            value: 1.5,\n            unit: 'em'\n          };\n        } else {\n          heightValue = NumberExt.parseCssNumeric(styles.lineHeight, ['em']) || {\n            value: 1,\n            unit: 'em'\n          };\n        }\n\n        lineHeight = heightValue.value;\n\n        if (heightValue.unit === 'em') {\n          if (Platform.IS_FIREFOX) {\n            lineHeight *= tspan.getBBox().height;\n          } else {\n            lineHeight *= telem.getBBox().height;\n          }\n        }\n      }\n\n      if (lineHeight * lines.length > height) {\n        // remove overflowing lines\n        const lastLineIndex = Math.floor(height / lineHeight) - 1;\n        const lastLine = lines[lastLineIndex];\n        const overflowLine = lines[lastLineIndex + 1];\n        lines.splice(lastLineIndex + 1);\n\n        if (lastLine == null) {\n          break;\n        } // add ellipsis\n\n\n        let ellipsis = options.ellipsis;\n\n        if (!ellipsis) {\n          break;\n        }\n\n        if (typeof ellipsis !== 'string') {\n          ellipsis = '\\u2026';\n        }\n\n        let fullLastLine = lastLine;\n\n        if (overflowLine && breakWord) {\n          fullLastLine += currentSeparator + overflowLine;\n        }\n\n        let lastCharIndex = fullLastLine.length;\n        let fixedLastLine;\n        let lastChar;\n\n        do {\n          lastChar = fullLastLine[lastCharIndex];\n          fixedLastLine = fullLastLine.substring(0, lastCharIndex);\n\n          if (!lastChar) {\n            fixedLastLine += lineSeprators[lastLineIndex];\n          } else if (lastChar.match(separator)) {\n            fixedLastLine += lastChar;\n          }\n\n          fixedLastLine += ellipsis;\n          tnode.data = fixedLastLine;\n\n          if (tspan.getComputedTextLength() <= width) {\n            lines[lastLineIndex] = fixedLastLine;\n            break;\n          }\n\n          lastCharIndex -= 1;\n        } while (lastCharIndex >= 0);\n\n        break;\n      }\n    }\n  }\n\n  if (shouldAppend) {\n    remove(svgDocument);\n  } else {\n    remove(telem);\n  }\n\n  return lines.join(eol);\n}","map":null,"metadata":{},"sourceType":"module"}