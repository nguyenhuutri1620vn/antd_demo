{"ast":null,"code":"// @ts-ignore\nimport { copy, create, dot } from 'gl-vec2'; // @ts-ignore\n\nimport { computeMiter, direction, normal } from 'polyline-miter-util';\n\nfunction extrusions(positions, out, point, normal, scale) {\n  addNext(out, normal, -scale);\n  addNext(out, normal, scale);\n  positions.push(point);\n  positions.push(point);\n}\n\nfunction addNext(out, normal, length) {\n  out.push([[normal[0], normal[1]], length]);\n}\n\nexport default function (points, closed, indexOffset) {\n  var lineA = [0, 0];\n  var lineB = [0, 0];\n  var tangent = [0, 0];\n  var miter = [0, 0];\n\n  var _lastFlip = -1;\n\n  var _started = false;\n  var _normal = null;\n  var tmp = create();\n  var count = indexOffset || 0;\n  var miterLimit = 3;\n  var out = [];\n  var attrPos = [];\n  var attrIndex = [];\n  var attrCounters = [0, 0];\n\n  if (closed) {\n    points = points.slice();\n    points.push(points[0]);\n  }\n\n  var total = points.length;\n\n  for (var i = 1; i < total; i++) {\n    var index = count;\n    var last = points[i - 1];\n    var cur = points[i];\n    var next = i < points.length - 1 ? points[i + 1] : null;\n    attrCounters.push(i / total, i / total);\n    direction(lineA, cur, last);\n\n    if (!_normal) {\n      _normal = [0, 0];\n      normal(_normal, lineA);\n    }\n\n    if (!_started) {\n      _started = true;\n      extrusions(attrPos, out, last, _normal, 1);\n    }\n\n    attrIndex.push([index + 0, index + 1, index + 2]);\n\n    if (!next) {\n      // no miter, simple segment\n      normal(_normal, lineA); // reset normal\n\n      extrusions(attrPos, out, cur, _normal, 1);\n      attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n      count += 2;\n    } else {\n      // miter with last\n      // get unit dir of next line\n      direction(lineB, next, cur); // stores tangent & miter\n\n      var miterLen = computeMiter(tangent, miter, lineA, lineB, 1); // get orientation\n\n      var flip = dot(tangent, _normal) < 0 ? -1 : 1;\n      var bevel = miterLen > miterLimit; // 处理相邻线段重叠的情况\n\n      if (!isFinite(miterLen)) {\n        normal(_normal, lineA); // reset normal\n\n        extrusions(attrPos, out, cur, _normal, 1);\n        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n        count += 2;\n        _lastFlip = flip;\n        continue;\n      }\n\n      if (bevel) {\n        miterLen = miterLimit;\n        attrCounters.push(i / total); // next two points in our first segment\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur);\n        addNext(out, miter, miterLen * flip);\n        attrPos.push(cur);\n        attrIndex.push(_lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]); // now add the bevel triangle\n\n        attrIndex.push([index + 2, index + 3, index + 4]);\n        normal(tmp, lineB);\n        copy(_normal, tmp); // store normal for next round\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur); // the miter is now the normal for our next join\n\n        count += 3;\n      } else {\n        // miter\n        // next two points for our miter join\n        extrusions(attrPos, out, cur, miter, miterLen);\n        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n        flip = -1; // the miter is now the normal for our next join\n\n        copy(_normal, miter);\n        count += 2;\n      }\n\n      _lastFlip = flip;\n    }\n  }\n\n  return {\n    normals: out,\n    attrIndex: attrIndex,\n    attrPos: attrPos,\n    attrCounters: attrCounters\n  };\n}","map":null,"metadata":{},"sourceType":"module"}