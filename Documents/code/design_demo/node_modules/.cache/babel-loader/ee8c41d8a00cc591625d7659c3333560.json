{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { ScheduleTypeEnum } from './interface';\nimport { ErrorUtils, HookUtils, Deferred } from './utils';\nexport { ScheduleTypeEnum } from './interface';\nexport class HookHub {\n  constructor(options) {\n    var _this = this;\n\n    /** scheduleType */\n    this.scheduleType = ScheduleTypeEnum.ASYNC_SRRIES;\n    /** hasRegistered */\n\n    this.hasHook = hookName => {\n      return this.hookMap.has(hookName);\n    };\n    /** getHooks */\n\n\n    this.getHooks = function () {\n      let runtimeHooks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      let sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      const hooks = HookUtils.normalize(runtimeHooks, _this.hookMap);\n\n      if (!sort) {\n        return hooks;\n      }\n\n      return HookUtils.sort(hooks, _this.hookMap);\n    };\n    /** registerHook */\n\n\n    this.registerHook = hookMeta => {\n      if (this.hookMap.has(hookMeta.name)) {\n        console.error(`${hookMeta.name} is duplicated in hookmap`);\n      }\n\n      this.hookMap.set(hookMeta.name, hookMeta);\n      return {\n        dispose: () => {\n          this.hookMap.delete(hookMeta.name);\n        }\n      };\n    };\n    /** registerHook */\n\n\n    this.call = function (args) {\n      let main = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mainArgs => __awaiter(_this, void 0, void 0, function* () {\n        return mainArgs;\n      });\n      let runtimeHook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return __awaiter(_this, void 0, void 0, function* () {\n        // TODO: 这里加cache\n        const hooks = this.getHooks(runtimeHook, true);\n        const scheduler = this.schedulers[this.scheduleType];\n        return scheduler(args, main, hooks);\n      });\n    };\n    /** 执行hook的scheduler */\n\n\n    this.schedulers = {\n      /** pipeline执行 */\n      [ScheduleTypeEnum.ASYNC_SRRIES]: function (args, main) {\n        let hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        return __awaiter(_this, void 0, void 0, function* () {\n          let callback = main;\n          /** 用 hook 加工 args  */\n\n          for (const hook of hooks) {\n            if ([0, 1].includes(hook.handler.length)) {\n              yield hook.handler.call(this, args);\n              continue;\n            }\n\n            if ([2].includes(hook.handler.length) && callback !== null) {\n              // eslint-disable-next-line @typescript-eslint/no-shadow\n              const result = yield hook.handler.call(this, args, callback);\n              /** 如果返回为null，则直接中断执行 */\n\n              if (result === null) {\n                callback = null;\n                break;\n              } else if (typeof result === 'function') {\n                callback = result;\n                continue;\n              }\n            }\n\n            const err = ErrorUtils.InvalidHookArguments(hook);\n            throw err;\n          }\n          /** 检查是否被替换为null */\n\n\n          if (callback) {\n            return yield callback.call(this, args);\n          }\n        });\n      },\n      [ScheduleTypeEnum.ASYNC_PARALLEL]: function (args, main) {\n        let hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        return __awaiter(_this, void 0, void 0, function* () {\n          /** 同时触发 hook */\n          const promises = hooks.map(hook => {\n            if ([0, 1].includes(hook.handler.length)) {\n              return hook.handler.call(this, args);\n            }\n\n            if ([2].includes(hook.handler.length)) {\n              return hook.handler.call(this, args, main);\n            }\n\n            throw ErrorUtils.InvalidHookArguments(hook);\n          });\n          const defer = new Deferred();\n          Promise.all(promises).then(res => defer.resolve(res));\n          /** 检查是否被替换 */\n\n          if (main) {\n            return yield main.call(this, defer);\n          }\n        });\n      }\n    };\n    this.hookMap = new Map();\n\n    if (options && options.type) {\n      this.scheduleType = options.type;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}