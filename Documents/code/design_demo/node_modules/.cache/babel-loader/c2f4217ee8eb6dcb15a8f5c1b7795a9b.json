{"ast":null,"code":"const graphWidth = 1200;\nconst graphHeight = 800;\nconst OVERLAP_QUOT = 10000000;\nconst MIN_DIST = 10;\nconst M_PI = 3.14159265358979323846;\nconst M_PI_2 = 1.57079632679489661923;\nconst PI_38 = M_PI * 0.375;\nconst PI_58 = M_PI * 0.625;\nconst nodeEdgeMap = new Map();\nconst CELL_W = 10;\nconst CELL_H = 10;\nlet T = 0.8;\nconst T_MIN = 0.1;\nconst R = 0.5;\n\nfunction distanceToNode(node1, node2, isHoriz) {\n  const x11 = node1.x - node1.size[0] / 2;\n  const y11 = node1.y - node1.size[1] / 2;\n  const x12 = node1.x + node1.size[0] / 2;\n  const y12 = node1.y + node1.size[1] / 2;\n  const x21 = node2.x - node2.size[0] / 2;\n  const y21 = node2.y - node2.size[1] / 2;\n  const x22 = node2.x + node2.size[0] / 2;\n  const y22 = node2.y + node2.size[1] / 2;\n  const cx1 = node1.x;\n  const cy1 = node1.y;\n  const cx2 = node2.x;\n  const cy2 = node2.y;\n  const dcx = cx2 - cx1; // 两个节点间的方位角  \n\n  const qr = Math.atan2(dcx, cy2 - cy1);\n  let dx = 0;\n  let dy = 0;\n  let l1 = 0;\n  let l2 = 0;\n\n  if (qr > M_PI_2) {\n    dy = y11 - y22;\n    dx = x21 - x12;\n    l1 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : dx.toFixed(2));\n    l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : dy.toFixed(2));\n  } else if (0.0 < qr && qr <= M_PI_2) {\n    dy = y21 - y12;\n    dx = x21 - x12;\n\n    if (dy > dx) {\n      l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : dx.toFixed(2));\n    } else {\n      l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : dy.toFixed(2));\n    }\n  } else if (qr < -M_PI_2) {\n    dy = y11 - y22;\n    dx = -(x22 - x11);\n\n    if (dy > dx) {\n      l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : dx.toFixed(2));\n    } else {\n      l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : dy.toFixed(2));\n    }\n  } else {\n    dy = y21 - y12;\n\n    if (Math.abs(dcx) > (x12 - x11) / 2) {\n      dx = x11 - x22;\n    } else {\n      dx = dcx;\n    }\n\n    if (dy > dx) {\n      l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : dx.toFixed(2));\n    } else {\n      l1 = l2 = parseFloat(dx && qr !== 0.0 ? (dx / Math.sin(qr)).toFixed(2) : dy.toFixed(2));\n    }\n  }\n\n  const aqr = parseFloat(qr.toFixed(2)); // 判断是否水平，角度\n\n  let newHoriz = isHoriz;\n\n  if (isHoriz) {\n    newHoriz = PI_38 < aqr && aqr < PI_58;\n  }\n\n  return {\n    distance: Math.abs(l1 < l2 ? l1 : l2),\n    isHoriz: newHoriz\n  };\n}\n\nfunction calcNodePair(nodeA, nodeB) {\n  // 确定两个节点间是否存在连线\n  const edges = nodeEdgeMap.get(nodeA.id) || [];\n  const isLinked = edges.find(edge => {\n    return edge.source === nodeB.id || edge.target === nodeB.id;\n  });\n  const areaA = nodeA.size[0] * nodeA.size[1];\n  const areaB = nodeB.size[0] * nodeB.size[1];\n  const node1 = areaA > areaB ? nodeB : nodeA;\n  const node2 = areaA > areaB ? nodeA : nodeB;\n  const x11 = node1.x - node1.size[0] / 2;\n  const y11 = node1.y - node1.size[1] / 2;\n  const x12 = node1.x + node1.size[0] / 2;\n  const y12 = node1.y + node1.size[1] / 2;\n  const x21 = node2.x - node2.size[0] / 2;\n  const y21 = node2.y - node2.size[1] / 2;\n  const x22 = node2.x + node2.size[0] / 2;\n  const y22 = node2.y + node2.size[1] / 2;\n  const cx1 = node1.x;\n  const cy1 = node1.y;\n  const cx2 = node2.x;\n  const cy2 = node2.y; // Detect if nodes overlap  检查节点之间是否存在覆盖问题\n\n  const isoverlap = x12 >= x21 && x22 >= x11 && y12 >= y21 && y22 >= y11;\n  let e = 0;\n  let distance = 0;\n\n  if (isoverlap) {\n    distance = Math.sqrt(Math.pow(cx2 - cx1, 2) + Math.pow(cy2 - cy1, 2)); // calc area of overlap 计算重复区域的坐标和面积\n\n    const sx1 = x11 > x21 ? x11 : x21;\n    const sy1 = y11 > y21 ? y11 : y21;\n    const sx2 = x12 < x22 ? x12 : x22;\n    const sy2 = y12 < y22 ? y12 : y22;\n    const dsx = sx2 - sx1;\n    const dsy = sy2 - sy1;\n    const sov = dsx * dsy;\n\n    if (distance === 0.0) {\n      distance = 0.0000001;\n    }\n\n    e = MIN_DIST * 1 / distance * 100 + sov;\n    e *= OVERLAP_QUOT;\n  } else {\n    let isHoriz = false;\n    const res = distanceToNode(node1, node2, isHoriz);\n    distance = res.distance;\n    isHoriz = res.isHoriz;\n\n    if (distance <= MIN_DIST) {\n      if (distance !== 0) {\n        if (isLinked) {\n          e += MIN_DIST + OVERLAP_QUOT * 1 / distance;\n        } else {\n          e += MIN_DIST + OVERLAP_QUOT * MIN_DIST / distance;\n        }\n      } else {\n        e += OVERLAP_QUOT;\n      }\n    } else {\n      e += distance;\n\n      if (isLinked) {\n        e += distance * distance;\n      }\n    }\n  }\n\n  return e;\n}\n\nfunction calcEnergy(nodes) {\n  let energy = 0;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (node.x < 0 || node.y < 0 || node.x > graphWidth || node.y > graphHeight) {\n      energy += 1000000000000;\n    }\n\n    for (let j = i + 1; j < nodes.length; j++) {\n      energy += calcNodePair(node, nodes[j]);\n    }\n  }\n\n  return energy;\n}\n\nfunction isCorrectPosition(node, newPosition, nodes, edges) {\n  const nodeIdxMap = new Map();\n  nodes.forEach((o, i) => {\n    nodeIdxMap.set(o.id, o);\n  });\n  const relateEdges = edges.filter(edge => edge.source === node.id || edge.target === node.id) || [];\n  const relateNodes = [];\n  relateEdges.forEach(edge => {\n    const otherNodeId = edge.source === node.id ? edge.target : edge.source;\n    const otherNode = nodeIdxMap.get(otherNodeId);\n\n    if (otherNode) {\n      relateNodes.push(otherNode);\n    }\n  });\n  let flag = true;\n\n  for (let i = 0; i < relateNodes.length; i++) {\n    const item = relateNodes[i]; // 判断条件调整，节点的坐标不需要完全一致。可以根据节点间的夹角来判断\n\n    const delta = Math.atan((node.y - item.y) / (item.x - node.y)) * 180;\n    const newDelta = Math.atan((newPosition.y - item.y) / (item.x - newPosition.y)) * 180;\n    const isHor = delta < 30 || delta > 150;\n    const newIsHor = newDelta < 30 || newDelta > 150;\n    const isVer = delta > 70 && delta < 110;\n    const newIsVer = newDelta > 70 && newDelta < 110; // 定义四个相似角度区间，0-15度，75-90度，90到105度，165到180度。\n\n    if (isHor && !newIsHor || delta * newDelta < 0) {\n      flag = false;\n      break;\n    } else if (isVer && !newIsVer || delta * newDelta < 0) {\n      flag = false;\n      break;\n    } else if ((item.x - node.x) * (item.x - newPosition.x) < 0) {\n      flag = false;\n      break;\n    } else if ((item.y - node.y) * (item.y - newPosition.y) < 0) {\n      flag = false;\n      break;\n    }\n  }\n\n  return flag;\n}\n\nfunction shuffle(nodes, edges) {\n  let foundSmallerEnergy = false; // 多次测试发现step为1时的效果最佳。\n\n  const step = 1;\n  const wstep = CELL_W * step;\n  const hstep = CELL_H * step;\n  const wsteps = [wstep, -wstep, 0, 0];\n  const hsteps = [0, 0, hstep, -hstep];\n\n  for (let i = 0; i < nodes.length; ++i) {\n    const node = nodes[i];\n    let nodeEnergy = calcNodeEnergy(node, nodes);\n\n    for (let ns = 0; ns < wsteps.length; ns++) {\n      // 判断新位置与其他连线节点的位置关系是否违规\n      const flag = isCorrectPosition(node, {\n        x: node.x + wsteps[ns],\n        y: node.y + hsteps[ns]\n      }, nodes, edges);\n\n      if (flag) {\n        // 节点朝上下左右四个方向移动，找到能量最小的那个位置\n        node.x += wsteps[ns];\n        node.y += hsteps[ns]; // 计算移动后节点的能量\n\n        const energy = calcNodeEnergy(node, nodes);\n        const rdm = Math.random();\n\n        if (energy < nodeEnergy) {\n          nodeEnergy = energy;\n          foundSmallerEnergy = true;\n        } else if (rdm < T && rdm > T_MIN) {\n          nodeEnergy = energy;\n          foundSmallerEnergy = true;\n        } else {\n          // 回归原位\n          node.x -= wsteps[ns];\n          node.y -= hsteps[ns];\n        }\n      }\n    }\n  }\n\n  if (T > T_MIN) {\n    T *= R;\n  } // 重新计算图整体的能量\n\n\n  if (foundSmallerEnergy) {\n    return calcEnergy(nodes);\n  }\n\n  return 0;\n} // 计算节点的能量，\n\n\nfunction calcNodeEnergy(node, nodes) {\n  let e = 0.0;\n\n  if (node.x < 0 || node.y < 0 || node.x + node.size[0] + 20 > graphWidth || node.y + node.size[1] + 20 > graphHeight) {\n    e += 1000000000000.0;\n  }\n\n  for (let i = 0; i < nodes.length; ++i) {\n    if (node.id !== nodes[i].id) {\n      e += calcNodePair(node, nodes[i]);\n    }\n  }\n\n  return e;\n}\n\nfunction layout(nodes, edges) {\n  if (nodes.length === 0) {\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  nodes.forEach(node => {\n    const relateEdge = edges.filter(edge => edge.source === node.id || edge.target === node.id);\n    nodeEdgeMap.set(node, relateEdge);\n  }); // 1. 初始化\n  // 将node按照连接数进行排序\n\n  nodes.sort((node1, node2) => {\n    var _a, _b;\n\n    return ((_a = nodeEdgeMap.get(node1.id)) === null || _a === void 0 ? void 0 : _a.length) - ((_b = nodeEdgeMap.get(node2.id)) === null || _b === void 0 ? void 0 : _b.length);\n  }); // 2. 计算图能量\n\n  let minEnergy = calcEnergy(nodes);\n  let deSameCount = 20; // de=0 count\n\n  let de = 1; // energy delta\n\n  let prevEnergy = 0; // 定义总的迭代次数。超过就停掉，防止死循环\n\n  const MAX_COUNT = 50;\n  let count = 0;\n\n  while (deSameCount > 0) {\n    count++;\n\n    if (count >= MAX_COUNT) {\n      break;\n    }\n\n    const ea = shuffle(nodes, edges);\n\n    if (ea !== 0) {\n      prevEnergy = ea;\n    }\n\n    de = prevEnergy - minEnergy;\n    minEnergy = prevEnergy;\n\n    if (de === 0) {\n      --deSameCount;\n    } else {\n      deSameCount = 20;\n    }\n  }\n\n  nodes.forEach(node => {\n    node.x = node.x - node.size[0] / 2;\n    node.y = node.y - node.size[1] / 2;\n  });\n  return {\n    nodes,\n    edges\n  };\n}\n\nexport default layout;","map":null,"metadata":{},"sourceType":"module"}