{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Registry } from '../registry';\nimport { Point, Rectangle, Angle } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt } from '../util';\nimport { Markup } from '../view/markup';\nimport { Cell } from './cell';\nimport { ShareRegistry } from './registry';\nimport { PortManager } from './port';\nimport { Interp } from '../common';\nexport class Node extends Cell {\n  constructor() {\n    let metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(metadata);\n    this.initPorts();\n  }\n\n  get [Symbol.toStringTag]() {\n    return Node.toStringTag;\n  }\n\n  preprocess(metadata, ignoreIdCheck) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = metadata,\n          others = __rest(metadata, [\"x\", \"y\", \"width\", \"height\"]);\n\n    if (x != null || y != null) {\n      const position = others.position;\n      others.position = Object.assign(Object.assign({}, position), {\n        x: x != null ? x : position ? position.x : 0,\n        y: y != null ? y : position ? position.y : 0\n      });\n    }\n\n    if (width != null || height != null) {\n      const size = others.size;\n      others.size = Object.assign(Object.assign({}, size), {\n        width: width != null ? width : size ? size.width : 0,\n        height: height != null ? height : size ? size.height : 0\n      });\n    }\n\n    return super.preprocess(others, ignoreIdCheck);\n  }\n\n  isNode() {\n    return true;\n  }\n\n  size(width, height, options) {\n    if (width === undefined) {\n      return this.getSize();\n    }\n\n    if (typeof width === 'number') {\n      return this.setSize(width, height, options);\n    }\n\n    return this.setSize(width, height);\n  }\n\n  getSize() {\n    const size = this.store.get('size');\n    return size ? Object.assign({}, size) : {\n      width: 1,\n      height: 1\n    };\n  }\n\n  setSize(width, height, options) {\n    if (typeof width === 'object') {\n      this.resize(width.width, width.height, height);\n    } else {\n      this.resize(width, height, options);\n    }\n\n    return this;\n  }\n\n  resize(width, height) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.startBatch('resize', options);\n    const direction = options.direction;\n\n    if (direction) {\n      const currentSize = this.getSize();\n\n      switch (direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height; // eslint-disable-line\n\n          break;\n\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width; // eslint-disable-line\n\n          break;\n\n        default:\n          break;\n      }\n\n      const map = {\n        right: 0,\n        'top-right': 0,\n        top: 1,\n        'top-left': 1,\n        left: 2,\n        'bottom-left': 2,\n        bottom: 3,\n        'bottom-right': 3\n      };\n      let quadrant = map[direction];\n      const angle = Angle.normalize(this.getAngle() || 0);\n\n      if (options.absolute) {\n        // We are taking the node's rotation into account\n        quadrant += Math.floor((angle + 45) / 90);\n        quadrant %= 4;\n      } // This is a rectangle in size of the un-rotated node.\n\n\n      const bbox = this.getBBox(); // Pick the corner point on the node, which meant to stay on its\n      // place before and after the rotation.\n\n      let fixedPoint;\n\n      if (quadrant === 0) {\n        fixedPoint = bbox.getBottomLeft();\n      } else if (quadrant === 1) {\n        fixedPoint = bbox.getCorner();\n      } else if (quadrant === 2) {\n        fixedPoint = bbox.getTopRight();\n      } else {\n        fixedPoint = bbox.getOrigin();\n      } // Find an image of the previous indent point. This is the position,\n      // where is the point actually located on the screen.\n\n\n      const imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox.getCenter()); // Every point on the element rotates around a circle with the centre of\n      // rotation in the middle of the element while the whole element is being\n      // rotated. That means that the distance from a point in the corner of\n      // the element (supposed its always rect) to the center of the element\n      // doesn't change during the rotation and therefore it equals to a\n      // distance on un-rotated element.\n      // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\n      const radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting\n      // at image of fixed point and ending at the center of the element.\n      // We call this angle `alpha`.\n      // The image of a fixed point is located in n-th quadrant. For each\n      // quadrant passed going anti-clockwise we have to add 90 degrees.\n      // Note that the first quadrant has index 0.\n      //\n      // 3 | 2\n      // --c-- Quadrant positions around the element's center `c`\n      // 0 | 1\n      //\n\n      let alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line\n      // parallel with x-axis or y-axis going through the center of the\n      // element) and line crossing the indent of the fixed point and the\n      // center of the element. This is the angle we need but on the\n      // un-rotated element.\n\n      alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated\n      // by and that's it.\n\n      alpha -= Angle.toRad(angle); // With this angle and distance we can easily calculate the centre of\n      // the un-rotated element.\n      // Note that fromPolar constructor accepts an angle in radians.\n\n      const center = Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width\n      // on the left and half a height to the top from the center. This will\n      // be the origin of rectangle we were looking for.\n\n      const origin = center.clone().translate(width / -2, height / -2);\n      this.store.set('size', {\n        width,\n        height\n      }, options);\n      this.setPosition(origin.x, origin.y, options);\n    } else {\n      this.store.set('size', {\n        width,\n        height\n      }, options);\n    }\n\n    this.stopBatch('resize', options);\n    return this;\n  }\n\n  scale(sx, sy, origin) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);\n    this.startBatch('scale', options);\n    this.setPosition(scaledBBox.x, scaledBBox.y, options);\n    this.resize(scaledBBox.width, scaledBBox.height, options);\n    this.stopBatch('scale');\n    return this;\n  }\n\n  position(arg0, arg1, arg2) {\n    if (typeof arg0 === 'number') {\n      return this.setPosition(arg0, arg1, arg2);\n    }\n\n    return this.getPosition(arg0);\n  }\n\n  getPosition() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.relative) {\n      const parent = this.getParent();\n\n      if (parent != null && parent.isNode()) {\n        const currentPosition = this.getPosition();\n        const parentPosition = parent.getPosition();\n        return {\n          x: currentPosition.x - parentPosition.x,\n          y: currentPosition.y - parentPosition.y\n        };\n      }\n    }\n\n    const pos = this.store.get('position');\n    return pos ? Object.assign({}, pos) : {\n      x: 0,\n      y: 0\n    };\n  }\n\n  setPosition(arg0, arg1) {\n    let arg2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let x;\n    let y;\n    let options;\n\n    if (typeof arg0 === 'object') {\n      x = arg0.x;\n      y = arg0.y;\n      options = arg1 || {};\n    } else {\n      x = arg0;\n      y = arg1;\n      options = arg2 || {};\n    }\n\n    if (options.relative) {\n      const parent = this.getParent();\n\n      if (parent != null && parent.isNode()) {\n        const parentPosition = parent.getPosition();\n        x += parentPosition.x;\n        y += parentPosition.y;\n      }\n    }\n\n    if (options.deep) {\n      const currentPosition = this.getPosition();\n      this.translate(x - currentPosition.x, y - currentPosition.y, options);\n    } else {\n      this.store.set('position', {\n        x,\n        y\n      }, options);\n    }\n\n    return this;\n  }\n\n  translate() {\n    let tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (tx === 0 && ty === 0) {\n      return this;\n    } // Pass the initiator of the translation.\n\n\n    options.translateBy = options.translateBy || this.id;\n    const position = this.getPosition();\n\n    if (options.restrict != null && options.translateBy === this.id) {\n      // We are restricting the translation for the element itself only. We get\n      // the bounding box of the element including all its embeds.\n      // All embeds have to be translated the exact same way as the element.\n      const bbox = this.getBBox({\n        deep: true\n      });\n      const ra = options.restrict; // - - - - - - - - - - - - -> ra.x + ra.width\n      // - - - -> position.x      |\n      // -> bbox.x\n      //                ▓▓▓▓▓▓▓   |\n      //         ░░░░░░░▓▓▓▓▓▓▓\n      //         ░░░░░░░░░        |\n      //   ▓▓▓▓▓▓▓▓░░░░░░░\n      //   ▓▓▓▓▓▓▓▓               |\n      //   <-dx->                     | restricted area right border\n      //         <-width->        |   ░ translated element\n      //   <- - bbox.width - ->       ▓ embedded element\n\n      const dx = position.x - bbox.x;\n      const dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated\n      // while complies the restrictions.\n\n      const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n      const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.\n\n      tx = x - position.x; // eslint-disable-line\n\n      ty = y - position.y; // eslint-disable-line\n    }\n\n    const translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty\n    }; // To find out by how much an element was translated in event\n    // 'change:position' handlers.\n\n    options.tx = tx;\n    options.ty = ty;\n\n    if (options.transition) {\n      if (typeof options.transition !== 'object') {\n        options.transition = {};\n      }\n\n      this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), {\n        interp: Interp.object\n      }));\n      this.eachChild(child => {\n        var _a;\n\n        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n        if (!excluded) {\n          child.translate(tx, ty, options);\n        }\n      });\n    } else {\n      this.startBatch('translate', options);\n      this.store.set('position', translatedPosition, options);\n      this.eachChild(child => {\n        var _a;\n\n        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n        if (!excluded) {\n          child.translate(tx, ty, options);\n        }\n      });\n      this.stopBatch('translate', options);\n    }\n\n    return this;\n  }\n\n  angle(val, options) {\n    if (val == null) {\n      return this.getAngle();\n    }\n\n    return this.rotate(val, options);\n  }\n\n  getAngle() {\n    return this.store.get('angle', 0);\n  }\n\n  rotate(angle) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const currentAngle = this.getAngle();\n\n    if (options.center) {\n      const size = this.getSize();\n      const position = this.getPosition();\n      const center = this.getBBox().getCenter();\n      center.rotate(currentAngle - angle, options.center);\n      const dx = center.x - size.width / 2 - position.x;\n      const dy = center.y - size.height / 2 - position.y;\n      this.startBatch('rotate', {\n        angle,\n        options\n      });\n      this.setPosition(position.x + dx, position.y + dy, options);\n      this.rotate(angle, Object.assign(Object.assign({}, options), {\n        center: null\n      }));\n      this.stopBatch('rotate');\n    } else {\n      this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);\n    }\n\n    return this;\n  } // #endregion\n  // #region common\n\n\n  getBBox() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.deep) {\n      const cells = this.getDescendants({\n        deep: true,\n        breadthFirst: true\n      });\n      cells.push(this);\n      return Cell.getCellsBBox(cells);\n    }\n\n    return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());\n  }\n\n  getConnectionPoint(edge, type) {\n    const bbox = this.getBBox();\n    const center = bbox.getCenter();\n    const terminal = edge.getTerminal(type);\n\n    if (terminal == null) {\n      return center;\n    }\n\n    const portId = terminal.port;\n\n    if (!portId || !this.hasPort(portId)) {\n      return center;\n    }\n\n    const port = this.getPort(portId);\n\n    if (!port || !port.group) {\n      return center;\n    }\n\n    const layouts = this.getPortsPosition(port.group);\n    const position = layouts[portId].position;\n    const portCenter = Point.create(position).translate(bbox.getOrigin());\n    const angle = this.getAngle();\n\n    if (angle) {\n      portCenter.rotate(-angle, center);\n    }\n\n    return portCenter;\n  }\n  /**\n   * Sets cell's size and position based on the children bbox and given padding.\n   */\n\n\n  fit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const children = this.getChildren() || [];\n    const embeds = children.filter(cell => cell.isNode());\n\n    if (embeds.length === 0) {\n      return this;\n    }\n\n    this.startBatch('fit-embeds', options);\n\n    if (options.deep) {\n      embeds.forEach(cell => cell.fit(options));\n    }\n\n    let {\n      x,\n      y,\n      width,\n      height\n    } = Cell.getCellsBBox(embeds);\n    const padding = NumberExt.normalizeSides(options.padding);\n    x -= padding.left;\n    y -= padding.top;\n    width += padding.left + padding.right;\n    height += padding.bottom + padding.top;\n    this.store.set({\n      position: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    }, options);\n    this.stopBatch('fit-embeds');\n    return this;\n  } // #endregion\n  // #region ports\n\n\n  get portContainerMarkup() {\n    return this.getPortContainerMarkup();\n  }\n\n  set portContainerMarkup(markup) {\n    this.setPortContainerMarkup(markup);\n  }\n\n  getDefaultPortContainerMarkup() {\n    return this.store.get('defaultPortContainerMarkup') || Markup.getPortContainerMarkup();\n  }\n\n  getPortContainerMarkup() {\n    return this.store.get('portContainerMarkup') || this.getDefaultPortContainerMarkup();\n  }\n\n  setPortContainerMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('portContainerMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get portMarkup() {\n    return this.getPortMarkup();\n  }\n\n  set portMarkup(markup) {\n    this.setPortMarkup(markup);\n  }\n\n  getDefaultPortMarkup() {\n    return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();\n  }\n\n  getPortMarkup() {\n    return this.store.get('portMarkup') || this.getDefaultPortMarkup();\n  }\n\n  setPortMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('portMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get portLabelMarkup() {\n    return this.getPortLabelMarkup();\n  }\n\n  set portLabelMarkup(markup) {\n    this.setPortLabelMarkup(markup);\n  }\n\n  getDefaultPortLabelMarkup() {\n    return this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup();\n  }\n\n  getPortLabelMarkup() {\n    return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();\n  }\n\n  setPortLabelMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('portLabelMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get ports() {\n    const res = this.store.get('ports', {\n      items: []\n    });\n\n    if (res.items == null) {\n      res.items = [];\n    }\n\n    return res;\n  }\n\n  getPorts() {\n    return ObjectExt.cloneDeep(this.ports.items);\n  }\n\n  getPortsByGroup(groupName) {\n    return this.getPorts().filter(port => port.group === groupName);\n  }\n\n  getPort(portId) {\n    return ObjectExt.cloneDeep(this.ports.items.find(port => port.id && port.id === portId));\n  }\n\n  getPortAt(index) {\n    return this.ports.items[index] || null;\n  }\n\n  hasPorts() {\n    return this.ports.items.length > 0;\n  }\n\n  hasPort(portId) {\n    return this.getPortIndex(portId) !== -1;\n  }\n\n  getPortIndex(port) {\n    const portId = typeof port === 'string' ? port : port.id;\n    return portId != null ? this.ports.items.findIndex(item => item.id === portId) : -1;\n  }\n\n  getPortsPosition(groupName) {\n    const size = this.getSize();\n    const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));\n    return layouts.reduce((memo, item) => {\n      const layout = item.portLayout;\n      memo[item.portId] = {\n        position: Object.assign({}, layout.position),\n        angle: layout.angle || 0\n      };\n      return memo;\n    }, {});\n  }\n\n  getPortProp(portId, path) {\n    return this.getPropByPath(this.prefixPortPath(portId, path));\n  }\n\n  setPortProp(portId, arg1, arg2, arg3) {\n    if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n      const path = this.prefixPortPath(portId, arg1);\n      const value = arg2;\n      return this.setPropByPath(path, value, arg3);\n    }\n\n    const path = this.prefixPortPath(portId);\n    const value = arg1;\n    return this.setPropByPath(path, value, arg2);\n  }\n\n  removePortProp(portId, path, options) {\n    if (typeof path === 'string' || Array.isArray(path)) {\n      return this.removePropByPath(this.prefixPortPath(portId, path), options);\n    }\n\n    return this.removePropByPath(this.prefixPortPath(portId), path);\n  }\n\n  portProp(portId, path, value, options) {\n    if (path == null) {\n      return this.getPortProp(portId);\n    }\n\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 2) {\n        return this.getPortProp(portId, path);\n      }\n\n      if (value == null) {\n        return this.removePortProp(portId, path, options);\n      }\n\n      return this.setPortProp(portId, path, value, options);\n    }\n\n    return this.setPortProp(portId, path, value);\n  }\n\n  prefixPortPath(portId, path) {\n    const index = this.getPortIndex(portId);\n\n    if (index === -1) {\n      throw new Error(`Unable to find port with id: \"${portId}\"`);\n    }\n\n    if (path == null || path === '') {\n      return ['ports', 'items', `${index}`];\n    }\n\n    if (Array.isArray(path)) {\n      return ['ports', 'items', `${index}`, ...path];\n    }\n\n    return `ports/items/${index}/${path}`;\n  }\n\n  addPort(port, options) {\n    const ports = [...this.ports.items];\n    ports.push(port);\n    this.setPropByPath('ports/items', ports, options);\n    return this;\n  }\n\n  addPorts(ports, options) {\n    this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);\n    return this;\n  }\n\n  insertPort(index, port, options) {\n    const ports = [...this.ports.items];\n    ports.splice(index, 0, port);\n    this.setPropByPath('ports/items', ports, options);\n    return this;\n  }\n\n  removePort(port) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.removePortAt(this.getPortIndex(port), options);\n  }\n\n  removePortAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (index >= 0) {\n      const ports = [...this.ports.items];\n      ports.splice(index, 1);\n      options.rewrite = true;\n      this.setPropByPath('ports/items', ports, options);\n    }\n\n    return this;\n  }\n\n  removePorts(portsForRemoval, opt) {\n    let options;\n\n    if (Array.isArray(portsForRemoval)) {\n      options = opt || {};\n\n      if (portsForRemoval.length) {\n        options.rewrite = true;\n        const currentPorts = [...this.ports.items];\n        const remainingPorts = currentPorts.filter(cp => !portsForRemoval.some(p => {\n          const id = typeof p === 'string' ? p : p.id;\n          return cp.id === id;\n        }));\n        this.setPropByPath('ports/items', remainingPorts, options);\n      }\n    } else {\n      options = portsForRemoval || {};\n      options.rewrite = true;\n      this.setPropByPath('ports/items', [], options);\n    }\n\n    return this;\n  }\n\n  getParsedPorts() {\n    return this.port.getPorts();\n  }\n\n  getParsedGroups() {\n    return this.port.groups;\n  }\n\n  getPortsLayoutByGroup(groupName, bbox) {\n    return this.port.getPortsLayoutByGroup(groupName, bbox);\n  }\n\n  initPorts() {\n    this.updatePortData();\n    this.on('change:ports', () => {\n      this.processRemovedPort();\n      this.updatePortData();\n    });\n  }\n\n  processRemovedPort() {\n    const current = this.ports;\n    const currentItemsMap = {};\n    current.items.forEach(item => {\n      if (item.id) {\n        currentItemsMap[item.id] = true;\n      }\n    });\n    const removed = {};\n    const previous = this.store.getPrevious('ports') || {\n      items: []\n    };\n    previous.items.forEach(item => {\n      if (item.id && !currentItemsMap[item.id]) {\n        removed[item.id] = true;\n      }\n    });\n    const model = this.model;\n\n    if (model && !ObjectExt.isEmpty(removed)) {\n      const incomings = model.getConnectedEdges(this, {\n        incoming: true\n      });\n      incomings.forEach(edge => {\n        const portId = edge.getTargetPortId();\n\n        if (portId && removed[portId]) {\n          edge.remove();\n        }\n      });\n      const outgoings = model.getConnectedEdges(this, {\n        outgoing: true\n      });\n      outgoings.forEach(edge => {\n        const portId = edge.getSourcePortId();\n\n        if (portId && removed[portId]) {\n          edge.remove();\n        }\n      });\n    }\n  }\n\n  validatePorts() {\n    const ids = {};\n    const errors = [];\n    this.ports.items.forEach(p => {\n      if (typeof p !== 'object') {\n        errors.push(`Invalid port ${p}.`);\n      }\n\n      if (p.id == null) {\n        p.id = this.generatePortId();\n      }\n\n      if (ids[p.id]) {\n        errors.push('Duplicitied port id.');\n      }\n\n      ids[p.id] = true;\n    });\n    return errors;\n  }\n\n  generatePortId() {\n    return StringExt.uuid();\n  }\n\n  updatePortData() {\n    const err = this.validatePorts();\n\n    if (err.length > 0) {\n      this.store.set('ports', this.store.getPrevious('ports'));\n      throw new Error(err.join(' '));\n    }\n\n    const prev = this.port ? this.port.getPorts() : null;\n    this.port = new PortManager(this.ports);\n    const curr = this.port.getPorts();\n    const added = prev ? curr.filter(item => {\n      if (!prev.find(prevPort => prevPort.id === item.id)) {\n        return item;\n      }\n\n      return null;\n    }) : [...curr];\n    const removed = prev ? prev.filter(item => {\n      if (!curr.find(curPort => curPort.id === item.id)) {\n        return item;\n      }\n\n      return null;\n    }) : [];\n\n    if (added.length > 0) {\n      this.notify('ports:added', {\n        added,\n        cell: this,\n        node: this\n      });\n    }\n\n    if (removed.length > 0) {\n      this.notify('ports:removed', {\n        removed,\n        cell: this,\n        node: this\n      });\n    }\n  }\n\n}\nNode.defaults = {\n  angle: 0,\n  position: {\n    x: 0,\n    y: 0\n  },\n  size: {\n    width: 1,\n    height: 1\n  }\n};\n\n(function (Node) {\n  Node.toStringTag = `X6.${Node.name}`;\n\n  function isNode(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Node) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const node = instance;\n\n    if ((tag == null || tag === Node.toStringTag) && typeof node.isNode === 'function' && typeof node.isEdge === 'function' && typeof node.prop === 'function' && typeof node.attr === 'function' && typeof node.size === 'function' && typeof node.position === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Node.isNode = isNode;\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.config({\n    propHooks(_a) {\n      var {\n        ports\n      } = _a,\n          metadata = __rest(_a, [\"ports\"]);\n\n      if (ports) {\n        metadata.ports = Array.isArray(ports) ? {\n          items: ports\n        } : ports;\n      }\n\n      return metadata;\n    }\n\n  });\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.registry = Registry.create({\n    type: 'node',\n\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, true)) {\n        throw new Error(`Node with name '${shape}' was registered by anthor Edge`);\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape\n        });\n        return options;\n      }\n\n      let parent = Node;\n\n      const {\n        inherit\n      } = options,\n            config = __rest(options, [\"inherit\"]);\n\n      if (inherit) {\n        if (typeof inherit === 'string') {\n          const base = this.get(inherit);\n\n          if (base == null) {\n            this.onNotFound(inherit, 'inherited');\n          } else {\n            parent = base;\n          }\n        } else {\n          parent = inherit;\n        }\n      }\n\n      if (config.constructorName == null) {\n        config.constructorName = shape;\n      }\n\n      const ctor = parent.define.call(parent, config);\n      ctor.config({\n        shape\n      });\n      return ctor;\n    }\n\n  });\n  ShareRegistry.setNodeRegistry(Node.registry);\n})(Node || (Node = {}));\n\n(function (Node) {\n  let counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return `CustomNode${counter}`;\n  }\n\n  function define(config) {\n    const {\n      constructorName,\n      overwrite\n    } = config,\n          others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Node.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Node.define = define;\n\n  function create(options) {\n    const shape = options.shape || 'rect';\n    const Ctor = Node.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Node.registry.onNotFound(shape);\n  }\n\n  Node.create = create;\n})(Node || (Node = {}));","map":null,"metadata":{},"sourceType":"module"}