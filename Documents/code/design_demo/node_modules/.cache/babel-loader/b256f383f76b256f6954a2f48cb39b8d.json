{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Util } from '../../global';\nimport { Rectangle, Angle } from '../../geometry';\nimport { ObjectExt, StringExt, FunctionExt } from '../../util';\nimport { Cell } from '../../model/cell';\nimport { Collection } from '../../model/collection';\nimport { View } from '../../view/view';\nimport { notify } from '../transform/util';\nimport { Handle } from '../common';\nexport class Selection extends View {\n  constructor(options) {\n    super();\n    this.options = ObjectExt.merge({}, Private.defaultOptions, options);\n\n    if (this.options.model) {\n      this.options.collection = this.options.model.collection;\n    }\n\n    if (this.options.collection) {\n      this.collection = this.options.collection;\n    } else {\n      this.collection = new Collection([], {\n        comparator: Private.depthComparator\n      });\n      this.options.collection = this.collection;\n    }\n\n    this.boxCount = 0;\n    this.createContainer();\n    this.initHandles();\n    this.startListening();\n  }\n\n  get graph() {\n    return this.options.graph;\n  }\n\n  get boxClassName() {\n    return this.prefixClassName(Private.classNames.box);\n  }\n\n  get $boxes() {\n    return this.$container.children(`.${this.boxClassName}`);\n  }\n\n  get handleOptions() {\n    return this.options;\n  }\n\n  startListening() {\n    const graph = this.graph;\n    const collection = this.collection;\n    this.delegateEvents({\n      [`mousedown .${this.boxClassName}`]: 'onSelectionBoxMouseDown',\n      [`touchstart .${this.boxClassName}`]: 'onSelectionBoxMouseDown'\n    }, true);\n    graph.on('scale', this.onGraphTransformed, this);\n    graph.on('translate', this.onGraphTransformed, this);\n    graph.model.on('updated', this.onModelUpdated, this);\n    collection.on('added', this.onCellAdded, this);\n    collection.on('removed', this.onCellRemoved, this);\n    collection.on('reseted', this.onReseted, this);\n    collection.on('updated', this.onCollectionUpdated, this);\n    collection.on('node:change:position', this.onNodePositionChanged, this);\n    collection.on('cell:changed', this.onCellChanged, this);\n  }\n\n  stopListening() {\n    const graph = this.graph;\n    const collection = this.collection;\n    this.undelegateEvents();\n    graph.off('scale', this.onGraphTransformed, this);\n    graph.off('translate', this.onGraphTransformed, this);\n    graph.model.off('updated', this.onModelUpdated, this);\n    collection.off('added', this.onCellAdded, this);\n    collection.off('removed', this.onCellRemoved, this);\n    collection.off('reseted', this.onReseted, this);\n    collection.off('updated', this.onCollectionUpdated, this);\n    collection.off('node:change:position', this.onNodePositionChanged, this);\n    collection.off('cell:changed', this.onCellChanged, this);\n  }\n\n  onRemove() {\n    this.stopListening();\n  }\n\n  onGraphTransformed() {\n    this.updateSelectionBoxes({\n      async: false\n    });\n  }\n\n  onCellChanged() {\n    this.updateSelectionBoxes();\n  }\n\n  onNodePositionChanged(_ref) {\n    let {\n      node,\n      options\n    } = _ref;\n    const {\n      showNodeSelectionBox,\n      pointerEvents\n    } = this.options;\n    const {\n      ui,\n      selection\n    } = options;\n    let allowTranslating = !this.translating;\n    /* Scenarios where this method is not called:\n     * 1. ShowNodeSelection is true or ponterEvents is none\n     * 2. Avoid circular calls with the selection tag\n     */\n\n    allowTranslating = allowTranslating && (showNodeSelectionBox !== true || pointerEvents === 'none');\n    allowTranslating = allowTranslating && ui && !selection;\n\n    if (allowTranslating) {\n      this.translating = true;\n      const current = node.position();\n      const previous = node.previous('position');\n      const dx = current.x - previous.x;\n      const dy = current.y - previous.y;\n\n      if (dx !== 0 || dy !== 0) {\n        this.translateSelectedNodes(dx, dy, node, options);\n      }\n\n      this.translating = false;\n    }\n  }\n\n  onModelUpdated(_ref2) {\n    let {\n      removed\n    } = _ref2;\n\n    if (removed && removed.length) {\n      this.unselect(removed);\n    }\n  }\n\n  isEmpty() {\n    return this.length <= 0;\n  }\n\n  isSelected(cell) {\n    return this.collection.has(cell);\n  }\n\n  get length() {\n    return this.collection.length;\n  }\n\n  get cells() {\n    return this.collection.toArray();\n  }\n\n  select(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.dryrun = true;\n    const items = this.filter(Array.isArray(cells) ? cells : [cells]);\n    this.collection.add(items, options);\n    return this;\n  }\n\n  unselect(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // dryrun to prevent cell be removed from graph\n    options.dryrun = true;\n    this.collection.remove(Array.isArray(cells) ? cells : [cells], options);\n    return this;\n  }\n\n  reset(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (cells) {\n      if (options.batch) {\n        const filterCells = this.filter(Array.isArray(cells) ? cells : [cells]);\n        this.collection.reset(filterCells, Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n        return this;\n      }\n\n      const prev = this.cells;\n      const next = this.filter(Array.isArray(cells) ? cells : [cells]);\n      const prevMap = {};\n      const nextMap = {};\n      prev.forEach(cell => prevMap[cell.id] = cell);\n      next.forEach(cell => nextMap[cell.id] = cell);\n      const added = [];\n      const removed = [];\n      next.forEach(cell => {\n        if (!prevMap[cell.id]) {\n          added.push(cell);\n        }\n      });\n      prev.forEach(cell => {\n        if (!nextMap[cell.id]) {\n          removed.push(cell);\n        }\n      });\n\n      if (removed.length) {\n        this.unselect(removed, Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n      }\n\n      if (added.length) {\n        this.select(added, Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n      }\n\n      if (removed.length === 0 && added.length === 0) {\n        this.updateContainer();\n      }\n\n      return this;\n    }\n\n    return this.clean(options);\n  }\n\n  clean() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.length) {\n      if (options.batch === false) {\n        this.unselect(this.cells, options);\n      } else {\n        this.collection.reset([], Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n      }\n    }\n\n    return this;\n  }\n\n  setFilter(filter) {\n    this.options.filter = filter;\n  }\n\n  setContent(content) {\n    this.options.content = content;\n  }\n\n  startSelecting(evt) {\n    // Flow: startSelecting => adjustSelection => stopSelecting\n    evt = this.normalizeEvent(evt); // eslint-disable-line\n\n    this.clean();\n    let x;\n    let y;\n    const graphContainer = this.graph.container;\n\n    if (evt.offsetX != null && evt.offsetY != null && graphContainer.contains(evt.target)) {\n      x = evt.offsetX;\n      y = evt.offsetY;\n    } else {\n      const offset = this.$(graphContainer).offset();\n      const scrollLeft = graphContainer.scrollLeft;\n      const scrollTop = graphContainer.scrollTop;\n      x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;\n      y = evt.clientY - offset.top + window.pageYOffset + scrollTop;\n    }\n\n    this.$container.css({\n      top: y,\n      left: x,\n      width: 1,\n      height: 1\n    });\n    this.setEventData(evt, {\n      action: 'selecting',\n      clientX: evt.clientX,\n      clientY: evt.clientY,\n      offsetX: x,\n      offsetY: y,\n      scrollerX: 0,\n      scrollerY: 0\n    });\n    this.delegateDocumentEvents(Private.documentEvents, evt.data);\n  }\n\n  filter(cells) {\n    const filter = this.options.filter;\n\n    if (Array.isArray(filter)) {\n      return cells.filter(cell => !filter.includes(cell) && !filter.includes(cell.shape));\n    }\n\n    if (typeof filter === 'function') {\n      return cells.filter(cell => FunctionExt.call(filter, this.graph, cell));\n    }\n\n    return cells;\n  }\n\n  stopSelecting(evt) {\n    const graph = this.graph;\n    const eventData = this.getEventData(evt);\n    const action = eventData.action;\n\n    switch (action) {\n      case 'selecting':\n        {\n          let width = this.$container.width();\n          let height = this.$container.height();\n          const offset = this.$container.offset();\n          const origin = graph.pageToLocal(offset.left, offset.top);\n          const scale = graph.transform.getScale();\n          width /= scale.sx;\n          height /= scale.sy;\n          const rect = new Rectangle(origin.x, origin.y, width, height);\n          const cells = this.getCellViewsInArea(rect).map(view => view.cell);\n          this.reset(cells, {\n            batch: true\n          });\n          this.hideRubberband();\n          break;\n        }\n\n      case 'translating':\n        {\n          const client = graph.snapToGrid(evt.clientX, evt.clientY);\n\n          if (!this.options.following) {\n            const data = eventData;\n            this.updateSelectedNodesPosition({\n              dx: data.clientX - data.originX,\n              dy: data.clientY - data.originY\n            });\n          }\n\n          this.graph.model.stopBatch('move-selection');\n          this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);\n          break;\n        }\n\n      default:\n        {\n          this.clean();\n          break;\n        }\n    }\n  }\n\n  onMouseUp(evt) {\n    const action = this.getEventData(evt).action;\n\n    if (action) {\n      this.stopSelecting(evt);\n      this.undelegateDocumentEvents();\n    }\n  }\n\n  onSelectionBoxMouseDown(evt) {\n    if (!this.options.following) {\n      evt.stopPropagation();\n    }\n\n    const e = this.normalizeEvent(evt);\n\n    if (this.options.movable) {\n      this.startTranslating(e);\n    }\n\n    const activeView = this.getCellViewFromElem(e.target);\n    this.setEventData(e, {\n      activeView\n    });\n    const client = this.graph.snapToGrid(e.clientX, e.clientY);\n    this.notifyBoxEvent('box:mousedown', e, client.x, client.y);\n    this.delegateDocumentEvents(Private.documentEvents, e.data);\n  }\n\n  startTranslating(evt) {\n    this.graph.model.startBatch('move-selection');\n    const client = this.graph.snapToGrid(evt.clientX, evt.clientY);\n    this.setEventData(evt, {\n      action: 'translating',\n      clientX: client.x,\n      clientY: client.y,\n      originX: client.x,\n      originY: client.y\n    });\n  }\n\n  getSelectionOffset(client, data) {\n    let dx = client.x - data.clientX;\n    let dy = client.y - data.clientY;\n    const restrict = this.graph.hook.getRestrictArea();\n\n    if (restrict) {\n      const cells = this.collection.toArray();\n      const totalBBox = Cell.getCellsBBox(cells, {\n        deep: true\n      }) || Rectangle.create();\n      const minDx = restrict.x - totalBBox.x;\n      const minDy = restrict.y - totalBBox.y;\n      const maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);\n      const maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);\n\n      if (dx < minDx) {\n        dx = minDx;\n      }\n\n      if (dy < minDy) {\n        dy = minDy;\n      }\n\n      if (maxDx < dx) {\n        dx = maxDx;\n      }\n\n      if (maxDy < dy) {\n        dy = maxDy;\n      }\n\n      if (!this.options.following) {\n        const offsetX = client.x - data.originX;\n        const offsetY = client.y - data.originY;\n        dx = offsetX <= minDx || offsetX >= maxDx ? 0 : dx;\n        dy = offsetY <= minDy || offsetY >= maxDy ? 0 : dy;\n      }\n    }\n\n    return {\n      dx,\n      dy\n    };\n  }\n\n  updateSelectedNodesPosition(offset) {\n    const {\n      dx,\n      dy\n    } = offset;\n\n    if (dx || dy) {\n      if (this.translateSelectedNodes(dx, dy), this.boxesUpdated) {\n        if (this.collection.length > 1) {\n          this.updateSelectionBoxes();\n        }\n      } else {\n        const scale = this.graph.transform.getScale();\n        this.$boxes.add(this.$selectionContainer).css({\n          left: `+=${dx * scale.sx}`,\n          top: `+=${dy * scale.sy}`\n        });\n      }\n    }\n  }\n\n  autoScrollGraph(x, y) {\n    const scroller = this.graph.scroller.widget;\n\n    if (scroller) {\n      return scroller.autoScroll(x, y);\n    }\n\n    return {\n      scrollerX: 0,\n      scrollerY: 0\n    };\n  }\n\n  adjustSelection(evt) {\n    const e = this.normalizeEvent(evt);\n    const eventData = this.getEventData(e);\n    const action = eventData.action;\n\n    switch (action) {\n      case 'selecting':\n        {\n          const data = eventData;\n\n          if (data.moving !== true) {\n            this.$container.appendTo(this.graph.container);\n            this.showRubberband();\n            data.moving = true;\n          }\n\n          const {\n            scrollerX,\n            scrollerY\n          } = this.autoScrollGraph(e.clientX, e.clientY);\n          data.scrollerX += scrollerX;\n          data.scrollerY += scrollerY;\n          const dx = e.clientX - data.clientX + data.scrollerX;\n          const dy = e.clientY - data.clientY + data.scrollerY;\n          const left = parseInt(this.$container.css('left'), 10);\n          const top = parseInt(this.$container.css('top'), 10);\n          this.$container.css({\n            left: dx < 0 ? data.offsetX + dx : left,\n            top: dy < 0 ? data.offsetY + dy : top,\n            width: Math.abs(dx),\n            height: Math.abs(dy)\n          });\n          break;\n        }\n\n      case 'translating':\n        {\n          const client = this.graph.snapToGrid(e.clientX, e.clientY);\n          const data = eventData;\n          const offset = this.getSelectionOffset(client, data);\n\n          if (this.options.following) {\n            this.updateSelectedNodesPosition(offset);\n          } else {\n            this.updateContainerPosition(offset);\n          }\n\n          if (offset.dx) {\n            data.clientX = client.x;\n          }\n\n          if (offset.dy) {\n            data.clientY = client.y;\n          }\n\n          this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    this.boxesUpdated = false;\n  }\n\n  translateSelectedNodes(dx, dy, exclude, otherOptions) {\n    const map = {};\n    const excluded = [];\n\n    if (exclude) {\n      map[exclude.id] = true;\n    }\n\n    this.collection.toArray().forEach(cell => {\n      cell.getDescendants({\n        deep: true\n      }).forEach(child => {\n        map[child.id] = true;\n      });\n    });\n\n    if (otherOptions && otherOptions.translateBy) {\n      const currentCell = this.graph.getCellById(otherOptions.translateBy);\n\n      if (currentCell) {\n        map[currentCell.id] = true;\n        currentCell.getDescendants({\n          deep: true\n        }).forEach(child => {\n          map[child.id] = true;\n        });\n        excluded.push(currentCell);\n      }\n    }\n\n    this.collection.toArray().forEach(cell => {\n      if (!map[cell.id]) {\n        const options = Object.assign(Object.assign({}, otherOptions), {\n          selection: this.cid,\n          exclude: excluded\n        });\n        cell.translate(dx, dy, options);\n        this.graph.model.getConnectedEdges(cell).forEach(edge => {\n          if (!map[edge.id]) {\n            edge.translate(dx, dy, options);\n            map[edge.id] = true;\n          }\n        });\n      }\n    });\n  }\n\n  getCellViewsInArea(rect) {\n    const graph = this.graph;\n    const options = {\n      strict: this.options.strict\n    };\n    let views = [];\n\n    if (this.options.rubberNode) {\n      if (this.options.useCellGeometry) {\n        views = views.concat(graph.model.getNodesInArea(rect, options).map(node => graph.renderer.findViewByCell(node)).filter(view => view != null));\n      } else {\n        views = views.concat(graph.renderer.findViewsInArea(rect, options));\n      }\n    }\n\n    if (this.options.rubberEdge) {\n      if (this.options.useCellGeometry) {\n        views = views.concat(graph.model.getEdgesInArea(rect, options).map(edge => graph.renderer.findViewByCell(edge)).filter(view => view != null));\n      } else {\n        views = views.concat(graph.renderer.findEdgeViewsInArea(rect, options));\n      }\n    }\n\n    return views;\n  }\n\n  notifyBoxEvent(name, e, x, y) {\n    const data = this.getEventData(e);\n    const view = data.activeView;\n    this.trigger(name, {\n      e,\n      view,\n      x,\n      y,\n      cell: view.cell\n    });\n  }\n\n  getSelectedClassName(cell) {\n    return this.prefixClassName(`${cell.isNode() ? 'node' : 'edge'}-selected`);\n  }\n\n  addCellSelectedClassName(cell) {\n    const view = this.graph.renderer.findViewByCell(cell);\n\n    if (view) {\n      view.addClass(this.getSelectedClassName(cell));\n    }\n  }\n\n  removeCellUnSelectedClassName(cell) {\n    const view = this.graph.renderer.findViewByCell(cell);\n\n    if (view) {\n      view.removeClass(this.getSelectedClassName(cell));\n    }\n  }\n\n  destroySelectionBox(cell) {\n    this.removeCellUnSelectedClassName(cell);\n\n    if (this.canShowSelectionBox(cell)) {\n      this.$container.find(`[data-cell-id=\"${cell.id}\"]`).remove();\n\n      if (this.$boxes.length === 0) {\n        this.hide();\n      }\n\n      this.boxCount = Math.max(0, this.boxCount - 1);\n    }\n  }\n\n  destroyAllSelectionBoxes(cells) {\n    cells.forEach(cell => this.removeCellUnSelectedClassName(cell));\n    this.hide();\n    this.$boxes.remove();\n    this.boxCount = 0;\n  }\n\n  hide() {\n    this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband)).removeClass(this.prefixClassName(Private.classNames.selected));\n  }\n\n  showRubberband() {\n    this.$container.addClass(this.prefixClassName(Private.classNames.rubberband));\n  }\n\n  hideRubberband() {\n    this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband));\n  }\n\n  showSelected() {\n    this.$container.removeAttr('style').addClass(this.prefixClassName(Private.classNames.selected));\n  }\n\n  createContainer() {\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container);\n    this.$container.addClass(this.prefixClassName(Private.classNames.root));\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n\n    this.$selectionContainer = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.inner));\n    this.$selectionContent = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.content));\n    this.$selectionContainer.append(this.$selectionContent);\n    this.$selectionContainer.attr('data-selection-length', this.collection.length);\n    this.$container.prepend(this.$selectionContainer);\n    this.$handleContainer = this.$selectionContainer;\n  }\n\n  updateContainerPosition(offset) {\n    if (offset.dx || offset.dy) {\n      this.$selectionContainer.css({\n        left: `+=${offset.dx}`,\n        top: `+=${offset.dy}`\n      });\n    }\n  }\n\n  updateContainer() {\n    const origin = {\n      x: Infinity,\n      y: Infinity\n    };\n    const corner = {\n      x: 0,\n      y: 0\n    };\n    const cells = this.collection.toArray().filter(cell => this.canShowSelectionBox(cell));\n    cells.forEach(cell => {\n      const view = this.graph.renderer.findViewByCell(cell);\n\n      if (view) {\n        const bbox = view.getBBox({\n          useCellGeometry: this.options.useCellGeometry\n        });\n        origin.x = Math.min(origin.x, bbox.x);\n        origin.y = Math.min(origin.y, bbox.y);\n        corner.x = Math.max(corner.x, bbox.x + bbox.width);\n        corner.y = Math.max(corner.y, bbox.y + bbox.height);\n      }\n    });\n    this.$selectionContainer.css({\n      position: 'absolute',\n      pointerEvents: 'none',\n      left: origin.x,\n      top: origin.y,\n      width: corner.x - origin.x,\n      height: corner.y - origin.y\n    }).attr('data-selection-length', this.collection.length);\n    const boxContent = this.options.content;\n\n    if (boxContent) {\n      if (typeof boxContent === 'function') {\n        const content = FunctionExt.call(boxContent, this.graph, this, this.$selectionContent[0]);\n\n        if (content) {\n          this.$selectionContent.html(content);\n        }\n      } else {\n        this.$selectionContent.html(boxContent);\n      }\n    }\n\n    if (this.collection.length > 0 && !this.container.parentNode) {\n      this.$container.appendTo(this.graph.container);\n    } else if (this.collection.length <= 0 && this.container.parentNode) {\n      this.container.parentNode.removeChild(this.container);\n    }\n  }\n\n  canShowSelectionBox(cell) {\n    return cell.isNode() && this.options.showNodeSelectionBox === true || cell.isEdge() && this.options.showEdgeSelectionBox === true;\n  }\n\n  createSelectionBox(cell) {\n    this.addCellSelectedClassName(cell);\n\n    if (this.canShowSelectionBox(cell)) {\n      const view = this.graph.renderer.findViewByCell(cell);\n\n      if (view) {\n        const bbox = view.getBBox({\n          useCellGeometry: this.options.useCellGeometry\n        });\n        const className = this.boxClassName;\n        this.$('<div/>').addClass(className).addClass(`${className}-${cell.isNode() ? 'node' : 'edge'}`).attr('data-cell-id', cell.id).css({\n          position: 'absolute',\n          left: bbox.x,\n          top: bbox.y,\n          width: bbox.width,\n          height: bbox.height,\n          pointerEvents: this.options.pointerEvents || 'auto'\n        }).appendTo(this.container);\n        this.showSelected();\n        this.boxCount += 1;\n      }\n    }\n  }\n\n  updateSelectionBoxes() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.collection.length > 0) {\n      this.boxesUpdated = true;\n      this.graph.renderer.requestViewUpdate(this, 1, 2, options);\n    }\n  }\n\n  confirmUpdate() {\n    if (this.boxCount) {\n      this.hide();\n      this.$boxes.each((_, elem) => {\n        const cellId = this.$(elem).remove().attr('data-cell-id');\n        const cell = this.collection.get(cellId);\n\n        if (cell) {\n          this.createSelectionBox(cell);\n        }\n      });\n      this.updateContainer();\n    }\n\n    return 0;\n  }\n\n  getCellViewFromElem(elem) {\n    const id = elem.getAttribute('data-cell-id');\n\n    if (id) {\n      const cell = this.collection.get(id);\n\n      if (cell) {\n        return this.graph.renderer.findViewByCell(cell);\n      }\n    }\n\n    return null;\n  }\n\n  onCellRemoved(_ref3) {\n    let {\n      cell\n    } = _ref3;\n    this.destroySelectionBox(cell);\n    this.updateContainer();\n  }\n\n  onReseted(_ref4) {\n    let {\n      previous,\n      current\n    } = _ref4;\n    this.destroyAllSelectionBoxes(previous);\n    current.forEach(cell => {\n      this.listenCellRemoveEvent(cell);\n      this.createSelectionBox(cell);\n    });\n    this.updateContainer();\n  }\n\n  onCellAdded(_ref5) {\n    let {\n      cell\n    } = _ref5;\n    // The collection do not known the cell was removed when cell was\n    // removed by interaction(such as, by \"delete\" shortcut), so we should\n    // manually listen to cell's remove evnet.\n    this.listenCellRemoveEvent(cell);\n    this.createSelectionBox(cell);\n    this.updateContainer();\n  }\n\n  listenCellRemoveEvent(cell) {\n    cell.off('removed', this.onCellRemoved, this);\n    cell.on('removed', this.onCellRemoved, this);\n  }\n\n  onCollectionUpdated(_ref6) {\n    let {\n      added,\n      removed,\n      options\n    } = _ref6;\n    added.forEach(cell => {\n      this.trigger('cell:selected', {\n        cell,\n        options\n      });\n      this.graph.trigger('cell:selected', {\n        cell,\n        options\n      });\n\n      if (cell.isNode()) {\n        this.trigger('node:selected', {\n          cell,\n          options,\n          node: cell\n        });\n        this.graph.trigger('node:selected', {\n          cell,\n          options,\n          node: cell\n        });\n      } else if (cell.isEdge()) {\n        this.trigger('edge:selected', {\n          cell,\n          options,\n          edge: cell\n        });\n        this.graph.trigger('edge:selected', {\n          cell,\n          options,\n          edge: cell\n        });\n      }\n    });\n    removed.forEach(cell => {\n      this.trigger('cell:unselected', {\n        cell,\n        options\n      });\n      this.graph.trigger('cell:unselected', {\n        cell,\n        options\n      });\n\n      if (cell.isNode()) {\n        this.trigger('node:unselected', {\n          cell,\n          options,\n          node: cell\n        });\n        this.graph.trigger('node:unselected', {\n          cell,\n          options,\n          node: cell\n        });\n      } else if (cell.isEdge()) {\n        this.trigger('edge:unselected', {\n          cell,\n          options,\n          edge: cell\n        });\n        this.graph.trigger('edge:unselected', {\n          cell,\n          options,\n          edge: cell\n        });\n      }\n    });\n    const args = {\n      added,\n      removed,\n      options,\n      selected: this.cells\n    };\n    this.trigger('selection:changed', args);\n    this.graph.trigger('selection:changed', args);\n  } // #region handle\n\n\n  deleteSelectedCells() {\n    const cells = this.collection.toArray();\n    this.clean();\n    this.graph.model.removeCells(cells, {\n      selection: this.cid\n    });\n  }\n\n  startRotate(_ref7) {\n    let {\n      e\n    } = _ref7;\n    const cells = this.collection.toArray();\n    const center = Cell.getCellsBBox(cells).getCenter();\n    const client = this.graph.snapToGrid(e.clientX, e.clientY);\n    const angles = cells.reduce((memo, cell) => {\n      memo[cell.id] = Angle.normalize(cell.getAngle());\n      return memo;\n    }, {});\n    this.setEventData(e, {\n      center,\n      angles,\n      start: client.theta(center)\n    });\n  }\n\n  doRotate(_ref8) {\n    let {\n      e\n    } = _ref8;\n    const data = this.getEventData(e);\n    const grid = this.graph.options.rotating.grid;\n    const gridSize = typeof grid === 'function' ? FunctionExt.call(grid, this.graph, null) : grid;\n    const client = this.graph.snapToGrid(e.clientX, e.clientY);\n    const delta = data.start - client.theta(data.center);\n\n    if (!data.rotated) {\n      data.rotated = true;\n    }\n\n    if (Math.abs(delta) > 0.001) {\n      this.collection.toArray().forEach(node => {\n        const angle = Util.snapToGrid(data.angles[node.id] + delta, gridSize || 15);\n        node.rotate(angle, {\n          absolute: true,\n          center: data.center,\n          selection: this.cid\n        });\n      });\n      this.updateSelectionBoxes();\n    }\n  }\n\n  stopRotate(_ref9) {\n    let {\n      e\n    } = _ref9;\n    const data = this.getEventData(e);\n\n    if (data.rotated) {\n      data.rotated = false;\n      this.collection.toArray().forEach(node => {\n        notify('node:rotated', e, this.graph.findViewByCell(node));\n      });\n    }\n  }\n\n  startResize(_ref10) {\n    let {\n      e\n    } = _ref10;\n    const gridSize = this.graph.getGridSize();\n    const cells = this.collection.toArray();\n    const bbox = Cell.getCellsBBox(cells);\n    const bboxes = cells.map(cell => cell.getBBox());\n    const maxWidth = bboxes.reduce((maxWidth, bbox) => {\n      return bbox.width < maxWidth ? bbox.width : maxWidth;\n    }, Infinity);\n    const maxHeight = bboxes.reduce((maxHeight, bbox) => {\n      return bbox.height < maxHeight ? bbox.height : maxHeight;\n    }, Infinity);\n    this.setEventData(e, {\n      bbox,\n      cells: this.graph.model.getSubGraph(cells),\n      minWidth: gridSize * bbox.width / maxWidth,\n      minHeight: gridSize * bbox.height / maxHeight\n    });\n  }\n\n  doResize(_ref11) {\n    let {\n      e,\n      dx,\n      dy\n    } = _ref11;\n    const data = this.eventData(e);\n    const bbox = data.bbox;\n    const width = bbox.width;\n    const height = bbox.height;\n    const newWidth = Math.max(width + dx, data.minWidth);\n    const newHeight = Math.max(height + dy, data.minHeight);\n\n    if (!data.resized) {\n      data.resized = true;\n    }\n\n    if (Math.abs(width - newWidth) > 0.001 || Math.abs(height - newHeight) > 0.001) {\n      this.graph.model.resizeCells(newWidth, newHeight, data.cells, {\n        selection: this.cid\n      });\n      bbox.width = newWidth;\n      bbox.height = newHeight;\n      this.updateSelectionBoxes();\n    }\n  }\n\n  stopResize(_ref12) {\n    let {\n      e\n    } = _ref12;\n    const data = this.eventData(e);\n\n    if (data.resized) {\n      data.resized = false;\n      this.collection.toArray().forEach(node => {\n        notify('node:resized', e, this.graph.findViewByCell(node));\n      });\n    }\n  } // #endregion\n\n\n  dispose() {\n    this.clean();\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Selection.prototype, \"dispose\", null);\n\nObjectExt.applyMixins(Selection, Handle); // private\n// -------\n\nvar Private;\n\n(function (Private) {\n  const base = 'widget-selection';\n  Private.classNames = {\n    root: base,\n    inner: `${base}-inner`,\n    box: `${base}-box`,\n    content: `${base}-content`,\n    rubberband: `${base}-rubberband`,\n    selected: `${base}-selected`\n  };\n  Private.documentEvents = {\n    mousemove: 'adjustSelection',\n    touchmove: 'adjustSelection',\n    mouseup: 'onMouseUp',\n    touchend: 'onMouseUp',\n    touchcancel: 'onMouseUp'\n  };\n  Private.defaultOptions = {\n    movable: true,\n    following: true,\n    strict: false,\n    useCellGeometry: false,\n\n    content(selection) {\n      return StringExt.template('<%= length %> node<%= length > 1 ? \"s\":\"\" %> selected.')({\n        length: selection.length\n      });\n    },\n\n    handles: [{\n      name: 'remove',\n      position: 'nw',\n      events: {\n        mousedown: 'deleteSelectedCells'\n      }\n    }, {\n      name: 'rotate',\n      position: 'sw',\n      events: {\n        mousedown: 'startRotate',\n        mousemove: 'doRotate',\n        mouseup: 'stopRotate'\n      }\n    }, {\n      name: 'resize',\n      position: 'se',\n      events: {\n        mousedown: 'startResize',\n        mousemove: 'doResize',\n        mouseup: 'stopResize'\n      }\n    }]\n  };\n\n  function depthComparator(cell) {\n    return cell.getAncestors().length;\n  }\n\n  Private.depthComparator = depthComparator;\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}