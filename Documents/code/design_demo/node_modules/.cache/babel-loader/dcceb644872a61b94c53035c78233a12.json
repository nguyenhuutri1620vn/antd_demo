{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _temp;\n\nimport { inject, injectable } from 'inversify';\nimport { createEntity } from '../..';\nimport { IDENTIFIER } from '../../identifier';\nimport { gl } from '../renderer/gl';\nexport var GeometrySystem = (_dec = injectable(), _dec2 = inject(IDENTIFIER.GeometryComponentManager), _dec3 = inject(IDENTIFIER.RenderEngine), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {\n  function GeometrySystem() {\n    _classCallCheck(this, GeometrySystem);\n\n    _initializerDefineProperty(this, \"geometry\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"engine\", _descriptor2, this);\n  }\n\n  _createClass(GeometrySystem, [{\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.geometry.forEach(function (entity, component) {\n                  // build buffers for each geometry\n                  if (component.dirty) {\n                    component.attributes.forEach(function (attribute) {\n                      if (attribute.dirty && attribute.data) {\n                        if (!attribute.buffer) {\n                          attribute.buffer = _this.engine.createBuffer({\n                            data: attribute.data,\n                            type: gl.FLOAT\n                          });\n                        } else {\n                          var _attribute$buffer;\n\n                          (_attribute$buffer = attribute.buffer) === null || _attribute$buffer === void 0 ? void 0 : _attribute$buffer.subData({\n                            data: attribute.data,\n                            // TODO: support offset in subdata\n                            offset: 0\n                          });\n                        }\n\n                        attribute.dirty = false;\n                      }\n                    }); // create index buffer if needed\n\n                    if (component.indices) {\n                      if (!component.indicesBuffer) {\n                        component.indicesBuffer = _this.engine.createElements({\n                          data: component.indices,\n                          count: component.indices.length,\n                          type: gl.UNSIGNED_INT,\n                          usage: gl.STATIC_DRAW\n                        });\n                      } else {\n                        component.indicesBuffer.subData({\n                          data: component.indices,\n                          offset: 0\n                        });\n                      }\n                    }\n\n                    component.dirty = false;\n                  }\n                });\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute() {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.geometry.forEach(function (_, geometry) {\n        if (geometry.indicesBuffer) {\n          geometry.indicesBuffer.destroy();\n        }\n\n        geometry.attributes.forEach(function (attribute) {\n          if (attribute.buffer) {\n            attribute.buffer.destroy();\n          }\n        });\n      });\n      this.geometry.clear();\n    }\n    /**\n     * @see https://threejs.org/docs/#api/en/core/BufferGeometry\n     */\n\n  }, {\n    key: \"createBufferGeometry\",\n    value: function createBufferGeometry() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        vertexCount: 3\n      },\n          vertexCount = _ref.vertexCount;\n\n      var entity = createEntity();\n      return this.geometry.create(entity, {\n        vertexCount: vertexCount\n      });\n    }\n    /**\n     * @see https://threejs.org/docs/#api/en/core/InstancedBufferGeometry\n     */\n\n  }, {\n    key: \"createInstancedBufferGeometry\",\n    value: function createInstancedBufferGeometry(_ref2) {\n      var maxInstancedCount = _ref2.maxInstancedCount,\n          vertexCount = _ref2.vertexCount;\n      var entity = createEntity();\n      return this.geometry.create(entity, {\n        maxInstancedCount: maxInstancedCount,\n        vertexCount: vertexCount\n      });\n    }\n  }]);\n\n  return GeometrySystem;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"geometry\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"engine\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":null,"metadata":{},"sourceType":"module"}