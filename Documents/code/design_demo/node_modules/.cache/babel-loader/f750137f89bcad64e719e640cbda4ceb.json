{"ast":null,"code":"import { Angle } from '../../geometry';\nimport { resolve } from './util';\n\nconst orthogonal = function (view, magnet, refPoint, options) {\n  const angle = view.cell.getAngle();\n  const bbox = view.getBBoxOfElement(magnet);\n  const result = bbox.getCenter();\n  const topLeft = bbox.getTopLeft();\n  const bottomRight = bbox.getBottomRight();\n  let padding = options.padding;\n\n  if (!Number.isFinite(padding)) {\n    padding = 0;\n  }\n\n  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n    const dy = refPoint.y - result.y;\n    result.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(Angle.toRad(angle));\n    result.y += dy;\n  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n    const dx = refPoint.x - result.x;\n    result.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));\n    result.x += dx;\n  }\n\n  return result;\n};\n/**\n * Tries to place the anchor of the edge inside the view bbox so that the\n * edge is made orthogonal. The anchor is placed along two line segments\n * inside the view bbox (between the centers of the top and bottom side and\n * between the centers of the left and right sides). If it is not possible\n * to place the anchor so that the edge would be orthogonal, the anchor is\n * placed at the center of the view bbox instead.\n */\n\n\nexport const orth = resolve(orthogonal);","map":null,"metadata":{},"sourceType":"module"}