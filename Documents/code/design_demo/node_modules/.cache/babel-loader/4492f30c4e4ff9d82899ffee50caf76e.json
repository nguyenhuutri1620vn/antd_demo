{"ast":null,"code":"import { Point } from './point';\nimport { Line } from './line';\nimport { Rectangle } from './rectangle';\nimport { Polyline } from './polyline';\nimport { Geometry } from './geometry';\nexport class Curve extends Geometry {\n  constructor(start, controlPoint1, controlPoint2, end) {\n    super();\n    this.PRECISION = 3;\n    this.start = Point.create(start);\n    this.controlPoint1 = Point.create(controlPoint1);\n    this.controlPoint2 = Point.create(controlPoint2);\n    this.end = Point.create(end);\n  }\n\n  get [Symbol.toStringTag]() {\n    return Curve.toStringTag;\n  }\n\n  bbox() {\n    const start = this.start;\n    const controlPoint1 = this.controlPoint1;\n    const controlPoint2 = this.controlPoint2;\n    const end = this.end;\n    const x0 = start.x;\n    const y0 = start.y;\n    const x1 = controlPoint1.x;\n    const y1 = controlPoint1.y;\n    const x2 = controlPoint2.x;\n    const y2 = controlPoint2.y;\n    const x3 = end.x;\n    const y3 = end.y;\n    const points = []; // local extremes\n\n    const tvalues = []; // t values of local extremes\n\n    const bounds = [[], []];\n    let a;\n    let b;\n    let c;\n    let t;\n    let t1;\n    let t2;\n    let b2ac;\n    let sqrtb2ac;\n\n    for (let i = 0; i < 2; i += 1) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n\n        t = -c / b;\n        if (t > 0 && t < 1) tvalues.push(t);\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n      if (b2ac < 0) continue;\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (t1 > 0 && t1 < 1) tvalues.push(t1);\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (t2 > 0 && t2 < 1) tvalues.push(t2);\n    }\n\n    let x;\n    let y;\n    let mt;\n    let j = tvalues.length;\n    const jlen = j;\n\n    while (j) {\n      j -= 1;\n      t = tvalues[j];\n      mt = 1 - t;\n      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[0][j] = x;\n      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n      bounds[1][j] = y;\n      points[j] = {\n        X: x,\n        Y: y\n      };\n    }\n\n    tvalues[jlen] = 0;\n    tvalues[jlen + 1] = 1;\n    points[jlen] = {\n      X: x0,\n      Y: y0\n    };\n    points[jlen + 1] = {\n      X: x3,\n      Y: y3\n    };\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    tvalues.length = jlen + 2;\n    bounds[0].length = jlen + 2;\n    bounds[1].length = jlen + 2;\n    points.length = jlen + 2;\n    const left = Math.min.apply(null, bounds[0]);\n    const top = Math.min.apply(null, bounds[1]);\n    const right = Math.max.apply(null, bounds[0]);\n    const bottom = Math.max.apply(null, bounds[1]);\n    return new Rectangle(left, top, right - left, bottom - top);\n  }\n\n  closestPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.pointAtT(this.closestPointT(p, options));\n  }\n\n  closestPointLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    return this.lengthAtT(this.closestPointT(p, opts), opts);\n  }\n\n  closestPointNormalizedLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n\n    if (!cpLength) {\n      return 0;\n    }\n\n    const length = this.length(opts);\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointT(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n\n    let investigatedSubdivision = null;\n    let investigatedSubdivisionStartT = 0;\n    let investigatedSubdivisionEndT = 0;\n    let distFromStart = 0;\n    let distFromEnd = 0;\n    let chordLength = 0;\n    let minSumDist = null;\n    const count = subdivisions.length;\n    let piece = count > 0 ? 1 / count : 0;\n    subdivisions.forEach((division, i) => {\n      const startDist = division.start.distance(p);\n      const endDist = division.end.distance(p);\n      const sumDist = startDist + endDist;\n\n      if (minSumDist == null || sumDist < minSumDist) {\n        investigatedSubdivision = division;\n        investigatedSubdivisionStartT = i * piece;\n        investigatedSubdivisionEndT = (i + 1) * piece;\n        distFromStart = startDist;\n        distFromEnd = endDist;\n        minSumDist = sumDist;\n        chordLength = division.endpointDistance();\n      }\n    }); // Recursively divide investigated subdivision, until distance between\n    // baselinePoint and closest path endpoint is within `10^(-precision)`,\n    // then return the closest endpoint of that final subdivision.\n    // eslint-disable-next-line\n\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      const startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;\n      const endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;\n      const hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\n      const hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n      const hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;\n\n      if (hasRequiredPrecision || hasMiniDistance) {\n        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n      } // otherwise, set up for next iteration\n\n\n      const divided = investigatedSubdivision.divide(0.5);\n      piece /= 2;\n      const startDist1 = divided[0].start.distance(p);\n      const endDist1 = divided[0].end.distance(p);\n      const sumDist1 = startDist1 + endDist1;\n      const startDist2 = divided[1].start.distance(p);\n      const endDist2 = divided[1].end.distance(p);\n      const sumDist2 = startDist2 + endDist2;\n\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= piece;\n        distFromStart = startDist1;\n        distFromEnd = endDist1;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += piece;\n        distFromStart = startDist2;\n        distFromEnd = endDist2;\n      }\n    }\n  }\n\n  closestPointTangent(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.tangentAtT(this.closestPointT(p, options));\n  }\n\n  containsPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const polyline = this.toPolyline(options);\n    return polyline.containsPoint(p);\n  }\n\n  divideAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ratio <= 0) {\n      return this.divideAtT(0);\n    }\n\n    if (ratio >= 1) {\n      return this.divideAtT(1);\n    }\n\n    const t = this.tAt(ratio, options);\n    return this.divideAtT(t);\n  }\n\n  divideAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const t = this.tAtLength(length, options);\n    return this.divideAtT(t);\n  }\n\n  divide(t) {\n    return this.divideAtT(t);\n  }\n\n  divideAtT(t) {\n    const start = this.start;\n    const controlPoint1 = this.controlPoint1;\n    const controlPoint2 = this.controlPoint2;\n    const end = this.end;\n\n    if (t <= 0) {\n      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n    }\n\n    if (t >= 1) {\n      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n    }\n\n    const dividerPoints = this.getSkeletonPoints(t);\n    const startControl1 = dividerPoints.startControlPoint1;\n    const startControl2 = dividerPoints.startControlPoint2;\n    const divider = dividerPoints.divider;\n    const dividerControl1 = dividerPoints.dividerControlPoint1;\n    const dividerControl2 = dividerPoints.dividerControlPoint2;\n    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n  }\n\n  endpointDistance() {\n    return this.start.distance(this.end);\n  }\n\n  getSkeletonPoints(t) {\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end; // shortcuts for `t` values that are out of range\n\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone()\n      };\n    }\n\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone()\n      };\n    }\n\n    const midpoint1 = new Line(start, control1).pointAt(t);\n    const midpoint2 = new Line(control1, control2).pointAt(t);\n    const midpoint3 = new Line(control2, end).pointAt(t);\n    const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n    const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n    const divideLine = new Line(subControl1, subControl2).pointAt(t);\n    return {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divideLine,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3\n    };\n  }\n\n  getSubdivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    let subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n\n    if (precision === 0) {\n      return subdivisions;\n    }\n\n    let previousLength = this.endpointDistance();\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n    // Recursively divide curve at `t = 0.5`, until the difference between\n    // observed length at subsequent iterations is lower than precision.\n\n    let iteration = 0; // eslint-disable-next-line\n\n    while (true) {\n      iteration += 1;\n      const divisions = [];\n      subdivisions.forEach(c => {\n        // dividing at t = 0.5 (not at middle length!)\n        const divided = c.divide(0.5);\n        divisions.push(divided[0], divided[1]);\n      }); // measure new length\n\n      const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0); // check if we have reached required observed precision\n      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n      // not a problem for further iterations because cubic curves cannot have more than two local extrema\n      // (i.e. cubic curves cannot intersect the baseline more than once)\n      // therefore two subsequent iterations cannot produce sampling with equal length\n\n      const ratio = length !== 0 ? (length - previousLength) / length : 0;\n\n      if (iteration > 1 && ratio < precisionRatio) {\n        return divisions;\n      }\n\n      subdivisions = divisions;\n      previousLength = length;\n    }\n  }\n\n  length() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const divisions = this.getDivisions(options);\n    return divisions.reduce((memo, c) => {\n      return memo + c.endpointDistance();\n    }, 0);\n  }\n\n  lengthAtT(t) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (t <= 0) {\n      return 0;\n    }\n\n    const precision = options.precision === undefined ? this.PRECISION : options.precision;\n    const subCurve = this.divide(t)[0];\n    return subCurve.length({\n      precision\n    });\n  }\n\n  pointAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n\n    const t = this.tAt(ratio, options);\n    return this.pointAtT(t);\n  }\n\n  pointAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const t = this.tAtLength(length, options);\n    return this.pointAtT(t);\n  }\n\n  pointAtT(t) {\n    if (t <= 0) {\n      return this.start.clone();\n    }\n\n    if (t >= 1) {\n      return this.end.clone();\n    }\n\n    return this.getSkeletonPoints(t).divider;\n  }\n\n  isDifferentiable() {\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  }\n\n  tangentAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.isDifferentiable()) return null;\n\n    if (ratio < 0) {\n      ratio = 0; // eslint-disable-line\n    } else if (ratio > 1) {\n      ratio = 1; // eslint-disable-line\n    }\n\n    const t = this.tAt(ratio, options);\n    return this.tangentAtT(t);\n  }\n\n  tangentAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n\n    const t = this.tAtLength(length, options);\n    return this.tangentAtT(t);\n  }\n\n  tangentAtT(t) {\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n\n    if (t < 0) {\n      t = 0; // eslint-disable-line\n    }\n\n    if (t > 1) {\n      t = 1; // eslint-disable-line\n    }\n\n    const skeletonPoints = this.getSkeletonPoints(t);\n    const p1 = skeletonPoints.startControlPoint2;\n    const p2 = skeletonPoints.dividerControlPoint1;\n    const tangentStart = skeletonPoints.divider;\n    const tangentLine = new Line(p1, p2); // move so that tangent line starts at the point requested\n\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);\n    return tangentLine;\n  }\n\n  getPrecision() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n\n  getDivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.subdivisions != null) {\n      return options.subdivisions;\n    }\n\n    const precision = this.getPrecision(options);\n    return this.getSubdivisions({\n      precision\n    });\n  }\n\n  getOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    return {\n      precision,\n      subdivisions\n    };\n  }\n\n  tAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ratio <= 0) {\n      return 0;\n    }\n\n    if (ratio >= 1) {\n      return 1;\n    }\n\n    const opts = this.getOptions(options);\n    const total = this.length(opts);\n    const length = total * ratio;\n    return this.tAtLength(length, opts);\n  }\n\n  tAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    const opts = {\n      precision,\n      subdivisions\n    };\n    let investigatedSubdivision = null;\n    let investigatedSubdivisionStartT;\n    let investigatedSubdivisionEndT;\n    let baselinePointDistFromStart = 0;\n    let baselinePointDistFromEnd = 0;\n    let memo = 0;\n    const count = subdivisions.length;\n    let piece = count > 0 ? 1 / count : 0;\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const division = subdivisions[i];\n      const dist = division.endpointDistance();\n\n      if (length <= memo + dist) {\n        investigatedSubdivision = division;\n        investigatedSubdivisionStartT = index * piece;\n        investigatedSubdivisionEndT = (index + 1) * piece;\n        baselinePointDistFromStart = fromStart ? length - memo : dist + memo - length;\n        baselinePointDistFromEnd = fromStart ? dist + memo - length : length - memo;\n        break;\n      }\n\n      memo += dist;\n    }\n\n    if (investigatedSubdivision == null) {\n      return fromStart ? 1 : 0;\n    } // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\n    const total = this.length(opts);\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n    // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n    // eslint-disable-next-line\n\n    while (true) {\n      let ratio;\n      ratio = total !== 0 ? baselinePointDistFromStart / total : 0;\n\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionStartT;\n      }\n\n      ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;\n\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionEndT;\n      } // otherwise, set up for next iteration\n\n\n      let newBaselinePointDistFromStart;\n      let newBaselinePointDistFromEnd;\n      const divided = investigatedSubdivision.divide(0.5);\n      piece /= 2;\n      const baseline1Length = divided[0].endpointDistance();\n      const baseline2Length = divided[1].endpointDistance();\n\n      if (baselinePointDistFromStart <= baseline1Length) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= piece;\n        newBaselinePointDistFromStart = baselinePointDistFromStart;\n        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += piece;\n        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n      }\n\n      baselinePointDistFromStart = newBaselinePointDistFromStart;\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n    }\n  }\n\n  toPoints() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const subdivisions = this.getDivisions(options);\n    const points = [subdivisions[0].start.clone()];\n    subdivisions.forEach(c => points.push(c.end.clone()));\n    return points;\n  }\n\n  toPolyline() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Polyline(this.toPoints(options));\n  }\n\n  scale(sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.start.rotate(angle, origin);\n    this.controlPoint1.rotate(angle, origin);\n    this.controlPoint2.rotate(angle, origin);\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty);\n      this.controlPoint1.translate(tx, ty);\n      this.controlPoint2.translate(tx, ty);\n      this.end.translate(tx, ty);\n    } else {\n      this.start.translate(tx);\n      this.controlPoint1.translate(tx);\n      this.controlPoint2.translate(tx);\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  equals(c) {\n    return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);\n  }\n\n  clone() {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  }\n\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end.serialize()].join(' ');\n  }\n\n}\n\n(function (Curve) {\n  Curve.toStringTag = `X6.Geometry.${Curve.name}`;\n\n  function isCurve(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Curve) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const curve = instance;\n\n    try {\n      if ((tag == null || tag === Curve.toStringTag) && Point.isPoint(curve.start) && Point.isPoint(curve.controlPoint1) && Point.isPoint(curve.controlPoint2) && Point.isPoint(curve.end) && typeof curve.toPoints === 'function' && typeof curve.toPolyline === 'function') {\n        return true;\n      }\n    } catch (e) {\n      return false;\n    }\n\n    return false;\n  }\n\n  Curve.isCurve = isCurve;\n})(Curve || (Curve = {}));\n\n(function (Curve) {\n  function getFirstControlPoints(rhs) {\n    const n = rhs.length;\n    const x = []; // `x` is a solution vector.\n\n    const tmp = [];\n    let b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (let i = 1; i < n; i += 1) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (let i = 1; i < n; i += 1) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n\n    return x;\n  }\n\n  function getCurveControlPoints(points) {\n    const knots = points.map(p => Point.clone(p));\n    const firstControlPoints = [];\n    const secondControlPoints = [];\n    const n = knots.length - 1; // Special case: Bezier curve should be a straight line.\n\n    if (n === 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 – P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    const rhs = []; // Set right hand side X values.\n\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    const x = getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    const y = getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (let i = 0; i < n; i += 1) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i])); // Second control point.\n\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  }\n\n  function throughPoints(points) {\n    if (points == null || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n\n    const controlPoints = getCurveControlPoints(points);\n    const curves = [];\n\n    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n      const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n\n    return curves;\n  }\n\n  Curve.throughPoints = throughPoints;\n})(Curve || (Curve = {}));","map":null,"metadata":{},"sourceType":"module"}