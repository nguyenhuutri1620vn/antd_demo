{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { getMask } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapGridTriangulation } from '../../core/triangulation';\nvar heatmapGridVert = \"precision highp float;\\r\\n// \\u591A\\u8FB9\\u5F62\\u9876\\u70B9\\u5750\\u6807\\r\\nattribute vec3 a_Position;\\r\\n// \\u591A\\u8FB9\\u5F62\\u7ECF\\u7EAC\\u5EA6\\u5750\\u6807\\r\\nattribute vec3 a_Pos;\\r\\nattribute float a_Size;\\r\\nattribute vec4 a_Color;\\r\\nuniform vec2 u_radius;\\r\\nuniform float u_coverage: 0.9;\\r\\nuniform float u_angle: 0;\\r\\nuniform mat4 u_ModelMatrix;\\r\\nuniform mat4 u_Mvp;\\r\\nvarying vec4 v_color;\\r\\n\\r\\nuniform vec2 u_SceneCenterMKT;\\r\\n\\r\\n#pragma include \\\"projection\\\"\\r\\n#pragma include \\\"project\\\"\\r\\n#pragma include \\\"picking\\\"\\r\\n\\r\\nvoid main() {\\r\\n  v_color = a_Color;\\r\\n\\r\\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\\r\\n  vec2 offset = a_Position.xy * u_radius * rotationMatrix * u_coverage ;\\r\\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\\r\\n  // vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\\r\\n  // gl_Position = project_common_position_to_clipspace(project_pos);\\r\\n\\r\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\r\\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\\r\\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT; // \\u5C06\\u7ECF\\u7EAC\\u5EA6\\u8F6C\\u6362\\u4E3A\\u9AD8\\u5FB72.0\\u9700\\u8981\\u7684\\u5E73\\u9762\\u5750\\u6807\\r\\n    vec4 project_pos = project_position(vec4(customLnglat, 0, 1.0));\\r\\n    gl_Position = u_Mvp * (project_pos);\\r\\n  } else {\\r\\n     vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\\r\\n    vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\\r\\n    gl_Position = project_common_position_to_clipspace(project_pos);\\r\\n  }\\r\\n\\r\\n  setPickingColor(a_PickingColor);\\r\\n}\\r\\n\";\nvar heatmapGridFrag = \"precision highp float;\\nvarying vec4 v_color;\\nuniform float u_opacity: 1;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  gl_FragColor.a *= u_opacity;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\n\nvar GridModel = function (_BaseModel) {\n  _inherits(GridModel, _BaseModel);\n\n  var _super = _createSuper(GridModel);\n\n  function GridModel() {\n    _classCallCheck(this, GridModel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GridModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          coverage = _ref.coverage,\n          angle = _ref.angle;\n\n      return {\n        u_opacity: opacity || 1.0,\n        u_coverage: coverage || 0.9,\n        u_angle: angle || 0,\n        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      return this.buildModels();\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      var _ref2 = this.layer.getLayerConfig(),\n          _ref2$mask = _ref2.mask,\n          mask = _ref2$mask === void 0 ? false : _ref2$mask,\n          _ref2$maskInside = _ref2.maskInside,\n          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;\n\n      return [this.layer.buildLayerModel({\n        moduleName: 'gridheatmap',\n        vertexShader: heatmapGridVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: HeatmapGridTriangulation,\n        depth: {\n          enable: false\n        },\n        primitive: gl.TRIANGLES,\n        blend: this.getBlend(),\n        stencil: getMask(mask, maskInside)\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'pos',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Pos',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx) {\n            var coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;\n            return [coordinates[0], coordinates[1], 0];\n          }\n        }\n      });\n    }\n  }]);\n\n  return GridModel;\n}(BaseModel);\n\nexport { GridModel as default };","map":null,"metadata":{},"sourceType":"module"}