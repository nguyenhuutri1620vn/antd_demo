{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, StringExt } from '../util';\nimport { Point, Polyline } from '../geometry';\nimport { Registry } from '../registry';\nimport { Markup } from '../view/markup';\nimport { ShareRegistry } from './registry';\nimport { Cell } from './cell';\nexport class Edge extends Cell {\n  constructor() {\n    let metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(metadata);\n  }\n\n  get [Symbol.toStringTag]() {\n    return Edge.toStringTag;\n  }\n\n  preprocess(metadata, ignoreIdCheck) {\n    const {\n      source,\n      sourceCell,\n      sourcePort,\n      sourcePoint,\n      target,\n      targetCell,\n      targetPort,\n      targetPoint\n    } = metadata,\n          others = __rest(metadata, [\"source\", \"sourceCell\", \"sourcePort\", \"sourcePoint\", \"target\", \"targetCell\", \"targetPort\", \"targetPoint\"]);\n\n    const data = others;\n\n    const isValidId = val => typeof val === 'string' || typeof val === 'number';\n\n    if (source != null) {\n      if (Cell.isCell(source)) {\n        data.source = {\n          cell: source.id\n        };\n      } else if (isValidId(source)) {\n        data.source = {\n          cell: source\n        };\n      } else if (Point.isPoint(source)) {\n        data.source = source.toJSON();\n      } else if (Array.isArray(source)) {\n        data.source = {\n          x: source[0],\n          y: source[1]\n        };\n      } else {\n        const cell = source.cell;\n\n        if (Cell.isCell(cell)) {\n          data.source = Object.assign(Object.assign({}, source), {\n            cell: cell.id\n          });\n        } else {\n          data.source = source;\n        }\n      }\n    }\n\n    if (sourceCell != null || sourcePort != null) {\n      let terminal = data.source;\n\n      if (sourceCell != null) {\n        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;\n\n        if (terminal) {\n          terminal.cell = id;\n        } else {\n          terminal = data.source = {\n            cell: id\n          };\n        }\n      }\n\n      if (sourcePort != null && terminal) {\n        terminal.port = sourcePort;\n      }\n    } else if (sourcePoint != null) {\n      data.source = Point.create(sourcePoint).toJSON();\n    }\n\n    if (target != null) {\n      if (Cell.isCell(target)) {\n        data.target = {\n          cell: target.id\n        };\n      } else if (isValidId(target)) {\n        data.target = {\n          cell: target\n        };\n      } else if (Point.isPoint(target)) {\n        data.target = target.toJSON();\n      } else if (Array.isArray(target)) {\n        data.target = {\n          x: target[0],\n          y: target[1]\n        };\n      } else {\n        const cell = target.cell;\n\n        if (Cell.isCell(cell)) {\n          data.target = Object.assign(Object.assign({}, target), {\n            cell: cell.id\n          });\n        } else {\n          data.target = target;\n        }\n      }\n    }\n\n    if (targetCell != null || targetPort != null) {\n      let terminal = data.target;\n\n      if (targetCell != null) {\n        const id = isValidId(targetCell) ? targetCell : targetCell.id;\n\n        if (terminal) {\n          terminal.cell = id;\n        } else {\n          terminal = data.target = {\n            cell: id\n          };\n        }\n      }\n\n      if (targetPort != null && terminal) {\n        terminal.port = targetPort;\n      }\n    } else if (targetPoint != null) {\n      data.target = Point.create(targetPoint).toJSON();\n    }\n\n    return super.preprocess(data, ignoreIdCheck);\n  }\n\n  setup() {\n    super.setup();\n    this.on('change:labels', args => this.onLabelsChanged(args));\n    this.on('change:vertices', args => this.onVertexsChanged(args));\n  }\n\n  isEdge() {\n    return true;\n  } // #region terminal\n\n\n  disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.set({\n      source: {\n        x: 0,\n        y: 0\n      },\n      target: {\n        x: 0,\n        y: 0\n      }\n    }, options);\n    return this;\n  }\n\n  get source() {\n    return this.getSource();\n  }\n\n  set source(data) {\n    this.setSource(data);\n  }\n\n  getSource() {\n    return this.getTerminal('source');\n  }\n\n  getSourceCellId() {\n    return this.source.cell;\n  }\n\n  getSourcePortId() {\n    return this.source.port;\n  }\n\n  setSource(source, args) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.setTerminal('source', source, args, options);\n  }\n\n  get target() {\n    return this.getTarget();\n  }\n\n  set target(data) {\n    this.setTarget(data);\n  }\n\n  getTarget() {\n    return this.getTerminal('target');\n  }\n\n  getTargetCellId() {\n    return this.target.cell;\n  }\n\n  getTargetPortId() {\n    return this.target.port;\n  }\n\n  setTarget(target, args) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.setTerminal('target', target, args, options);\n  }\n\n  getTerminal(type) {\n    return Object.assign({}, this.store.get(type));\n  }\n\n  setTerminal(type, terminal, args) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    // `terminal` is a cell\n    if (Cell.isCell(terminal)) {\n      this.store.set(type, ObjectExt.merge({}, args, {\n        cell: terminal.id\n      }), options);\n      return this;\n    } // `terminal` is a point-like object\n\n\n    const p = terminal;\n\n    if (Point.isPoint(terminal) || p.x != null && p.y != null) {\n      this.store.set(type, ObjectExt.merge({}, args, {\n        x: p.x,\n        y: p.y\n      }), options);\n      return this;\n    } // `terminal` is an object\n\n\n    this.store.set(type, ObjectExt.cloneDeep(terminal), options);\n    return this;\n  }\n\n  getSourcePoint() {\n    return this.getTerminalPoint('source');\n  }\n\n  getTargetPoint() {\n    return this.getTerminalPoint('target');\n  }\n\n  getTerminalPoint(type) {\n    const terminal = this[type];\n\n    if (Point.isPointLike(terminal)) {\n      return Point.create(terminal);\n    }\n\n    const cell = this.getTerminalCell(type);\n\n    if (cell) {\n      return cell.getConnectionPoint(this, type);\n    }\n\n    return new Point();\n  }\n\n  getSourceCell() {\n    return this.getTerminalCell('source');\n  }\n\n  getTargetCell() {\n    return this.getTerminalCell('target');\n  }\n\n  getTerminalCell(type) {\n    if (this.model) {\n      const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();\n\n      if (cellId) {\n        return this.model.getCell(cellId);\n      }\n    }\n\n    return null;\n  }\n\n  getSourceNode() {\n    return this.getTerminalNode('source');\n  }\n\n  getTargetNode() {\n    return this.getTerminalNode('target');\n  }\n\n  getTerminalNode(type) {\n    let cell = this; // eslint-disable-line\n\n    const visited = {};\n\n    while (cell && cell.isEdge()) {\n      if (visited[cell.id]) {\n        return null;\n      }\n\n      visited[cell.id] = true;\n      cell = cell.getTerminalCell(type);\n    }\n\n    return cell && cell.isNode() ? cell : null;\n  } // #endregion\n  // #region router\n\n\n  get router() {\n    return this.getRouter();\n  }\n\n  set router(data) {\n    if (data == null) {\n      this.removeRouter();\n    } else {\n      this.setRouter(data);\n    }\n  }\n\n  getRouter() {\n    return this.store.get('router');\n  }\n\n  setRouter(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('router', name, args);\n    } else {\n      this.store.set('router', {\n        name,\n        args\n      }, options);\n    }\n\n    return this;\n  }\n\n  removeRouter() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('router', options);\n    return this;\n  } // #endregion\n  // #region connector\n\n\n  get connector() {\n    return this.getConnector();\n  }\n\n  set connector(data) {\n    if (data == null) {\n      this.removeConnector();\n    } else {\n      this.setConnector(data);\n    }\n  }\n\n  getConnector() {\n    return this.store.get('connector');\n  }\n\n  setConnector(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('connector', name, args);\n    } else {\n      this.store.set('connector', {\n        name,\n        args\n      }, options);\n    }\n\n    return this;\n  }\n\n  removeConnector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.store.remove('connector', options);\n  } // #endregion\n  // #region strategy\n\n\n  get strategy() {\n    return this.getStrategy();\n  }\n\n  set strategy(data) {\n    if (data == null) {\n      this.removeStrategy();\n    } else {\n      this.setStrategy(data);\n    }\n  }\n\n  getStrategy() {\n    return this.store.get('strategy');\n  }\n\n  setStrategy(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('strategy', name, args);\n    } else {\n      this.store.set('strategy', {\n        name,\n        args\n      }, options);\n    }\n\n    return this;\n  }\n\n  removeStrategy() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.store.remove('strategy', options);\n  } // #endregion\n  // #region labels\n\n\n  getDefaultLabel() {\n    const ctor = this.constructor;\n    const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};\n    return ObjectExt.cloneDeep(defaults);\n  }\n\n  get labels() {\n    return this.getLabels();\n  }\n\n  set labels(labels) {\n    this.setLabels(labels);\n  }\n\n  getLabels() {\n    return [...this.store.get('labels', [])].map(item => this.parseLabel(item));\n  }\n\n  setLabels(labels) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);\n    return this;\n  }\n\n  insertLabel(label, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const labels = this.getLabels();\n    const len = labels.length;\n    let idx = index != null && Number.isFinite(index) ? index : len;\n\n    if (idx < 0) {\n      idx = len + idx + 1;\n    }\n\n    labels.splice(idx, 0, this.parseLabel(label));\n    return this.setLabels(labels, options);\n  }\n\n  appendLabel(label) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.insertLabel(label, -1, options);\n  }\n\n  getLabelAt(index) {\n    const labels = this.getLabels();\n\n    if (index != null && Number.isFinite(index)) {\n      return this.parseLabel(labels[index]);\n    }\n\n    return null;\n  }\n\n  setLabelAt(index, label) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (index != null && Number.isFinite(index)) {\n      const labels = this.getLabels();\n      labels[index] = this.parseLabel(label);\n      this.setLabels(labels, options);\n    }\n\n    return this;\n  }\n\n  removeLabelAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const labels = this.getLabels();\n    const idx = index != null && Number.isFinite(index) ? index : -1;\n    const removed = labels.splice(idx, 1);\n    this.setLabels(labels, options);\n    return removed.length ? removed[0] : null;\n  }\n\n  parseLabel(label) {\n    if (typeof label === 'string') {\n      const ctor = this.constructor;\n      return ctor.parseStringLabel(label);\n    }\n\n    return label;\n  }\n\n  onLabelsChanged(_ref) {\n    let {\n      previous,\n      current\n    } = _ref;\n    const added = previous && current ? current.filter(label1 => {\n      if (!previous.find(label2 => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n        return label1;\n      }\n\n      return null;\n    }) : current ? [...current] : [];\n    const removed = previous && current ? previous.filter(label1 => {\n      if (!current.find(label2 => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n        return label1;\n      }\n\n      return null;\n    }) : previous ? [...previous] : [];\n\n    if (added.length > 0) {\n      this.notify('labels:added', {\n        added,\n        cell: this,\n        edge: this\n      });\n    }\n\n    if (removed.length > 0) {\n      this.notify('labels:removed', {\n        removed,\n        cell: this,\n        edge: this\n      });\n    }\n  } // #endregion\n  // #region vertices\n\n\n  get vertexMarkup() {\n    return this.getVertexMarkup();\n  }\n\n  set vertexMarkup(markup) {\n    this.setVertexMarkup(markup);\n  }\n\n  getDefaultVertexMarkup() {\n    return this.store.get('defaultVertexMarkup') || Markup.getEdgeVertexMarkup();\n  }\n\n  getVertexMarkup() {\n    return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();\n  }\n\n  setVertexMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('vertexMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get vertices() {\n    return this.getVertices();\n  }\n\n  set vertices(vertices) {\n    this.setVertices(vertices);\n  }\n\n  getVertices() {\n    return [...this.store.get('vertices', [])];\n  }\n\n  setVertices(vertices) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const points = Array.isArray(vertices) ? vertices : [vertices];\n    this.store.set('vertices', points.map(p => Point.toJSON(p)), options);\n    return this;\n  }\n\n  insertVertex(vertice, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const vertices = this.getVertices();\n    const len = vertices.length;\n    let idx = index != null && Number.isFinite(index) ? index : len;\n\n    if (idx < 0) {\n      idx = len + idx + 1;\n    }\n\n    vertices.splice(idx, 0, Point.toJSON(vertice));\n    return this.setVertices(vertices, options);\n  }\n\n  appendVertex(vertex) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.insertVertex(vertex, -1, options);\n  }\n\n  getVertexAt(index) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices();\n      return vertices[index];\n    }\n\n    return null;\n  }\n\n  setVertexAt(index, vertice) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices();\n      vertices[index] = vertice;\n      this.setVertices(vertices, options);\n    }\n\n    return this;\n  }\n\n  removeVertexAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const vertices = this.getVertices();\n    const idx = index != null && Number.isFinite(index) ? index : -1;\n    vertices.splice(idx, 1);\n    return this.setVertices(vertices, options);\n  }\n\n  onVertexsChanged(_ref2) {\n    let {\n      previous,\n      current\n    } = _ref2;\n    const added = previous && current ? current.filter(p1 => {\n      if (!previous.find(p2 => Point.equals(p1, p2))) {\n        return p1;\n      }\n\n      return null;\n    }) : current ? [...current] : [];\n    const removed = previous && current ? previous.filter(p1 => {\n      if (!current.find(p2 => Point.equals(p1, p2))) {\n        return p1;\n      }\n\n      return null;\n    }) : previous ? [...previous] : [];\n\n    if (added.length > 0) {\n      this.notify('vertexs:added', {\n        added,\n        cell: this,\n        edge: this\n      });\n    }\n\n    if (removed.length > 0) {\n      this.notify('vertexs:removed', {\n        removed,\n        cell: this,\n        edge: this\n      });\n    }\n  } // #endregion\n  // #region markup\n\n\n  getDefaultMarkup() {\n    return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();\n  }\n\n  getMarkup() {\n    return super.getMarkup() || this.getDefaultMarkup();\n  } // #endregion\n  // #region toolMarkup\n\n\n  get toolMarkup() {\n    return this.getToolMarkup();\n  }\n\n  set toolMarkup(markup) {\n    this.setToolMarkup(markup);\n  }\n\n  getDefaultToolMarkup() {\n    return this.store.get('defaultToolMarkup') || Markup.getEdgeToolMarkup();\n  }\n\n  getToolMarkup() {\n    return this.store.get('toolMarkup') || this.getDefaultToolMarkup();\n  }\n\n  setToolMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('toolMarkup', markup, options);\n    return this;\n  }\n\n  get doubleToolMarkup() {\n    return this.getDoubleToolMarkup();\n  }\n\n  set doubleToolMarkup(markup) {\n    this.setDoubleToolMarkup(markup);\n  }\n\n  getDefaultDoubleToolMarkup() {\n    return this.store.get('defaultDoubleToolMarkup');\n  }\n\n  getDoubleToolMarkup() {\n    return this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup();\n  }\n\n  setDoubleToolMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('doubleToolMarkup', markup, options);\n    return this;\n  } // #endregion\n  // #region arrowheadMarkup\n\n\n  get arrowheadMarkup() {\n    return this.getArrowheadMarkup();\n  }\n\n  set arrowheadMarkup(markup) {\n    this.setArrowheadMarkup(markup);\n  }\n\n  getDefaultArrowheadMarkup() {\n    return this.store.get('defaultArrowheadMarkup') || Markup.getEdgeArrowheadMarkup();\n  }\n\n  getArrowheadMarkup() {\n    return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();\n  }\n\n  setArrowheadMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('arrowheadMarkup', markup, options);\n    return this;\n  } // #endregion\n  // #region transform\n\n  /**\n   * Translate the edge vertices (and source and target if they are points)\n   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n   */\n\n\n  translate(tx, ty) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    options.translateBy = options.translateBy || this.id;\n    options.tx = tx;\n    options.ty = ty;\n    return this.applyToPoints(p => ({\n      x: (p.x || 0) + tx,\n      y: (p.y || 0) + ty\n    }), options);\n  }\n  /**\n   * Scales the edge's points (vertices) relative to the given origin.\n   */\n\n\n  scale(sx, sy, origin) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    return this.applyToPoints(p => {\n      return Point.create(p).scale(sx, sy, origin).toJSON();\n    }, options);\n  }\n\n  applyToPoints(worker) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const attrs = {};\n    const source = this.getSource();\n    const target = this.getTarget();\n\n    if (Point.isPointLike(source)) {\n      attrs.source = worker(source);\n    }\n\n    if (Point.isPointLike(target)) {\n      attrs.target = worker(target);\n    }\n\n    const vertices = this.getVertices();\n\n    if (vertices.length > 0) {\n      attrs.vertices = vertices.map(worker);\n    }\n\n    this.store.set(attrs, options);\n    return this;\n  } // #endregion\n  // #region common\n\n\n  getBBox() {\n    return this.getPolyline().bbox();\n  }\n\n  getConnectionPoint() {\n    return this.getPolyline().pointAt(0.5);\n  }\n\n  getPolyline() {\n    const points = [this.getSourcePoint(), ...this.getVertices().map(vertice => Point.create(vertice)), this.getTargetPoint()];\n    return new Polyline(points);\n  }\n\n  updateParent(options) {\n    let newParent = null;\n    const source = this.getSourceCell();\n    const target = this.getTargetCell();\n    const prevParent = this.getParent();\n\n    if (source && target) {\n      if (source === target || source.isDescendantOf(target)) {\n        newParent = target;\n      } else if (target.isDescendantOf(source)) {\n        newParent = source;\n      } else {\n        newParent = Cell.getCommonAncestor(source, target);\n      }\n    } // Unembeds the edge if source and target has no common\n    // ancestor or common ancestor changed\n\n\n    if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n      prevParent.unembed(this, options);\n    }\n\n    if (newParent) {\n      newParent.embed(this, options);\n    }\n\n    return newParent;\n  }\n\n  hasLoop() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const source = this.getSource();\n    const target = this.getTarget();\n    const sourceId = source.cell;\n    const targetId = target.cell;\n\n    if (!sourceId || !targetId) {\n      return false;\n    }\n\n    let loop = sourceId === targetId; // Note that there in the deep mode a edge can have a loop,\n    // even if it connects only a parent and its embed.\n    // A loop \"target equals source\" is valid in both shallow and deep mode.\n    // eslint-disable-next-line\n\n    if (!loop && options.deep && this._model) {\n      const sourceCell = this.getSourceCell();\n      const targetCell = this.getTargetCell();\n\n      if (sourceCell && targetCell) {\n        loop = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);\n      }\n    }\n\n    return loop;\n  }\n\n  getFragmentAncestor() {\n    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter(item => item != null);\n    return this.getCommonAncestor(...cells);\n  }\n\n  isFragmentDescendantOf(cell) {\n    const ancestor = this.getFragmentAncestor();\n    return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));\n  }\n\n}\nEdge.defaults = {};\n\n(function (Edge) {\n  function equalTerminals(a, b) {\n    const a1 = a;\n    const b1 = b;\n\n    if (a1.cell === b1.cell) {\n      return a1.port === b1.port || a1.port == null && b1.port == null;\n    }\n\n    return false;\n  }\n\n  Edge.equalTerminals = equalTerminals;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.defaultLabel = {\n    markup: [{\n      tagName: 'rect',\n      selector: 'body'\n    }, {\n      tagName: 'text',\n      selector: 'label'\n    }],\n    attrs: {\n      text: {\n        fill: '#000',\n        fontSize: 14,\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n        pointerEvents: 'none'\n      },\n      rect: {\n        ref: 'label',\n        fill: '#fff',\n        rx: 3,\n        ry: 3,\n        refWidth: 1,\n        refHeight: 1,\n        refX: 0,\n        refY: 0\n      }\n    },\n    position: {\n      distance: 0.5\n    }\n  };\n\n  function parseStringLabel(text) {\n    return {\n      attrs: {\n        label: {\n          text\n        }\n      }\n    };\n  }\n\n  Edge.parseStringLabel = parseStringLabel;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.toStringTag = `X6.${Edge.name}`;\n\n  function isEdge(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Edge) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const edge = instance;\n\n    if ((tag == null || tag === Edge.toStringTag) && typeof edge.isNode === 'function' && typeof edge.isEdge === 'function' && typeof edge.prop === 'function' && typeof edge.attr === 'function' && typeof edge.disconnect === 'function' && typeof edge.getSource === 'function' && typeof edge.getTarget === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Edge.isEdge = isEdge;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.registry = Registry.create({\n    type: 'edge',\n\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, false)) {\n        throw new Error(`Edge with name '${shape}' was registered by anthor Node`);\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape\n        });\n        return options;\n      }\n\n      let parent = Edge; // default inherit from 'dege'\n\n      const {\n        inherit = 'edge'\n      } = options,\n            others = __rest(options, [\"inherit\"]);\n\n      if (typeof inherit === 'string') {\n        const base = this.get(inherit || 'edge');\n\n        if (base == null && inherit) {\n          this.onNotFound(inherit, 'inherited');\n        } else {\n          parent = base;\n        }\n      } else {\n        parent = inherit;\n      }\n\n      if (others.constructorName == null) {\n        others.constructorName = shape;\n      }\n\n      const ctor = parent.define.call(parent, others);\n      ctor.config({\n        shape\n      });\n      return ctor;\n    }\n\n  });\n  ShareRegistry.setEdgeRegistry(Edge.registry);\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  let counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return `CustomEdge${counter}`;\n  }\n\n  function define(config) {\n    const {\n      constructorName,\n      overwrite\n    } = config,\n          others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Edge.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Edge.define = define;\n\n  function create(options) {\n    const shape = options.shape || 'edge';\n    const Ctor = Edge.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Edge.registry.onNotFound(shape);\n  }\n\n  Edge.create = create;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  const shape = 'basic.edge';\n  Edge.config({\n    shape,\n\n    propHooks(metadata) {\n      const {\n        label,\n        vertices\n      } = metadata,\n            others = __rest(metadata, [\"label\", \"vertices\"]);\n\n      if (label) {\n        if (others.labels == null) {\n          others.labels = [];\n        }\n\n        const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;\n        others.labels.push(formated);\n      }\n\n      if (vertices) {\n        if (Array.isArray(vertices)) {\n          others.vertices = vertices.map(item => Point.create(item).toJSON());\n        }\n      }\n\n      return others;\n    }\n\n  });\n  Edge.registry.register(shape, Edge);\n})(Edge || (Edge = {}));","map":null,"metadata":{},"sourceType":"module"}