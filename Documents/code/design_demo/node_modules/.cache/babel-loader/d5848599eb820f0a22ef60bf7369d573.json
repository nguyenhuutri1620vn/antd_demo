{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { vec3 } from 'gl-matrix';\nvar tmpVecA = vec3.create();\nvar tmpVecB = vec3.create();\nvar tmpVecC = vec3.create();\nvar tmpVecD = vec3.create();\nvar tmpVecE = vec3.create();\n/**\n * 包含求交方法：\n * * intersectsShape(Shape, intersection) 返回交点和求交结果\n * @see https://github.com/playcanvas/engine/blob/master/src/shape/bounding-box.js#L161\n * @see https://github.com/mrdoob/three.js/blob/dev/src/math/Ray.js\n */\n\nexport var Ray = /*#__PURE__*/function () {\n  function Ray(origin, direction) {\n    _classCallCheck(this, Ray);\n\n    this.origin = void 0;\n    this.direction = void 0;\n    this.origin = origin || vec3.create();\n    this.direction = direction || vec3.fromValues(0, 0, -1);\n  }\n\n  _createClass(Ray, [{\n    key: \"intersectsAABB\",\n    value: function intersectsAABB(aabb, intersection) {\n      return intersection ? this.intersectAABBWithIntersection(aabb, intersection) : this.intersectsAABBWithoutIntersection(aabb);\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere, intersection) {\n      var m = vec3.sub(tmpVecA, this.origin, sphere.center);\n      vec3.normalize(tmpVecB, vec3.copy(tmpVecB, this.direction));\n      var b = vec3.dot(m, tmpVecB);\n      var c = vec3.dot(m, m) - sphere.radius * sphere.radius; // exit if ray's origin outside of sphere (c > 0) and ray pointing away from s (b > 0)\n\n      if (c > 0 && b > 0) {\n        return null;\n      }\n\n      var discr = b * b - c; // a negative discriminant corresponds to ray missing sphere\n\n      if (discr < 0) {\n        return false;\n      } // ray intersects sphere, compute smallest t value of intersection\n\n\n      var t = Math.abs(-b - Math.sqrt(discr)); // if t is negative, ray started inside sphere so clamp t to zero\n\n      if (intersection) {\n        vec3.copy(intersection, this.direction);\n        vec3.scaleAndAdd(intersection, this.origin, intersection, t);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"intersectsPlane\",\n    value: function intersectsPlane(plane, intersection) {\n      var t = (plane.distance - vec3.dot(plane.normal, this.origin)) / vec3.dot(plane.normal, this.direction);\n      var intersects = t >= 0;\n\n      if (intersects && intersection) {\n        vec3.scaleAndAdd(intersection, this.origin, this.direction, t);\n      }\n\n      return intersects;\n    }\n    /**\n     * faster than implements like Three.js\n     * @see https://github.com/playcanvas/engine/blob/master/src/shape/bounding-box.js#L161\n     */\n\n  }, {\n    key: \"intersectsAABBWithoutIntersection\",\n    value: function intersectsAABBWithoutIntersection(aabb) {\n      var diff = tmpVecA;\n      var cross = tmpVecB;\n      var prod = tmpVecC;\n      var absDiff = tmpVecD;\n      var absDir = tmpVecE;\n      var rayDir = this.direction;\n      vec3.sub(diff, this.origin, aabb.center);\n      vec3.set(absDiff, Math.abs(diff[0]), Math.abs(diff[1]), Math.abs(diff[2]));\n      vec3.mul(prod, diff, rayDir);\n\n      if (absDiff[0] > aabb.halfExtents[0] && prod[0] >= 0 || absDiff[1] > aabb.halfExtents[1] && prod[1] >= 0 || absDiff[2] > aabb.halfExtents[2] && prod[2] >= 0) {\n        return false;\n      }\n\n      vec3.set(absDir, Math.abs(rayDir[0]), Math.abs(rayDir[1]), Math.abs(rayDir[2]));\n      vec3.cross(cross, rayDir, diff);\n      vec3.set(cross, Math.abs(cross[0]), Math.abs(cross[1]), Math.abs(cross[2]));\n      return !(cross[0] > aabb.halfExtents[1] * absDir[2] + aabb.halfExtents[2] * absDir[1] || cross[1] > aabb.halfExtents[0] * absDir[2] + aabb.halfExtents[2] * absDir[0] || cross[2] > aabb.halfExtents[0] * absDir[1] + aabb.halfExtents[1] * absDir[0]);\n    }\n  }, {\n    key: \"intersectAABBWithIntersection\",\n    value: function intersectAABBWithIntersection(aabb, intersection) {\n      var tMin = vec3.copy(vec3.create(), aabb.getMin());\n      vec3.sub(tMin, tMin, this.origin);\n      var tMax = vec3.copy(vec3.create(), aabb.getMax());\n      vec3.sub(tMax, tMax, this.origin);\n      var dir = this.direction; // Ensure that we are not dividing it by zero\n\n      if (dir[0] === 0) {\n        tMin[0] = tMin[0] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n        tMax[0] = tMax[0] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n      } else {\n        tMin[0] /= dir[0];\n        tMax[0] /= dir[0];\n      }\n\n      if (dir[1] === 0) {\n        tMin[1] = tMin[1] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n        tMax[1] = tMax[1] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n      } else {\n        tMin[1] /= dir[1];\n        tMax[1] /= dir[1];\n      }\n\n      if (dir[2] === 0) {\n        tMin[2] = tMin[2] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n        tMax[2] = tMax[2] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n      } else {\n        tMin[2] /= dir[2];\n        tMax[2] /= dir[2];\n      }\n\n      var realMin = vec3.set(tmpVecC, Math.min(tMin[0], tMax[0]), Math.min(tMin[1], tMax[1]), Math.min(tMin[2], tMax[2]));\n      var realMax = vec3.set(tmpVecD, Math.max(tMin[0], tMax[0]), Math.max(tMin[1], tMax[1]), Math.max(tMin[2], tMax[2]));\n      var minMax = Math.min(Math.min(realMax[0], realMax[1]), realMax[2]);\n      var maxMin = Math.max(Math.max(realMin[0], realMin[1]), realMin[2]);\n      var intersects = minMax >= maxMin && maxMin >= 0;\n\n      if (intersects) {\n        vec3.copy(intersection, this.direction);\n        vec3.scaleAndAdd(intersection, this.origin, intersection, maxMin);\n      }\n\n      return intersects;\n    }\n  }]);\n\n  return Ray;\n}();","map":null,"metadata":{},"sourceType":"module"}