{"ast":null,"code":"import { isObject, each, get, groupBy, isNil, filter } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\n/** label text和line距离 4px */\n\nvar MARGIN = 4;\n/**\n * 配置 labelline\n * @param item PolarLabelItem\n */\n\nfunction drawLabelline(item\n/** PolarLabelItem */\n, coordinate) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n\n  if (item && item.labelLine) {\n    var angle = item.angle,\n        labelOffset = item.offset; // 贴近圆周\n\n    var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n    var itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n    var itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n    var endPoint = {\n      x: itemX - Math.cos(angle) * MARGIN,\n      y: itemY - Math.sin(angle) * MARGIN\n    };\n    var smoothConnector = item.labelLine.smooth;\n    var path = [];\n    var dx = endPoint.x - center.x;\n    var dy = endPoint.y - center.y;\n    var endAngle = Math.atan(dy / dx); // 第三象限 & 第四象限\n\n    if (dx < 0) {\n      endAngle += Math.PI;\n    } // 默认 smooth, undefined 也为 smooth\n\n\n    if (smoothConnector === false) {\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      } // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n\n\n      var sweepFlag = 0; // 第一象限\n\n      if (angle < 0 && angle > -Math.PI / 2 || angle > Math.PI * 1.5) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      } // 第二象限\n\n\n      if (angle >= 0 && angle < Math.PI / 2) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      } // 第三象限\n\n\n      if (angle >= Math.PI / 2 && angle < Math.PI) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      } // 第四象限\n\n\n      if (angle < -Math.PI / 2 || angle >= Math.PI && angle < Math.PI * 1.5) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      var distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);\n      var breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle); // 圆弧的结束点\n\n      var breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);\n      /**\n       * @example\n       * M 100 100 L100 90 A 50 50 0 0 0 150 50\n       * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n       * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n       * 第 5 个参数: 是否顺时针绘制\n       */\n      // 默认小弧\n\n      var largeArcFlag = 0; // step1: 移动至起点\n\n      path.push(\"M \".concat(startPoint.x, \" \").concat(startPoint.y)); // step2: 连接拐点\n\n      path.push(\"L \".concat(breakPoint.x, \" \").concat(breakPoint.y)); // step3: 绘制圆弧 至 结束点\n\n      path.push(\"A \".concat(center.x, \" \").concat(center.y, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(breakPoint3.x, \" \").concat(breakPoint3.y)); // step4: 连接结束点\n\n      path.push(\"L \".concat(endPoint.x, \" \").concat(endPoint.y));\n    } else {\n      var breakPoint = polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle); // G2 旧的拉线\n      // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n\n      var xSign = startPoint.x < center.x ? 1 : -1; // step1: 连接结束点\n\n      path.push(\"M \".concat(endPoint.x, \" \").concat(endPoint.y));\n      var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n      var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n\n      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n        // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n        path.push.apply(path, ['C', endPoint.x + xSign * 4, endPoint.y, 2 * breakPoint.x - startPoint.x, 2 * breakPoint.y - startPoint.y, startPoint.x, startPoint.y]);\n      } // step3: 连接至起点\n\n\n      path.push(\"L \".concat(startPoint.x, \" \").concat(startPoint.y));\n    }\n\n    item.labelLine.path = path.join(' ');\n  }\n}\n/**\n * 饼图 outer-label 布局, 适用于 type = pie 且 label offset > 0 的标签\n */\n\n\nexport function pieOuterLabelLayout(originalItems, labels, shapes, region) {\n  var items = filter(originalItems, function (item) {\n    return !isNil(item);\n  });\n  /** 坐标系 */\n\n  var coordinate = labels[0] && labels[0].get('coordinate');\n\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n\n\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n  /** label shapes */\n\n  var labelsMap = {};\n\n  for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {\n    var labelShape = labels_1[_i];\n    labelsMap[labelShape.get('id')] = labelShape;\n  } // note labelHeight 可以控制 label 的行高\n\n\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = get(items[0], 'offset', 0);\n\n  if (labelOffset <= 0) {\n    return;\n  }\n\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right'; // step 1: separate labels\n\n  var separateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  });\n  var start = coordinate.start,\n      end = coordinate.end; // step2: calculate totalHeight\n\n  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());\n  var totalR = totalHeight / 2;\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalR,\n    maxY: center.y + totalR\n  }; // step 3: antiCollision\n\n  each(separateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);\n\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx + 1 > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  each(separateLabels, function (half, key) {\n    each(half, function (item) {\n      var isRight = key === RIGHT_HALF_KEY;\n      var labelShape = labelsMap[item.id]; // because group could not effect content-shape, should set content-shape position manually\n\n      var content = labelShape.getChildByIndex(0); // textShape 发生过调整\n\n      if (content) {\n        var r = radius + labelOffset; // (x - cx)^2 + (y - cy)^2 = totalR^2\n\n        var dy = item.y - center.y;\n        var rPow2 = Math.pow(r, 2);\n        var dyPow2 = Math.pow(dy, 2);\n        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;\n        var dx = Math.sqrt(dxPow2);\n        var dx_offset = Math.abs(Math.cos(item.angle) * r);\n\n        if (!isRight) {\n          // left\n          item.x = center.x - Math.max(dx, dx_offset);\n        } else {\n          // right\n          item.x = center.x + Math.max(dx, dx_offset);\n        }\n      } // adjust labelShape\n\n\n      if (content) {\n        content.attr('y', item.y);\n        content.attr('x', item.x);\n      }\n\n      drawLabelline(item, coordinate);\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}