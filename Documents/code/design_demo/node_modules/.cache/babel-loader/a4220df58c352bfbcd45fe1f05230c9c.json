{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { generateColorRamp, getMask } from '@antv/l7-utils';\nimport { mat4 } from 'gl-matrix';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapTriangulation } from '../../core/triangulation';\nvar heatmap3DFrag = \"uniform sampler2D u_texture;\\nuniform sampler2D u_colorTexture;\\nuniform float u_opacity;\\nvarying vec2 v_texCoord;\\nvarying float v_intensity;\\n\\nvoid main(){\\n   \\n     float intensity = texture2D(u_texture, v_texCoord).r;\\n    vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\\n    gl_FragColor = color;\\n    // gl_FragColor.a = color.a * smoothstep(0.1,0.2,intensity)* u_opacity;\\n     gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\\n}\\n\";\nvar heatmap3DVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute vec2 a_Uv;\\nuniform sampler2D u_texture;\\nvarying vec2 v_texCoord;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_InverseViewProjectionMatrix;\\nuniform mat4 u_ViewProjectionMatrixUncentered;\\nvarying float v_intensity;\\n\\n\\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\\n    float t2 = t * t;\\n    float one_minus_t = 1.0 - t;\\n    float one_minus_t2 = one_minus_t * one_minus_t;\\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t);\\n}\\nvec2 toBezier(float t, vec4 p){\\n    return toBezier(t, vec2(0.0, 0.0), vec2(p.x, p.y), vec2(p.z, p.w), vec2(1.0, 1.0));\\n}\\n#pragma include \\\"projection\\\"\\nvoid main() {\\n  v_texCoord = a_Uv;\\n\\n  vec2 pos = a_Uv * vec2(2.0) - vec2(1.0); // \\u5C06\\u539F\\u672C 0 -> 1 \\u7684 uv \\u8F6C\\u6362\\u4E3A -1 -> 1 \\u7684\\u6807\\u51C6\\u5750\\u6807\\u7A7A\\u95F4\\uFF08NDC\\uFF09\\n\\n  vec4 p1 = vec4(pos, 0.0, 1.0); // x/y \\u5E73\\u9762\\u4E0A\\u7684\\u70B9\\uFF08z == 0\\uFF09\\u53EF\\u4EE5\\u8BA4\\u4E3A\\u662F\\u4E09\\u7EF4\\u4E0A\\u7684\\u70B9\\u88AB\\u6295\\u5F71\\u5230\\u5E73\\u9762\\u540E\\u7684\\u70B9\\n\\tvec4 p2 = vec4(pos, 1.0, 1.0); // \\u5E73\\u884C\\u4E8Ex/y\\u5E73\\u9762\\u3001z==1 \\u7684\\u5E73\\u9762\\u4E0A\\u7684\\u70B9\\n\\n\\tvec4 inverseP1 = u_InverseViewProjectionMatrix * p1; // \\u6839\\u636E\\u89C6\\u56FE\\u6295\\u5F71\\u77E9\\u9635\\u7684\\u9006\\u77E9\\u9635\\u5E73\\u9762\\u4E0A\\u7684\\u53CD\\u7B97\\u51FA\\u4E09\\u7EF4\\u7A7A\\u95F4\\u4E2D\\u7684\\u70B9\\uFF08p1\\u5E73\\u9762\\u4E0A\\u7684\\u70B9\\uFF09\\n\\tvec4 inverseP2 = u_InverseViewProjectionMatrix * p2;\\n\\n  inverseP1 = inverseP1 / inverseP1.w; // \\u5F52\\u4E00\\u5316\\u64CD\\u4F5C\\uFF08\\u5F52\\u4E00\\u5316\\u540E\\u4E3A\\u4E16\\u754C\\u5750\\u6807\\uFF09\\n\\tinverseP2 = inverseP2 / inverseP2.w;\\n\\n\\tfloat zPos = (0.0 - inverseP1.z) / (inverseP2.z - inverseP1.z); // ??\\n\\tvec4 position = inverseP1 + zPos * (inverseP2 - inverseP1);\\n\\n  vec4 b= vec4(0.5000, 0.0, 1.0, 0.5000);\\n  float fh;\\n\\n  v_intensity = texture2D(u_texture, v_texCoord).r;\\n  fh = toBezier(v_intensity, b).y;\\n  gl_Position = u_ViewProjectionMatrixUncentered * vec4(position.xy, fh * project_pixel(50.), 1.0);\\n \\n}\\n\";\nvar heatmapColorFrag = \"uniform sampler2D u_texture;        // \\u70ED\\u529B\\u5F3A\\u5EA6\\u56FE\\nuniform sampler2D u_colorTexture;   // \\u6839\\u636E\\u5F3A\\u5EA6\\u5206\\u5E03\\u7684\\u8272\\u5E26\\nuniform float u_opacity;\\nvarying vec2 v_texCoord;\\n\\nfloat getBlurIndusty() {\\n    float h = 2.0/512.0;\\n    vec2 vUv = v_texCoord;\\n    float i11 = texture2D( u_texture, vec2( vUv.x - 1.0 * h, vUv.y + 1.0 * h) ).r;\\n    float i12 = texture2D( u_texture, vec2( vUv.x - 0.0 * h, vUv.y + 1.0 * h) ).r;\\n    float i13 = texture2D( u_texture, vec2( vUv.x + 1.0 * h, vUv.y + 1.0 * h) ).r;\\n\\n    float i21 = texture2D( u_texture, vec2( vUv.x - 1.0 * h, vUv.y) ).r;\\n    float i22 = texture2D( u_texture, vec2( vUv.x , vUv.y) ).r;\\n    float i23 = texture2D( u_texture, vec2( vUv.x + 1.0 * h, vUv.y) ).r;\\n\\n    float i31 = texture2D( u_texture, vec2( vUv.x - 1.0 * h, vUv.y-1.0*h) ).r;\\n    float i32 = texture2D( u_texture, vec2( vUv.x - 0.0 * h, vUv.y-1.0*h) ).r;\\n    float i33 = texture2D( u_texture, vec2( vUv.x + 1.0 * h, vUv.y-1.0*h) ).r;\\n\\n    return(\\n        i11 + \\n        i12 + \\n        i13 + \\n        i21 + \\n        i21 + \\n        i22 + \\n        i23 + \\n        i31 + \\n        i32 + \\n        i33\\n        )/9.0;\\n}\\n\\n\\nvoid main(){\\n    // float intensity = texture2D(u_texture, v_texCoord).r;\\n    float intensity = getBlurIndusty();\\n    vec4 color = texture2D(u_colorTexture, vec2(intensity, 0.0));\\n\\n    gl_FragColor =color;\\n    gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\\n\\n}\\n\";\nvar heatmapColorVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute vec2 a_Uv;\\nvarying vec2 v_texCoord;\\n\\nvoid main() {\\n  v_texCoord = a_Uv;\\n\\n  gl_Position = vec4(a_Position.xy, 0, 1.);\\n}\\n\";\nvar heatmapFramebufferFrag = \"precision highp float;\\nuniform float u_intensity;\\nvarying float v_weight;\\nvarying vec2 v_extrude;\\n#define GAUSS_COEF  0.3989422804014327\\nvoid main(){\\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\\n    float val = v_weight * u_intensity * GAUSS_COEF * exp(d);\\n    gl_FragColor = vec4(val, 1., 1., 1.);\\n}\\n\";\nvar heatmapFramebufferVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute float a_Size;\\nattribute vec2 a_Dir;\\nuniform float u_intensity;\\nuniform float u_radius;\\nvarying vec2 v_extrude;\\nvarying float v_weight;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_Mvp;\\n\\n#define GAUSS_COEF  0.3989422804014327\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main(){\\n    v_weight = a_Size;\\n    float ZERO = 1.0 / 255.0 / 16.0;\\n    float extrude_x = a_Dir.x * 2.0 -1.0;\\n    float extrude_y = a_Dir.y * 2.0 -1.0;\\n    vec2 extrude_dir = normalize(vec2(extrude_x,extrude_y));\\n    float S = sqrt(-2.0 * log(ZERO / a_Size / u_intensity / GAUSS_COEF)) / 2.5;\\n    v_extrude = extrude_dir * S;\\n\\n    vec2 offset = project_pixel(v_extrude * u_radius);\\n    vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\\n\\n    // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\\n\\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n        gl_Position = u_Mvp * (vec4(project_pos.xy + offset, 0.0, 1.0));\\n    } else {\\n        gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\\n    }\\n}\\n\";\nimport { heatMap3DTriangulation } from '../triangulation';\nvar HeatMapModel = (_dec = injectable(), _dec(_class = function (_BaseModel) {\n  _inherits(HeatMapModel, _BaseModel);\n\n  var _super = _createSuper(HeatMapModel);\n\n  function HeatMapModel() {\n    var _this;\n\n    _classCallCheck(this, HeatMapModel);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"texture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"colorTexture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"heatmapFramerBuffer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"intensityModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"colorModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"shapeType\", void 0);\n\n    return _this;\n  }\n\n  _createClass(HeatMapModel, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$rendererService = this.rendererService,\n          clear = _this$rendererService.clear,\n          useFramebuffer = _this$rendererService.useFramebuffer;\n      useFramebuffer(this.heatmapFramerBuffer, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: _this2.heatmapFramerBuffer\n        });\n\n        _this2.drawIntensityMode();\n      });\n\n      if (this.layer.styleNeedUpdate) {\n        this.updateColorTexture();\n      }\n\n      this.shapeType === 'heatmap' ? this.drawColorMode() : this.draw3DHeatMap();\n    }\n  }, {\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      var _shapeAttr$scale;\n\n      var _this$rendererService2 = this.rendererService,\n          createFramebuffer = _this$rendererService2.createFramebuffer,\n          clear = _this$rendererService2.clear,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          createTexture2D = _this$rendererService2.createTexture2D,\n          useFramebuffer = _this$rendererService2.useFramebuffer;\n      var shapeAttr = this.styleAttributeService.getLayerStyleAttribute('shape');\n      var shapeType = (shapeAttr === null || shapeAttr === void 0 ? void 0 : (_shapeAttr$scale = shapeAttr.scale) === null || _shapeAttr$scale === void 0 ? void 0 : _shapeAttr$scale.field) || 'heatmap';\n      this.shapeType = shapeType;\n      this.intensityModel = this.buildHeatMapIntensity();\n      this.colorModel = shapeType === 'heatmap' ? this.buildHeatmapColor() : this.build3dHeatMap();\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      this.heatmapFramerBuffer = createFramebuffer({\n        color: createTexture2D({\n          width: Math.floor(width / 4),\n          height: Math.floor(height / 4),\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE,\n          min: gl.LINEAR,\n          mag: gl.LINEAR\n        }),\n        depth: false\n      });\n      this.updateColorTexture();\n      return [this.intensityModel, this.colorModel];\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return this.initModels();\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'dir',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Dir',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4]];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$size = feature.size,\n                size = _feature$size === void 0 ? 1 : _feature$size;\n            return [size];\n          }\n        }\n      });\n    }\n  }, {\n    key: \"buildHeatMapIntensity\",\n    value: function buildHeatMapIntensity() {\n      return this.layer.buildLayerModel({\n        moduleName: 'heatmapintensity',\n        vertexShader: heatmapFramebufferVert,\n        fragmentShader: heatmapFramebufferFrag,\n        triangulation: HeatmapTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.ONE,\n            srcAlpha: 1,\n            dstRGB: gl.ONE,\n            dstAlpha: 1\n          }\n        }\n      });\n    }\n  }, {\n    key: \"buildHeatmapColor\",\n    value: function buildHeatmapColor() {\n      var _ref = this.layer.getLayerConfig(),\n          _ref$mask = _ref.mask,\n          mask = _ref$mask === void 0 ? false : _ref$mask,\n          _ref$maskInside = _ref.maskInside,\n          maskInside = _ref$maskInside === void 0 ? true : _ref$maskInside;\n\n      this.shaderModuleService.registerModule('heatmapColor', {\n        vs: heatmapColorVert,\n        fs: heatmapColorFrag\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('heatmapColor'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService3 = this.rendererService,\n          createAttribute = _this$rendererService3.createAttribute,\n          createElements = _this$rendererService3.createElements,\n          createBuffer = _this$rendererService3.createBuffer,\n          createModel = _this$rendererService3.createModel;\n      return createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],\n              type: gl.FLOAT\n            }),\n            size: 3\n          }),\n          a_Uv: createAttribute({\n            buffer: createBuffer({\n              data: [0, 1, 1, 1, 0, 0, 1, 0],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend(),\n        count: 6,\n        elements: createElements({\n          data: [0, 2, 1, 2, 3, 1],\n          type: gl.UNSIGNED_INT,\n          count: 6\n        }),\n        stencil: getMask(mask, maskInside)\n      });\n    }\n  }, {\n    key: \"drawIntensityMode\",\n    value: function drawIntensityMode() {\n      var _ref2 = this.layer.getLayerConfig(),\n          opacity = _ref2.opacity,\n          _ref2$intensity = _ref2.intensity,\n          intensity = _ref2$intensity === void 0 ? 10 : _ref2$intensity,\n          _ref2$radius = _ref2.radius,\n          radius = _ref2$radius === void 0 ? 5 : _ref2$radius;\n\n      this.intensityModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_radius: radius,\n          u_intensity: intensity\n        }\n      });\n    }\n  }, {\n    key: \"drawColorMode\",\n    value: function drawColorMode() {\n      var _ref3 = this.layer.getLayerConfig(),\n          opacity = _ref3.opacity;\n\n      this.colorModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_colorTexture: this.colorTexture,\n          u_texture: this.heatmapFramerBuffer\n        }\n      });\n    }\n  }, {\n    key: \"draw3DHeatMap\",\n    value: function draw3DHeatMap() {\n      var _ref4 = this.layer.getLayerConfig(),\n          opacity = _ref4.opacity;\n\n      var invert = mat4.create();\n      mat4.invert(invert, this.cameraService.getViewProjectionMatrixUncentered());\n      this.colorModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_colorTexture: this.colorTexture,\n          u_texture: this.heatmapFramerBuffer,\n          u_ViewProjectionMatrixUncentered: this.cameraService.getViewProjectionMatrixUncentered(),\n          u_InverseViewProjectionMatrix: _toConsumableArray(invert)\n        }\n      });\n    }\n  }, {\n    key: \"build3dHeatMap\",\n    value: function build3dHeatMap() {\n      var _ref5 = this.layer.getLayerConfig(),\n          _ref5$mask = _ref5.mask,\n          mask = _ref5$mask === void 0 ? false : _ref5$mask,\n          _ref5$maskInside = _ref5.maskInside,\n          maskInside = _ref5$maskInside === void 0 ? true : _ref5$maskInside;\n\n      var getViewportSize = this.rendererService.getViewportSize;\n\n      var _getViewportSize2 = getViewportSize(),\n          width = _getViewportSize2.width,\n          height = _getViewportSize2.height;\n\n      var triangulation = heatMap3DTriangulation(width / 4.0, height / 4.0);\n      this.shaderModuleService.registerModule('heatmap3dColor', {\n        vs: heatmap3DVert,\n        fs: heatmap3DFrag\n      });\n\n      var _this$shaderModuleSer2 = this.shaderModuleService.getModule('heatmap3dColor'),\n          vs = _this$shaderModuleSer2.vs,\n          fs = _this$shaderModuleSer2.fs,\n          uniforms = _this$shaderModuleSer2.uniforms;\n\n      var _this$rendererService4 = this.rendererService,\n          createAttribute = _this$rendererService4.createAttribute,\n          createElements = _this$rendererService4.createElements,\n          createBuffer = _this$rendererService4.createBuffer,\n          createModel = _this$rendererService4.createModel;\n      return createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: triangulation.vertices,\n              type: gl.FLOAT\n            }),\n            size: 3\n          }),\n          a_Uv: createAttribute({\n            buffer: createBuffer({\n              data: triangulation.uvs,\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        primitive: gl.TRIANGLES,\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: true\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.SRC_ALPHA,\n            srcAlpha: 1,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            dstAlpha: 1\n          }\n        },\n        elements: createElements({\n          data: triangulation.indices,\n          type: gl.UNSIGNED_INT,\n          count: triangulation.indices.length\n        }),\n        stencil: getMask(mask, maskInside)\n      });\n    }\n  }, {\n    key: \"updateStyle\",\n    value: function updateStyle() {\n      this.updateColorTexture();\n    }\n  }, {\n    key: \"updateColorTexture\",\n    value: function updateColorTexture() {\n      var createTexture2D = this.rendererService.createTexture2D;\n\n      if (this.texture) {\n        this.texture.destroy();\n      }\n\n      var _ref6 = this.layer.getLayerConfig(),\n          rampColors = _ref6.rampColors;\n\n      var imageData = generateColorRamp(rampColors);\n      this.colorTexture = createTexture2D({\n        data: new Uint8Array(imageData.data),\n        width: imageData.width,\n        height: imageData.height,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        min: gl.NEAREST,\n        mag: gl.NEAREST,\n        flipY: false\n      });\n    }\n  }]);\n\n  return HeatMapModel;\n}(BaseModel)) || _class);\nexport { HeatMapModel as default };","map":null,"metadata":{},"sourceType":"module"}