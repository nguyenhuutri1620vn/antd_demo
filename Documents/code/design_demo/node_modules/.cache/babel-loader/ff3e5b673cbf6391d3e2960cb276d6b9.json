{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { FunctionExt, ObjectExt } from '../util';\nimport { Model } from '../model/model';\nimport { CellView } from '../view/cell';\nimport { NodeView } from '../view/node';\nimport { EdgeView } from '../view/edge';\nimport { Knob } from '../addon/knob';\nimport { MiniMap } from '../addon/minimap';\nimport { Snapline } from '../addon/snapline';\nimport { Scroller } from '../addon/scroller';\nimport { Selection } from '../addon/selection';\nimport { Clipboard } from '../addon/clipboard';\nimport { Transform } from '../addon/transform';\nimport { HTML } from '../shape/standard/html';\nimport { Edge as StandardEdge } from '../shape/standard/edge';\nimport { Base } from './base';\nimport { Options } from './options';\nimport { Renderer } from './renderer';\nimport { GraphView } from './view';\nimport { DefsManager } from './defs';\nimport { GridManager } from './grid';\nimport { CoordManager } from './coord';\nimport { SnaplineManager } from './snapline';\nimport { ScrollerManager } from './scroller';\nimport { ClipboardManager } from './clipboard';\nimport { HighlightManager } from './highlight';\nimport { TransformManager } from './transform';\nimport { SelectionManager } from './selection';\nimport { BackgroundManager } from './background';\nimport { HistoryManager } from './history';\nimport { MiniMapManager } from './minimap';\nimport { Keyboard } from './keyboard';\nimport { MouseWheel } from './mousewheel';\nimport { PrintManager } from './print';\nimport { FormatManager } from './format';\nimport { KnobManager } from './knob';\nimport { PanningManager } from './panning';\nimport { SizeManager } from './size';\nvar Decorator;\n\n(function (Decorator) {\n  function hook(nullable, hookName) {\n    return (target, methodName, descriptor) => {\n      const raw = descriptor.value;\n      const name = hookName || methodName;\n\n      descriptor.value = function () {\n        const hook = this.options[name];\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (hook != null) {\n          this.getNativeValue = raw.bind(this, ...args);\n          const ret = FunctionExt.call(hook, this.graph, ...args);\n          this.getNativeValue = null;\n\n          if (ret != null || nullable === true && ret === null) {\n            return ret;\n          }\n        }\n\n        return raw.call(this, ...args);\n      };\n    };\n  }\n\n  Decorator.hook = hook;\n\n  function after(hookName) {\n    return (target, methodName, descriptor) => {\n      const raw = descriptor.value;\n      const name = hookName || methodName;\n\n      descriptor.value = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        let ret = raw.call(this, ...args);\n        const hook = this.options[name];\n\n        if (hook != null) {\n          ret = FunctionExt.call(hook, this.graph, ...args) && ret;\n        }\n\n        return ret;\n      };\n    };\n  }\n\n  Decorator.after = after;\n})(Decorator || (Decorator = {}));\n\nexport class Hook extends Base {\n  createModel() {\n    if (this.options.model) {\n      return this.options.model;\n    }\n\n    const model = new Model();\n    model.graph = this.graph;\n    return model;\n  }\n\n  createView() {\n    return new GraphView(this.graph);\n  }\n\n  createRenderer() {\n    return new Renderer(this.graph);\n  }\n\n  createDefsManager() {\n    return new DefsManager(this.graph);\n  }\n\n  createGridManager() {\n    return new GridManager(this.graph);\n  }\n\n  createCoordManager() {\n    return new CoordManager(this.graph);\n  }\n\n  createKnobManager() {\n    return new KnobManager(this.graph);\n  }\n\n  createTransform(node, widgetOptions) {\n    const options = this.getTransformOptions(node);\n\n    if (options.resizable || options.rotatable) {\n      return new Transform(Object.assign(Object.assign({\n        node,\n        graph: this.graph\n      }, options), widgetOptions));\n    }\n\n    if (options.clearAll) {\n      Transform.removeInstances(this.graph);\n    }\n\n    return null;\n  }\n\n  createKnob(node, widgetOptions) {\n    const options = Options.parseOptionGroup(this.graph, node, this.options.knob);\n    const localOptions = Object.assign(Object.assign({}, options), widgetOptions);\n\n    if (localOptions.clearAll) {\n      Knob.removeInstances(this.graph);\n    }\n\n    localOptions.clearAll = false;\n    const knob = node.prop('knob');\n    const widgets = [];\n    const meta = Array.isArray(knob) ? knob : [knob];\n    meta.forEach((knob, index) => {\n      if (knob) {\n        if (knob.enabled === false) {\n          return;\n        }\n\n        if (typeof knob.enabled === 'function' && knob.enabled.call(this.graph, node) === false) {\n          return;\n        }\n      } else {\n        return;\n      }\n\n      if (options.enabled) {\n        widgets.push(new Knob(Object.assign({\n          node,\n          index,\n          graph: this.graph\n        }, localOptions)));\n      }\n    });\n    return widgets;\n  }\n\n  getTransformOptions(node) {\n    const resizing = Options.parseOptionGroup(this.graph, node, this.options.resizing);\n    const rotating = Options.parseOptionGroup(this.graph, node, this.options.rotating);\n    const transforming = Options.parseOptionGroup(this.graph, node, this.options.transforming);\n    const options = Object.assign(Object.assign({}, transforming), {\n      resizable: resizing.enabled,\n      minWidth: resizing.minWidth,\n      maxWidth: resizing.maxWidth,\n      minHeight: resizing.minHeight,\n      maxHeight: resizing.maxHeight,\n      orthogonalResizing: resizing.orthogonal,\n      restrictedResizing: resizing.restrict != null ? resizing.restrict : resizing.restricted,\n      autoScrollOnResizing: resizing.autoScroll,\n      preserveAspectRatio: resizing.preserveAspectRatio,\n      allowReverse: resizing.allowReverse,\n      rotatable: rotating.enabled,\n      rotateGrid: rotating.grid\n    });\n    return options;\n  }\n\n  createTransformManager() {\n    return new TransformManager(this.graph);\n  }\n\n  createHighlightManager() {\n    return new HighlightManager(this.graph);\n  }\n\n  createBackgroundManager() {\n    return new BackgroundManager(this.graph);\n  }\n\n  createClipboard() {\n    return new Clipboard();\n  }\n\n  createClipboardManager() {\n    return new ClipboardManager(this.graph);\n  }\n\n  createSnapline() {\n    return new Snapline(Object.assign({\n      graph: this.graph\n    }, this.options.snapline));\n  }\n\n  createSnaplineManager() {\n    return new SnaplineManager(this.graph);\n  }\n\n  createSelection() {\n    return new Selection(Object.assign({\n      graph: this.graph\n    }, this.options.selecting));\n  }\n\n  createSelectionManager() {\n    return new SelectionManager(this.graph);\n  } // eslint-disable-next-line\n\n\n  allowRubberband(e) {\n    return true;\n  }\n\n  createHistoryManager() {\n    return new HistoryManager(Object.assign({\n      graph: this.graph\n    }, this.options.history));\n  }\n\n  createScroller() {\n    if (this.options.scroller.enabled) {\n      return new Scroller(Object.assign({\n        graph: this.graph\n      }, this.options.scroller));\n    }\n\n    return null;\n  }\n\n  createScrollerManager() {\n    return new ScrollerManager(this.graph);\n  } // eslint-disable-next-line\n\n\n  allowPanning(e) {\n    return true;\n  }\n\n  createMiniMap() {\n    const _a = this.options.minimap,\n          {\n      enabled\n    } = _a,\n          options = __rest(_a, [\"enabled\"]);\n\n    if (enabled) {\n      return new MiniMap(Object.assign({\n        graph: this.graph\n      }, options));\n    }\n\n    return null;\n  }\n\n  createMiniMapManager() {\n    return new MiniMapManager(this.graph);\n  }\n\n  createKeyboard() {\n    return new Keyboard(Object.assign({\n      graph: this.graph\n    }, this.options.keyboard));\n  }\n\n  createMouseWheel() {\n    return new MouseWheel(Object.assign({\n      graph: this.graph\n    }, this.options.mousewheel));\n  }\n\n  createPrintManager() {\n    return new PrintManager(this.graph);\n  }\n\n  createFormatManager() {\n    return new FormatManager(this.graph);\n  }\n\n  createPanningManager() {\n    return new PanningManager(this.graph);\n  }\n\n  createSizeManager() {\n    return new SizeManager(this.graph);\n  }\n\n  allowConnectToBlank(edge) {\n    const options = this.options.connecting;\n    const allowBlank = options.allowBlank != null ? options.allowBlank : options.dangling;\n\n    if (typeof allowBlank !== 'function') {\n      return !!allowBlank;\n    }\n\n    const edgeView = this.graph.findViewByCell(edge);\n    const sourceCell = edge.getSourceCell();\n    const targetCell = edge.getTargetCell();\n    const sourceView = this.graph.findViewByCell(sourceCell);\n    const targetView = this.graph.findViewByCell(targetCell);\n    return FunctionExt.call(allowBlank, this.graph, {\n      edge,\n      edgeView,\n      sourceCell,\n      targetCell,\n      sourceView,\n      targetView,\n      sourcePort: edge.getSourcePortId(),\n      targetPort: edge.getTargetPortId(),\n      sourceMagnet: edgeView.sourceMagnet,\n      targetMagnet: edgeView.targetMagnet\n    });\n  }\n\n  validateEdge(edge, type, initialTerminal) {\n    if (!this.allowConnectToBlank(edge)) {\n      const sourceId = edge.getSourceCellId();\n      const targetId = edge.getTargetCellId();\n\n      if (!(sourceId && targetId)) {\n        return false;\n      }\n    }\n\n    const validate = this.options.connecting.validateEdge;\n\n    if (validate) {\n      return FunctionExt.call(validate, this.graph, {\n        edge,\n        type,\n        previous: initialTerminal\n      });\n    }\n\n    return true;\n  }\n\n  validateMagnet(cellView, magnet, e) {\n    if (magnet.getAttribute('magnet') !== 'passive') {\n      const validate = this.options.connecting.validateMagnet;\n\n      if (validate) {\n        return FunctionExt.call(validate, this.graph, {\n          e,\n          magnet,\n          view: cellView,\n          cell: cellView.cell\n        });\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getDefaultEdge(sourceView, sourceMagnet) {\n    let edge;\n    const create = this.options.connecting.createEdge;\n\n    if (create) {\n      edge = FunctionExt.call(create, this.graph, {\n        sourceMagnet,\n        sourceView,\n        sourceCell: sourceView.cell\n      });\n    }\n\n    if (edge == null) {\n      edge = new StandardEdge();\n    }\n\n    return edge;\n  }\n\n  validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {\n    const options = this.options.connecting;\n    const allowLoop = options.allowLoop;\n    const allowNode = options.allowNode;\n    const allowEdge = options.allowEdge;\n    const allowPort = options.allowPort;\n    const allowMulti = options.allowMulti != null ? options.allowMulti : options.multi;\n    const validate = options.validateConnection;\n    const edge = edgeView ? edgeView.cell : null;\n    const terminalView = terminalType === 'target' ? targetView : sourceView;\n    const terminalMagnet = terminalType === 'target' ? targetMagnet : sourceMagnet;\n    let valid = true;\n\n    const doValidate = validate => {\n      const sourcePort = terminalType === 'source' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getSourcePortId() : null;\n      const targetPort = terminalType === 'target' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getTargetPortId() : null;\n      return FunctionExt.call(validate, this.graph, {\n        edge,\n        edgeView,\n        sourceView,\n        targetView,\n        sourcePort,\n        targetPort,\n        sourceMagnet,\n        targetMagnet,\n        sourceCell: sourceView ? sourceView.cell : null,\n        targetCell: targetView ? targetView.cell : null,\n        type: terminalType\n      });\n    };\n\n    if (allowLoop != null) {\n      if (typeof allowLoop === 'boolean') {\n        if (!allowLoop && sourceView === targetView) {\n          valid = false;\n        }\n      } else {\n        valid = doValidate(allowLoop);\n      }\n    }\n\n    if (valid && allowPort != null) {\n      if (typeof allowPort === 'boolean') {\n        if (!allowPort && terminalMagnet) {\n          valid = false;\n        }\n      } else {\n        valid = doValidate(allowPort);\n      }\n    }\n\n    if (valid && allowEdge != null) {\n      if (typeof allowEdge === 'boolean') {\n        if (!allowEdge && EdgeView.isEdgeView(terminalView)) {\n          valid = false;\n        }\n      } else {\n        valid = doValidate(allowEdge);\n      }\n    }\n\n    if (valid && allowNode != null) {\n      if (typeof allowNode === 'boolean') {\n        if (!allowNode && terminalView != null) {\n          if (NodeView.isNodeView(terminalView) && terminalMagnet == null) {\n            valid = false;\n          }\n        }\n      } else {\n        valid = doValidate(allowNode);\n      }\n    }\n\n    if (valid && allowMulti != null && edgeView) {\n      const edge = edgeView.cell;\n      const source = terminalType === 'source' ? candidateTerminal : edge.getSource();\n      const target = terminalType === 'target' ? candidateTerminal : edge.getTarget();\n      const terminalCell = candidateTerminal ? this.graph.getCellById(candidateTerminal.cell) : null;\n\n      if (source && target && source.cell && target.cell && terminalCell) {\n        if (typeof allowMulti === 'function') {\n          valid = doValidate(allowMulti);\n        } else {\n          const connectedEdges = this.model.getConnectedEdges(terminalCell, {\n            outgoing: terminalType === 'source',\n            incoming: terminalType === 'target'\n          });\n\n          if (connectedEdges.length) {\n            if (allowMulti === 'withPort') {\n              const exist = connectedEdges.some(link => {\n                const s = link.getSource();\n                const t = link.getTarget();\n                return s && t && s.cell === source.cell && t.cell === target.cell && s.port != null && s.port === source.port && t.port != null && t.port === target.port;\n              });\n\n              if (exist) {\n                valid = false;\n              }\n            } else if (!allowMulti) {\n              const exist = connectedEdges.some(link => {\n                const s = link.getSource();\n                const t = link.getTarget();\n                return s && t && s.cell === source.cell && t.cell === target.cell;\n              });\n\n              if (exist) {\n                valid = false;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (valid && validate != null) {\n      valid = doValidate(validate);\n    }\n\n    return valid;\n  }\n\n  getRestrictArea(view) {\n    const restrict = this.options.translating.restrict;\n    const area = typeof restrict === 'function' ? FunctionExt.call(restrict, this.graph, view) : restrict;\n\n    if (typeof area === 'number') {\n      return this.graph.transform.getGraphArea().inflate(area);\n    }\n\n    if (area === true) {\n      return this.graph.transform.getGraphArea();\n    }\n\n    return area || null;\n  }\n\n  onViewUpdated(view, flag, options) {\n    if (flag & Renderer.FLAG_INSERT || options.mounting) {\n      return;\n    }\n\n    this.graph.renderer.requestConnectedEdgesUpdate(view, options);\n  }\n\n  onViewPostponed(view, flag, options) {\n    return this.graph.renderer.forcePostponedViewUpdate(view, flag);\n  }\n\n  getCellView(cell) {\n    return null;\n  }\n\n  createCellView(cell) {\n    const options = {\n      graph: this.graph\n    };\n    const ctor = this.getCellView(cell);\n\n    if (ctor) {\n      return new ctor(cell, options); // eslint-disable-line new-cap\n    }\n\n    const view = cell.view;\n\n    if (view != null && typeof view === 'string') {\n      const def = CellView.registry.get(view);\n\n      if (def) {\n        return new def(cell, options); // eslint-disable-line new-cap\n      }\n\n      return CellView.registry.onNotFound(view);\n    }\n\n    if (cell.isNode()) {\n      return new NodeView(cell, options);\n    }\n\n    if (cell.isEdge()) {\n      return new EdgeView(cell, options);\n    }\n\n    return null;\n  }\n\n  getHTMLComponent(node) {\n    let ret = node.getHTML();\n\n    if (typeof ret === 'string') {\n      ret = HTML.componentRegistry.get(ret) || ret;\n    }\n\n    if (ObjectExt.isPlainObject(ret)) {\n      ret = ret.render;\n    }\n\n    if (typeof ret === 'function') {\n      return FunctionExt.call(ret, this.graph, node);\n    }\n\n    return ret;\n  }\n\n  shouldUpdateHTMLComponent(node) {\n    let html = node.getHTML();\n\n    if (typeof html === 'string') {\n      html = HTML.componentRegistry.get(html) || html;\n    }\n\n    if (ObjectExt.isPlainObject(html)) {\n      const shouldUpdate = html.shouldComponentUpdate;\n\n      if (typeof shouldUpdate === 'function') {\n        return FunctionExt.call(shouldUpdate, this.graph, node);\n      }\n\n      return !!shouldUpdate;\n    }\n\n    return false;\n  }\n\n  onEdgeLabelRendered(args) {} // eslint-disable-line\n\n\n  onPortRendered(args) {} // eslint-disable-line\n\n\n  onToolItemCreated(args) {} // eslint-disable-line\n\n\n}\n\n__decorate([Decorator.hook()], Hook.prototype, \"createModel\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createView\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createRenderer\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createDefsManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createGridManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createCoordManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createKnobManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createTransform\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createKnob\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createTransformManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createHighlightManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createBackgroundManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createClipboard\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createClipboardManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSnapline\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSnaplineManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSelection\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSelectionManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"allowRubberband\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createHistoryManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createScroller\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createScrollerManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"allowPanning\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createMiniMap\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createMiniMapManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createKeyboard\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createMouseWheel\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createPrintManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createFormatManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createPanningManager\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"createSizeManager\", null);\n\n__decorate([Decorator.after()], Hook.prototype, \"onViewUpdated\", null);\n\n__decorate([Decorator.after()], Hook.prototype, \"onViewPostponed\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"getCellView\", null);\n\n__decorate([Decorator.hook(true)], Hook.prototype, \"createCellView\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"getHTMLComponent\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"shouldUpdateHTMLComponent\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"onEdgeLabelRendered\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"onPortRendered\", null);\n\n__decorate([Decorator.hook()], Hook.prototype, \"onToolItemCreated\", null);","map":null,"metadata":{},"sourceType":"module"}