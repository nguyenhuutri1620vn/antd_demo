{"ast":null,"code":"import { Line } from '../line';\nimport { Curve } from '../curve';\nimport { Point } from '../point';\nimport { LineTo } from './lineto';\nimport { Segment } from './segment';\nexport class MoveTo extends Segment {\n  constructor(x, y) {\n    super();\n    this.isVisible = false;\n    this.isSubpathStart = true;\n\n    if (Line.isLine(x) || Curve.isCurve(x)) {\n      this.endPoint = x.end.clone().round(2);\n    } else {\n      this.endPoint = Point.create(x, y).round(2);\n    }\n  }\n\n  get start() {\n    throw new Error('Illegal access. Moveto segments should not need a start property.');\n  }\n\n  get type() {\n    return 'M';\n  }\n\n  bbox() {\n    return null;\n  }\n\n  closestPoint() {\n    return this.end.clone();\n  }\n\n  closestPointLength() {\n    return 0;\n  }\n\n  closestPointNormalizedLength() {\n    return 0;\n  }\n\n  closestPointT() {\n    return 1;\n  }\n\n  closestPointTangent() {\n    return null;\n  }\n\n  length() {\n    return 0;\n  }\n\n  lengthAtT() {\n    return 0;\n  }\n\n  divideAt() {\n    return [this.clone(), this.clone()];\n  }\n\n  divideAtLength() {\n    return [this.clone(), this.clone()];\n  }\n\n  getSubdivisions() {\n    return [];\n  }\n\n  pointAt() {\n    return this.end.clone();\n  }\n\n  pointAtLength() {\n    return this.end.clone();\n  }\n\n  pointAtT() {\n    return this.end.clone();\n  }\n\n  tangentAt() {\n    return null;\n  }\n\n  tangentAtLength() {\n    return null;\n  }\n\n  tangentAtT() {\n    return null;\n  }\n\n  isDifferentiable() {\n    return false;\n  }\n\n  scale(sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty);\n    } else {\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  clone() {\n    return new MoveTo(this.end);\n  }\n\n  equals(s) {\n    return this.type === s.type && this.end.equals(s.end);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    const end = this.end;\n    return `${this.type} ${end.x} ${end.y}`;\n  }\n\n}\n\n(function (MoveTo) {\n  function create() {\n    const len = arguments.length;\n    const arg0 = arguments.length <= 0 ? undefined : arguments[0]; // line provided\n\n    if (Line.isLine(arg0)) {\n      return new MoveTo(arg0);\n    } // curve provided\n\n\n    if (Curve.isCurve(arg0)) {\n      return new MoveTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new MoveTo(arg0);\n      } // this is a moveto-with-subsequent-poly-line segment\n\n\n      const segments = []; // points come one by one\n\n      for (let i = 0; i < len; i += 1) {\n        if (i === 0) {\n          segments.push(new MoveTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));\n        } else {\n          segments.push(new LineTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));\n        }\n      }\n\n      return segments;\n    } // coordinates provided\n\n\n    if (len === 2) {\n      return new MoveTo(+(arguments.length <= 0 ? undefined : arguments[0]), +(arguments.length <= 1 ? undefined : arguments[1]));\n    } // this is a moveto-with-subsequent-poly-line segment\n\n\n    const segments = [];\n\n    for (let i = 0; i < len; i += 2) {\n      const x = +(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      const y = +(i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);\n\n      if (i === 0) {\n        segments.push(new MoveTo(x, y));\n      } else {\n        segments.push(new LineTo(x, y));\n      }\n    }\n\n    return segments;\n  }\n\n  MoveTo.create = create;\n})(MoveTo || (MoveTo = {}));","map":null,"metadata":{},"sourceType":"module"}