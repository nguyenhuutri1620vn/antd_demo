{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { gl, IDENTIFIER } from '@antv/g-webgpu-core';\nimport { inject, injectable, named } from 'inversify';\nimport getNormals from '../../utils/polyline-normals';\nimport { Renderable } from '../Renderable';\n/* babel-plugin-inline-import './shaders/webgl.line.frag.glsl' */\n\nvar lineFrag = \"uniform float u_dash_array : 0.02;\\nuniform float u_dash_offset : 0;\\nuniform float u_dash_ratio : 0;\\nuniform float u_thickness : 0.02;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_counters;\\n\\nvoid main() {\\n    float blur = 1. - smoothstep(0.98, 1., length(v_normal));\\n\\n    gl_FragColor = v_color;\\n    gl_FragColor.a *= blur * ceil(mod(v_counters + u_dash_offset, u_dash_array) - (u_dash_array * u_dash_ratio));\\n}\";\n/* babel-plugin-inline-import './shaders/webgl.line.vert.glsl' */\n\nvar lineVert = \"attribute vec2 a_pos;\\nattribute vec4 a_color;\\nattribute float a_line_miter;\\nattribute vec2 a_line_normal;\\nattribute float a_counters;\\n\\nuniform mat4 projectionMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform float u_thickness : 0.02;\\nuniform vec2 u_viewport;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_counters;\\n\\nvoid main() {\\n  v_color = a_color;\\n  v_counters = a_counters;\\n\\n  vec3 normal = normalize(vec3(a_line_normal, 0.0));\\n\\n  vec4 offset = vec4(normal * u_thickness / 2.0 * a_line_miter, 0.0);\\n\\n  v_normal = vec2(normal * sign(a_line_miter));\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(a_pos, 0.0, 1.0) + offset;\\n}\\n\";\nexport var Line = (_dec = injectable(), _dec2 = inject(IDENTIFIER.Systems), _dec3 = named(IDENTIFIER.MaterialSystem), _dec4 = inject(IDENTIFIER.Systems), _dec5 = named(IDENTIFIER.GeometrySystem), _dec6 = inject(IDENTIFIER.ShaderModuleService), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_Renderable) {\n  _inherits(Line, _Renderable);\n\n  var _super = _createSuper(Line);\n\n  function Line() {\n    var _this;\n\n    _classCallCheck(this, Line);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _initializerDefineProperty(_this, \"materialSystem\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"geometrySystem\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"shaderModuleService\", _descriptor3, _assertThisInitialized(_this));\n\n    _this.vertexCount = void 0;\n    return _this;\n  }\n\n  _createClass(Line, [{\n    key: \"onAttributeChanged\",\n    value: function onAttributeChanged(_ref) {\n      var name = _ref.name,\n          data = _ref.data;\n      var mesh = this.getMeshComponent();\n\n      if (mesh && mesh.material) {\n        switch (name) {\n          case 'dashArray':\n            mesh.material.setUniform('u_dash_array', data);\n            break;\n\n          case 'dashOffset':\n            mesh.material.setUniform('u_dash_offset', data);\n            break;\n\n          case 'dashRatio':\n            mesh.material.setUniform('u_dash_ratio', data);\n            break;\n\n          case 'thickness':\n            mesh.material.setUniform('u_thickness', data);\n            break;\n\n          case 'color':\n            var colors = new Array(this.vertexCount).fill(undefined).map(function () {\n              return data;\n            }).reduce(function (prev, cur) {\n              // @ts-ignore\n              return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));\n            }, []); // @ts-ignore\n\n            mesh.geometry.setAttribute('a_color', Float32Array.from(colors), {\n              arrayStride: 4 * 4,\n              stepMode: 'vertex',\n              attributes: [{\n                shaderLocation: 1,\n                offset: 0,\n                format: 'float4'\n              }]\n            });\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this2 = this;\n\n      this.shaderModuleService.registerModule('line', {\n        vs: lineVert,\n        fs: lineFrag\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('line'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          extractedUniforms = _this$shaderModuleSer.uniforms;\n\n      var material = this.materialSystem.createShaderMaterial({\n        vertexShader: vs,\n        fragmentShader: fs\n      });\n\n      var _getNormals = getNormals(this.config.points, false),\n          normals = _getNormals.normals,\n          attrIndex = _getNormals.attrIndex,\n          attrPos = _getNormals.attrPos,\n          attrCounters = _getNormals.attrCounters;\n\n      var vertexCount = attrPos.length;\n      this.vertexCount = vertexCount;\n      var geometry = this.geometrySystem.createBufferGeometry({\n        vertexCount: vertexCount\n      });\n      this.setMaterial(material);\n      this.setGeometry(geometry);\n      material.setCull({\n        enable: false,\n        face: gl.BACK\n      }) // @ts-ignore\n      .setUniform(extractedUniforms);\n      this.setAttributes({\n        dashArray: this.config.dashArray,\n        dashOffset: this.config.dashOffset,\n        dashRatio: this.config.dashRatio,\n        thickness: this.config.thickness\n      });\n      var attrNormal = [];\n      var attrMiter = [];\n      normals.forEach(function (n) {\n        var norm = n[0];\n        var miter = n[1];\n        attrNormal.push([norm[0], norm[1]]); // @ts-ignore\n\n        attrMiter.push(miter);\n      }); // [[0,1,2], [2,1,3]]\n\n      geometry.setIndex(attrIndex.reduce(function (prev, cur) {\n        return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));\n      }, []));\n      geometry.setAttribute('a_pos', Float32Array.from(attrPos.reduce(function (prev, cur) {\n        return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));\n      }, [])), {\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float2'\n        }]\n      });\n      var colors = new Array(vertexCount).fill(undefined).map(function () {\n        return _toConsumableArray(_this2.config.color);\n      }).reduce(function (prev, cur) {\n        return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));\n      }, []);\n      geometry.setAttribute('a_color', Float32Array.from(colors), {\n        arrayStride: 4 * 4,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float4'\n        }]\n      });\n      geometry.setAttribute('a_line_miter', Float32Array.from(attrMiter), {\n        arrayStride: 4 * 1,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float'\n        }]\n      });\n      geometry.setAttribute('a_line_normal', Float32Array.from(attrNormal.reduce(function (prev, cur) {\n        return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));\n      }, [])), {\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 3,\n          offset: 0,\n          format: 'float2'\n        }]\n      });\n      geometry.setAttribute('a_counters', Float32Array.from(attrCounters), {\n        arrayStride: 4 * 1,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 4,\n          offset: 0,\n          format: 'float'\n        }]\n      });\n    }\n  }]);\n\n  return Line;\n}(Renderable), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"materialSystem\", [_dec2, _dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"geometrySystem\", [_dec4, _dec5], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec6], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":null,"metadata":{},"sourceType":"module"}