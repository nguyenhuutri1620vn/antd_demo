{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nvar primitiveUv1Padding = 4.0 / 64;\nvar primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nexport var\n/**\n * borrow from playcanvas:\n * Creates a procedural box-shaped mesh\n */\nBox = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Box, _Geometry);\n\n  var _super = _createSuper(Box);\n\n  function Box() {\n    _classCallCheck(this, Box);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Box, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config = this.config,\n          _this$config$widthSeg = _this$config.widthSegments,\n          widthSegments = _this$config$widthSeg === void 0 ? 1 : _this$config$widthSeg,\n          _this$config$heightSe = _this$config.heightSegments,\n          heightSegments = _this$config$heightSe === void 0 ? 1 : _this$config$heightSe,\n          _this$config$depthSeg = _this$config.depthSegments,\n          depthSegments = _this$config$depthSeg === void 0 ? 1 : _this$config$depthSeg,\n          _this$config$halfExte = _this$config.halfExtents,\n          halfExtents = _this$config$halfExte === void 0 ? vec3.fromValues(0.5, 0.5, 0.5) : _this$config$halfExte;\n      var ws = widthSegments;\n      var hs = heightSegments;\n      var ds = depthSegments;\n\n      var _halfExtents = _slicedToArray(halfExtents, 3),\n          hex = _halfExtents[0],\n          hey = _halfExtents[1],\n          hez = _halfExtents[2];\n\n      var corners = [vec3.fromValues(-hex, -hey, hez), vec3.fromValues(hex, -hey, hez), vec3.fromValues(hex, hey, hez), vec3.fromValues(-hex, hey, hez), vec3.fromValues(hex, -hey, -hez), vec3.fromValues(-hex, -hey, -hez), vec3.fromValues(-hex, hey, -hez), vec3.fromValues(hex, hey, -hez)];\n      var faceAxes = [[0, 1, 3], // FRONT\n      [4, 5, 7], // BACK\n      [3, 2, 6], // TOP\n      [1, 0, 4], // BOTTOM\n      [1, 4, 2], // RIGHT\n      [5, 0, 6] // LEFT\n      ];\n      var faceNormals = [[0, 0, 1], // FRONT\n      [0, 0, -1], // BACK\n      [0, 1, 0], // TOP\n      [0, -1, 0], // BOTTOM\n      [1, 0, 0], // RIGHT\n      [-1, 0, 0] // LEFT\n      ];\n      var sides = {\n        FRONT: 0,\n        BACK: 1,\n        TOP: 2,\n        BOTTOM: 3,\n        RIGHT: 4,\n        LEFT: 5\n      };\n      var positions = [];\n      var normals = [];\n      var uvs = [];\n      var uvs1 = [];\n      var indices = [];\n      var vcounter = 0;\n\n      var generateFace = function generateFace(side, uSegments, vSegments) {\n        var u;\n        var v;\n        var i;\n        var j;\n\n        for (i = 0; i <= uSegments; i++) {\n          for (j = 0; j <= vSegments; j++) {\n            var temp1 = vec3.create();\n            var temp2 = vec3.create();\n            var temp3 = vec3.create();\n            var r = vec3.create();\n            vec3.lerp(temp1, corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n            vec3.lerp(temp2, corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n            vec3.sub(temp3, temp2, corners[faceAxes[side][0]]);\n            vec3.add(r, temp1, temp3);\n            u = i / uSegments;\n            v = j / vSegments;\n            positions.push(r[0], r[1], r[2]);\n            normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n            uvs.push(u, v); // pack as 3x2\n            // 1/3 will be empty, but it's either that or stretched pixels\n            // TODO: generate non-rectangular lightMaps, so we could use space without stretching\n\n            u /= 3;\n            v /= 3;\n            u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n            v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n            u += side % 3 / 3;\n            v += Math.floor(side / 3) / 3;\n            uvs1.push(u, v);\n\n            if (i < uSegments && j < vSegments) {\n              indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n              indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n            }\n\n            vcounter++;\n          }\n        }\n      };\n\n      generateFace(sides.FRONT, ws, hs);\n      generateFace(sides.BACK, ws, hs);\n      generateFace(sides.TOP, ws, ds);\n      generateFace(sides.BOTTOM, ws, ds);\n      generateFace(sides.RIGHT, ds, hs);\n      generateFace(sides.LEFT, ds, hs); // generate AABB\n\n      var aabb = generateAABBFromVertices(positions);\n      var component = this.getComponent();\n      component.indices = Uint32Array.from(indices);\n      component.aabb = aabb;\n      component.vertexCount = vcounter;\n      component.attributes = [{\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float2'\n        }]\n      }]; // TODO: barycentric & tangent\n    }\n  }]);\n\n  return Box;\n}(Geometry)) || _class);","map":null,"metadata":{},"sourceType":"module"}