{"ast":null,"code":"import { ext } from '@antv/matrix-util';\nimport { clone } from '@antv/util';\nvar transform = ext.transform;\nvar DELTA = 0.05;\nexport default {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      sensitivity: 2,\n      minZoom: undefined,\n      maxZoom: undefined,\n      enableOptimize: false,\n      optimizeZoom: 0.1,\n      fixSelectedItems: {\n        fixAll: false,\n        fixLineWidth: false,\n        fixLabel: false,\n        fixState: 'selected'\n      },\n      animate: false,\n      animateCfg: {\n        duration: 500\n      }\n    };\n  },\n  getEvents: function getEvents() {\n    var fixSelectedItems = this.fixSelectedItems;\n    if (!fixSelectedItems.fixState) fixSelectedItems.fixState = 'selected';\n\n    if (fixSelectedItems.fixAll) {\n      fixSelectedItems.fixLineWidth = true;\n      fixSelectedItems.fixLabel = true;\n    }\n\n    return {\n      wheel: 'onWheel',\n      touchstart: 'onTouchStart',\n      touchmove: 'onTouchMove',\n      touchend: 'onTouchEnd'\n    };\n  },\n  onTouchStart: function onTouchStart(evt) {\n    var touches = evt.originalEvent.touches;\n    var event1 = touches[0];\n    var event2 = touches[1];\n    evt.preventDefault(); // 如果不是缩放事件则禁止继续执行\n\n    if (!event2) {\n      return;\n    }\n\n    if (this.shouldBegin && !this.shouldBegin.call(this, evt)) {\n      return;\n    } // 第一个触摸点位置\n\n\n    this.startPoint = {\n      pageX: event1.pageX,\n      pageY: event1.pageY\n    };\n    this.moveable = true;\n\n    if (event2) {\n      this.endPoint = {\n        pageX: event2.pageX,\n        pageY: event2.pageY\n      };\n    }\n\n    this.originScale = this.graph.getZoom() || this.currentScale || 1;\n  },\n  onTouchMove: function onTouchMove(evt) {\n    if (!this.moveable) {\n      return;\n    }\n\n    evt.preventDefault();\n    var touches = evt.originalEvent.touches;\n    var event1 = touches[0];\n    var event2 = touches[1];\n\n    if (!event2) {\n      return;\n    }\n\n    if (!this.endPoint) {\n      this.endPoint = {\n        pageX: event2.pageX,\n        pageY: event2.pageY\n      };\n    } // 获取坐标之间的距离\n\n\n    var getDistance = function getDistance(start, end) {\n      return Math.hypot(end.x - start.x, end.y - start.y);\n    }; // 双指缩放比例\n\n\n    var scale = getDistance({\n      x: event1.pageX,\n      y: event1.pageY\n    }, {\n      x: event2.pageX,\n      y: event2.pageY\n    }) / getDistance({\n      x: this.startPoint.pageX,\n      y: this.startPoint.pageY\n    }, {\n      x: this.endPoint.pageX,\n      y: this.endPoint.pageY\n    }); // 应用到画布上的缩放比例\n\n    var zoom = this.originScale * scale; // 缓存当前的缩放比例\n\n    this.currentScale = zoom;\n    var minZoom = this.get('minZoom') || this.graph.get('minZoom');\n    var maxZoom = this.get('maxZoom') || this.graph.get('maxZoom');\n\n    if (zoom > maxZoom || zoom < minZoom) {\n      return;\n    }\n\n    var animate = this.get('animate');\n    var animateCfg = this.get('animateCfg');\n    var canvas = this.graph.get('canvas');\n    var point = canvas.getPointByClient(evt.clientX, evt.clientY);\n    this.graph.zoomTo(zoom, {\n      x: point.x,\n      y: point.y\n    }, animate, animateCfg);\n    this.graph.emit('wheelzoom', evt);\n  },\n  onTouchEnd: function onTouchEnd() {\n    this.moveable = false;\n    this.endPoint = null;\n  },\n  onWheel: function onWheel(e) {\n    var _this = this;\n\n    var _a = this,\n        graph = _a.graph,\n        fixSelectedItems = _a.fixSelectedItems;\n\n    if (this.shouldBegin && !this.shouldBegin.call(this, e)) {\n      return;\n    }\n\n    if (!this.shouldUpdate.call(this, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    var canvas = graph.get('canvas');\n    var point = canvas.getPointByClient(e.clientX, e.clientY);\n    var sensitivity = this.get('sensitivity');\n    var graphZoom = graph.getZoom();\n    var ratio = graphZoom;\n    var zoom = graphZoom; // 兼容IE、Firefox及Chrome\n\n    if (e.wheelDelta < 0) {\n      ratio = 1 - DELTA * sensitivity;\n    } else {\n      ratio = 1 / (1 - DELTA * sensitivity);\n    }\n\n    zoom = graphZoom * ratio; // const zoom = ratio * graphZoom;\n\n    var minZoom = this.get('minZoom') || graph.get('minZoom');\n    var maxZoom = this.get('maxZoom') || graph.get('maxZoom');\n\n    if (zoom > maxZoom || zoom < minZoom) {\n      return;\n    } // hide the shapes when the zoom ratio is smaller than optimizeZoom\n    // hide the shapes when zoomming\n\n\n    var enableOptimize = this.get('enableOptimize');\n\n    if (enableOptimize) {\n      var optimizeZoom_1 = this.get('optimizeZoom');\n      var optimized = this.get('optimized');\n      var nodes_1 = graph.getNodes();\n      var edges_1 = graph.getEdges();\n      var nodesLength_1 = nodes_1.length;\n      var edgesLength_1 = edges_1.length; // hiding\n\n      if (!optimized) {\n        for (var n = 0; n < nodesLength_1; n++) {\n          var node = nodes_1[n];\n\n          if (!node.destroyed) {\n            var children = node.get('group').get('children');\n            var childrenLength = children.length;\n\n            for (var c = 0; c < childrenLength; c++) {\n              var shape = children[c];\n\n              if (!shape.destoryed && !shape.get('isKeyShape')) {\n                shape.set('ori-visibility', shape.get('ori-visibility') || shape.get('visible'));\n                shape.hide();\n              }\n            }\n          }\n        }\n\n        for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {\n          var edge = edges_1[edgeIndex];\n          var children = edge.get('group').get('children');\n          var childrenLength = children.length;\n\n          for (var c = 0; c < childrenLength; c++) {\n            var shape = children[c];\n            shape.set('ori-visibility', shape.get('ori-visibility') || shape.get('visible'));\n            shape.hide();\n          }\n        }\n\n        this.set('optimized', true);\n      } // showing after 100ms\n\n\n      clearTimeout(this.get('timeout'));\n      var timeout = setTimeout(function () {\n        var currentZoom = graph.getZoom();\n\n        var curOptimized = _this.get('optimized');\n\n        if (curOptimized) {\n          _this.set('optimized', false);\n\n          for (var n = 0; n < nodesLength_1; n++) {\n            var node = nodes_1[n];\n            var children = node.get('group').get('children');\n            var childrenLength = children.length;\n\n            if (currentZoom < optimizeZoom_1) {\n              var keyShape = node.getKeyShape();\n              var oriVis = keyShape.get('ori-visibility');\n              if (oriVis) keyShape.show();\n            } else {\n              for (var c = 0; c < childrenLength; c++) {\n                var shape = children[c];\n                var oriVis = shape.get('ori-visibility');\n\n                if (!shape.get('visible') && oriVis) {\n                  if (oriVis) shape.show();\n                }\n              }\n            }\n          }\n\n          for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {\n            var edge = edges_1[edgeIndex];\n            var children = edge.get('group').get('children');\n            var childrenLength = children.length;\n\n            if (currentZoom < optimizeZoom_1) {\n              var keyShape = edge.getKeyShape();\n              var oriVis = keyShape.get('ori-visibility');\n              if (oriVis) keyShape.show();\n            } else {\n              for (var c = 0; c < childrenLength; c++) {\n                var shape = children[c];\n\n                if (!shape.get('visible')) {\n                  var oriVis = shape.get('ori-visibility');\n                  if (oriVis) shape.show();\n                }\n              }\n            }\n          }\n        }\n      }, 100);\n      this.set('timeout', timeout);\n    } // fix the items when zooming\n\n\n    if (graphZoom <= 1) {\n      var fixNodes = void 0,\n          fixEdges = void 0;\n\n      if (fixSelectedItems.fixAll || fixSelectedItems.fixLineWidth || fixSelectedItems.fixLabel) {\n        fixNodes = graph.findAllByState('node', fixSelectedItems.fixState);\n        fixEdges = graph.findAllByState('edge', fixSelectedItems.fixState);\n        var scale = graphZoom / zoom;\n        var fixNodesLength = fixNodes.length;\n\n        for (var fn = 0; fn < fixNodesLength; fn++) {\n          var node = fixNodes[fn];\n          var group = node.getContainer();\n          var nodeModel = node.getModel();\n          var originStyle = node.getOriginStyle();\n          var itemStateStyle = node.getStateStyle(fixSelectedItems.fixState);\n          var shapeStateStyle = node.get('shapeFactory').getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, node)[fixSelectedItems.fixState];\n\n          if (fixSelectedItems.fixAll) {\n            if (zoom <= 1) {\n              var groupMatrix = clone(group.getMatrix());\n              if (!groupMatrix) groupMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n              var _b = node.getModel(),\n                  x = _b.x,\n                  y = _b.y;\n\n              groupMatrix = transform(groupMatrix, [['t', -x, -y], ['s', scale, scale], ['t', x, y]]);\n              group.setMatrix(groupMatrix);\n            }\n          } else {\n            var children = group.get('children');\n            var childrenLength = children.length;\n\n            for (var c = 0; c < childrenLength; c++) {\n              var shape = children[c];\n              var fontSize = void 0,\n                  lineWidth = void 0;\n\n              if (fixSelectedItems.fixLabel) {\n                var shapeType = shape.get('type');\n\n                if (shapeType === 'text') {\n                  fontSize = shape.attr('fontSize') || 12;\n                  var itemStyle = itemStateStyle[shape.get('name')];\n                  var shapeStyle = shapeStateStyle[shape.get('name')];\n                  var itemFontSize = itemStyle ? itemStyle.fontSize : 12;\n                  var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;\n                  var oriFontSize = itemFontSize || shapeFontSize || 12;\n                  if (zoom <= 1) shape.attr('fontSize', oriFontSize / zoom); // * graphZoom / zoom\n\n                  if (lineWidth) break;\n                }\n              }\n\n              if (fixSelectedItems.fixLineWidth) {\n                if (shape.get('isKeyShape')) {\n                  lineWidth = shape.attr('lineWidth') || 0;\n                  var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || originStyle.lineWidth || 0;\n                  if (zoom <= 1) shape.attr('lineWidth', oriLineWidth / zoom); // * graphZoom / zoom\n\n                  if (fontSize) break;\n                }\n              }\n            }\n          }\n        }\n\n        var fixEdgesLength = fixEdges.length;\n\n        for (var fe = 0; fe < fixEdgesLength; fe++) {\n          var edge = fixEdges[fe];\n          var group = edge.getContainer();\n          var children = group.get('children');\n          var nodeModel = edge.getModel();\n          var itemStateStyle = edge.getStateStyle(fixSelectedItems.fixState);\n          var shapeStateStyle = edge.get('shapeFactory').getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, edge)[fixSelectedItems.fixState];\n          var childrenLength = children.length;\n\n          for (var c = 0; c < childrenLength; c++) {\n            var shape = children[c];\n            var fontSize = void 0,\n                lineWidth = void 0;\n\n            if (fixSelectedItems.fixLabel || fixSelectedItems.fixAll) {\n              var shapeType = shape.get('type');\n\n              if (shapeType === 'text') {\n                fontSize = shape.attr('fontSize') || 12;\n                var itemStyle = itemStateStyle[shape.get('name')];\n                var shapeStyle = shapeStateStyle[shape.get('name')];\n                var itemFontSize = itemStyle ? itemStyle.fontSize : 12;\n                var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;\n                var oriFontSize = itemFontSize || shapeFontSize || 12;\n                if (zoom <= 1) shape.attr('fontSize', oriFontSize / zoom);\n                if (lineWidth) break;\n              }\n            }\n\n            if (fixSelectedItems.fixLineWidth || fixSelectedItems.fixAll) {\n              if (shape.get('isKeyShape')) {\n                lineWidth = shape.attr('lineWidth') || 0;\n                var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || 1;\n                if (zoom <= 1) shape.attr('lineWidth', oriLineWidth / zoom);\n                if (fontSize) break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    var animate = this.get('animate');\n    var animateCfg = this.get('animateCfg');\n    graph.zoomTo(zoom, {\n      x: point.x,\n      y: point.y\n    }, animate, animateCfg);\n    graph.emit('wheelzoom', e);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}