{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _isString from \"lodash/isString\";\nimport _isNumber from \"lodash/isNumber\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isArray from \"lodash/isArray\";\n\nvar _dec, _class, _descriptor;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { BlendType, gl, lazyInject, TYPES } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport { color } from 'd3-color';\nimport { BlendTypes } from '../utils/blend';\nvar BaseModel = (_dec = lazyInject(TYPES.IGlobalConfigService), (_class = function () {\n  function BaseModel(layer) {\n    _classCallCheck(this, BaseModel);\n\n    _defineProperty(this, \"triangulation\", void 0);\n\n    _defineProperty(this, \"createTexture2D\", void 0);\n\n    _defineProperty(this, \"layer\", void 0);\n\n    _defineProperty(this, \"dataTexture\", void 0);\n\n    _defineProperty(this, \"DATA_TEXTURE_WIDTH\", void 0);\n\n    _defineProperty(this, \"rowCount\", void 0);\n\n    _defineProperty(this, \"cacheStyleProperties\", void 0);\n\n    _defineProperty(this, \"cellLength\", void 0);\n\n    _defineProperty(this, \"cellProperties\", void 0);\n\n    _defineProperty(this, \"cellTypeLayout\", void 0);\n\n    _defineProperty(this, \"stylePropertyesExist\", void 0);\n\n    _defineProperty(this, \"dataTextureTest\", void 0);\n\n    _initializerDefineProperty(this, \"configService\", _descriptor, this);\n\n    _defineProperty(this, \"shaderModuleService\", void 0);\n\n    _defineProperty(this, \"rendererService\", void 0);\n\n    _defineProperty(this, \"iconService\", void 0);\n\n    _defineProperty(this, \"fontService\", void 0);\n\n    _defineProperty(this, \"styleAttributeService\", void 0);\n\n    _defineProperty(this, \"mapService\", void 0);\n\n    _defineProperty(this, \"cameraService\", void 0);\n\n    _defineProperty(this, \"layerService\", void 0);\n\n    this.layer = layer;\n    this.rendererService = layer.getContainer().get(TYPES.IRendererService);\n    this.shaderModuleService = layer.getContainer().get(TYPES.IShaderModuleService);\n    this.styleAttributeService = layer.getContainer().get(TYPES.IStyleAttributeService);\n    this.mapService = layer.getContainer().get(TYPES.IMapService);\n    this.iconService = layer.getContainer().get(TYPES.IIconService);\n    this.fontService = layer.getContainer().get(TYPES.IFontService);\n    this.cameraService = layer.getContainer().get(TYPES.ICameraService);\n    this.layerService = layer.getContainer().get(TYPES.ILayerService);\n    this.registerBuiltinAttributes();\n    this.startModelAnimate();\n    var createTexture2D = this.rendererService.createTexture2D;\n    this.createTexture2D = createTexture2D;\n    this.DATA_TEXTURE_WIDTH = 1024;\n    this.rowCount = 1;\n    this.cellLength = 0;\n    this.cellProperties = [];\n    this.cacheStyleProperties = {\n      thetaOffset: undefined,\n      opacity: undefined,\n      strokeOpacity: undefined,\n      strokeWidth: undefined,\n      stroke: undefined,\n      offsets: undefined\n    };\n    this.stylePropertyesExist = {\n      hasThetaOffset: 0,\n      hasOpacity: 0,\n      hasStrokeOpacity: 0,\n      hasStrokeWidth: 0,\n      hasStroke: 0,\n      hasOffsets: 0\n    };\n    this.dataTextureTest = this.layerService.getOESTextureFloat();\n\n    if (!this.dataTextureTest) {\n      this.dataTexture = this.createTexture2D({\n        data: new Uint8Array(4),\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        width: 1,\n        height: 1\n      });\n    }\n  }\n\n  _createClass(BaseModel, [{\n    key: \"clearLastCalRes\",\n    value: function clearLastCalRes() {\n      this.cellProperties = [];\n      this.cellLength = 0;\n      this.stylePropertyesExist = {\n        hasThetaOffset: 0,\n        hasOpacity: 0,\n        hasStrokeOpacity: 0,\n        hasStrokeWidth: 0,\n        hasStroke: 0,\n        hasOffsets: 0\n      };\n    }\n  }, {\n    key: \"getCellTypeLayout\",\n    value: function getCellTypeLayout() {\n      if (this.dataTextureTest) {\n        return [this.rowCount, this.DATA_TEXTURE_WIDTH, 0.0, 0.0, this.stylePropertyesExist.hasOpacity, this.stylePropertyesExist.hasStrokeOpacity, this.stylePropertyesExist.hasStrokeWidth, this.stylePropertyesExist.hasStroke, this.stylePropertyesExist.hasOffsets, this.stylePropertyesExist.hasThetaOffset, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0];\n      } else {\n        return [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0];\n      }\n    }\n  }, {\n    key: \"dataTextureNeedUpdate\",\n    value: function dataTextureNeedUpdate(options) {\n      var isUpdate = false;\n\n      if (!_isEqual(options.thetaOffset, this.cacheStyleProperties.thetaOffset)) {\n        isUpdate = true;\n        this.cacheStyleProperties.thetaOffset = options.thetaOffset;\n      }\n\n      if (!_isEqual(options.opacity, this.cacheStyleProperties.opacity)) {\n        isUpdate = true;\n        this.cacheStyleProperties.opacity = options.opacity;\n      }\n\n      if (!_isEqual(options.strokeOpacity, this.cacheStyleProperties.strokeOpacity)) {\n        isUpdate = true;\n        this.cacheStyleProperties.strokeOpacity = options.strokeOpacity;\n      }\n\n      if (!_isEqual(options.strokeWidth, this.cacheStyleProperties.strokeWidth)) {\n        isUpdate = true;\n        this.cacheStyleProperties.strokeWidth = options.strokeWidth;\n      }\n\n      if (!_isEqual(options.stroke, this.cacheStyleProperties.stroke)) {\n        isUpdate = true;\n        this.cacheStyleProperties.stroke = options.stroke;\n      }\n\n      if (!_isEqual(options.offsets, this.cacheStyleProperties.offsets)) {\n        isUpdate = true;\n        this.cacheStyleProperties.offsets = options.offsets;\n      }\n\n      if (this.dataTexture === undefined) {\n        isUpdate = true;\n      }\n\n      return isUpdate;\n    }\n  }, {\n    key: \"judgeStyleAttributes\",\n    value: function judgeStyleAttributes(options) {\n      this.clearLastCalRes();\n\n      if (options.opacity !== undefined && !_isNumber(options.opacity)) {\n        this.cellProperties.push({\n          attr: 'opacity',\n          count: 1\n        });\n        this.stylePropertyesExist.hasOpacity = 1;\n        this.cellLength += 1;\n      }\n\n      if (options.strokeOpacity !== undefined && !_isNumber(options.strokeOpacity)) {\n        this.cellProperties.push({\n          attr: 'strokeOpacity',\n          count: 1\n        });\n        this.stylePropertyesExist.hasStrokeOpacity = 1;\n        this.cellLength += 1;\n      }\n\n      if (options.strokeWidth !== undefined && !_isNumber(options.strokeWidth)) {\n        this.cellProperties.push({\n          attr: 'strokeWidth',\n          count: 1\n        });\n        this.stylePropertyesExist.hasStrokeWidth = 1;\n        this.cellLength += 1;\n      }\n\n      if (options.stroke !== undefined && !this.isStaticColor(options.stroke)) {\n        this.cellProperties.push({\n          attr: 'stroke',\n          count: 4\n        });\n        this.stylePropertyesExist.hasStroke = 1;\n        this.cellLength += 4;\n      }\n\n      if (options.offsets !== undefined && !this.isOffsetStatic(options.offsets)) {\n        this.cellProperties.push({\n          attr: 'offsets',\n          count: 2\n        });\n        this.stylePropertyesExist.hasOffsets = 1;\n        this.cellLength += 2;\n      }\n\n      if (options.thetaOffset !== undefined && !_isNumber(options.thetaOffset)) {\n        this.cellProperties.push({\n          attr: 'thetaOffset',\n          count: 1\n        });\n        this.stylePropertyesExist.hasThetaOffset = 1;\n        this.cellLength += 1;\n      }\n    }\n  }, {\n    key: \"isStaticColor\",\n    value: function isStaticColor(stroke) {\n      if (_isString(stroke)) {\n        if (color(stroke)) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getStrokeColor\",\n    value: function getStrokeColor(stroke) {\n      if (this.isStaticColor(stroke)) {\n        var strokeColor = rgb2arr(stroke);\n        strokeColor[0] = strokeColor[0] ? strokeColor[0] : 0;\n        strokeColor[1] = strokeColor[1] ? strokeColor[1] : 0;\n        strokeColor[2] = strokeColor[2] ? strokeColor[2] : 0;\n        strokeColor[3] = strokeColor[3] ? strokeColor[3] : 0;\n        return strokeColor;\n      } else {\n        return [0, 0, 0, 0];\n      }\n    }\n  }, {\n    key: \"isOffsetStatic\",\n    value: function isOffsetStatic(offsets) {\n      if (_isArray(offsets) && offsets.length === 2 && _isNumber(offsets[0]) && _isNumber(offsets[1])) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"patchMod\",\n    value: function patchMod(d, count) {\n      for (var i = 0; i < count; i++) {\n        d.push(-1);\n      }\n    }\n  }, {\n    key: \"patchData\",\n    value: function patchData(d, cellData, cellPropertiesLayouts) {\n      var _iterator = _createForOfIteratorHelper(cellPropertiesLayouts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layout = _step.value;\n          var attr = layout.attr,\n              count = layout.count;\n          var value = cellData[attr];\n\n          if (value !== undefined) {\n            if (attr === 'stroke') {\n              d.push.apply(d, _toConsumableArray(rgb2arr(value)));\n            } else if (attr === 'offsets') {\n              if (this.isOffsetStatic(value)) {\n                d.push(-value[0], value[1]);\n              } else {\n                d.push(0, 0);\n              }\n            } else {\n              d.push(_isNumber(value) ? value : 1.0);\n            }\n          } else {\n            this.patchMod(d, count);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"calDataFrame\",\n    value: function calDataFrame(cellLength, encodeData, cellPropertiesLayouts) {\n      var encodeDatalength = encodeData.length;\n      var rowCount = Math.ceil(encodeDatalength * cellLength / this.DATA_TEXTURE_WIDTH);\n      var totalLength = rowCount * this.DATA_TEXTURE_WIDTH;\n      var d = [];\n\n      for (var i = 0; i < encodeDatalength; i++) {\n        var cellData = encodeData[i];\n        this.patchData(d, cellData, cellPropertiesLayouts);\n      }\n\n      for (var _i = d.length; _i < totalLength; _i++) {\n        d.push(-1);\n      }\n\n      return {\n        data: d,\n        width: this.DATA_TEXTURE_WIDTH,\n        height: rowCount\n      };\n    }\n  }, {\n    key: \"getBlend\",\n    value: function getBlend() {\n      var _this$layer$getLayerC = this.layer.getLayerConfig(),\n          _this$layer$getLayerC2 = _this$layer$getLayerC.blend,\n          blend = _this$layer$getLayerC2 === void 0 ? 'normal' : _this$layer$getLayerC2;\n\n      return BlendTypes[BlendType[blend]];\n    }\n  }, {\n    key: \"getDefaultStyle\",\n    value: function getDefaultStyle() {\n      return {};\n    }\n  }, {\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      return {};\n    }\n  }, {\n    key: \"needUpdate\",\n    value: function needUpdate() {\n      return false;\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      return;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"animateOption2Array\",\n    value: function animateOption2Array(option) {\n      return [option.enable ? 0 : 1.0, option.duration || 4.0, option.interval || 0.2, option.trailLength || 0.1];\n    }\n  }, {\n    key: \"startModelAnimate\",\n    value: function startModelAnimate() {\n      var _ref = this.layer.getLayerConfig(),\n          animateOption = _ref.animateOption;\n\n      if (animateOption.enable) {\n        this.layer.setAnimateStartTime();\n      }\n    }\n  }]);\n\n  return BaseModel;\n}(), _descriptor = _applyDecoratedDescriptor(_class.prototype, \"configService\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class));\nexport { BaseModel as default };","map":null,"metadata":{},"sourceType":"module"}