{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar _dec, _class, _temp;\n/**\n * render w/ regl\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md\n */\n\n\nimport { gl } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport regl from 'regl';\nimport ReglAttribute from './ReglAttribute';\nimport ReglBuffer from './ReglBuffer';\nimport ReglComputeModel from './ReglComputeModel';\nimport ReglElements from './ReglElements';\nimport ReglFramebuffer from './ReglFramebuffer';\nimport ReglModel from './ReglModel';\nimport ReglTexture2D from './ReglTexture2D';\n/**\n * regl renderer\n */\n\nexport var WebGLEngine = (_dec = injectable(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function WebGLEngine() {\n    var _this = this;\n\n    _classCallCheck(this, WebGLEngine);\n\n    this.supportWebGPU = false;\n    this.useWGSL = false;\n    this.$canvas = void 0;\n    this.gl = void 0;\n    this.inited = void 0;\n\n    this.createModel = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!options.uniforms) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                _context2.next = 3;\n                return Promise.all(Object.keys(options.uniforms).map( /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name) {\n                    var texture;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (!(options.uniforms[name] && options.uniforms[name].load !== undefined)) {\n                              _context.next = 5;\n                              break;\n                            }\n\n                            _context.next = 3;\n                            return options.uniforms[name].load();\n\n                          case 3:\n                            texture = _context.sent; // @ts-ignore\n\n                            options.uniforms[name] = texture;\n\n                          case 5:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()));\n\n              case 3:\n                return _context2.abrupt(\"return\", new ReglModel(_this.gl, options));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.createAttribute = function (options) {\n      return new ReglAttribute(_this.gl, options);\n    };\n\n    this.createBuffer = function (options) {\n      return new ReglBuffer(_this.gl, options);\n    };\n\n    this.createElements = function (options) {\n      return new ReglElements(_this.gl, options);\n    };\n\n    this.createTexture2D = function (options) {\n      return new ReglTexture2D(_this.gl, options);\n    };\n\n    this.createFramebuffer = function (options) {\n      return new ReglFramebuffer(_this.gl, options);\n    };\n\n    this.useFramebuffer = function (framebuffer, drawCommands) {\n      _this.gl({\n        framebuffer: framebuffer ? framebuffer.get() : null\n      })(drawCommands);\n    };\n\n    this.createComputeModel = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(context) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", new ReglComputeModel(_this.gl, context));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    this.clear = function (options) {\n      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clear-the-draw-buffer\n      var color = options.color,\n          depth = options.depth,\n          stencil = options.stencil,\n          _options$framebuffer = options.framebuffer,\n          framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;\n      var reglClearOptions = {\n        color: color,\n        depth: depth,\n        stencil: stencil\n      };\n      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();\n\n      _this.gl.clear(reglClearOptions);\n    };\n\n    this.setScissor = function (scissor) {\n      if (_this.gl && _this.gl._gl) {\n        // https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/scissor\n        if (scissor.enable && scissor.box) {\n          // console.log(scissor.box);\n          _this.gl._gl.enable(gl.SCISSOR_TEST);\n\n          _this.gl._gl.scissor(scissor.box.x, scissor.box.y, scissor.box.width, scissor.box.height);\n        } else {\n          _this.gl._gl.disable(gl.SCISSOR_TEST);\n        }\n\n        _this.gl._refresh();\n      }\n    };\n\n    this.viewport = function (_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y,\n          width = _ref4.width,\n          height = _ref4.height;\n\n      if (_this.gl && _this.gl._gl) {\n        // use WebGL context directly\n        // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#unsafe-escape-hatch\n        _this.gl._gl.viewport(x, y, width, height);\n\n        _this.gl._refresh();\n      }\n    };\n\n    this.readPixels = function (options) {\n      var framebuffer = options.framebuffer,\n          x = options.x,\n          y = options.y,\n          width = options.width,\n          height = options.height;\n      var readPixelsOptions = {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n\n      if (framebuffer) {\n        readPixelsOptions.framebuffer = framebuffer.get();\n      }\n\n      return _this.gl.read(readPixelsOptions);\n    };\n\n    this.getCanvas = function () {\n      return _this.$canvas;\n    };\n\n    this.getGLContext = function () {\n      return _this.gl._gl;\n    };\n\n    this.destroy = function () {\n      if (_this.gl) {\n        // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clean-up\n        _this.gl.destroy();\n\n        _this.inited = false;\n      }\n    };\n  }\n\n  _createClass(WebGLEngine, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cfg) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.inited) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                this.$canvas = cfg.canvas; // tslint:disable-next-line:typedef\n\n                _context4.next = 5;\n                return new Promise(function (resolve, reject) {\n                  regl({\n                    canvas: cfg.canvas,\n                    attributes: {\n                      alpha: true,\n                      // use TAA instead of MSAA\n                      // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1\n                      antialias: cfg.antialias,\n                      premultipliedAlpha: true // preserveDrawingBuffer: false,\n\n                    },\n                    pixelRatio: 1,\n                    // TODO: use extensions\n                    extensions: ['OES_element_index_uint', 'OES_texture_float', 'OES_standard_derivatives', // wireframe\n                    'angle_instanced_arrays' // VSM shadow map\n                    ],\n                    optionalExtensions: ['EXT_texture_filter_anisotropic', 'EXT_blend_minmax', 'WEBGL_depth_texture'],\n                    profile: true,\n                    onDone: function onDone(err, r) {\n                      if (err || !r) {\n                        reject(err);\n                      } // @ts-ignore\n\n\n                      resolve(r);\n                    }\n                  });\n                });\n\n              case 5:\n                this.gl = _context4.sent;\n                this.inited = true;\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function init(_x4) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"isFloatSupported\",\n    value: function isFloatSupported() {\n      // @see https://github.com/antvis/GWebGPUEngine/issues/26\n      // @ts-ignore\n      return this.gl.limits.readFloat;\n    }\n  }, {\n    key: \"beginFrame\",\n    value: function beginFrame() {//\n    }\n  }, {\n    key: \"endFrame\",\n    value: function endFrame() {//\n    }\n  }]);\n\n  return WebGLEngine;\n}(), _temp)) || _class);","map":null,"metadata":{},"sourceType":"module"}