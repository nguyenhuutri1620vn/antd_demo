{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util';\nimport { Point, Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Renderer } from '../../graph/renderer';\nimport { GraphView } from '../../graph/view';\nimport { BackgroundManager } from '../../graph/background';\nexport class Scroller extends View {\n  constructor(options) {\n    super();\n    this.padding = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    this.options = Util.getOptions(options);\n    const scale = this.graph.transform.getScale();\n    this.sx = scale.sx;\n    this.sy = scale.sy;\n    const width = this.options.width || this.graph.options.width;\n    const height = this.options.height || this.graph.options.height;\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container).addClass(this.prefixClassName(Util.containerClass)).css({\n      width,\n      height\n    });\n\n    if (this.options.pageVisible) {\n      this.$container.addClass(this.prefixClassName(Util.pagedClass));\n    }\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n\n    const graphContainer = this.graph.container;\n\n    if (graphContainer.parentNode) {\n      this.$container.insertBefore(graphContainer);\n    } // copy style\n\n\n    const style = graphContainer.getAttribute('style');\n\n    if (style) {\n      const obj = {};\n      const styles = style.split(';');\n      styles.forEach(item => {\n        const section = item.trim();\n\n        if (section) {\n          const pair = section.split(':');\n\n          if (pair.length) {\n            obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';\n          }\n        }\n      });\n      Object.keys(obj).forEach(key => {\n        if (key === 'width' || key === 'height') {\n          return;\n        }\n\n        graphContainer.style[key] = '';\n        this.container.style[key] = obj[key];\n      });\n    }\n\n    this.content = document.createElement('div');\n    this.$content = this.$(this.content).addClass(this.prefixClassName(Util.contentClass)).css({\n      width: this.graph.options.width,\n      height: this.graph.options.height\n    }); // custom background\n\n    this.background = document.createElement('div');\n    this.$background = this.$(this.background).addClass(this.prefixClassName(Util.backgroundClass));\n    this.$content.append(this.background);\n\n    if (!this.options.pageVisible) {\n      this.$content.append(this.graph.view.grid);\n    }\n\n    this.$content.append(graphContainer);\n    this.$content.appendTo(this.container);\n    this.startListening();\n\n    if (!this.options.pageVisible) {\n      this.graph.grid.update();\n    }\n\n    this.backgroundManager = new Scroller.Background(this);\n\n    if (!this.options.autoResize) {\n      this.update();\n    }\n  }\n\n  get graph() {\n    return this.options.graph;\n  }\n\n  get model() {\n    return this.graph.model;\n  }\n\n  startListening() {\n    const graph = this.graph;\n    const model = this.model;\n    graph.on('scale', this.onScale, this);\n    graph.on('resize', this.onResize, this);\n    graph.on('before:print', this.storeScrollPosition, this);\n    graph.on('before:export', this.storeScrollPosition, this);\n    graph.on('after:print', this.restoreScrollPosition, this);\n    graph.on('after:export', this.restoreScrollPosition, this);\n    graph.on('render:done', this.onRenderDone, this);\n    graph.on('unfreeze', this.onUpdate, this);\n    model.on('reseted', this.onUpdate, this);\n    model.on('cell:added', this.onUpdate, this);\n    model.on('cell:removed', this.onUpdate, this);\n    model.on('cell:changed', this.onUpdate, this);\n    model.on('batch:stop', this.onBatchStop, this);\n    this.delegateBackgroundEvents();\n  }\n\n  stopListening() {\n    const graph = this.graph;\n    const model = this.model;\n    graph.off('scale', this.onScale, this);\n    graph.off('resize', this.onResize, this);\n    graph.off('beforeprint', this.storeScrollPosition, this);\n    graph.off('beforeexport', this.storeScrollPosition, this);\n    graph.off('afterprint', this.restoreScrollPosition, this);\n    graph.off('afterexport', this.restoreScrollPosition, this);\n    graph.off('render:done', this.onRenderDone, this);\n    graph.off('unfreeze', this.onUpdate, this);\n    model.off('reseted', this.onUpdate, this);\n    model.off('cell:added', this.onUpdate, this);\n    model.off('cell:removed', this.onUpdate, this);\n    model.off('cell:changed', this.onUpdate, this);\n    model.off('batch:stop', this.onBatchStop, this);\n    this.undelegateBackgroundEvents();\n  }\n\n  enableAutoResize() {\n    this.options.autoResize = true;\n  }\n\n  disableAutoResize() {\n    this.options.autoResize = false;\n  }\n\n  onUpdate() {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return;\n    }\n\n    this.update();\n  }\n\n  onBatchStop(args) {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return;\n    }\n\n    if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n      this.update();\n    }\n  }\n\n  delegateBackgroundEvents(events) {\n    const evts = events || GraphView.events;\n    this.delegatedHandlers = Object.keys(evts).reduce((memo, name) => {\n      const handler = evts[name];\n\n      if (name.indexOf(' ') === -1) {\n        if (typeof handler === 'function') {\n          memo[name] = handler;\n        } else {\n          let method = this.graph.view[handler];\n\n          if (typeof method === 'function') {\n            method = method.bind(this.graph.view);\n            memo[name] = method;\n          }\n        }\n      }\n\n      return memo;\n    }, {});\n    this.onBackgroundEvent = this.onBackgroundEvent.bind(this);\n    Object.keys(this.delegatedHandlers).forEach(name => {\n      this.delegateEvent(name, {\n        guarded: false\n      }, this.onBackgroundEvent);\n    });\n  }\n\n  undelegateBackgroundEvents() {\n    Object.keys(this.delegatedHandlers).forEach(name => {\n      this.undelegateEvent(name, this.onBackgroundEvent);\n    });\n  }\n\n  onBackgroundEvent(e) {\n    let valid = false;\n    const target = e.target;\n\n    if (!this.options.pageVisible) {\n      const view = this.graph.view;\n      valid = view.background === target || view.grid === target;\n    } else if (this.options.background) {\n      valid = this.background === target;\n    } else {\n      valid = this.content === target;\n    }\n\n    if (valid) {\n      const handler = this.delegatedHandlers[e.type];\n\n      if (typeof handler === 'function') {\n        handler.apply(this.graph, arguments); // eslint-disable-line\n      }\n    }\n  }\n\n  onRenderDone(_ref) {\n    let {\n      stats\n    } = _ref;\n\n    if (this.options.autoResize && stats.priority < 2) {\n      this.update();\n    }\n  }\n\n  onResize() {\n    if (this.cachedCenterPoint) {\n      this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);\n      this.updatePageBreak();\n    }\n  }\n\n  onScale(_ref2) {\n    let {\n      sx,\n      sy,\n      ox,\n      oy\n    } = _ref2;\n    this.updateScale(sx, sy);\n\n    if (ox || oy) {\n      this.centerPoint(ox, oy);\n      this.updatePageBreak();\n    }\n\n    const autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n    if (typeof autoResizeOptions === 'function') {\n      this.update();\n    }\n  }\n\n  storeScrollPosition() {\n    this.cachedScrollLeft = this.container.scrollLeft;\n    this.cachedScrollTop = this.container.scrollTop;\n  }\n\n  restoreScrollPosition() {\n    this.container.scrollLeft = this.cachedScrollLeft;\n    this.container.scrollTop = this.cachedScrollTop;\n    this.cachedScrollLeft = null;\n    this.cachedScrollTop = null;\n  }\n\n  storeClientSize() {\n    this.cachedClientSize = {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight\n    };\n  }\n\n  restoreClientSize() {\n    this.cachedClientSize = null;\n  }\n\n  beforeManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'hidden');\n    }\n  }\n\n  afterManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'visible');\n    }\n  }\n\n  updatePageSize(width, height) {\n    if (width != null) {\n      this.options.pageWidth = width;\n    }\n\n    if (height != null) {\n      this.options.pageHeight = height;\n    }\n\n    this.updatePageBreak();\n  }\n\n  updatePageBreak() {\n    if (this.pageBreak && this.pageBreak.parentNode) {\n      this.pageBreak.parentNode.removeChild(this.pageBreak);\n    }\n\n    this.pageBreak = null;\n\n    if (this.options.pageVisible && this.options.pageBreak) {\n      const graphWidth = this.graph.options.width;\n      const graphHeight = this.graph.options.height;\n      const pageWidth = this.options.pageWidth * this.sx;\n      const pageHeight = this.options.pageHeight * this.sy;\n\n      if (graphWidth > pageWidth || graphHeight > pageHeight) {\n        let hasPageBreak = false;\n        const container = document.createElement('div');\n\n        for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-vertical`)).css({\n            left: i * pageWidth\n          }).appendTo(container);\n          hasPageBreak = true;\n        }\n\n        for (let i = 1, l = Math.floor(graphHeight / pageHeight); i < l; i += 1) {\n          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-horizontal`)).css({\n            top: i * pageHeight\n          }).appendTo(container);\n          hasPageBreak = true;\n        }\n\n        if (hasPageBreak) {\n          Dom.addClass(container, this.prefixClassName('graph-pagebreak'));\n          this.$(this.graph.view.grid).after(container);\n          this.pageBreak = container;\n        }\n      }\n    }\n  }\n\n  update() {\n    const size = this.getClientSize();\n    this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);\n    let resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n    if (typeof resizeOptions === 'function') {\n      resizeOptions = FunctionExt.call(resizeOptions, this, this);\n    }\n\n    const options = Object.assign({\n      gridWidth: this.options.pageWidth,\n      gridHeight: this.options.pageHeight,\n      allowNewOrigin: 'negative'\n    }, resizeOptions);\n    this.graph.fitToContent(this.getFitToContentOptions(options));\n  }\n\n  getFitToContentOptions(options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    options.gridWidth && (options.gridWidth *= sx);\n    options.gridHeight && (options.gridHeight *= sy);\n    options.minWidth && (options.minWidth *= sx);\n    options.minHeight && (options.minHeight *= sy);\n\n    if (typeof options.padding === 'object') {\n      options.padding = {\n        left: (options.padding.left || 0) * sx,\n        right: (options.padding.right || 0) * sx,\n        top: (options.padding.top || 0) * sy,\n        bottom: (options.padding.bottom || 0) * sy\n      };\n    } else if (typeof options.padding === 'number') {\n      options.padding *= sx;\n    }\n\n    if (!this.options.autoResize) {\n      options.contentArea = Rectangle.create();\n    }\n\n    return options;\n  }\n\n  updateScale(sx, sy) {\n    const options = this.graph.options;\n    const dx = sx / this.sx;\n    const dy = sy / this.sy;\n    this.sx = sx;\n    this.sy = sy;\n    this.graph.translate(options.x * dx, options.y * dy);\n    this.graph.resizeGraph(options.width * dx, options.height * dy);\n  }\n\n  scrollbarPosition(left, top, options) {\n    if (left == null && top == null) {\n      return {\n        left: this.container.scrollLeft,\n        top: this.container.scrollTop\n      };\n    }\n\n    const prop = {};\n\n    if (typeof left === 'number') {\n      prop.scrollLeft = left;\n    }\n\n    if (typeof top === 'number') {\n      prop.scrollTop = top;\n    }\n\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation);\n    } else {\n      this.$container.prop(prop);\n    }\n\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the position (x,y) on the graph (in local\n   * coordinates) is at the center of the viewport. If only one of the\n   * coordinates is specified, only scroll in the specified dimension and\n   * keep the other coordinate unchanged.\n   */\n\n\n  scrollToPoint(x, y, options) {\n    const size = this.getClientSize();\n    const ctm = this.graph.matrix();\n    const prop = {};\n\n    if (typeof x === 'number') {\n      prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);\n    }\n\n    if (typeof y === 'number') {\n      prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);\n    }\n\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation);\n    } else {\n      this.$container.prop(prop);\n    }\n\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the center of graph content is at the\n   * center of the viewport.\n   */\n\n\n  scrollToContent(options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    const center = this.graph.getContentArea().getCenter();\n    return this.scrollToPoint(center.x * sx, center.y * sy, options);\n  }\n  /**\n   * Try to scroll to ensure that the center of cell is at the center of\n   * the viewport.\n   */\n\n\n  scrollToCell(cell, options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    const center = cell.getBBox().getCenter();\n    return this.scrollToPoint(center.x * sx, center.y * sy, options);\n  }\n  /**\n   * The center methods are more aggressive than the scroll methods. These\n   * methods position the graph so that a specific point on the graph lies\n   * at the center of the viewport, adding paddings around the paper if\n   * necessary (e.g. if the requested point lies in a corner of the paper).\n   * This means that the requested point will always move into the center\n   * of the viewport. (Use the scroll functions to avoid adding paddings\n   * and only scroll the viewport as far as the graph boundary.)\n   */\n\n  /**\n   * Position the center of graph to the center of the viewport.\n   */\n\n\n  center(optons) {\n    return this.centerPoint(optons);\n  }\n\n  centerPoint(x, y, options) {\n    const ctm = this.graph.matrix();\n    const sx = ctm.a;\n    const sy = ctm.d;\n    const tx = -ctm.e;\n    const ty = -ctm.f;\n    const tWidth = tx + this.graph.options.width;\n    const tHeight = ty + this.graph.options.height;\n    let localOptions;\n    this.storeClientSize(); // avoid multilple reflow\n\n    if (typeof x === 'number' || typeof y === 'number') {\n      localOptions = options;\n      const visibleCenter = this.getVisibleArea().getCenter();\n\n      if (typeof x === 'number') {\n        x *= sx; // eslint-disable-line\n      } else {\n        x = visibleCenter.x; // eslint-disable-line\n      }\n\n      if (typeof y === 'number') {\n        y *= sy; // eslint-disable-line\n      } else {\n        y = visibleCenter.y; // eslint-disable-line\n      }\n    } else {\n      localOptions = x;\n      x = (tx + tWidth) / 2; // eslint-disable-line\n\n      y = (ty + tHeight) / 2; // eslint-disable-line\n    }\n\n    if (localOptions && localOptions.padding) {\n      return this.positionPoint({\n        x,\n        y\n      }, '50%', '50%', localOptions);\n    }\n\n    const padding = this.getPadding();\n    const clientSize = this.getClientSize();\n    const cx = clientSize.width / 2;\n    const cy = clientSize.height / 2;\n    const left = cx - padding.left - x + tx;\n    const right = cx - padding.right + x - tWidth;\n    const top = cy - padding.top - y + ty;\n    const bottom = cy - padding.bottom + y - tHeight;\n    this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));\n    const result = this.scrollToPoint(x, y, localOptions || undefined);\n    this.restoreClientSize();\n    return result;\n  }\n\n  centerContent(options) {\n    return this.positionContent('center', options);\n  }\n\n  centerCell(cell, options) {\n    return this.positionCell(cell, 'center', options);\n  }\n  /**\n   * The position methods are a more general version of the center methods.\n   * They position the graph so that a specific point on the graph lies at\n   * requested coordinates inside the viewport.\n   */\n\n  /**\n   *\n   */\n\n\n  positionContent(pos, options) {\n    const rect = this.graph.getContentArea(options);\n    return this.positionRect(rect, pos, options);\n  }\n\n  positionCell(cell, pos, options) {\n    const bbox = cell.getBBox();\n    return this.positionRect(bbox, pos, options);\n  }\n\n  positionRect(rect, pos, options) {\n    const bbox = Rectangle.create(rect);\n\n    switch (pos) {\n      case 'center':\n        return this.positionPoint(bbox.getCenter(), '50%', '50%', options);\n\n      case 'top':\n        return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);\n\n      case 'top-right':\n        return this.positionPoint(bbox.getTopRight(), '100%', 0, options);\n\n      case 'right':\n        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);\n\n      case 'bottom-right':\n        return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);\n\n      case 'bottom':\n        return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);\n\n      case 'bottom-left':\n        return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);\n\n      case 'left':\n        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);\n\n      case 'top-left':\n        return this.positionPoint(bbox.getTopLeft(), 0, 0, options);\n\n      default:\n        return this;\n    }\n  }\n\n  positionPoint(point, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    const {\n      padding: pad\n    } = options,\n          localOptions = __rest(options, [\"padding\"]);\n\n    const padding = NumberExt.normalizeSides(pad);\n    const clientRect = Rectangle.fromSize(this.getClientSize());\n    const targetRect = clientRect.clone().moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.right - padding.left,\n      height: -padding.top - padding.bottom\n    }); // eslint-disable-next-line\n\n    x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));\n\n    if (x < 0) {\n      x = targetRect.width + x; // eslint-disable-line\n    } // eslint-disable-next-line\n\n\n    y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));\n\n    if (y < 0) {\n      y = targetRect.height + y; // eslint-disable-line\n    }\n\n    const origin = targetRect.getTopLeft().translate(x, y);\n    const diff = clientRect.getCenter().diff(origin);\n    const scale = this.zoom();\n    const rawDiff = diff.scale(1 / scale, 1 / scale);\n    const result = Point.create(point).translate(rawDiff);\n    return this.centerPoint(result.x, result.y, localOptions);\n  }\n\n  zoom(factor, options) {\n    if (factor == null) {\n      return this.sx;\n    }\n\n    options = options || {}; // eslint-disable-line\n\n    let cx;\n    let cy;\n    const clientSize = this.getClientSize();\n    const center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n    let sx = factor;\n    let sy = factor;\n\n    if (!options.absolute) {\n      sx += this.sx;\n      sy += this.sy;\n    }\n\n    if (options.scaleGrid) {\n      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n    }\n\n    if (options.maxScale) {\n      sx = Math.min(options.maxScale, sx);\n      sy = Math.min(options.maxScale, sy);\n    }\n\n    if (options.minScale) {\n      sx = Math.max(options.minScale, sx);\n      sy = Math.max(options.minScale, sy);\n    }\n\n    sx = this.graph.transform.clampScale(sx);\n    sy = this.graph.transform.clampScale(sy);\n\n    if (options.center) {\n      const fx = sx / this.sx;\n      const fy = sy / this.sy;\n      cx = options.center.x - (options.center.x - center.x) / fx;\n      cy = options.center.y - (options.center.y - center.y) / fy;\n    } else {\n      cx = center.x;\n      cy = center.y;\n    }\n\n    this.beforeManipulation();\n    this.graph.transform.scale(sx, sy);\n    this.centerPoint(cx, cy);\n    this.afterManipulation();\n    return this;\n  }\n\n  zoomToRect(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const area = Rectangle.create(rect);\n    const graph = this.graph;\n    options.contentArea = area;\n\n    if (options.viewportArea == null) {\n      options.viewportArea = {\n        x: graph.options.x,\n        y: graph.options.y,\n        width: this.$container.width(),\n        height: this.$container.height()\n      };\n    }\n\n    this.beforeManipulation();\n    graph.transform.scaleContentToFitImpl(options, false);\n    const center = area.getCenter();\n    this.centerPoint(center.x, center.y);\n    this.afterManipulation();\n    return this;\n  }\n\n  zoomToFit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.zoomToRect(this.graph.getContentArea(options), options);\n  }\n\n  transitionToPoint(x, y, options) {\n    if (typeof x === 'object') {\n      options = y; // eslint-disable-line\n\n      y = x.y; // eslint-disable-line\n\n      x = x.x; // eslint-disable-line\n    } else {\n      y = y; // eslint-disable-line\n    }\n\n    if (options == null) {\n      options = {}; // eslint-disable-line\n    }\n\n    let transform;\n    let transformOrigin;\n    const scale = this.sx;\n    const targetScale = Math.max(options.scale || scale, 0.000001);\n    const clientSize = this.getClientSize();\n    const targetPoint = new Point(x, y);\n    const localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n\n    if (scale === targetScale) {\n      const translate = localPoint.diff(targetPoint).scale(scale, scale).round();\n      transform = `translate(${translate.x}px,${translate.y}px)`;\n    } else {\n      const delta = targetScale / (scale - targetScale) * targetPoint.distance(localPoint);\n      const range = localPoint.clone().move(targetPoint, delta);\n      const origin = this.localToBackgroundPoint(range).round();\n      transform = `scale(${targetScale / scale})`;\n      transformOrigin = `${origin.x}px ${origin.y}px`;\n    }\n\n    const onTransitionEnd = options.onTransitionEnd;\n    this.$container.addClass(Util.transitionClassName);\n    this.$content.off(Util.transitionEventName).on(Util.transitionEventName, e => {\n      this.syncTransition(targetScale, {\n        x: x,\n        y: y\n      });\n\n      if (typeof onTransitionEnd === 'function') {\n        FunctionExt.call(onTransitionEnd, this, e.originalEvent);\n      }\n    }).css({\n      transform,\n      transformOrigin,\n      transition: 'transform',\n      transitionDuration: options.duration || '1s',\n      transitionDelay: options.delay,\n      transitionTimingFunction: options.timing\n    });\n    return this;\n  }\n\n  syncTransition(scale, p) {\n    this.beforeManipulation();\n    this.graph.scale(scale);\n    this.removeTransition();\n    this.centerPoint(p.x, p.y);\n    this.afterManipulation();\n    return this;\n  }\n\n  removeTransition() {\n    this.$container.removeClass(Util.transitionClassName);\n    this.$content.off(Util.transitionEventName).css({\n      transform: '',\n      transformOrigin: '',\n      transition: '',\n      transitionDuration: '',\n      transitionDelay: '',\n      transitionTimingFunction: ''\n    });\n    return this;\n  }\n\n  transitionToRect(rectangle) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rect = Rectangle.create(rectangle);\n    const maxScale = options.maxScale || Infinity;\n    const minScale = options.minScale || Number.MIN_VALUE;\n    const scaleGrid = options.scaleGrid || null;\n    const PIXEL_SIZE = options.visibility || 1;\n    const center = options.center ? Point.create(options.center) : rect.getCenter();\n    const clientSize = this.getClientSize();\n    const w = clientSize.width * PIXEL_SIZE;\n    const h = clientSize.height * PIXEL_SIZE;\n    let scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);\n    scale = Math.min(scale, maxScale);\n\n    if (scaleGrid) {\n      scale = Math.floor(scale / scaleGrid) * scaleGrid;\n    }\n\n    scale = Math.max(minScale, scale);\n    return this.transitionToPoint(center, Object.assign({\n      scale\n    }, options));\n  }\n\n  startPanning(evt) {\n    const e = this.normalizeEvent(evt);\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.trigger('pan:start', {\n      e\n    });\n    this.$(document.body).on({\n      'mousemove.panning touchmove.panning': this.pan.bind(this),\n      'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n      'mouseleave.panning': this.stopPanning.bind(this)\n    });\n    this.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n  }\n\n  pan(evt) {\n    const e = this.normalizeEvent(evt);\n    const dx = e.clientX - this.clientX;\n    const dy = e.clientY - this.clientY;\n    this.container.scrollTop -= dy;\n    this.container.scrollLeft -= dx;\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.trigger('panning', {\n      e\n    });\n  }\n\n  stopPanning(e) {\n    this.$(document.body).off('.panning');\n    this.$(window).off('.panning');\n    this.trigger('pan:stop', {\n      e\n    });\n  }\n\n  clientToLocalPoint(a, b) {\n    let x = typeof a === 'object' ? a.x : a;\n    let y = typeof a === 'object' ? a.y : b;\n    const ctm = this.graph.matrix();\n    x += this.container.scrollLeft - this.padding.left - ctm.e;\n    y += this.container.scrollTop - this.padding.top - ctm.f;\n    return new Point(x / ctm.a, y / ctm.d);\n  }\n\n  localToBackgroundPoint(x, y) {\n    const p = typeof x === 'object' ? Point.create(x) : new Point(x, y);\n    const ctm = this.graph.matrix();\n    const padding = this.padding;\n    return Dom.transformPoint(p, ctm).translate(padding.left, padding.top);\n  }\n\n  resize(width, height) {\n    let w = width != null ? width : this.container.clientWidth;\n    let h = height != null ? height : this.container.clientHeight;\n\n    if (typeof w === 'number') {\n      w = Math.round(w);\n    }\n\n    if (typeof h === 'number') {\n      h = Math.round(h);\n    }\n\n    this.options.width = w;\n    this.options.height = h;\n    this.$container.css({\n      width: w,\n      height: h\n    });\n    this.update();\n  }\n\n  getClientSize() {\n    if (this.cachedClientSize) {\n      return this.cachedClientSize;\n    }\n\n    return {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight\n    };\n  }\n\n  autoScroll(clientX, clientY) {\n    const buffer = 10;\n    const container = this.container;\n    const rect = container.getBoundingClientRect();\n    let dx = 0;\n    let dy = 0;\n\n    if (clientX <= rect.left + buffer) {\n      dx = -buffer;\n    }\n\n    if (clientY <= rect.top + buffer) {\n      dy = -buffer;\n    }\n\n    if (clientX >= rect.right - buffer) {\n      dx = buffer;\n    }\n\n    if (clientY >= rect.bottom - buffer) {\n      dy = buffer;\n    }\n\n    if (dx !== 0) {\n      container.scrollLeft += dx;\n    }\n\n    if (dy !== 0) {\n      container.scrollTop += dy;\n    }\n\n    return {\n      scrollerX: dx,\n      scrollerY: dy\n    };\n  }\n\n  addPadding(left, right, top, bottom) {\n    let padding = this.getPadding();\n    this.padding = {\n      left: Math.round(padding.left + (left || 0)),\n      top: Math.round(padding.top + (top || 0)),\n      bottom: Math.round(padding.bottom + (bottom || 0)),\n      right: Math.round(padding.right + (right || 0))\n    };\n    padding = this.padding;\n    this.$content.css({\n      width: padding.left + this.graph.options.width + padding.right,\n      height: padding.top + this.graph.options.height + padding.bottom\n    });\n    const container = this.graph.container;\n    container.style.left = `${this.padding.left}px`;\n    container.style.top = `${this.padding.top}px`;\n    return this;\n  }\n\n  getPadding() {\n    const padding = this.options.padding;\n\n    if (typeof padding === 'function') {\n      return NumberExt.normalizeSides(FunctionExt.call(padding, this, this));\n    }\n\n    return NumberExt.normalizeSides(padding);\n  }\n  /**\n   * Returns the untransformed size and origin of the current viewport.\n   */\n\n\n  getVisibleArea() {\n    const ctm = this.graph.matrix();\n    const size = this.getClientSize();\n    const box = {\n      x: this.container.scrollLeft || 0,\n      y: this.container.scrollTop || 0,\n      width: size.width,\n      height: size.height\n    };\n    const area = Dom.transformRectangle(box, ctm.inverse());\n    area.x -= (this.padding.left || 0) / this.sx;\n    area.y -= (this.padding.top || 0) / this.sy;\n    return area;\n  }\n\n  isCellVisible(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const bbox = cell.getBBox();\n    const area = this.getVisibleArea();\n    return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n  }\n\n  isPointVisible(point) {\n    return this.getVisibleArea().containsPoint(point);\n  }\n  /**\n   * Lock the current viewport by disabling user scrolling.\n   */\n\n\n  lock() {\n    this.$container.css('overflow', 'hidden');\n    return this;\n  }\n  /**\n   * Enable user scrolling if previously locked.\n   */\n\n\n  unlock() {\n    this.$container.css('overflow', 'scroll');\n    return this;\n  }\n\n  onRemove() {\n    this.stopListening();\n  }\n\n  dispose() {\n    this.$(this.graph.container).insertBefore(this.$container);\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Scroller.prototype, \"dispose\", null);\n\n(function (Scroller) {\n  class Background extends BackgroundManager {\n    constructor(scroller) {\n      super(scroller.graph);\n      this.scroller = scroller;\n\n      if (scroller.options.background) {\n        this.draw(scroller.options.background);\n      }\n    }\n\n    get elem() {\n      return this.scroller.background;\n    }\n\n    init() {\n      this.graph.on('scale', this.update, this);\n      this.graph.on('translate', this.update, this);\n    }\n\n    updateBackgroundOptions(options) {\n      this.scroller.options.background = options;\n    }\n\n  }\n\n  Scroller.Background = Background;\n})(Scroller || (Scroller = {}));\n\nvar Util;\n\n(function (Util) {\n  Util.containerClass = 'graph-scroller';\n  Util.panningClass = `${Util.containerClass}-panning`;\n  Util.pannableClass = `${Util.containerClass}-pannable`;\n  Util.pagedClass = `${Util.containerClass}-paged`;\n  Util.contentClass = `${Util.containerClass}-content`;\n  Util.backgroundClass = `${Util.containerClass}-background`;\n  Util.transitionClassName = 'transition-in-progress';\n  Util.transitionEventName = 'transitionend.graph-scroller-transition';\n  Util.defaultOptions = {\n    padding() {\n      const size = this.getClientSize();\n      const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;\n      const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;\n      const left = Math.max(size.width - minWidth, 0);\n      const top = Math.max(size.height - minHeight, 0);\n      return {\n        left,\n        top,\n        right: left,\n        bottom: top\n      };\n    },\n\n    minVisibleWidth: 50,\n    minVisibleHeight: 50,\n    pageVisible: false,\n    pageBreak: false,\n    autoResize: true\n  };\n\n  function getOptions(options) {\n    const result = ObjectExt.merge({}, Util.defaultOptions, options);\n\n    if (result.pageWidth == null) {\n      result.pageWidth = options.graph.options.width;\n    }\n\n    if (result.pageHeight == null) {\n      result.pageHeight = options.graph.options.height;\n    }\n\n    return result;\n  }\n\n  Util.getOptions = getOptions;\n})(Util || (Util = {}));","map":null,"metadata":{},"sourceType":"module"}