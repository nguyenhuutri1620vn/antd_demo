{"ast":null,"code":"import Grid from './grid';\nexport default function layout(data, options) {\n  if (!data.nodes || data.nodes.length === 0) return data;\n  const width = options.width;\n  const height = options.height;\n  const nodeMinGap = options.nodeMinGap; // 2. 网格布局\n\n  let CELL_W = 10000;\n  let CELL_H = 10000;\n  data.nodes.forEach(node => {\n    const nodeWidth = node.size[0] || 50;\n    const nodeHeight = node.size[1] || 50;\n    CELL_W = Math.min(nodeWidth, CELL_W);\n    CELL_H = Math.min(nodeHeight, CELL_H);\n  });\n  const grid = new Grid();\n  grid.init(width, height, {\n    CELL_H,\n    CELL_W\n  });\n  data.nodes.forEach(d => {\n    const gridpoint = grid.occupyNearest(d);\n\n    if (gridpoint) {\n      gridpoint.node = {\n        id: d.id,\n        size: d.size\n      };\n      d.x = gridpoint.x;\n      d.y = gridpoint.y;\n      d.dx = gridpoint.dx;\n      d.dy = gridpoint.dy;\n    }\n  }); // 加入节点size\n\n  for (let i = 0; i < data.nodes.length; i++) {\n    //  节点宽度大于网格宽度，则往当前网格的右边插入列\n    const node = data.nodes[i];\n    const result = grid.findGridByNodeId(node.id);\n    if (!result) throw new Error(\"can not find node cell\");\n    const {\n      column,\n      row\n    } = result;\n\n    if (node.size[0] + nodeMinGap > CELL_W) {\n      const addGridSize = Math.ceil((node.size[0] + nodeMinGap) / CELL_W) - 1;\n      let realAdd = addGridSize; // 优化，假设同一列，不同行存在两个size为2的节点，遍历到第一个节点的时候，会往右插入两列，遍历到第二个节点，又往右插入。就会导致多余的网格\n\n      for (let j = 0; j < addGridSize; j++) {\n        const hasColumn = grid.additionColumn.indexOf(column + j + 1) > -1;\n\n        if (hasColumn && !grid.cells[column + j + 1][row].node) {\n          realAdd--;\n        } else {\n          break;\n        }\n      }\n\n      grid.insertColumn(column, realAdd);\n    } // 节点高度大于网格宽度，则往当前网格的下边插入行\n\n\n    if (node.size[1] + nodeMinGap > CELL_H) {\n      const addGridSize = Math.ceil((node.size[1] + nodeMinGap) / CELL_H) - 1;\n      let realAdd = addGridSize;\n\n      for (let j = 0; j < addGridSize; j++) {\n        const hasColumn = grid.additionRow.indexOf(row + j + 1) > -1;\n\n        if (hasColumn && !grid.cells[column][row + j + 1].node) {\n          realAdd--;\n        } else {\n          break;\n        }\n      }\n\n      grid.insertRow(row, realAdd);\n    }\n  } // 同步节点坐标\n\n\n  for (let i = 0; i < grid.columnNum; i++) {\n    for (let j = 0; j < grid.rowNum; j++) {\n      const cell = grid.cells[i][j];\n\n      if (cell.node) {\n        const node = data.nodes.find(node => {\n          var _a;\n\n          return node.id === ((_a = cell === null || cell === void 0 ? void 0 : cell.node) === null || _a === void 0 ? void 0 : _a.id);\n        });\n\n        if (node) {\n          node.x = cell.x + node.size[0] / 2;\n          node.y = cell.y + node.size[1] / 2;\n        }\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}