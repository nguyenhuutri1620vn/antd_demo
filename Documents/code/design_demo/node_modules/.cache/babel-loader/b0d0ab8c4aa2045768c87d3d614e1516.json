{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _class2, _descriptor, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // tslint:disable-next-line:no-reference\n/// <reference path=\"../../../node_modules/@webgpu/types/dist/index.d.ts\" />\n\n\nimport { createEntity as _createEntity, createWorldContainer, IDENTIFIER } from '@antv/g-webgpu-core';\nimport { WebGLEngine, WebGPUEngine } from '@antv/g-webgpu-engine'; // tslint:disable-next-line:no-submodule-imports\n\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { inject, injectable } from 'inversify';\nimport { Camera } from './camera/Camera';\nimport { Geometry } from './geometry';\nimport { Box } from './geometry/Box';\nimport { Merged } from './geometry/Merged';\nimport { Plane } from './geometry/Plane';\nimport { Sphere } from './geometry/Sphere';\nimport { Kernel } from './Kernel';\nimport { Material } from './material';\nimport { Basic } from './material/basic';\nimport { Grid } from './renderable/grid';\nimport { Line } from './renderable/line';\nimport { Point } from './renderable/point';\nimport { Renderable } from './renderable/Renderable';\nimport { Renderer } from './Renderer';\nimport { Scene } from './Scene';\nimport { TextureCache } from './texture/Cache';\nimport { Texture2D } from './texture/Texture2D';\nimport { createCanvas } from './utils/canvas';\nimport { View } from './View';\nexport var World = (_dec = injectable(), _dec2 = inject(IDENTIFIER.ConfigService), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {\n  function World() {\n    _classCallCheck(this, World);\n\n    _initializerDefineProperty(this, \"configService\", _descriptor, this);\n\n    this.container = void 0;\n  }\n\n  _createClass(World, [{\n    key: \"getEngine\",\n    value: function () {\n      var _getEngine = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var engine, _this$configService$g, canvas, engineOptions;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                engine = this.container.get(IDENTIFIER.RenderEngine);\n                _this$configService$g = this.configService.get(), canvas = _this$configService$g.canvas, engineOptions = _this$configService$g.engineOptions;\n                _context.next = 4;\n                return engine.init(_objectSpread({\n                  canvas: canvas || createCanvas(),\n                  swapChainFormat: WebGPUConstants.TextureFormat.BGRA8Unorm,\n                  antialiasing: false\n                }, engineOptions));\n\n              case 4:\n                return _context.abrupt(\"return\", engine);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getEngine() {\n        return _getEngine.apply(this, arguments);\n      }\n\n      return getEngine;\n    }()\n    /**\n     * get transform component\n     * @param entity\n     */\n\n  }, {\n    key: \"getTransformComponent\",\n    value: function getTransformComponent(entity) {\n      var manager = this.container.get(IDENTIFIER.TransformComponentManager);\n      return manager.getComponentByEntity(entity);\n    }\n  }, {\n    key: \"getMeshComponent\",\n    value: function getMeshComponent(entity) {\n      var manager = this.container.get(IDENTIFIER.MeshComponentManager);\n      return manager.getComponentByEntity(entity);\n    }\n  }, {\n    key: \"setConfig\",\n    value: function setConfig(config) {\n      this.configService.set(config);\n    }\n  }, {\n    key: \"setContainer\",\n    value: function setContainer(container) {\n      this.container = container;\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n  }, {\n    key: \"createEntity\",\n    value: function createEntity() {\n      return _createEntity();\n    }\n  }, {\n    key: \"createScene\",\n    value: function createScene() {\n      return this.container.get(Scene);\n    }\n  }, {\n    key: \"createCamera\",\n    value: function createCamera() {\n      return this.container.get(Camera);\n    }\n  }, {\n    key: \"createView\",\n    value: function createView() {\n      return this.container.get(View);\n    } // public createLight(type: string,) {\n    //   return this.container.getNamed(IDENTIFIER.Light, type)\n    // }\n\n  }, {\n    key: \"createRenderable\",\n    value: function createRenderable(type, config) {\n      var renderable = type ? this.container.getNamed(IDENTIFIER.Renderable, type) : this.container.get(Renderable);\n\n      var entity = _createEntity();\n\n      renderable.setConfig(config || {});\n      renderable.setEntity(entity);\n      return renderable;\n    }\n  }, {\n    key: \"createGeometry\",\n    value: function createGeometry(type, config) {\n      var geometry = this.container.getNamed(IDENTIFIER.Geometry, type);\n\n      var entity = _createEntity();\n\n      geometry.setConfig(config || {});\n      geometry.setEntity(entity);\n      return geometry.getComponent();\n    }\n  }, {\n    key: \"createMaterial\",\n    value: function createMaterial(type, config) {\n      var material = this.container.getNamed(IDENTIFIER.Material, type);\n\n      var entity = _createEntity();\n\n      material.setConfig(config || {});\n      material.setEntity(entity, type);\n      return material.getComponent();\n    }\n  }, {\n    key: \"createTexture2D\",\n    value: function createTexture2D(config) {\n      var texture = this.container.get(Texture2D);\n      texture.setConfig(config);\n      return texture;\n    }\n  }, {\n    key: \"createBufferGeometry\",\n    value: function createBufferGeometry(params) {\n      var geometrySystem = this.container.getNamed(IDENTIFIER.Systems, IDENTIFIER.GeometrySystem);\n      return geometrySystem.createBufferGeometry(params);\n    }\n  }, {\n    key: \"createInstancedBufferGeometry\",\n    value: function createInstancedBufferGeometry(params) {\n      var geometrySystem = this.container.getNamed(IDENTIFIER.Systems, IDENTIFIER.GeometrySystem);\n      return geometrySystem.createInstancedBufferGeometry(params);\n    }\n  }, {\n    key: \"createShaderMaterial\",\n    value: function createShaderMaterial(params) {\n      var materialSystem = this.container.getNamed(IDENTIFIER.Systems, IDENTIFIER.MaterialSystem);\n      return materialSystem.createShaderMaterial(params);\n    }\n  }, {\n    key: \"createKernel\",\n    value: function createKernel(precompiledBundle) {\n      var kernel = this.container.get(Kernel);\n\n      if (typeof precompiledBundle === 'string') {\n        kernel.setBundle(JSON.parse(precompiledBundle));\n      } else {\n        kernel.setBundle(precompiledBundle);\n      }\n\n      kernel.init();\n      return kernel;\n    }\n  }, {\n    key: \"createRenderer\",\n    value: function createRenderer() {\n      var renderer = this.container.get(Renderer);\n      renderer.container = this.container;\n      renderer.init();\n      return renderer;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var systems = this.container.getAll(IDENTIFIER.Systems);\n      systems.forEach(function (system) {\n        if (system.tearDown) {\n          system.tearDown();\n        }\n      });\n      var engine = this.container.get(IDENTIFIER.RenderEngine);\n      engine.destroy();\n      var interactor = this.container.get(IDENTIFIER.InteractorService);\n      interactor.destroy();\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var worldContainer = createWorldContainer(); // bind render engine, fallback to WebGL\n\n      var engineClazz = !navigator.gpu ? WebGLEngine : WebGPUEngine;\n\n      if (!worldContainer.isBound(IDENTIFIER.RenderEngine)) {\n        worldContainer.bind(IDENTIFIER.RenderEngine) // @ts-ignore\n        .to(engineClazz).inSingletonScope();\n      }\n\n      worldContainer.bind(Renderer).toSelf();\n      worldContainer.bind(Kernel).toSelf();\n      worldContainer.bind(Renderable).toSelf();\n      worldContainer.bind(View).toSelf();\n      worldContainer.bind(Camera).toSelf();\n      worldContainer.bind(Scene).toSelf();\n      worldContainer.bind(World).toSelf();\n      worldContainer.bind(TextureCache).toSelf();\n      worldContainer.bind(Texture2D).toSelf(); // bind geometries\n\n      worldContainer.bind(IDENTIFIER.Geometry).to(Box).whenTargetNamed(Geometry.BOX);\n      worldContainer.bind(IDENTIFIER.Geometry).to(Sphere).whenTargetNamed(Geometry.SPHERE);\n      worldContainer.bind(IDENTIFIER.Geometry).to(Plane).whenTargetNamed(Geometry.PLANE);\n      worldContainer.bind(IDENTIFIER.Geometry).to(Merged).whenTargetNamed(Geometry.MERGED); // bind materials\n\n      worldContainer.bind(IDENTIFIER.Material).to(Basic).whenTargetNamed(Material.BASIC); // bind renderables\n\n      worldContainer.bind(IDENTIFIER.Renderable).to(Point).whenTargetNamed(Renderable.POINT);\n      worldContainer.bind(IDENTIFIER.Renderable).to(Line).whenTargetNamed(Renderable.LINE);\n      worldContainer.bind(IDENTIFIER.Renderable).to(Grid).whenTargetNamed(Renderable.GRID);\n      var world = worldContainer.get(World);\n      world.setContainer(worldContainer);\n      world.setConfig(config);\n      return world;\n    }\n  }]);\n\n  return World;\n}(), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"configService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);","map":null,"metadata":{},"sourceType":"module"}