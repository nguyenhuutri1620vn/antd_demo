{"ast":null,"code":"import { __extends } from \"tslib\";\nimport Hierarchy from '@antv/hierarchy';\nimport { each, isObject, isString } from '@antv/util';\nimport Util from '../util';\nimport Graph from './graph';\nvar radialLayout = Util.radialLayout,\n    traverseTree = Util.traverseTree;\n\nvar TreeGraph =\n/** @class */\nfunction (_super) {\n  __extends(TreeGraph, _super);\n\n  function TreeGraph(cfg) {\n    var _this = _super.call(this, cfg) || this;\n\n    _this.layoutAnimating = false; // 用于缓存动画结束后需要删除的节点\n\n    _this.set('removeList', []);\n\n    _this.set('layoutMethod', _this.getLayout());\n\n    return _this;\n  }\n  /**\n   * 通过 Layout 配置获取布局配置\n   */\n\n\n  TreeGraph.prototype.getLayout = function () {\n    var layout = this.get('layout');\n\n    if (!layout) {\n      return null;\n    }\n\n    if (typeof layout === 'function') {\n      return layout;\n    }\n\n    if (!layout.type) {\n      layout.type = 'dendrogram';\n    }\n\n    if (!layout.direction) {\n      layout.direction = 'TB';\n    }\n\n    if (layout.radial) {\n      return function (data) {\n        var layoutData = Hierarchy[layout.type](data, layout);\n        radialLayout(layoutData);\n        return layoutData;\n      };\n    }\n\n    return function (data) {\n      return Hierarchy[layout.type](data, layout);\n    };\n  };\n  /**\n   * 返回指定节点在树图数据中的索引\n   * @param children 树图数据\n   * @param child 树图中某一个 Item 的数据\n   */\n\n\n  TreeGraph.indexOfChild = function (children, id) {\n    var index = -1; // eslint-disable-next-line consistent-return\n\n    each(children, function (former, i) {\n      if (id === former.id) {\n        index = i;\n        return false;\n      }\n    });\n    return index;\n  };\n\n  TreeGraph.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this); // 树图默认打开动画\n\n\n    cfg.animate = true;\n    return cfg;\n  };\n  /**\n   * 向🌲树中添加数据\n   * @param treeData 树图数据\n   * @param parent 父节点实例\n   * @param animate 是否开启动画\n   */\n\n\n  TreeGraph.prototype.innerAddChild = function (treeData, parent, animate) {\n    var self = this;\n    var model = treeData.data;\n\n    if (model) {\n      // model 中应存储真实的数据，特别是真实的 children\n      model.x = treeData.x;\n      model.y = treeData.y;\n      model.depth = treeData.depth;\n    }\n\n    var node = self.addItem('node', model, false);\n\n    if (parent) {\n      node.set('parent', parent);\n\n      if (animate) {\n        var origin_1 = parent.get('originAttrs');\n\n        if (origin_1) {\n          node.set('originAttrs', origin_1);\n        } else {\n          var parentModel = parent.getModel();\n          node.set('originAttrs', {\n            x: parentModel.x,\n            y: parentModel.y\n          });\n        }\n      }\n\n      var childrenList = parent.get('children');\n\n      if (!childrenList) {\n        parent.set('children', [node]);\n      } else {\n        childrenList.push(node);\n      }\n\n      self.addItem('edge', {\n        source: parent.get('id'),\n        target: node.get('id'),\n        id: \"\".concat(parent.get('id'), \":\").concat(node.get('id'))\n      }, false);\n    } // 渲染到视图上应参考布局的children, 避免多绘制了收起的节点\n\n\n    each(treeData.children || [], function (child) {\n      self.innerAddChild(child, node, animate);\n    });\n    self.emit('afteraddchild', {\n      item: node,\n      parent: parent\n    });\n    return node;\n  };\n  /**\n   * 将数据上的变更转换到视图上\n   * @param data\n   * @param parent\n   * @param animate\n   */\n\n\n  TreeGraph.prototype.innerUpdateChild = function (data, parent, animate) {\n    var self = this;\n    var current = self.findById(data.id); // 若子树不存在，整体添加即可\n\n    if (!current) {\n      self.innerAddChild(data, parent, animate);\n      return;\n    } // 更新新节点下所有子节点\n\n\n    each(data.children || [], function (child) {\n      self.innerUpdateChild(child, current, animate);\n    }); // 用现在节点的children实例来删除移除的子节点\n\n    var children = current.get('children');\n\n    if (children) {\n      var len = children.length;\n\n      if (len > 0) {\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i].getModel();\n\n          if (TreeGraph.indexOfChild(data.children || [], child.id) === -1) {\n            self.innerRemoveChild(child.id, {\n              x: data.x,\n              y: data.y\n            }, animate); // 更新父节点下缓存的子节点 item 实例列表\n\n            children.splice(i, 1);\n          }\n        }\n      }\n    }\n\n    var oriX;\n    var oriY;\n\n    if (current.get('originAttrs')) {\n      oriX = current.get('originAttrs').x;\n      oriY = current.get('originAttrs').y;\n    }\n\n    var model = current.getModel();\n\n    if (animate) {\n      // 如果有动画，先缓存节点运动再更新节点\n      current.set('originAttrs', {\n        x: model.x,\n        y: model.y\n      });\n    }\n\n    current.set('model', data.data);\n\n    if (oriX !== data.x || oriY !== data.y) {\n      current.updatePosition({\n        x: data.x,\n        y: data.y\n      });\n    }\n  };\n  /**\n   * 删除子节点Item对象\n   * @param id\n   * @param to\n   * @param animate\n   */\n\n\n  TreeGraph.prototype.innerRemoveChild = function (id, to, animate) {\n    var self = this;\n    var node = self.findById(id);\n\n    if (!node) {\n      return;\n    }\n\n    each(node.get('children'), function (child) {\n      self.innerRemoveChild(child.getModel().id, to, animate);\n    });\n\n    if (animate) {\n      var model = node.getModel();\n      node.set('to', to);\n      node.set('originAttrs', {\n        x: model.x,\n        y: model.y\n      });\n      self.get('removeList').push(node);\n    } else {\n      self.removeItem(node, false);\n    }\n  };\n  /**\n   * 更新数据模型，差量更新并重新渲染\n   * @param {object} data 数据模型\n   */\n\n\n  TreeGraph.prototype.changeData = function (data) {\n    var self = this; // 更改数据源后，取消所有状态\n\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n\n    if (data) {\n      self.data(data);\n      self.render();\n    } else {\n      self.layout(this.get('fitView'));\n    }\n  };\n  /**\n   * 已更名为 updateLayout，为保持兼容暂且保留。\n   * 更改并应用树布局算法\n   * @param {object} layout 布局算法\n   */\n\n\n  TreeGraph.prototype.changeLayout = function (layout) {\n    // eslint-disable-next-line no-console\n    console.warn('Please call updateLayout instead of changeLayout. changeLayout will be discarded soon');\n    var self = this;\n    self.updateLayout(layout);\n  };\n  /**\n   * 更改并应用树布局算法\n   * @param {object} layout 布局算法\n   */\n\n\n  TreeGraph.prototype.updateLayout = function (layout) {\n    var self = this;\n\n    if (!layout) {\n      // eslint-disable-next-line no-console\n      console.warn('layout cannot be null');\n      return;\n    }\n\n    self.set('layout', layout);\n    self.set('layoutMethod', self.getLayout());\n    self.layout();\n  };\n  /**\n   * 已更名为 layout，为保持兼容暂且保留。\n   * 根据目前的 data 刷新布局，更新到画布上。用于变更数据之后刷新视图。\n   * @param {boolean} fitView 更新布局时是否需要适应窗口\n   */\n\n\n  TreeGraph.prototype.refreshLayout = function (fitView) {\n    // eslint-disable-next-line no-console\n    console.warn('Please call layout instead of refreshLayout. refreshLayout will be discarded soon');\n    var self = this;\n    self.layout(fitView);\n  };\n  /**\n   * 根据目前的 data 刷新布局，更新到画布上。用于变更数据之后刷新视图。\n   * @param {boolean} fitView 更新布局时是否需要适应窗口\n   */\n\n\n  TreeGraph.prototype.layout = function (fitView) {\n    var self = this;\n    var data = self.get('data');\n    var layoutMethod = self.get('layoutMethod');\n    var layoutData = layoutMethod ? layoutMethod(data, self.get('layout')) : data;\n    var animate = self.get('animate');\n    self.emit('beforerefreshlayout', {\n      data: data,\n      layoutData: layoutData\n    });\n    self.emit('beforelayout');\n    self.innerUpdateChild(layoutData, undefined, animate);\n\n    if (fitView) {\n      var viewController = self.get('viewController');\n      viewController.fitView();\n    }\n\n    if (!animate) {\n      // 如果没有动画，目前仅更新了节点的位置，刷新一下边的样式\n      self.refresh();\n      self.paint();\n    } else {\n      self.layoutAnimate(layoutData);\n    }\n\n    self.emit('afterrefreshlayout', {\n      data: data,\n      layoutData: layoutData\n    });\n    self.emit('afterlayout');\n  };\n  /**\n   * 添加子树到对应 id 的节点\n   * @param {TreeGraphData} data 子树数据模型\n   * @param {string} parent 子树的父节点id\n   */\n\n\n  TreeGraph.prototype.addChild = function (data, parent) {\n    var self = this;\n    self.emit('beforeaddchild', {\n      model: data,\n      parent: parent\n    }); // 将数据添加到源数据中，走changeData方法\n\n    if (!isString(parent)) {\n      parent = parent.get('id');\n    }\n\n    var parentData = self.findDataById(parent);\n\n    if (parentData) {\n      if (!parentData.children) {\n        parentData.children = [];\n      }\n\n      parentData.children.push(data);\n      self.changeData();\n    }\n  };\n  /**\n   * 更新某个节点下的所有子节点\n   * @param {TreeGraphData[]} data 子树数据模型集合\n   * @param {string} parent 子树的父节点id\n   */\n\n\n  TreeGraph.prototype.updateChildren = function (data, parentId) {\n    var self = this; // 如果没有父节点或找不到该节点，是全量的更新，直接重置data\n\n    if (!parentId || !self.findById(parentId)) {\n      console.warn(\"Update children failed! There is no node with id '\".concat(parentId, \"'\"));\n      return;\n    }\n\n    var parentModel = self.findDataById(parentId);\n    parentModel.children = data;\n    self.changeData();\n  };\n  /**\n   * 更新源数据，差量更新子树\n   * @param {TreeGraphData} data 子树数据模型\n   * @param {string} parentId 子树的父节点id\n   */\n\n\n  TreeGraph.prototype.updateChild = function (data, parentId) {\n    var self = this; // 如果没有父节点或找不到该节点，是全量的更新，直接重置data\n\n    if (!parentId || !self.findById(parentId)) {\n      self.changeData(data);\n      return;\n    }\n\n    var parentModel = self.findDataById(parentId);\n    var current = self.findById(data.id);\n\n    if (!parentModel.children) {\n      // 当 current 不存在时，children 为空数组\n      parentModel.children = [];\n    } // 如果不存在该节点，则添加\n\n\n    if (!current) {\n      parentModel.children.push(data);\n    } else {\n      var index = TreeGraph.indexOfChild(parentModel.children, data.id);\n      parentModel.children[index] = data;\n    }\n\n    self.changeData();\n  };\n  /**\n   * 删除子树\n   * @param {string} id 子树根节点id\n   */\n\n\n  TreeGraph.prototype.removeChild = function (id) {\n    var self = this;\n    var node = self.findById(id);\n\n    if (!node) {\n      return;\n    }\n\n    var parent = node.get('parent');\n\n    if (parent && !parent.destroyed) {\n      var parentNode = self.findDataById(parent.get('id'));\n      var siblings = parentNode && parentNode.children || [];\n      var model = node.getModel();\n      var index = TreeGraph.indexOfChild(siblings, model.id);\n      siblings.splice(index, 1);\n    }\n\n    self.changeData();\n  };\n  /**\n   * 根据id获取对应的源数据\n   * @param {string} id 元素id\n   * @param {TreeGraphData | undefined} parent 从哪个节点开始寻找，为空时从根节点开始查找\n   * @return {TreeGraphData} 对应源数据\n   */\n\n\n  TreeGraph.prototype.findDataById = function (id, parent) {\n    var self = this;\n\n    if (!parent) {\n      parent = self.get('data');\n    }\n\n    if (id === parent.id) {\n      return parent;\n    }\n\n    var result = null; // eslint-disable-next-line consistent-return\n\n    each(parent.children || [], function (child) {\n      if (child.id === id) {\n        result = child;\n        return false;\n      }\n\n      result = self.findDataById(id, child);\n\n      if (result) {\n        return false;\n      }\n    });\n    return result;\n  };\n  /**\n   * 布局动画接口，用于数据更新时做节点位置更新的动画\n   * @param {TreeGraphData} data 更新的数据\n   * @param {function} onFrame 定义节点位置更新时如何移动\n   */\n\n\n  TreeGraph.prototype.layoutAnimate = function (data, onFrame) {\n    var self = this;\n    var animateCfg = this.get('animateCfg');\n    self.emit('beforeanimate', {\n      data: data\n    }); // 如果边中没有指定锚点，但是本身有锚点控制，在动画过程中保持锚点不变\n\n    self.getEdges().forEach(function (edge) {\n      var model = edge.get('model');\n\n      if (!model.sourceAnchor) {\n        model.sourceAnchor = edge.get('sourceAnchorIndex');\n      }\n    });\n    this.get('canvas').animate(function (ratio) {\n      traverseTree(data, function (child) {\n        var node = self.findById(child.id); // 只有当存在node的时候才执行\n\n        if (node) {\n          var origin_2 = node.get('originAttrs');\n          var model = node.get('model');\n\n          if (!origin_2) {\n            origin_2 = {\n              x: model.x,\n              y: model.y\n            };\n            node.set('originAttrs', origin_2);\n          }\n\n          if (onFrame) {\n            var attrs = onFrame(node, ratio, origin_2, data);\n            node.set('model', Object.assign(model, attrs));\n          } else {\n            model.x = origin_2.x + (child.x - origin_2.x) * ratio;\n            model.y = origin_2.y + (child.y - origin_2.y) * ratio;\n          }\n        }\n\n        return true;\n      });\n      each(self.get('removeList'), function (node) {\n        var model = node.getModel();\n        var from = node.get('originAttrs');\n        var to = node.get('to');\n        model.x = from.x + (to.x - from.x) * ratio;\n        model.y = from.y + (to.y - from.y) * ratio;\n      });\n      self.refreshPositions();\n    }, {\n      duration: animateCfg.duration,\n      easing: animateCfg.ease,\n      callback: function callback() {\n        each(self.getNodes(), function (node) {\n          node.set('originAttrs', null);\n        });\n        each(self.get('removeList'), function (node) {\n          self.removeItem(node);\n        });\n        self.set('removeList', []);\n\n        if (animateCfg.callback) {\n          animateCfg.callback();\n        }\n\n        self.emit('afteranimate', {\n          data: data\n        });\n      },\n      delay: animateCfg.delay\n    });\n  };\n  /**\n   * 立即停止布局动画\n   */\n\n\n  TreeGraph.prototype.stopLayoutAnimate = function () {\n    this.get('canvas').stopAnimate();\n    this.emit('layoutanimateend', {\n      data: this.get('data')\n    });\n    this.layoutAnimating = false;\n  };\n  /**\n   * 是否在布局动画\n   * @return {boolean} 是否有布局动画\n   */\n\n\n  TreeGraph.prototype.isLayoutAnimating = function () {\n    return this.layoutAnimating;\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n\n\n  TreeGraph.prototype.render = function () {\n    var self = this;\n    var data = self.get('data');\n\n    if (!data || !isObject(data) || !Object.keys(data).length) {\n      throw new Error('data must be defined first');\n    }\n\n    self.clear();\n    self.emit('beforerender');\n    self.layout(this.get('fitView'));\n    self.emit('afterrender');\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n\n\n  TreeGraph.prototype.save = function () {\n    return this.get('data');\n  };\n\n  return TreeGraph;\n}(Graph);\n\nexport default TreeGraph;","map":null,"metadata":{},"sourceType":"module"}