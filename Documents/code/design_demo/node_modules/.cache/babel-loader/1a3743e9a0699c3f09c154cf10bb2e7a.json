{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useRef, useEffect } from 'react';\nimport { isObject, isString, isEqual } from '@antv/util';\nimport { getGraphSize, processMinimap, getCommonConfig, getArrowCfg, getMarkerPosition, setTag, getLevelData, deepClone } from '../../utils';\nexport default function useGraph(graphInstance, config, container) {\n  var graphHook = useRef();\n  var data = config.data,\n      width = config.width,\n      height = config.height,\n      layout = config.layout,\n      minimapCfg = config.minimapCfg,\n      behaviors = config.behaviors,\n      fitCenter = config.fitCenter,\n      nodeCfg = config.nodeCfg,\n      edgeCfg = config.edgeCfg,\n      markerCfg = config.markerCfg,\n      level = config.level;\n  var graphOptions = useRef(); // data 单独处理，会被 G6 修改\n\n  var graphData = useRef();\n  /** 隐藏孤立边 */\n\n  var setEdgesState = function (edges) {\n    edges.forEach(function (edge) {\n      var _a, _b;\n\n      var _c = edge.getModel(),\n          source = _c.source,\n          target = _c.target;\n\n      var sourceVisible = (_a = graphInstance === null || graphInstance === void 0 ? void 0 : graphInstance.findById(source)) === null || _a === void 0 ? void 0 : _a.get('visible');\n      var targetVisible = (_b = graphInstance === null || graphInstance === void 0 ? void 0 : graphInstance.findById(target)) === null || _b === void 0 ? void 0 : _b.get('visible');\n\n      if (sourceVisible === false || targetVisible === false) {\n        edge.changeVisibility(false);\n      }\n    });\n  };\n\n  var changeData = function () {\n    var _a;\n\n    if (!graphInstance) {\n      return;\n    }\n\n    var currentData = data;\n\n    if (level) {\n      currentData = setTag(data);\n    }\n\n    graphInstance.changeData(level ? getLevelData(currentData, level) : data);\n    (_a = graphInstance.get('eventData')) === null || _a === void 0 ? void 0 : _a.setData(currentData);\n    setEdgesState(graphInstance.getEdges());\n\n    if (fitCenter) {\n      graphInstance.fitCenter();\n    }\n  };\n\n  var updateLayout = function () {\n    graphInstance === null || graphInstance === void 0 ? void 0 : graphInstance.updateLayout(layout);\n\n    if (fitCenter) {\n      graphInstance === null || graphInstance === void 0 ? void 0 : graphInstance.fitCenter();\n    }\n  };\n\n  var updateNodes = function () {\n    if (!graphInstance) {\n      return;\n    }\n\n    var _a = nodeCfg !== null && nodeCfg !== void 0 ? nodeCfg : {},\n        nodeType = _a.type,\n        nodeAnchorPoints = _a.anchorPoints,\n        nodeStyle = _a.style,\n        nodeLabelCfg = _a.title;\n\n    graphInstance.getNodes().forEach(function (node) {\n      graphInstance.updateItem(node, {\n        nodeCfg: nodeCfg,\n        markerCfg: markerCfg,\n        type: nodeType,\n        style: nodeStyle,\n        anchorPoints: nodeAnchorPoints,\n        labelCfg: nodeLabelCfg\n      });\n    });\n  };\n\n  var updateEdges = function () {\n    if (!graphInstance) {\n      return;\n    }\n\n    var _a = edgeCfg !== null && edgeCfg !== void 0 ? edgeCfg : {},\n        edgeType = _a.type,\n        edgeStyle = _a.style,\n        startArrowCfg = _a.startArrow,\n        endArrowCfg = _a.endArrow,\n        labelCfg = _a.label;\n\n    graphInstance.getEdges().forEach(function (edge) {\n      // 资金流向图\n      if (edgeType === 'fund-line') {\n        graphInstance.updateItem(edge, {\n          edgeCfg: edgeCfg\n        });\n      } else {\n        var edgeCfgModel = edge.getModel();\n        var startArrow = getArrowCfg(startArrowCfg, edgeCfgModel);\n        var endArrow = getArrowCfg(endArrowCfg, edgeCfgModel);\n\n        var _a = labelCfg !== null && labelCfg !== void 0 ? labelCfg : {},\n            style = _a.style,\n            content = _a.content;\n\n        graphInstance.updateItem(edge, {\n          type: edgeType,\n          label: getCommonConfig(content, edgeCfgModel, graphInstance),\n          labelCfg: {\n            style: getCommonConfig(style, edgeCfgModel, graphInstance)\n          },\n          style: __assign({\n            stroke: '#ccc',\n            startArrow: startArrow,\n            endArrow: endArrow\n          }, typeof edgeStyle === 'function' ? edgeStyle(edgeCfgModel, graphInstance) : edgeStyle)\n        });\n      }\n    });\n  }; // 目前仅支持更新位置\n\n\n  var updateMarker = function () {\n    if (!graphInstance) {\n      return;\n    }\n\n    graphInstance.getNodes().forEach(function (node) {\n      var _a = (typeof markerCfg === 'function' ? markerCfg(node.getModel(), node.get('group')) : markerCfg).position,\n          position = _a === void 0 ? 'right' : _a;\n\n      var _b = node.getBBox(),\n          width = _b.width,\n          height = _b.height;\n\n      var markerShape = node.get('group').get('children').find(function (item) {\n        return item.get('name') === 'collapse-icon';\n      });\n\n      if (markerShape) {\n        markerShape === null || markerShape === void 0 ? void 0 : markerShape.attr(__assign({}, getMarkerPosition(position, [width, height])));\n      }\n    });\n  };\n\n  useEffect(function () {\n    if (graphInstance && !graphInstance.destroyed) {\n      if (isEqual(data, graphData.current)) {\n        return;\n      }\n\n      graphData.current = deepClone(data);\n      changeData();\n    }\n  }, [data]);\n  useEffect(function () {\n    var _a, _b, _c, _d, _e;\n\n    if (graphInstance && !graphInstance.destroyed) {\n      if (isEqual(config, graphOptions.current)) {\n        return;\n      }\n\n      if (!isEqual(layout, (_a = graphOptions.current) === null || _a === void 0 ? void 0 : _a.layout)) {\n        updateLayout();\n      }\n\n      if (!isEqual(minimapCfg, (_b = graphOptions.current) === null || _b === void 0 ? void 0 : _b.minimapCfg)) {\n        processMinimap(minimapCfg, graphInstance);\n      }\n\n      if (!isEqual(nodeCfg, (_c = graphOptions.current) === null || _c === void 0 ? void 0 : _c.nodeCfg)) {\n        updateNodes();\n      }\n\n      if (!isEqual(edgeCfg, (_d = graphOptions.current) === null || _d === void 0 ? void 0 : _d.edgeCfg)) {\n        updateEdges();\n      }\n\n      if (!isEqual(markerCfg, (_e = graphOptions.current) === null || _e === void 0 ? void 0 : _e.markerCfg)) {\n        updateMarker();\n      }\n\n      graphOptions.current = config;\n    }\n  }, [config]);\n  useEffect(function () {\n    if (graphInstance && !graphInstance.destroyed) {\n      var graphSize = getGraphSize(width, height, container);\n      graphInstance.changeSize(graphSize[0], graphSize[1]);\n    }\n  }, [container, width, height]);\n  useEffect(function () {\n    if (graphInstance && !graphInstance.destroyed) {\n      var defaultMode = graphInstance.get('modes').default;\n      var removingBehaviors_1 = [];\n      defaultMode.forEach(function (be) {\n        if (isObject(be)) {\n          removingBehaviors_1.push(be.type);\n        } else if (isString(be)) {\n          removingBehaviors_1.push(be);\n        }\n      });\n      graphInstance.removeBehaviors(removingBehaviors_1, 'default');\n      graphInstance.addBehaviors(behaviors, 'default');\n    }\n  }, [behaviors]);\n  useEffect(function () {\n    graphHook.current = graphInstance;\n    return function () {\n      if (graphInstance && !graphInstance.destroyed) {\n        graphInstance.destroy();\n        graphInstance = undefined;\n      }\n    };\n  }, []);\n  return {\n    graphHook: graphHook\n  };\n}","map":null,"metadata":{},"sourceType":"module"}