{"ast":null,"code":"import JQuery from 'jquery';\nimport { Dom } from '../util';\nimport { Basecoat } from '../common';\nimport { Util, Config } from '../global';\nexport class View extends Basecoat {\n  constructor() {\n    super();\n    this.cid = Private.uniqueId();\n    View.views[this.cid] = this;\n  }\n\n  get priority() {\n    return 2;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  confirmUpdate(flag, options) {\n    return 0;\n  }\n\n  $(elem) {\n    return View.$(elem);\n  }\n\n  empty() {\n    let elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;\n    this.$(elem).empty();\n    return this;\n  }\n\n  unmount() {\n    let elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;\n    this.$(elem).remove();\n    return this;\n  }\n\n  remove() {\n    let elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;\n\n    if (elem === this.container) {\n      this.removeEventListeners(document);\n      this.onRemove();\n      delete View.views[this.cid];\n    }\n\n    this.unmount(elem);\n    return this;\n  }\n\n  onRemove() {}\n\n  setClass(className) {\n    let elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    elem.classList.value = Array.isArray(className) ? className.join(' ') : className;\n  }\n\n  addClass(className) {\n    let elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    this.$(elem).addClass(Array.isArray(className) ? className.join(' ') : className);\n    return this;\n  }\n\n  removeClass(className) {\n    let elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    this.$(elem).removeClass(Array.isArray(className) ? className.join(' ') : className);\n    return this;\n  }\n\n  setStyle(style) {\n    let elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    this.$(elem).css(style);\n    return this;\n  }\n\n  setAttrs(attrs) {\n    let elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n\n    if (attrs != null && elem != null) {\n      if (elem instanceof SVGElement) {\n        Dom.attr(elem, attrs);\n      } else {\n        this.$(elem).attr(attrs);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Returns the value of the specified attribute of `node`.\n   *\n   * If the node does not set a value for attribute, start recursing up\n   * the DOM tree from node to lookup for attribute at the ancestors of\n   * node. If the recursion reaches CellView's root node and attribute\n   * is not found even there, return `null`.\n   */\n\n\n  findAttr(attrName) {\n    let elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    let current = elem;\n\n    while (current && current.nodeType === 1) {\n      const value = current.getAttribute(attrName);\n\n      if (value != null) {\n        return value;\n      }\n\n      if (current === this.container) {\n        return null;\n      }\n\n      current = current.parentNode;\n    }\n\n    return null;\n  }\n\n  find(selector) {\n    let rootElem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    let selectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.selectors;\n    return View.find(selector, rootElem, selectors).elems;\n  }\n\n  findOne(selector) {\n    let rootElem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    let selectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.selectors;\n    const nodes = this.find(selector, rootElem, selectors);\n    return nodes.length > 0 ? nodes[0] : null;\n  }\n\n  findByAttr(attrName) {\n    let elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    let node = elem;\n\n    while (node && node.getAttribute) {\n      const val = node.getAttribute(attrName);\n\n      if ((val != null || node === this.container) && val !== 'false') {\n        return node;\n      }\n\n      node = node.parentNode;\n    } // If the overall cell has set `magnet === false`, then returns\n    // `null` to announce there is no magnet found for this cell.\n    // This is especially useful to set on cells that have 'ports'.\n    // In this case, only the ports have set `magnet === true` and the\n    // overall element has `magnet === false`.\n\n\n    return null;\n  }\n\n  getSelector(elem, prevSelector) {\n    let selector;\n\n    if (elem === this.container) {\n      if (typeof prevSelector === 'string') {\n        selector = `> ${prevSelector}`;\n      }\n\n      return selector;\n    }\n\n    if (elem) {\n      const nth = Dom.index(elem) + 1;\n      selector = `${elem.tagName.toLowerCase()}:nth-child(${nth})`;\n\n      if (prevSelector) {\n        selector += ` > ${prevSelector}`;\n      }\n\n      selector = this.getSelector(elem.parentNode, selector);\n    }\n\n    return selector;\n  }\n\n  prefixClassName(className) {\n    return Util.prefix(className);\n  }\n\n  delegateEvents(events, append) {\n    if (events == null) {\n      return this;\n    }\n\n    if (!append) {\n      this.undelegateEvents();\n    }\n\n    const splitter = /^(\\S+)\\s*(.*)$/;\n    Object.keys(events).forEach(key => {\n      const match = key.match(splitter);\n\n      if (match == null) {\n        return;\n      }\n\n      const method = this.getEventHandler(events[key]);\n\n      if (typeof method === 'function') {\n        this.delegateEvent(match[1], match[2], method);\n      }\n    });\n    return this;\n  }\n\n  undelegateEvents() {\n    this.$(this.container).off(this.getEventNamespace());\n    return this;\n  }\n\n  delegateDocumentEvents(events, data) {\n    this.addEventListeners(document, events, data);\n    return this;\n  }\n\n  undelegateDocumentEvents() {\n    this.removeEventListeners(document);\n    return this;\n  }\n\n  delegateEvent(eventName, selector, listener) {\n    this.$(this.container).on(eventName + this.getEventNamespace(), selector, listener);\n    return this;\n  }\n\n  undelegateEvent(eventName, selector, listener) {\n    const name = eventName + this.getEventNamespace();\n\n    if (selector == null) {\n      this.$(this.container).off(name);\n    } else if (typeof selector === 'string') {\n      this.$(this.container).off(name, selector, listener);\n    } else {\n      this.$(this.container).off(name, selector);\n    }\n\n    return this;\n  }\n\n  addEventListeners(elem, events, data) {\n    if (events == null) {\n      return this;\n    }\n\n    const ns = this.getEventNamespace();\n    const $elem = this.$(elem);\n    Object.keys(events).forEach(eventName => {\n      const method = this.getEventHandler(events[eventName]);\n\n      if (typeof method === 'function') {\n        $elem.on(eventName + ns, data, method);\n      }\n    });\n    return this;\n  }\n\n  removeEventListeners(elem) {\n    if (elem != null) {\n      this.$(elem).off(this.getEventNamespace());\n    }\n\n    return this;\n  }\n\n  getEventNamespace() {\n    return `.${Config.prefixCls}-event-${this.cid}`;\n  } // eslint-disable-next-line\n\n\n  getEventHandler(handler) {\n    var _this = this;\n\n    // eslint-disable-next-line\n    let method;\n\n    if (typeof handler === 'string') {\n      const fn = this[handler];\n\n      if (typeof fn === 'function') {\n        method = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return fn.call(_this, ...args);\n        };\n      }\n    } else {\n      method = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return handler.call(_this, ...args);\n      };\n    }\n\n    return method;\n  }\n\n  getEventTarget(e) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Touchmove/Touchend event's target is not reflecting the element\n    // under the coordinates as mousemove does.\n    // It holds the element when a touchstart triggered.\n    const {\n      target,\n      type,\n      clientX = 0,\n      clientY = 0\n    } = e;\n\n    if (options.fromPoint || type === 'touchmove' || type === 'touchend') {\n      return document.elementFromPoint(clientX, clientY);\n    }\n\n    return target;\n  }\n\n  stopPropagation(e) {\n    this.setEventData(e, {\n      propagationStopped: true\n    });\n    return this;\n  }\n\n  isPropagationStopped(e) {\n    return this.getEventData(e).propagationStopped === true;\n  }\n\n  getEventData(e) {\n    return this.eventData(e);\n  }\n\n  setEventData(e, data) {\n    return this.eventData(e, data);\n  }\n\n  eventData(e, data) {\n    if (e == null) {\n      throw new TypeError('Event object required');\n    }\n\n    let currentData = e.data;\n    const key = `__${this.cid}__`; // get\n\n    if (data == null) {\n      if (currentData == null) {\n        return {};\n      }\n\n      return currentData[key] || {};\n    } // set\n\n\n    if (currentData == null) {\n      currentData = e.data = {};\n    }\n\n    if (currentData[key] == null) {\n      currentData[key] = Object.assign({}, data);\n    } else {\n      currentData[key] = Object.assign(Object.assign({}, currentData[key]), data);\n    }\n\n    return currentData[key];\n  }\n\n  normalizeEvent(evt) {\n    return View.normalizeEvent(evt);\n  }\n\n}\n\n(function (View) {\n  function $(elem) {\n    return JQuery(elem);\n  }\n\n  View.$ = $;\n\n  function createElement(tagName, isSvgElement) {\n    return isSvgElement ? Dom.createSvgElement(tagName || 'g') : Dom.createElementNS(tagName || 'div');\n  }\n\n  View.createElement = createElement;\n\n  function find(selector, rootElem, selectors) {\n    if (!selector || selector === '.') {\n      return {\n        elems: [rootElem]\n      };\n    }\n\n    if (selectors) {\n      const nodes = selectors[selector];\n\n      if (nodes) {\n        return {\n          elems: Array.isArray(nodes) ? nodes : [nodes]\n        };\n      }\n    }\n\n    if (Config.useCSSSelector) {\n      return {\n        isCSSSelector: true,\n        // elems: Array.prototype.slice.call(rootElem.querySelectorAll(selector)),\n        elems: $(rootElem).find(selector).toArray()\n      };\n    }\n\n    return {\n      elems: []\n    };\n  }\n\n  View.find = find;\n\n  function normalizeEvent(evt) {\n    let normalizedEvent = evt;\n    const originalEvent = evt.originalEvent;\n    const touchEvt = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n\n    if (touchEvt) {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const key in evt) {\n        // copy all the properties from the input event that are not\n        // defined on the touch event (functions included).\n        if (touchEvt[key] === undefined) {\n          touchEvt[key] = evt[key];\n        }\n      }\n\n      normalizedEvent = touchEvt;\n    } // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n\n\n    const target = normalizedEvent.target;\n\n    if (target) {\n      const useElement = target.correspondingUseElement;\n\n      if (useElement) {\n        normalizedEvent.target = useElement;\n      }\n    }\n\n    return normalizedEvent;\n  }\n\n  View.normalizeEvent = normalizeEvent;\n})(View || (View = {}));\n\n(function (View) {\n  View.views = {};\n\n  function getView(cid) {\n    return View.views[cid] || null;\n  }\n\n  View.getView = getView;\n})(View || (View = {}));\n\nvar Private;\n\n(function (Private) {\n  let counter = 0;\n\n  function uniqueId() {\n    const id = `v${counter}`;\n    counter += 1;\n    return id;\n  }\n\n  Private.uniqueId = uniqueId;\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}