{"ast":null,"code":"import { isNumber } from '../../../util';\nimport graphlib from './graphlib';\nconst Graph = graphlib.Graph;\n/*\n * Adds a dummy node to the graph and return v.\n */\n\nconst addDummyNode = (g, type, attrs, name) => {\n  let v;\n\n  do {\n    v = `${name}${Math.random()}`;\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n};\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\n\n\nconst simplify = g => {\n  const simplified = new Graph().setGraph(g.graph());\n  g.nodes().forEach(v => {\n    simplified.setNode(v, g.node(v));\n  });\n  g.edges().forEach(e => {\n    const simpleLabel = simplified.edge(e.v, e.w) || {\n      weight: 0,\n      minlen: 1\n    };\n    const label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n};\n\nconst asNonCompoundGraph = g => {\n  const simplified = new Graph({\n    multigraph: g.isMultigraph()\n  }).setGraph(g.graph());\n  g.nodes().forEach(v => {\n    var _a;\n\n    if (!((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length)) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  g.edges().forEach(e => simplified.setEdge(e, g.edge(e)));\n  return simplified;\n};\n\nconst zipObject = (keys, values) => {\n  const result = {};\n  keys === null || keys === void 0 ? void 0 : keys.forEach((key, i) => {\n    result[key] = values[i];\n  });\n  return result;\n};\n\nconst successorWeights = g => {\n  const weightMap = g.nodes().map(v => {\n    var _a;\n\n    const sucs = {};\n    (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return zipObject(g.nodes(), weightMap);\n};\n\nconst predecessorWeights = g => {\n  const weightMap = g.nodes().map(v => {\n    var _a;\n\n    const preds = {};\n    (_a = g.inEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return zipObject(g.nodes(), weightMap);\n};\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\n\n\nconst intersectRect = (rect, point) => {\n  const x = rect.x;\n  const y = rect.y; // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n\n  const dx = point.x - x;\n  const dy = point.y - y;\n  let w = rect.width / 2;\n  let h = rect.height / 2;\n\n  if (!dx && !dy) {\n    // throw new Error(\"Not possible to find intersection inside of the rectangle\");\n    // completely overlapped\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  let sx;\n  let sy;\n\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return {\n    x: x + sx,\n    y: y + sy\n  };\n};\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * const will produce a matrix with the ids of each node.\n */\n\n\nconst buildLayerMatrix = g => {\n  const layering = [];\n  const layeringNodes = [];\n  const rankMax = maxRank(g) + 1;\n\n  for (let i = 0; i < rankMax; i++) {\n    layering.push([]);\n    layeringNodes.push([]);\n  } // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n\n\n  g.nodes().forEach(v => {\n    const node = g.node(v);\n    const rank = node.rank;\n\n    if (rank !== undefined && layering[rank]) {\n      layeringNodes[rank].push(v);\n    }\n  });\n  layeringNodes === null || layeringNodes === void 0 ? void 0 : layeringNodes.forEach((layer, rank) => {\n    layer === null || layer === void 0 ? void 0 : layer.sort((va, vb) => {\n      var _a, _b;\n\n      return ((_a = g.node(va)) === null || _a === void 0 ? void 0 : _a.order) - ((_b = g.node(vb)) === null || _b === void 0 ? void 0 : _b.order);\n    });\n    layer.forEach(v => {\n      layering[rank].push(v);\n    });\n  });\n  return layering;\n};\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\n\n\nconst normalizeRanks = g => {\n  const nodeRanks = g.nodes().filter(v => g.node(v).rank !== undefined).map(v => g.node(v).rank);\n  const min = Math.min(...nodeRanks);\n  g.nodes().forEach(v => {\n    const node = g.node(v);\n\n    if (node.hasOwnProperty(\"rank\")) {\n      if (!node.rank) node.rank = 0;\n      node.rank -= min;\n    }\n  });\n};\n\nconst removeEmptyRanks = g => {\n  // Ranks may not start at 0, so we need to offset them\n  const nodeRanks = g.nodes().filter(v => g.node(v).rank !== undefined).map(v => g.node(v).rank);\n  const offset = Math.min(...nodeRanks);\n  const layers = [];\n  g.nodes().forEach(v => {\n    var _a;\n\n    const rank = (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) || 0) - offset;\n\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n\n    layers[rank].push(v);\n  });\n  let delta = 0;\n  const nodeRankFactor = g.graph().nodeRankFactor || 0;\n\n  for (let i = 0; i < layers.length; i++) {\n    const vs = layers[i];\n\n    if (vs === undefined && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      vs === null || vs === void 0 ? void 0 : vs.forEach(v => {\n        if (!g.node(v).rank) g.node(v).rank = 0;\n        g.node(v).rank += delta;\n      });\n    }\n  }\n};\n\nconst addBorderNode = (g, prefix, rank, order) => {\n  const node = {\n    width: 0,\n    height: 0\n  };\n\n  if (isNumber(rank) && isNumber(order)) {\n    node.rank = rank;\n    node.order = order;\n  }\n\n  return addDummyNode(g, \"border\", node, prefix);\n};\n\nconst maxRank = g => {\n  const nodeRanks = g.nodes().map(v => {\n    const rank = g.node(v).rank;\n\n    if (rank !== undefined) {\n      return rank;\n    }\n\n    return -Infinity;\n  });\n  return Math.max(...nodeRanks);\n};\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * const returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\n\n\nconst partition = (collection, fn) => {\n  const result = {\n    lhs: [],\n    rhs: []\n  };\n  collection === null || collection === void 0 ? void 0 : collection.forEach(value => {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n};\n/*\n * Returns a new const that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\n\n\nconst time = (name, fn) => {\n  const start = Date.now();\n\n  try {\n    return fn();\n  } finally {\n    console.log(`${name} time: ${Date.now() - start}ms`);\n  }\n};\n\nconst notime = (name, fn) => {\n  return fn();\n};\n\nconst minBy = (array, func) => {\n  let min = Infinity;\n  let minObject;\n  array === null || array === void 0 ? void 0 : array.forEach(item => {\n    const value = func(item);\n\n    if (min > value) {\n      min = value;\n      minObject = item;\n    }\n  });\n  return minObject;\n};\n\nexport { addDummyNode, simplify, asNonCompoundGraph, successorWeights, predecessorWeights, intersectRect, buildLayerMatrix, normalizeRanks, removeEmptyRanks, addBorderNode, maxRank, partition, time, notime, zipObject, minBy };\nexport default {\n  addDummyNode,\n  simplify,\n  asNonCompoundGraph,\n  successorWeights,\n  predecessorWeights,\n  intersectRect,\n  buildLayerMatrix,\n  normalizeRanks,\n  removeEmptyRanks,\n  addBorderNode,\n  maxRank,\n  partition,\n  time,\n  notime,\n  zipObject,\n  minBy\n};","map":null,"metadata":{},"sourceType":"module"}