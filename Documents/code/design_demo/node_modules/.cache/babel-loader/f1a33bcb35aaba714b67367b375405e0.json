{"ast":null,"code":"import { __awaiter, __decorate, __metadata } from \"tslib\";\nimport classnames from 'classnames';\nimport { IHookContribution, ManaSyringe } from '@antv/xflow-core';\nimport { IGraphProvider } from '@antv/xflow-core';\nimport { ACTIVE_NODE_PORT, NsPortEvent } from '../interface';\nimport { DisposableCollection, IModelContribution, Disposable } from '@antv/xflow-core';\n/**\n * 内置的hook contribution\n * 处理 config上的runtime的注册项\n */\n\nlet NodePortTooltipContribution = class NodePortTooltipContribution {\n  constructor() {\n    this.toDispose = new DisposableCollection();\n    /** 获取画布实例 */\n\n    this.getGraphInstance = () => __awaiter(this, void 0, void 0, function* () {\n      const graphInstance = yield this.graphProvider.getGraphInstance();\n      const graphConfig = yield this.graphProvider.getGraphOptions();\n      return {\n        graph: graphInstance,\n        config: graphConfig\n      };\n    });\n    /** 获取GraphOptions */\n\n\n    this.getPortRenderConfig = () => {\n      const dagOptions = {\n        onPortRendered(portRenderedArgs) {\n          var _a, _b;\n          /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n\n          const graph = this;\n          const {\n            port,\n            node\n          } = portRenderedArgs;\n          const {\n            contentSelectors\n          } = portRenderedArgs;\n          const portContainer = contentSelectors && contentSelectors['xflow-port-group'];\n\n          if (portContainer instanceof Element) {\n            portContainer.setAttribute('class', classnames('xflow-port-group', {\n              connected: port.connected && port.group !== 'out',\n              groupPort: ((_a = node) === null || _a === void 0 ? void 0 : _a.isGroup) && ((_b = node) === null || _b === void 0 ? void 0 : _b.isGroup())\n            }));\n            portContainer.addEventListener('mouseenter', e => {\n              const eventArgs = {\n                e: e,\n                portId: port.id,\n                nodeId: node.id,\n                portData: port,\n                nodeData: node.getData(),\n                tooltip: port.tooltip,\n                placement: port.group\n              };\n              graph.trigger(NsPortEvent.MOUSE_ENTER, eventArgs);\n            });\n            portContainer.addEventListener('mouseleave', e => {\n              const eventArgs = {\n                e: e,\n                portId: port.id,\n                nodeId: node.id,\n                portData: port,\n                nodeData: node.getData(),\n                tooltip: port.tooltip,\n                placement: port.group\n              };\n              graph.trigger(NsPortEvent.MOUSE_LEAVE, eventArgs);\n            });\n          }\n        }\n\n      };\n      return dagOptions;\n    };\n\n    this.registerHookHub = () => __awaiter(this, void 0, void 0, function* () {\n      return Disposable.create(() => {});\n    });\n\n    this.registerHook = hooks => __awaiter(this, void 0, void 0, function* () {\n      const toDispose = new DisposableCollection();\n      const disposables = [hooks.graphOptions.registerHook({\n        name: 'add onPortRendered options ',\n        handler: args => __awaiter(this, void 0, void 0, function* () {\n          Object.assign(args, this.getPortRenderConfig());\n        })\n      })];\n      toDispose.pushAll(disposables);\n      return Disposable.create(() => {});\n    });\n  }\n\n  registerModel(registry) {\n    registry.registerModel({\n      id: ACTIVE_NODE_PORT.id,\n      watchChange: self => __awaiter(this, void 0, void 0, function* () {\n        const {\n          graph,\n          config\n        } = yield this.getGraphInstance();\n\n        const calcPosition = e => {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = e.target.getBoundingClientRect();\n          const clientRect = config.rootContainer.getBoundingClientRect();\n          const position = {\n            x: x - ((clientRect === null || clientRect === void 0 ? void 0 : clientRect.x) || 0) + width / 2,\n            y: y - ((clientRect === null || clientRect === void 0 ? void 0 : clientRect.y) || 0) + height / 2\n          };\n          return position;\n        };\n\n        const onMouseEnter = args => {\n          self.setValue(Object.assign(Object.assign({}, args), {\n            position: calcPosition(args.e)\n          }));\n        };\n\n        const onMouseLeave = () => {\n          self.setValue(null);\n        };\n        /** 绑定事件 */\n\n\n        graph.on(NsPortEvent.MOUSE_ENTER, onMouseEnter);\n        graph.on(NsPortEvent.MOUSE_LEAVE, onMouseLeave);\n        graph.on('cell:mouseleave', onMouseLeave);\n        return Disposable.create(() => {\n          /** 解除绑定 */\n          graph.off(NsPortEvent.MOUSE_ENTER, onMouseEnter);\n          graph.off(NsPortEvent.MOUSE_LEAVE, onMouseLeave);\n        });\n      })\n    });\n  }\n\n};\n\n__decorate([ManaSyringe.inject(IGraphProvider), __metadata(\"design:type\", Object)], NodePortTooltipContribution.prototype, \"graphProvider\", void 0);\n\nNodePortTooltipContribution = __decorate([ManaSyringe.singleton({\n  contrib: [IHookContribution, IModelContribution]\n})], NodePortTooltipContribution);\nexport { NodePortTooltipContribution };","map":null,"metadata":{},"sourceType":"module"}