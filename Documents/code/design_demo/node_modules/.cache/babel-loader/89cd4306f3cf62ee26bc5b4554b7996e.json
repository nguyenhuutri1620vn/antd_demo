{"ast":null,"code":"const SPEED_DIVISOR = 800;\nexport default class RadialNonoverlapForce {\n  constructor(params) {\n    this.disp = [];\n    this.positions = params.positions;\n    this.adjMatrix = params.adjMatrix;\n    this.focusID = params.focusID;\n    this.radii = params.radii;\n    this.iterations = params.iterations || 10;\n    this.height = params.height || 10;\n    this.width = params.width || 10;\n    this.speed = params.speed || 100;\n    this.gravity = params.gravity || 10;\n    this.nodeSizeFunc = params.nodeSizeFunc;\n    this.k = params.k || 5;\n    this.strictRadial = params.strictRadial;\n    this.nodes = params.nodes;\n  }\n\n  layout() {\n    const self = this;\n    const positions = self.positions;\n    const disp = [];\n    const iterations = self.iterations;\n    const maxDisplace = self.width / 10;\n    self.maxDisplace = maxDisplace;\n    self.disp = disp;\n\n    for (let i = 0; i < iterations; i++) {\n      positions.forEach((_, k) => {\n        disp[k] = {\n          x: 0,\n          y: 0\n        };\n      }); // 给重叠的节点增加斥力\n\n      self.getRepulsion();\n      self.updatePositions();\n    }\n\n    return positions;\n  }\n\n  getRepulsion() {\n    const self = this;\n    const positions = self.positions;\n    const nodes = self.nodes;\n    const disp = self.disp;\n    const k = self.k;\n    const radii = self.radii || [];\n    positions.forEach((v, i) => {\n      disp[i] = {\n        x: 0,\n        y: 0\n      };\n      positions.forEach((u, j) => {\n        if (i === j) {\n          return;\n        } // v and u are not on the same circle, return\n\n\n        if (radii[i] !== radii[j]) {\n          return;\n        }\n\n        let vecx = v[0] - u[0];\n        let vecy = v[1] - u[1];\n        let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);\n\n        if (vecLength === 0) {\n          vecLength = 1;\n          const sign = i > j ? 1 : -1;\n          vecx = 0.01 * sign;\n          vecy = 0.01 * sign;\n        } // these two nodes overlap\n\n\n        if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {\n          const common = k * k / vecLength;\n          disp[i].x += vecx / vecLength * common;\n          disp[i].y += vecy / vecLength * common;\n        }\n      });\n    });\n  }\n\n  updatePositions() {\n    const self = this;\n    const positions = self.positions;\n    const disp = self.disp;\n    const speed = self.speed;\n    const strictRadial = self.strictRadial;\n    const f = self.focusID;\n    const maxDisplace = self.maxDisplace || self.width / 10;\n\n    if (strictRadial) {\n      disp.forEach((di, i) => {\n        const vx = positions[i][0] - positions[f][0];\n        const vy = positions[i][1] - positions[f][1];\n        const vLength = Math.sqrt(vx * vx + vy * vy);\n        let vpx = vy / vLength;\n        let vpy = -vx / vLength;\n        const diLength = Math.sqrt(di.x * di.x + di.y * di.y);\n        let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);\n\n        if (alpha > Math.PI / 2) {\n          alpha -= Math.PI / 2;\n          vpx *= -1;\n          vpy *= -1;\n        }\n\n        const tdispLength = Math.cos(alpha) * diLength;\n        di.x = vpx * tdispLength;\n        di.y = vpy * tdispLength;\n      });\n    } // move\n\n\n    const radii = self.radii;\n    positions.forEach((n, i) => {\n      if (i === f) {\n        return;\n      }\n\n      const distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);\n\n      if (distLength > 0 && i !== f) {\n        const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n        n[0] += disp[i].x / distLength * limitedDist;\n        n[1] += disp[i].y / distLength * limitedDist;\n\n        if (strictRadial) {\n          let vx = n[0] - positions[f][0];\n          let vy = n[1] - positions[f][1];\n          const nfDis = Math.sqrt(vx * vx + vy * vy);\n          vx = vx / nfDis * radii[i];\n          vy = vy / nfDis * radii[i];\n          n[0] = positions[f][0] + vx;\n          n[1] = positions[f][1] + vy;\n        }\n      }\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}