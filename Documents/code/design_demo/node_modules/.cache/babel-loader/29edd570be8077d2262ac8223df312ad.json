{"ast":null,"code":"import { isArray, isString } from '@antv/util';\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\n\nexport function isBetween(value, start, end) {\n  var min = Math.min(start, end);\n  var max = Math.max(start, end);\n  return value >= min && value <= max;\n}\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\n\nexport function padEnd(source, targetLength, padValue) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    var sourceLength = source.length;\n\n    if (sourceLength < targetLength) {\n      var diff = targetLength - sourceLength;\n\n      for (var i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\n\nexport function omit(obj, keys) {\n  if (typeof obj === 'object') {\n    keys.forEach(function (key) {\n      delete obj[key];\n    });\n  }\n\n  return obj;\n}\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\n\nexport function uniq(sourceArray, targetArray, map) {\n  if (targetArray === void 0) {\n    targetArray = [];\n  }\n\n  if (map === void 0) {\n    map = new Map();\n  }\n\n  for (var _i = 0, sourceArray_1 = sourceArray; _i < sourceArray_1.length; _i++) {\n    var source = sourceArray_1[_i];\n\n    if (!map.has(source)) {\n      targetArray.push(source);\n      map.set(source, true);\n    }\n  }\n\n  return targetArray;\n}","map":null,"metadata":{},"sourceType":"module"}