{"ast":null,"code":"export var Scheduler;\n\n(function (Scheduler) {\n  const queue = [];\n  const threshold = 1000 / 60;\n  const unit = [];\n  let deadline = 0;\n\n  const getTime = () => performance.now();\n\n  const peek = queue => queue[0];\n\n  const schedule = cb => unit.push(cb) === 1 && postMessage();\n\n  const postMessage = (() => {\n    const cb = () => unit.splice(0, unit.length).forEach(c => c());\n\n    if (typeof MessageChannel !== 'undefined') {\n      const {\n        port1,\n        port2\n      } = new MessageChannel();\n      port1.onmessage = cb;\n      return () => port2.postMessage(null);\n    }\n\n    return () => setTimeout(cb);\n  })();\n\n  const flushTask = () => {\n    deadline = getTime() + threshold;\n    let job = peek(queue);\n\n    while (job && !Scheduler.shouldYield()) {\n      const {\n        callback,\n        data\n      } = job;\n      job.callback = null;\n      const next = callback && callback(data);\n\n      if (next) {\n        job.callback = next;\n      } else {\n        queue.shift();\n      }\n\n      job = peek(queue);\n    }\n\n    job && schedule(flushTask);\n  };\n\n  Scheduler.scheduleTask = (callback, data) => {\n    const task = {\n      callback,\n      data\n    };\n    queue.push(task);\n    schedule(flushTask);\n  };\n\n  Scheduler.shouldYield = () => {\n    var _a, _b;\n\n    return ((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline;\n  };\n})(Scheduler || (Scheduler = {}));","map":null,"metadata":{},"sourceType":"module"}