{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar _dec, _class, _temp;\n/**\n * implements renderService with WebGPU API\n * @see https://webgpu.io/\n * @see https://github.com/BabylonJS/Babylon.js/blob/WebGPU/src/Engines/webgpuEngine.ts\n */\n\n\nimport { isSafari } from '@antv/g-webgpu-core'; // import { Glslang } from '@webgpu/glslang/dist/web-devel/glslang.onefile';\n\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { injectable } from 'inversify';\nimport glslang from './glslang';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUComputeModel from './WebGPUComputeModel';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUModel from './WebGPUModel';\nimport WebGPUTexture2D from './WebGPUTexture2D';\nexport\n/**\n * regl renderer\n */\nvar WebGPUEngine = (_dec = injectable(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function WebGPUEngine() {\n    var _this = this;\n\n    _classCallCheck(this, WebGPUEngine);\n\n    this.supportWebGPU = true;\n    this.useWGSL = false;\n    this.options = void 0;\n    this.canvas = void 0;\n    this.context = void 0;\n    this.glslang = void 0;\n    this.adapter = void 0;\n    this.device = void 0;\n    this.swapChain = void 0;\n    this.mainPassSampleCount = void 0;\n    this.mainTexture = void 0;\n    this.depthTexture = void 0;\n    this.mainColorAttachments = void 0;\n    this.mainTextureExtends = void 0;\n    this.mainDepthAttachment = void 0;\n    this.uploadEncoder = void 0;\n    this.renderEncoder = void 0;\n    this.computeEncoder = void 0;\n    this.renderTargetEncoder = void 0;\n    this.commandBuffers = new Array(4).fill(undefined);\n    this.currentRenderPass = null;\n    this.mainRenderPass = null;\n    this.currentRenderTargetViewDescriptor = void 0;\n    this.currentComputePass = null;\n    this.bundleEncoder = void 0;\n    this.tempBuffers = [];\n    this.currentRenderTarget = null;\n    this.uploadEncoderDescriptor = {\n      label: 'upload'\n    };\n    this.renderEncoderDescriptor = {\n      label: 'render'\n    };\n    this.renderTargetEncoderDescriptor = {\n      label: 'renderTarget'\n    };\n    this.computeEncoderDescriptor = {\n      label: 'compute'\n    };\n    this.pipelines = {};\n    this.computePipelines = {};\n    this.defaultSampleCount = 4;\n    this.clearDepthValue = 1;\n    this.clearStencilValue = 0;\n    this.transientViewport = {\n      x: Infinity,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    this.cachedViewport = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n\n    this.clear = function (options) {\n      var framebuffer = options.framebuffer,\n          color = options.color,\n          depth = options.depth,\n          stencil = options.stencil;\n\n      if (_this.options.supportCompute) {\n        _this.startComputePass();\n      } // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n\n\n      if (_this.currentRenderTarget) {\n        if (_this.currentRenderPass) {\n          _this.endRenderTargetRenderPass();\n        }\n\n        _this.startRenderTargetRenderPass(_this.currentRenderTarget, color ? color : null, !!depth, !!stencil);\n      } else {\n        // if (this.useReverseDepthBuffer) {\n        //     this._depthCullingState.depthFunc = Constants.GREATER;\n        // }\n        _this.mainColorAttachments[0].loadValue = color ? color : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.depthLoadValue = depth ? depth : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.stencilLoadValue = stencil ? _this.clearStencilValue : WebGPUConstants.LoadOp.Load;\n\n        if (_this.mainRenderPass) {\n          _this.endMainRenderPass();\n        }\n\n        _this.startMainRenderPass();\n      }\n    };\n\n    this.createModel = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                model = new WebGPUModel(_this, options);\n                _context.next = 3;\n                return model.init();\n\n              case 3:\n                return _context.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.createAttribute = function (options) {\n      return new WebGPUAttribute(_this, options);\n    };\n\n    this.createBuffer = function (options) {\n      return new WebGPUBuffer(_this, options);\n    };\n\n    this.createElements = function (options) {\n      return new WebGPUElements(_this, options);\n    };\n\n    this.createTexture2D = function (options) {\n      return new WebGPUTexture2D(_this, options);\n    };\n\n    this.createFramebuffer = function (options) {\n      return new WebGPUFramebuffer(_this, options);\n    };\n\n    this.useFramebuffer = function (framebuffer, drawCommands) {\n      // bind\n      if (_this.currentRenderTarget) {\n        _this.unbindFramebuffer(_this.currentRenderTarget);\n      }\n\n      _this.currentRenderTarget = framebuffer; // TODO: use mipmap options in framebuffer\n\n      _this.currentRenderTargetViewDescriptor = {\n        dimension: WebGPUConstants.TextureViewDimension.E2d,\n        // mipLevelCount: bindWithMipMaps ? WebGPUTextureHelper.computeNumMipmapLevels(texture.width, texture.height) - lodLevel : 1,\n        // baseArrayLayer: faceIndex,\n        // baseMipLevel: lodLevel,\n        arrayLayerCount: 1,\n        aspect: WebGPUConstants.TextureAspect.All\n      };\n      _this.currentRenderPass = null;\n      drawCommands();\n    };\n\n    this.createComputeModel = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context) {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                model = new WebGPUComputeModel(_this, context);\n                _context2.next = 3;\n                return model.init();\n\n              case 3:\n                return _context2.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.getCanvas = function () {\n      return _this.canvas;\n    };\n\n    this.getGLContext = function () {\n      throw new Error('Method not implemented.');\n    };\n\n    this.viewport = function (_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          width = _ref3.width,\n          height = _ref3.height;\n\n      if (!_this.currentRenderPass) {\n        // call viewport() before current render pass created\n        _this.transientViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n      } else if (_this.transientViewport.x !== Infinity) {\n        var renderPass = _this.getCurrentRenderPass(); // @see https://gpuweb.github.io/gpuweb/#dom-gpurenderpassencoder-setviewport\n\n\n        renderPass.setViewport(_this.transientViewport.x, _this.transientViewport.y, _this.transientViewport.width, _this.transientViewport.height, 0, 1);\n      } else if (x !== _this.cachedViewport.x || y !== _this.cachedViewport.y || width !== _this.cachedViewport.width || height !== _this.cachedViewport.height) {\n        _this.cachedViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n\n        var _renderPass = _this.getCurrentRenderPass();\n\n        _renderPass.setViewport(x, y, width, height, 0, 1);\n      }\n    };\n\n    this.readPixels = function (options) {\n      throw new Error('Method not implemented.');\n    };\n  }\n\n  _createClass(WebGPUEngine, [{\n    key: \"isFloatSupported\",\n    value: function isFloatSupported() {\n      return true;\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(config) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.canvas = config.canvas;\n                this.options = config;\n                this.useWGSL = !!config.useWGSL;\n                this.mainPassSampleCount = config.antialiasing ? this.defaultSampleCount : 1;\n                _context3.next = 6;\n                return this.initGlslang();\n\n              case 6:\n                this.initContextAndSwapChain();\n                this.initMainAttachments();\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function init(_x3) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"setScissor\",\n    value: function setScissor(scissor) {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.mainTexture) {\n        this.mainTexture.destroy();\n      }\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.tempBuffers.forEach(function (buffer) {\n        return buffer.destroy();\n      });\n      this.tempBuffers = [];\n    }\n  }, {\n    key: \"beginFrame\",\n    value: function beginFrame() {\n      this.uploadEncoder = this.device.createCommandEncoder(this.uploadEncoderDescriptor);\n      this.renderEncoder = this.device.createCommandEncoder(this.renderEncoderDescriptor);\n      this.renderTargetEncoder = this.device.createCommandEncoder(this.renderTargetEncoderDescriptor);\n\n      if (this.options.supportCompute) {\n        this.computeEncoder = this.device.createCommandEncoder(this.computeEncoderDescriptor);\n      }\n    }\n  }, {\n    key: \"endFrame\",\n    value: function endFrame() {\n      if (this.options.supportCompute) {\n        this.endComputePass();\n      }\n\n      this.endMainRenderPass();\n      this.commandBuffers[0] = this.uploadEncoder.finish();\n      this.commandBuffers[1] = this.renderEncoder.finish();\n\n      if (this.options.supportCompute) {\n        this.commandBuffers[2] = this.computeEncoder.finish();\n      }\n\n      this.commandBuffers[3] = this.renderTargetEncoder.finish();\n\n      if (isSafari) {\n        this.device // @ts-ignore\n        .getQueue().submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      } else {\n        this.device.defaultQueue.submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      }\n    }\n  }, {\n    key: \"getCurrentRenderPass\",\n    value: function getCurrentRenderPass() {\n      if (this.currentRenderTarget && !this.currentRenderPass) {\n        this.startRenderTargetRenderPass(this.currentRenderTarget, null, false, false);\n      } else if (!this.currentRenderPass) {\n        this.startMainRenderPass();\n      }\n\n      return this.currentRenderPass;\n    }\n  }, {\n    key: \"initGlslang\",\n    value: function () {\n      var _initGlslang = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _navigator, _navigator$gpu;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return glslang();\n\n              case 2:\n                this.glslang = _context4.sent;\n                _context4.next = 5;\n                return (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$gpu = _navigator.gpu) === null || _navigator$gpu === void 0 ? void 0 : _navigator$gpu.requestAdapter();\n\n              case 5:\n                this.adapter = _context4.sent;\n                _context4.next = 8;\n                return this.adapter.requestDevice();\n\n              case 8:\n                this.device = _context4.sent;\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function initGlslang() {\n        return _initGlslang.apply(this, arguments);\n      }\n\n      return initGlslang;\n    }()\n  }, {\n    key: \"initContextAndSwapChain\",\n    value: function initContextAndSwapChain() {\n      this.context = this.canvas.getContext(isSafari ? 'gpu' : 'gpupresent');\n      this.swapChain = this.context.configureSwapChain({\n        device: this.device,\n        format: this.options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment | WebGPUConstants.TextureUsage.CopySrc\n      });\n    }\n  }, {\n    key: \"initMainAttachments\",\n    value: function initMainAttachments() {\n      this.mainTextureExtends = {\n        width: this.canvas.width,\n        height: this.canvas.height,\n        depth: 1\n      };\n\n      if (this.options.antialiasing) {\n        var mainTextureDescriptor = {\n          size: this.mainTextureExtends,\n          // TODO: arrayLayerCount is deprecated: use size.depth\n          // arrayLayerCount: 1,\n          mipLevelCount: 1,\n          sampleCount: this.mainPassSampleCount,\n          dimension: WebGPUConstants.TextureDimension.E2d,\n          format: WebGPUConstants.TextureFormat.BGRA8Unorm,\n          usage: WebGPUConstants.TextureUsage.OutputAttachment\n        };\n\n        if (this.mainTexture) {\n          this.mainTexture.destroy();\n        }\n\n        this.mainTexture = this.device.createTexture(mainTextureDescriptor);\n        this.mainColorAttachments = [{\n          attachment: isSafari ? // @ts-ignore\n          this.mainTexture.createDefaultView() : this.mainTexture.createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      } else {\n        this.mainColorAttachments = [{\n          attachment: isSafari ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      }\n\n      var depthTextureDescriptor = {\n        size: this.mainTextureExtends,\n        // arrayLayerCount: 1,\n        mipLevelCount: 1,\n        sampleCount: this.mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: isSafari ? 'depth32float-stencil8' : WebGPUConstants.TextureFormat.Depth24PlusStencil8,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment\n      };\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.depthTexture = this.device.createTexture( // @ts-ignore\n      depthTextureDescriptor);\n      this.mainDepthAttachment = {\n        attachment: isSafari ? // @ts-ignore\n        this.depthTexture.createDefaultView() : this.depthTexture.createView(),\n        depthLoadValue: this.clearDepthValue,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilLoadValue: this.clearStencilValue,\n        stencilStoreOp: WebGPUConstants.StoreOp.Store\n      };\n    }\n  }, {\n    key: \"startComputePass\",\n    value: function startComputePass() {\n      if (this.currentComputePass) {\n        this.endComputePass();\n      }\n\n      this.currentComputePass = this.computeEncoder.beginComputePass();\n    }\n  }, {\n    key: \"startMainRenderPass\",\n    value: function startMainRenderPass() {\n      if (this.currentRenderPass && !this.currentRenderTarget) {\n        this.endMainRenderPass();\n      } // Resolve in case of MSAA\n\n\n      if (this.options.antialiasing) {\n        this.mainColorAttachments[0].resolveTarget = isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      } else {\n        this.mainColorAttachments[0].attachment = isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      }\n\n      this.currentRenderPass = this.renderEncoder.beginRenderPass({\n        colorAttachments: this.mainColorAttachments,\n        depthStencilAttachment: this.mainDepthAttachment // TODO: use framebuffer's depth & stencil\n\n      });\n      this.mainRenderPass = this.currentRenderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      }\n    }\n  }, {\n    key: \"startRenderTargetRenderPass\",\n    value: function startRenderTargetRenderPass(renderTarget, clearColor, clearDepth) {\n      var _renderTarget$get$col, _renderTarget$get$dep;\n\n      var clearStencil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var gpuTexture = (_renderTarget$get$col = renderTarget.get().color) === null || _renderTarget$get$col === void 0 ? void 0 : _renderTarget$get$col.texture;\n      var colorTextureView;\n\n      if (gpuTexture) {\n        colorTextureView = gpuTexture.createView(this.currentRenderTargetViewDescriptor);\n      }\n\n      var depthStencilTexture = (_renderTarget$get$dep = renderTarget.get().depth) === null || _renderTarget$get$dep === void 0 ? void 0 : _renderTarget$get$dep.texture;\n      var depthStencilTextureView;\n\n      if (depthStencilTexture) {\n        depthStencilTextureView = depthStencilTexture.createView();\n      }\n\n      var renderPass = this.renderTargetEncoder.beginRenderPass({\n        colorAttachments: [{\n          attachment: colorTextureView,\n          loadValue: clearColor !== null ? clearColor : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        }],\n        depthStencilAttachment: depthStencilTexture && depthStencilTextureView ? {\n          attachment: depthStencilTextureView,\n          depthLoadValue: clearDepth ? this.clearDepthValue : WebGPUConstants.LoadOp.Load,\n          depthStoreOp: WebGPUConstants.StoreOp.Store,\n          stencilLoadValue: clearStencil ? this.clearStencilValue : WebGPUConstants.LoadOp.Load,\n          stencilStoreOp: WebGPUConstants.StoreOp.Store\n        } : undefined\n      });\n      this.currentRenderPass = renderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      } // TODO WEBGPU set the scissor rect and the stencil reference value\n\n    }\n  }, {\n    key: \"endMainRenderPass\",\n    value: function endMainRenderPass() {\n      if (this.currentRenderPass === this.mainRenderPass && this.currentRenderPass !== null) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n        this.currentRenderPass = null;\n        this.mainRenderPass = null;\n      }\n    }\n  }, {\n    key: \"endComputePass\",\n    value: function endComputePass() {\n      if (this.currentComputePass) {\n        this.currentComputePass.endPass();\n        this.currentComputePass = null;\n      }\n    }\n  }, {\n    key: \"endRenderTargetRenderPass\",\n    value: function endRenderTargetRenderPass() {\n      if (this.currentRenderPass) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n      }\n    }\n  }, {\n    key: \"resetCachedViewport\",\n    value: function resetCachedViewport() {\n      this.cachedViewport = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"unbindFramebuffer\",\n    value: function unbindFramebuffer(framebuffer) {\n      // unbind\n      if (this.currentRenderPass && this.currentRenderPass !== this.mainRenderPass) {\n        this.endRenderTargetRenderPass();\n      }\n\n      this.transientViewport.x = Infinity;\n      this.currentRenderTarget = null; // if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      //   this._generateMipmaps(texture);\n      // }\n\n      this.currentRenderPass = this.mainRenderPass;\n    }\n  }]);\n\n  return WebGPUEngine;\n}(), _temp)) || _class);","map":null,"metadata":{},"sourceType":"module"}