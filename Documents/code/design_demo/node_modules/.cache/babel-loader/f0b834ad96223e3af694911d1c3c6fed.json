{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { isNumber, isString } from '@antv/util';\nimport { formatPadding } from '../../util/base';\nimport { applyMatrix, invertMatrix } from '../../util/math';\n\nvar ViewController =\n/** @class */\nfunction () {\n  function ViewController(graph) {\n    this.destroyed = false;\n    this.graph = graph;\n    this.destroyed = false;\n  } // get view center coordinate\n\n\n  ViewController.prototype.getViewCenter = function () {\n    var padding = this.getFormatPadding();\n    var graph = this.graph;\n    var width = this.graph.get('width');\n    var height = graph.get('height');\n    return {\n      x: (width - padding[1] - padding[3]) / 2 + padding[3],\n      y: (height - padding[0] - padding[2]) / 2 + padding[0]\n    };\n  };\n\n  ViewController.prototype.fitCenter = function () {\n    var graph = this.graph;\n    var group = graph.get('group');\n    group.resetMatrix();\n    var bbox = group.getCanvasBBox();\n    if (bbox.width === 0 || bbox.height === 0) return;\n    var viewCenter = this.getViewCenter();\n    var groupCenter = {\n      x: bbox.x + bbox.width / 2,\n      y: bbox.y + bbox.height / 2\n    };\n    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);\n  }; // fit view graph\n\n\n  ViewController.prototype.fitView = function () {\n    var graph = this.graph;\n    var padding = this.getFormatPadding();\n    var width = graph.get('width');\n    var height = graph.get('height');\n    var group = graph.get('group');\n    group.resetMatrix();\n    var bbox = group.getCanvasBBox();\n    if (bbox.width === 0 || bbox.height === 0) return;\n    var viewCenter = this.getViewCenter();\n    var groupCenter = {\n      x: bbox.x + bbox.width / 2,\n      y: bbox.y + bbox.height / 2\n    };\n    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);\n    var w = (width - padding[1] - padding[3]) / bbox.width;\n    var h = (height - padding[0] - padding[2]) / bbox.height;\n    var ratio = w;\n\n    if (w > h) {\n      ratio = h;\n    }\n\n    if (!graph.zoom(ratio, viewCenter)) {\n      console.warn('zoom failed, ratio out of range, ratio: %f', ratio);\n    }\n  }; // fit view graph by rule\n\n\n  ViewController.prototype.fitViewByRules = function (rules) {\n    var _a = rules.onlyOutOfViewPort,\n        onlyOutOfViewPort = _a === void 0 ? false : _a,\n        _b = rules.direction,\n        direction = _b === void 0 ? 'both' : _b,\n        _c = rules.ratioRule,\n        ratioRule = _c === void 0 ? 'min' : _c;\n    var graph = this.graph;\n    var padding = this.getFormatPadding();\n    var width = graph.get('width');\n    var height = graph.get('height');\n    var group = graph.get('group');\n    group.resetMatrix();\n    var bbox = group.getCanvasBBox();\n    if (bbox.width === 0 || bbox.height === 0) return;\n    var viewCenter = this.getViewCenter();\n    var groupCenter = {\n      x: bbox.x + bbox.width / 2,\n      y: bbox.y + bbox.height / 2\n    };\n    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);\n    var wRatio = (width - padding[1] - padding[3]) / bbox.width;\n    var hRatio = (height - padding[0] - padding[2]) / bbox.height;\n    var ratio;\n\n    if (direction === 'x') {\n      ratio = wRatio;\n    } else if (direction === 'y') {\n      ratio = hRatio;\n    } else {\n      // ratioRule\n      ratio = ratioRule === 'max' ? Math.max(wRatio, hRatio) : Math.min(wRatio, hRatio);\n    } // 如果设置了仅对超出视口宽高的场景进行fitview，则没超出的场景zoom取1\n\n\n    if (onlyOutOfViewPort) {\n      ratio = ratio < 1 ? ratio : 1;\n    }\n\n    var initZoomRatio = graph.getZoom();\n    var endZoom = initZoomRatio * ratio;\n    var minZoom = graph.get('minZoom'); // 如果zoom小于最小zoom, 则以最小zoom为准\n\n    if (endZoom < minZoom) {\n      endZoom = minZoom;\n      console.warn('fitview failed, ratio out of range, ratio: %f', ratio, 'graph minzoom has been used instead');\n    }\n\n    graph.zoomTo(endZoom, viewCenter);\n  };\n\n  ViewController.prototype.getFormatPadding = function () {\n    var padding = this.graph.get('fitViewPadding');\n    return formatPadding(padding);\n  };\n\n  ViewController.prototype.focusPoint = function (point, animate, animateCfg) {\n    var _this = this;\n\n    var viewCenter = this.getViewCenter();\n    var modelCenter = this.getPointByCanvas(viewCenter.x, viewCenter.y);\n    var viewportMatrix = this.graph.get('group').getMatrix();\n    if (!viewportMatrix) viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    if (animate) {\n      var dx_1 = (modelCenter.x - point.x) * viewportMatrix[0];\n      var dy_1 = (modelCenter.y - point.y) * viewportMatrix[4];\n      var lastX_1 = 0;\n      var lastY_1 = 0;\n      var newX_1 = 0;\n      var newY_1 = 0; // 动画每次平移一点，直到目标位置\n\n      this.graph.get('canvas').animate(function (ratio) {\n        newX_1 = dx_1 * ratio;\n        newY_1 = dy_1 * ratio;\n\n        _this.graph.translate(newX_1 - lastX_1, newY_1 - lastY_1);\n\n        lastX_1 = newX_1;\n        lastY_1 = newY_1;\n      }, __assign({}, animateCfg));\n    } else {\n      this.graph.translate((modelCenter.x - point.x) * viewportMatrix[0], (modelCenter.y - point.y) * viewportMatrix[4]);\n    }\n  };\n  /**\n   * 将 Canvas 坐标转成视口坐标\n   * @param canvasX canvas x 坐标\n   * @param canvasY canvas y 坐标\n   */\n\n\n  ViewController.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewportMatrix = this.graph.get('group').getMatrix();\n\n    if (!viewportMatrix) {\n      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    var point = invertMatrix({\n      x: canvasX,\n      y: canvasY\n    }, viewportMatrix);\n    return point;\n  };\n  /**\n   * 将页面坐标转成视口坐标\n   * @param clientX 页面 x 坐标\n   * @param clientY 页面 y 坐标\n   */\n\n\n  ViewController.prototype.getPointByClient = function (clientX, clientY) {\n    var canvas = this.graph.get('canvas');\n    var canvasPoint = canvas.getPointByClient(clientX, clientY);\n    return this.getPointByCanvas(canvasPoint.x, canvasPoint.y);\n  };\n  /**\n   * 将视口坐标转成页面坐标\n   * @param x 视口 x 坐标\n   * @param y 视口 y 坐标\n   */\n\n\n  ViewController.prototype.getClientByPoint = function (x, y) {\n    var canvas = this.graph.get('canvas');\n    var canvasPoint = this.getCanvasByPoint(x, y);\n    var point = canvas.getClientByPoint(canvasPoint.x, canvasPoint.y);\n    return {\n      x: point.x,\n      y: point.y\n    };\n  };\n  /**\n   * 将视口坐标转成 Canvas 坐标\n   * @param x 视口 x 坐标\n   * @param y 视口 y 坐标\n   */\n\n\n  ViewController.prototype.getCanvasByPoint = function (x, y) {\n    var viewportMatrix = this.graph.get('group').getMatrix();\n\n    if (!viewportMatrix) {\n      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    return applyMatrix({\n      x: x,\n      y: y\n    }, viewportMatrix);\n  };\n  /**\n   * 将元素移动到画布中心\n   * @param item Item 实例或 id\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  ViewController.prototype.focus = function (item, animate, animateCfg) {\n    if (isString(item)) {\n      item = this.graph.findById(item);\n    }\n\n    if (item) {\n      var x = 0,\n          y = 0;\n\n      if (item.getType && item.getType() === 'edge') {\n        var sourceMatrix = item.getSource().get('group').getMatrix();\n        var targetMatrix = item.getTarget().get('group').getMatrix();\n\n        if (sourceMatrix && targetMatrix) {\n          x = (sourceMatrix[6] + targetMatrix[6]) / 2;\n          y = (sourceMatrix[7] + targetMatrix[7]) / 2;\n        } else if (sourceMatrix || targetMatrix) {\n          x = sourceMatrix ? sourceMatrix[6] : targetMatrix[6];\n          y = sourceMatrix ? sourceMatrix[7] : targetMatrix[7];\n        }\n      } else {\n        var group = item.get('group');\n        var matrix = group.getMatrix();\n        if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        x = matrix[6];\n        y = matrix[7];\n      } // 用实际位置而不是model中的x,y,防止由于拖拽等的交互导致model的x,y并不是当前的x,y\n\n\n      this.focusPoint({\n        x: x,\n        y: y\n      }, animate, animateCfg);\n    }\n  };\n  /**\n   * 改变 canvas 画布的宽度和高度\n   * @param width canvas 宽度\n   * @param height canvas 高度\n   */\n\n\n  ViewController.prototype.changeSize = function (width, height) {\n    var graph = this.graph;\n\n    if (!isNumber(width) || !isNumber(height)) {\n      throw Error('invalid canvas width & height, please make sure width & height type is number');\n    }\n\n    graph.set({\n      width: width,\n      height: height\n    });\n    var canvas = graph.get('canvas');\n    canvas.changeSize(width, height); // change the size of grid plugin if it exists on graph\n\n    var plugins = graph.get('plugins');\n    plugins.forEach(function (plugin) {\n      if (plugin.get('gridContainer')) {\n        // 网格定位信息初始化\n        plugin.positionInit();\n      }\n    });\n  };\n\n  ViewController.prototype.destroy = function () {\n    this.graph = null;\n    this.destroyed = false;\n  };\n\n  return ViewController;\n}();\n\nexport default ViewController;","map":null,"metadata":{},"sourceType":"module"}