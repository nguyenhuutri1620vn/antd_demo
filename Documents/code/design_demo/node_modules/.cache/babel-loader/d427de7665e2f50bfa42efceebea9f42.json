{"ast":null,"code":"import { ObjectExt } from '../object';\nimport { mergeAttrs } from '../dom/attr';\nexport function annotate(t, annotations) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const offset = opt.offset || 0;\n  const compacted = [];\n  const ret = [];\n  let curr;\n  let prev;\n  let batch = null;\n\n  for (let i = 0; i < t.length; i += 1) {\n    curr = ret[i] = t[i];\n\n    for (let j = 0, jj = annotations.length; j < jj; j += 1) {\n      const annotation = annotations[j];\n      const start = annotation.start + offset;\n      const end = annotation.end + offset;\n\n      if (i >= start && i < end) {\n        if (typeof curr === 'string') {\n          curr = ret[i] = {\n            t: t[i],\n            attrs: annotation.attrs\n          };\n        } else {\n          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);\n        }\n\n        if (opt.includeAnnotationIndices) {\n          if (curr.annotations == null) {\n            curr.annotations = [];\n          }\n\n          curr.annotations.push(j);\n        }\n      }\n    }\n\n    prev = ret[i - 1];\n\n    if (!prev) {\n      batch = curr;\n    } else if (ObjectExt.isObject(curr) && ObjectExt.isObject(prev)) {\n      batch = batch; // Both previous item and the current one are annotations.\n      // If the attributes didn't change, merge the text.\n\n      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {\n        batch.t += curr.t;\n      } else {\n        compacted.push(batch);\n        batch = curr;\n      }\n    } else if (ObjectExt.isObject(curr)) {\n      // Previous item was a string, current item is an annotation.\n      batch = batch;\n      compacted.push(batch);\n      batch = curr;\n    } else if (ObjectExt.isObject(prev)) {\n      // Previous item was an annotation, current item is a string.\n      batch = batch;\n      compacted.push(batch);\n      batch = curr;\n    } else {\n      // Both previous and current item are strings.\n      batch = (batch || '') + curr;\n    }\n  }\n\n  if (batch != null) {\n    compacted.push(batch);\n  }\n\n  return compacted;\n}\nexport function findAnnotationsAtIndex(annotations, index) {\n  return annotations ? annotations.filter(a => a.start < index && index <= a.end) : [];\n}\nexport function findAnnotationsBetweenIndexes(annotations, start, end) {\n  return annotations ? annotations.filter(a => start >= a.start && start < a.end || end > a.start && end <= a.end || a.start >= start && a.end < end) : [];\n}\nexport function shiftAnnotations(annotations, index, offset) {\n  if (annotations) {\n    annotations.forEach(a => {\n      if (a.start < index && a.end >= index) {\n        a.end += offset;\n      } else if (a.start >= index) {\n        a.start += offset;\n        a.end += offset;\n      }\n    });\n  }\n\n  return annotations;\n}","map":null,"metadata":{},"sourceType":"module"}