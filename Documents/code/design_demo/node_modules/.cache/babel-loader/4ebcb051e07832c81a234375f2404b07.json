{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _class2, _descriptor;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { $window } from '@antv/l7-utils';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nvar blendFS = \"uniform float u_opacity : 1.0;\\nuniform float u_MixRatio : 0.5;\\n\\nuniform sampler2D u_Diffuse1;\\nuniform sampler2D u_Diffuse2;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  vec4 texel1 = texture2D(u_Diffuse1, v_UV);\\n  vec4 texel2 = texture2D(u_Diffuse2, v_UV);\\n  gl_FragColor = u_opacity * mix(texel1, texel2, u_MixRatio);\\n}\\n\";\nvar copyFS = \"varying vec2 v_UV;\\n\\nuniform sampler2D u_Texture;\\n\\nvoid main() {\\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\\n}\";\nvar quadVS = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport { TYPES } from '../../../types';\nimport { gl } from '../gl';\nimport { PassType } from '../IMultiPassRenderer';\nimport BaseNormalPass from './BaseNormalPass';\n\nfunction halton(index, base) {\n  var result = 0;\n  var f = 1 / base;\n  var i = index;\n\n  while (i > 0) {\n    result = result + f * (i % base);\n    i = Math.floor(i / base);\n    f = f / base;\n  }\n\n  return result;\n}\n\nvar accumulatingId = 1;\nvar TAAPass = (_dec = injectable(), _dec2 = inject(TYPES.IShaderModuleService), _dec(_class = (_class2 = function (_BaseNormalPass) {\n  _inherits(TAAPass, _BaseNormalPass);\n\n  var _super = _createSuper(TAAPass);\n\n  function TAAPass() {\n    var _this;\n\n    _classCallCheck(this, TAAPass);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _initializerDefineProperty(_assertThisInitialized(_this), \"shaderModuleService\", _descriptor, _assertThisInitialized(_this));\n\n    _defineProperty(_assertThisInitialized(_this), \"haltonSequence\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"accumulatingId\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"frame\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"timer\", undefined);\n\n    _defineProperty(_assertThisInitialized(_this), \"sampleRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"prevRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"outputRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"copyRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"blendModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"outputModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"copyModel\", void 0);\n\n    return _this;\n  }\n\n  _createClass(TAAPass, [{\n    key: \"getType\",\n    value: function getType() {\n      return PassType.Normal;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'taa';\n    }\n  }, {\n    key: \"init\",\n    value: function init(layer, config) {\n      _get(_getPrototypeOf(TAAPass.prototype), \"init\", this).call(this, layer, config);\n\n      var _this$rendererService = this.rendererService,\n          createFramebuffer = _this$rendererService.createFramebuffer,\n          createTexture2D = _this$rendererService.createTexture2D;\n      this.sampleRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.prevRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.outputRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.copyRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n\n      for (var i = 0; i < 30; i++) {\n        this.haltonSequence.push([halton(i, 2), halton(i, 3)]);\n      }\n\n      this.blendModel = this.createTriangleModel('blend-pass', blendFS);\n      this.outputModel = this.createTriangleModel('copy-pass', copyFS, {\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.ONE,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            srcAlpha: gl.ONE,\n            dstAlpha: gl.ONE_MINUS_SRC_ALPHA\n          },\n          equation: {\n            rgb: gl.FUNC_ADD,\n            alpha: gl.FUNC_ADD\n          }\n        }\n      });\n      this.copyModel = this.createTriangleModel('copy-pass', copyFS);\n    }\n  }, {\n    key: \"render\",\n    value: function render(layer) {\n      var _this2 = this;\n\n      var _this$rendererService2 = this.rendererService,\n          clear = _this$rendererService2.clear,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          useFramebuffer = _this$rendererService2.useFramebuffer;\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      this.sampleRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.prevRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.outputRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.copyRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.resetFrame();\n      this.stopAccumulating();\n      var readFBO = layer.multiPassRenderer.getPostProcessor().getReadFBO();\n      useFramebuffer(readFBO, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: readFBO\n        });\n        layer.multiPassRenderer.setRenderFlag(false);\n        layer.render();\n        layer.multiPassRenderer.setRenderFlag(true);\n      });\n\n      var accumulate = function accumulate(id) {\n        if (!_this2.accumulatingId || id !== _this2.accumulatingId) {\n          return;\n        }\n\n        if (!_this2.isFinished()) {\n          _this2.doRender(layer);\n\n          $window.requestAnimationFrame(function () {\n            accumulate(id);\n          });\n        }\n      };\n\n      this.accumulatingId = accumulatingId++;\n      this.timer = $window.setTimeout(function () {\n        accumulate(_this2.accumulatingId);\n      }, 50);\n    }\n  }, {\n    key: \"doRender\",\n    value: function doRender(layer) {\n      var _this3 = this;\n\n      var _this$rendererService3 = this.rendererService,\n          clear = _this$rendererService3.clear,\n          getViewportSize = _this$rendererService3.getViewportSize,\n          useFramebuffer = _this$rendererService3.useFramebuffer;\n\n      var _getViewportSize2 = getViewportSize(),\n          width = _getViewportSize2.width,\n          height = _getViewportSize2.height;\n\n      var _layer$getLayerConfig = layer.getLayerConfig(),\n          _layer$getLayerConfig2 = _layer$getLayerConfig.jitterScale,\n          jitterScale = _layer$getLayerConfig2 === void 0 ? 1 : _layer$getLayerConfig2;\n\n      var offset = this.haltonSequence[this.frame % this.haltonSequence.length];\n      this.cameraService.jitterProjectionMatrix((offset[0] * 2.0 - 1.0) / width * jitterScale, (offset[1] * 2.0 - 1.0) / height * jitterScale);\n      layer.multiPassRenderer.setRenderFlag(false);\n      layer.hooks.beforeRender.call();\n      useFramebuffer(this.sampleRenderTarget, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: _this3.sampleRenderTarget\n        });\n        layer.render();\n      });\n      layer.hooks.afterRender.call();\n      layer.multiPassRenderer.setRenderFlag(true);\n      var layerStyleOptions = layer.getLayerConfig();\n      useFramebuffer(this.outputRenderTarget, function () {\n        _this3.blendModel.draw({\n          uniforms: {\n            u_opacity: layerStyleOptions.opacity || 1,\n            u_MixRatio: _this3.frame === 0 ? 1 : 0.9,\n            u_Diffuse1: _this3.sampleRenderTarget,\n            u_Diffuse2: _this3.frame === 0 ? layer.multiPassRenderer.getPostProcessor().getReadFBO() : _this3.prevRenderTarget\n          }\n        });\n      });\n\n      if (this.frame === 0) {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: this.copyRenderTarget\n        });\n      }\n\n      if (this.frame >= 1) {\n        useFramebuffer(this.copyRenderTarget, function () {\n          _this3.outputModel.draw({\n            uniforms: {\n              u_Texture: _this3.outputRenderTarget\n            }\n          });\n        });\n        useFramebuffer(layer.multiPassRenderer.getPostProcessor().getReadFBO(), function () {\n          _this3.copyModel.draw({\n            uniforms: {\n              u_Texture: _this3.copyRenderTarget\n            }\n          });\n        });\n        layer.multiPassRenderer.getPostProcessor().render(layer);\n      }\n\n      var tmp = this.prevRenderTarget;\n      this.prevRenderTarget = this.outputRenderTarget;\n      this.outputRenderTarget = tmp;\n      this.frame++;\n      this.cameraService.clearJitterProjectionMatrix();\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      return this.frame >= this.haltonSequence.length;\n    }\n  }, {\n    key: \"resetFrame\",\n    value: function resetFrame() {\n      this.frame = 0;\n    }\n  }, {\n    key: \"stopAccumulating\",\n    value: function stopAccumulating() {\n      this.accumulatingId = 0;\n      $window.clearTimeout(this.timer);\n    }\n  }, {\n    key: \"createTriangleModel\",\n    value: function createTriangleModel(shaderModuleName, fragmentShader, options) {\n      this.shaderModuleService.registerModule(shaderModuleName, {\n        vs: quadVS,\n        fs: fragmentShader\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule(shaderModuleName),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService4 = this.rendererService,\n          createAttribute = _this$rendererService4.createAttribute,\n          createBuffer = _this$rendererService4.createBuffer,\n          createModel = _this$rendererService4.createModel;\n      return createModel(_objectSpread({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-4, -4, 4, -4, 0, 4],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: false\n        },\n        count: 3\n      }, options));\n    }\n  }]);\n\n  return TAAPass;\n}(BaseNormalPass), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { TAAPass as default };","map":null,"metadata":{},"sourceType":"module"}