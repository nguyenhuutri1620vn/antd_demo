{"ast":null,"code":"import { isObject } from './object';\nexport const getEdgeTerminal = (edge, type) => {\n  const terminal = edge[type];\n\n  if (isObject(terminal)) {\n    return terminal.cell;\n  }\n\n  return terminal;\n};\nexport const getDegree = (n, nodeIdxMap, edges) => {\n  const degrees = [];\n\n  for (let i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  if (!edges) return degrees;\n  edges.forEach(e => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n\n    if (source) {\n      degrees[nodeIdxMap[source]] += 1;\n    }\n\n    if (target) {\n      degrees[nodeIdxMap[target]] += 1;\n    }\n  });\n  return degrees;\n};\nexport const floydWarshall = adjMatrix => {\n  // initialize\n  const dist = [];\n  const size = adjMatrix.length;\n\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\nexport const getAdjMatrix = (data, directed) => {\n  const {\n    nodes,\n    edges\n  } = data;\n  const matrix = []; // map node with index in data.nodes\n\n  const nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(e => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      const sIndex = nodeMap[source];\n      const tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\nexport const scaleMatrix = (matrix, ratio) => {\n  const result = [];\n  matrix.forEach(row => {\n    const newRow = [];\n    row.forEach(v => {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\nconst traverseUp = (data, fn) => {\n  if (data && data.children) {\n    for (let i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (!fn(data)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\n\nexport const traverseTreeUp = (data, fn) => {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};","map":null,"metadata":{},"sourceType":"module"}