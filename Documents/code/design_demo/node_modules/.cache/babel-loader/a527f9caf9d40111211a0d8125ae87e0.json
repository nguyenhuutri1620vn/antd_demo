{"ast":null,"code":"import { ArrayExt } from '../../../util';\nimport { Point } from '../../../geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\n\nexport class ObstacleMap {\n  constructor(options) {\n    this.options = options;\n    this.mapGridSize = 100;\n    this.map = {};\n  }\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n\n\n  build(model, edge) {\n    const options = this.options; // source or target node could be excluded from set of obstacles\n\n    const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {\n      const terminal = edge[type];\n\n      if (terminal) {\n        const cell = model.getCell(terminal.cell);\n\n        if (cell) {\n          memo.push(cell);\n        }\n      }\n\n      return memo;\n    }, []);\n    let excludedAncestors = [];\n    const source = model.getCell(edge.getSourceCellId());\n\n    if (source) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map(cell => cell.id));\n    }\n\n    const target = model.getCell(edge.getTargetCellId());\n\n    if (target) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map(cell => cell.id));\n    } // The graph is divided into smaller cells, where each holds information\n    // about which node belong to it. When we query whether a point lies\n    // inside an obstacle we don't need to go through all obstacles, we check\n    // only those in a particular cell.\n\n\n    const mapGridSize = this.mapGridSize;\n    model.getNodes().reduce((map, node) => {\n      const shape = node.shape;\n      const excludeShapes = options.excludeShapes;\n      const excType = shape ? excludeShapes.includes(shape) : false;\n      const excTerminal = excludedTerminals.some(cell => cell.id === node.id);\n      const excAncestor = excludedAncestors.includes(node.id);\n      const excHidden = options.excludeHiddenNodes && !node.isVisible();\n      const excluded = excType || excTerminal || excAncestor || excHidden;\n\n      if (!excluded) {\n        const bbox = node.getBBox().moveAndExpand(options.paddingBox);\n        const origin = bbox.getOrigin().snapToGrid(mapGridSize);\n        const corner = bbox.getCorner().snapToGrid(mapGridSize);\n\n        for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n          for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n            const key = new Point(x, y).toString();\n\n            if (map[key] == null) {\n              map[key] = [];\n            }\n\n            map[key].push(bbox);\n          }\n        }\n      }\n\n      return map;\n    }, this.map);\n    return this;\n  }\n\n  isAccessible(point) {\n    const key = point.clone().snapToGrid(this.mapGridSize).toString();\n    const rects = this.map[key];\n    return rects ? rects.every(rect => !rect.containsPoint(point)) : true;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}