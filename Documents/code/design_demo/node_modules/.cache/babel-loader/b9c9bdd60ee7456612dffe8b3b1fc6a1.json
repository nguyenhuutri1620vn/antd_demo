{"ast":null,"code":"import { __awaiter, __decorate, __metadata } from \"tslib\";\nimport { inject, injectable } from 'mana-syringe';\nimport { ICommandHandler, ICommandContextProvider } from '../../command/interface';\nimport { XFlowGroupCommands } from '../constant';\nimport { Disposable } from '../../common/disposable';\nimport { XFlowNodeCommands } from '../constant';\nexport var NsAddGroup;\n\n(function (NsAddGroup) {\n  /** Command: 用于注册named factory */\n  NsAddGroup.command = XFlowGroupCommands.ADD_GROUP;\n  /** hookName */\n\n  NsAddGroup.hookKey = 'addGroup';\n  NsAddGroup.GROUP_PADDING = 12;\n  NsAddGroup.GROUP_HEADER_HEIGHT = 40;\n})(NsAddGroup || (NsAddGroup = {}));\n\nlet AddGroupCommand =\n/** 创建节点命令 */\nclass AddGroupCommand {\n  constructor() {\n    this.getBBox = (node, nodeConfig, graph) => {\n      const {\n        groupHeaderHeight = NsAddGroup.GROUP_HEADER_HEIGHT,\n        groupPadding = NsAddGroup.GROUP_PADDING\n      } = nodeConfig;\n      const bbox = graph.getCellsBBox(node.children);\n      bbox.moveAndExpand({\n        x: -groupPadding,\n        y: -(groupPadding + groupHeaderHeight),\n        width: groupPadding * 2,\n        height: groupPadding * 2 + groupHeaderHeight\n      });\n      return bbox;\n    };\n    /** 执行Cmd */\n\n\n    this.execute = () => __awaiter(this, void 0, void 0, function* () {\n      const ctx = this.contextProvider();\n      const {\n        args,\n        hooks: runtimeHook\n      } = ctx.getArgs();\n      const hooks = ctx.getHooks();\n      const result = yield hooks.addGroup.call(args, handlerArgs => __awaiter(this, void 0, void 0, function* () {\n        const {\n          nodeConfig,\n          createService: createGroupService,\n          cellFactory,\n          commandService\n        } = handlerArgs;\n        const graph = yield ctx.getX6Graph();\n        const res = yield commandService.executeCommand(XFlowNodeCommands.ADD_NODE.id, {\n          cellFactory,\n          createNodeService: createGroupService,\n          nodeConfig\n        });\n        const {\n          nodeCell: groupCell\n        } = res.contextProvider().getResult();\n        const {\n          id: groupId\n        } = groupCell;\n        const {\n          groupChildren\n        } = nodeConfig;\n\n        if (groupChildren.length) {\n          groupChildren.forEach(nodeId => {\n            const child = graph.getCellById(nodeId);\n\n            if (child) {\n              child.setData(Object.assign(Object.assign({}, child.getData()), {\n                group: groupId,\n                isCollapsed: false\n              }));\n              child.prop('group', groupId);\n              groupCell.addChild(child);\n              graph.unselect(child);\n            }\n          });\n          const groupBBox = this.getBBox(groupCell, nodeConfig, graph);\n          groupCell.position(groupBBox.x, groupBBox.y);\n          groupCell.size(groupBBox.width, groupBBox.height);\n          groupCell.setZIndex(0);\n          groupCell.prop('isGroup', true);\n          groupCell.setData(Object.assign(Object.assign({}, groupCell.getData()), {\n            width: groupBBox.width,\n            height: groupBBox.height,\n            groupChildrenSize: {\n              width: groupBBox.width,\n              height: groupBBox.height\n            },\n            x: groupBBox.x,\n            y: groupBBox.y,\n            isGroup: true\n          }));\n          graph.select(groupCell);\n        }\n\n        if (nodeConfig.isCollapsed) {\n          yield commandService.executeCommand(XFlowGroupCommands.COLLAPSE_GROUP.id, {\n            nodeId: nodeConfig.id,\n            isCollapsed: nodeConfig.isCollapsed\n          });\n        }\n        /** add undo: delete node */\n\n\n        ctx.addUndo(Disposable.create(() => __awaiter(this, void 0, void 0, function* () {\n          commandService.executeCommand(XFlowGroupCommands.DEL_GROUP.id, {\n            nodeConfig\n          });\n        })));\n        return {\n          nodeConfig: nodeConfig,\n          nodeCell: groupCell\n        };\n      }), runtimeHook);\n      ctx.setResult(result);\n      return this;\n    });\n    /** undo cmd */\n\n\n    this.undo = () => __awaiter(this, void 0, void 0, function* () {\n      const ctx = this.contextProvider();\n\n      if (this.isUndoable()) {\n        ctx.undo();\n      }\n\n      return this;\n    });\n    /** redo cmd */\n\n\n    this.redo = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.isUndoable()) {\n        yield this.execute();\n      }\n\n      return this;\n    });\n  }\n\n  isUndoable() {\n    const ctx = this.contextProvider();\n    return ctx.isUndoable();\n  }\n\n};\n\n__decorate([inject(ICommandContextProvider), __metadata(\"design:type\", Object)], AddGroupCommand.prototype, \"contextProvider\", void 0);\n\nAddGroupCommand = __decorate([injectable({\n  token: {\n    token: ICommandHandler,\n    named: NsAddGroup.command.id\n  }\n})\n/** 创建节点命令 */\n], AddGroupCommand);\nexport { AddGroupCommand };","map":null,"metadata":{},"sourceType":"module"}