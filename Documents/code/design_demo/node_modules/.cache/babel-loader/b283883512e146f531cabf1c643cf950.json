{"ast":null,"code":"import { Model } from '../model/model';\nexport function grid(cells) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const model = Model.isModel(cells) ? cells : new Model().resetCells(cells, {\n    sort: false,\n    dryrun: true\n  });\n  const nodes = model.getNodes();\n  const columns = options.columns || 1;\n  const rows = Math.ceil(nodes.length / columns);\n  const dx = options.dx || 0;\n  const dy = options.dy || 0;\n  const centre = options.center !== false;\n  const resizeToFit = options.resizeToFit === true;\n  const marginX = options.marginX || 0;\n  const marginY = options.marginY || 0;\n  const columnWidths = [];\n  let columnWidth = options.columnWidth;\n\n  if (columnWidth === 'compact') {\n    for (let j = 0; j < columns; j += 1) {\n      const items = GridLayout.getNodesInColumn(nodes, j, columns);\n      columnWidths.push(GridLayout.getMaxDim(items, 'width') + dx);\n    }\n  } else {\n    if (columnWidth == null || columnWidth === 'auto') {\n      columnWidth = GridLayout.getMaxDim(nodes, 'width') + dx;\n    }\n\n    for (let i = 0; i < columns; i += 1) {\n      columnWidths.push(columnWidth);\n    }\n  }\n\n  const columnLefts = GridLayout.accumulate(columnWidths, marginX);\n  const rowHeights = [];\n  let rowHeight = options.rowHeight;\n\n  if (rowHeight === 'compact') {\n    for (let i = 0; i < rows; i += 1) {\n      const items = GridLayout.getNodesInRow(nodes, i, columns);\n      rowHeights.push(GridLayout.getMaxDim(items, 'height') + dy);\n    }\n  } else {\n    if (rowHeight == null || rowHeight === 'auto') {\n      rowHeight = GridLayout.getMaxDim(nodes, 'height') + dy;\n    }\n\n    for (let i = 0; i < rows; i += 1) {\n      rowHeights.push(rowHeight);\n    }\n  }\n\n  const rowTops = GridLayout.accumulate(rowHeights, marginY);\n  model.startBatch('layout');\n  nodes.forEach((node, index) => {\n    const rowIndex = index % columns;\n    const columnIndex = Math.floor(index / columns);\n    const columnWidth = columnWidths[rowIndex];\n    const rowHeight = rowHeights[columnIndex];\n    let cx = 0;\n    let cy = 0;\n    let size = node.getSize();\n\n    if (resizeToFit) {\n      let width = columnWidth - 2 * dx;\n      let height = rowHeight - 2 * dy;\n      const calcHeight = size.height * (size.width ? width / size.width : 1);\n      const calcWidth = size.width * (size.height ? height / size.height : 1);\n\n      if (rowHeight < calcHeight) {\n        width = calcWidth;\n      } else {\n        height = calcHeight;\n      }\n\n      size = {\n        width,\n        height\n      };\n      node.setSize(size, options);\n    }\n\n    if (centre) {\n      cx = (columnWidth - size.width) / 2;\n      cy = (rowHeight - size.height) / 2;\n    }\n\n    node.position(columnLefts[rowIndex] + dx + cx, rowTops[columnIndex] + dy + cy, options);\n  });\n  model.stopBatch('layout');\n}\nvar GridLayout;\n\n(function (GridLayout) {\n  function getMaxDim(nodes, name) {\n    return nodes.reduce((memo, node) => Math.max(node.getSize()[name], memo), 0);\n  }\n\n  GridLayout.getMaxDim = getMaxDim;\n\n  function getNodesInRow(nodes, rowIndex, columnCount) {\n    const res = [];\n\n    for (let i = columnCount * rowIndex, ii = i + columnCount; i < ii; i += 1) {\n      res.push(nodes[i]);\n    }\n\n    return res;\n  }\n\n  GridLayout.getNodesInRow = getNodesInRow;\n\n  function getNodesInColumn(nodes, columnIndex, columnCount) {\n    const res = [];\n\n    for (let i = columnIndex, ii = nodes.length; i < ii; i += columnCount) {\n      res.push(nodes[i]);\n    }\n\n    return res;\n  }\n\n  GridLayout.getNodesInColumn = getNodesInColumn;\n\n  function accumulate(items, start) {\n    return items.reduce((memo, item, i) => {\n      memo.push(memo[i] + item);\n      return memo;\n    }, [start || 0]);\n  }\n\n  GridLayout.accumulate = accumulate;\n})(GridLayout || (GridLayout = {}));","map":null,"metadata":{},"sourceType":"module"}