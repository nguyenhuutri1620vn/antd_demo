{"ast":null,"code":"// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts\n\n/**\n * Given a name and a list of names that are not equal to the name, return a\n * spelling suggestion if there is one that is close enough. Names less than\n * length 3 only check for case-insensitive equality, not Levenshtein distance.\n *\n * - If there is a candidate that's the same except for case, return that.\n * - If there is a candidate that's within one edit of the name, return that.\n * - Otherwise, return the candidate with the smallest Levenshtein distance,\n *     except for candidates:\n *       * With no name\n *       * Whose length differs from the target name by more than 0.34 of the\n *         length of the name.\n *       * Whose levenshtein distance is more than 0.4 of the length of the\n *         name (0.4 allows 1 substitution/transposition for every 5 characters,\n *         and 1 insertion/deletion at 3 characters)\n */\nexport function getSpellingSuggestion(name, candidates, getName) {\n  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34)); // If the best result isn't better than this, don't bother.\n\n  let bestDistance = Math.floor(name.length * 0.4) + 1;\n  let bestCandidate;\n  let justCheckExactMatches = false;\n  const nameLowerCase = name.toLowerCase(); // eslint-disable-next-line\n\n  for (const candidate of candidates) {\n    const candidateName = getName(candidate);\n\n    if (candidateName !== undefined && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {\n      const candidateNameLowerCase = candidateName.toLowerCase();\n\n      if (candidateNameLowerCase === nameLowerCase) {\n        if (candidateName === name) {\n          continue;\n        }\n\n        return candidate;\n      }\n\n      if (justCheckExactMatches) {\n        continue;\n      }\n\n      if (candidateName.length < 3) {\n        // Don't bother, user would have noticed a\n        // 2-character name having an extra character.\n        continue;\n      } // Only care about a result better than the best so far.\n\n\n      const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);\n\n      if (distance === undefined) {\n        continue;\n      }\n\n      if (distance < 3) {\n        justCheckExactMatches = true;\n        bestCandidate = candidate;\n      } else {\n        // Debug.assert(distance < bestDistance)\n        bestDistance = distance;\n        bestCandidate = candidate;\n      }\n    }\n  }\n\n  return bestCandidate;\n}\n\nfunction levenshteinWithMax(s1, s2, max) {\n  let previous = new Array(s2.length + 1); // eslint-disable-line\n\n  let current = new Array(s2.length + 1); // eslint-disable-line\n\n  /** Represents any value > max. We don't care about the particular value. */\n\n  const big = max + 1;\n\n  for (let i = 0; i <= s2.length; i += 1) {\n    previous[i] = i;\n  }\n\n  for (let i = 1; i <= s1.length; i += 1) {\n    const c1 = s1.charCodeAt(i - 1);\n    const minJ = i > max ? i - max : 1;\n    const maxJ = s2.length > max + i ? max + i : s2.length;\n    current[0] = i;\n    /** Smallest value of the matrix in the ith column. */\n\n    let colMin = i;\n\n    for (let j = 1; j < minJ; j += 1) {\n      current[j] = big;\n    }\n\n    for (let j = minJ; j <= maxJ; j += 1) {\n      const dist = c1 === s2.charCodeAt(j - 1) ? previous[j - 1] : Math.min(\n      /* delete */\n      previous[j] + 1,\n      /* insert */\n      current[j - 1] + 1,\n      /* substitute */\n      previous[j - 1] + 2);\n      current[j] = dist;\n      colMin = Math.min(colMin, dist);\n    }\n\n    for (let j = maxJ + 1; j <= s2.length; j += 1) {\n      current[j] = big;\n    }\n\n    if (colMin > max) {\n      // Give up -- everything in this column is > max\n      // and it can't get better in future columns.\n      return undefined;\n    }\n\n    const temp = previous;\n    previous = current;\n    current = temp;\n  }\n\n  const res = previous[s2.length];\n  return res > max ? undefined : res;\n}","map":null,"metadata":{},"sourceType":"module"}