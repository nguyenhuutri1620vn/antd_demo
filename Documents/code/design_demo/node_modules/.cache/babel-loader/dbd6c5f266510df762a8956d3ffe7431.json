{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { deepMix, each, get, isUndefined } from '@antv/util';\nimport { DIRECTION, COMPONENT_TYPE, LAYER } from '../../constant';\nimport { CircleAxis, CircleGrid, LineAxis, LineGrid } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\nimport { getAxisDirection, getAxisFactorByRegion, getAxisRegion, getAxisThemeCfg, getAxisTitleOptions, getAxisTitleText, getCircleAxisCenterRadius, isVertical } from '../../util/axis';\nimport { getAxisOption } from '../../util/axis';\nimport { getCircleGridItems, getGridThemeCfg, getLineGridItems, showGrid } from '../../util/grid';\nimport { omit } from '../../util/helper';\nimport { Controller } from './base'; // update 组件的时候，忽略的数据更新\n\nvar OMIT_CFG = ['container']; // 坐标轴默认动画配置\n\nvar AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), {\n  appear: null\n});\n/**\n * @ignore\n * G2 Axis controller, will:\n *  - create component\n *    - axis\n *    - grid\n *  - life circle\n */\n\n\nvar Axis =\n/** @class */\nfunction (_super) {\n  __extends(Axis, _super);\n\n  function Axis(view) {\n    var _this = _super.call(this, view) || this;\n    /** 使用 object 存储组件 */\n\n\n    _this.cache = new Map(); // 先创建 gridContainer，将 grid 放到 axis 底层\n\n    _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    return _this;\n  }\n\n  Object.defineProperty(Axis.prototype, \"name\", {\n    get: function () {\n      return 'axis';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Axis.prototype.init = function () {};\n\n  Axis.prototype.render = function () {\n    this.update();\n  };\n  /**\n   * 更新组件布局，位置大小\n   */\n\n\n  Axis.prototype.layout = function () {\n    var _this = this;\n\n    var coordinate = this.view.getCoordinate();\n    each(this.getComponents(), function (co) {\n      var component = co.component,\n          direction = co.direction,\n          type = co.type,\n          extra = co.extra;\n      var dim = extra.dim,\n          scale = extra.scale,\n          alignTick = extra.alignTick;\n      var updated;\n\n      if (type === COMPONENT_TYPE.AXIS) {\n        if (coordinate.isPolar) {\n          if (dim === 'x') {\n            updated = coordinate.isTransposed ? getAxisRegion(coordinate, direction) : getCircleAxisCenterRadius(coordinate);\n          } else if (dim === 'y') {\n            updated = coordinate.isTransposed ? getCircleAxisCenterRadius(coordinate) : getAxisRegion(coordinate, direction);\n          }\n        } else {\n          updated = getAxisRegion(coordinate, direction);\n        }\n      } else if (type === COMPONENT_TYPE.GRID) {\n        if (coordinate.isPolar) {\n          var items = void 0;\n\n          if (coordinate.isTransposed) {\n            items = dim === 'x' ? getCircleGridItems(coordinate, _this.view.getYScales()[0], scale, alignTick, dim) : getLineGridItems(coordinate, scale, dim, alignTick);\n          } else {\n            items = dim === 'x' ? getLineGridItems(coordinate, scale, dim, alignTick) : getCircleGridItems(coordinate, _this.view.getXScale(), scale, alignTick, dim);\n          }\n\n          updated = {\n            items: items,\n            // coordinate 更新之后，center 也变化了\n            center: _this.view.getCoordinate().getCenter()\n          };\n        } else {\n          updated = {\n            items: getLineGridItems(coordinate, scale, dim, alignTick)\n          };\n        }\n      }\n\n      component.update(updated);\n    });\n  };\n  /**\n   * 更新 axis 组件\n   */\n\n\n  Axis.prototype.update = function () {\n    this.option = this.view.getOptions().axes;\n    var updatedCache = new Map();\n    this.updateXAxes(updatedCache);\n    this.updateYAxes(updatedCache); // 处理完成之后，销毁删除的\n    // 不在处理中的\n\n    var newCache = new Map();\n    this.cache.forEach(function (co, key) {\n      if (updatedCache.has(key)) {\n        newCache.set(key, co);\n      } else {\n        // 不存在，则是所有需要被销毁的组件\n        co.component.destroy();\n      }\n    }); // 更新缓存\n\n    this.cache = newCache;\n  };\n\n  Axis.prototype.clear = function () {\n    _super.prototype.clear.call(this);\n\n    this.cache.clear();\n    this.gridContainer.clear();\n    this.gridForeContainer.clear();\n    this.axisContainer.clear();\n    this.axisForeContainer.clear();\n  };\n\n  Axis.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.gridContainer.remove(true);\n    this.gridForeContainer.remove(true);\n    this.axisContainer.remove(true);\n    this.axisForeContainer.remove(true);\n  };\n  /**\n   * @override\n   */\n\n\n  Axis.prototype.getComponents = function () {\n    var co = [];\n    this.cache.forEach(function (value) {\n      co.push(value);\n    });\n    return co;\n  };\n  /**\n   * 更新 x axis\n   * @param updatedCache\n   */\n\n\n  Axis.prototype.updateXAxes = function (updatedCache) {\n    // x axis\n    var scale = this.view.getXScale();\n\n    if (!scale || scale.isIdentity) {\n      return;\n    }\n\n    var xAxisOption = getAxisOption(this.option, scale.field);\n\n    if (xAxisOption === false) {\n      return;\n    }\n\n    var direction = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);\n    var layer = LAYER.BG;\n    var dim = 'x';\n    var coordinate = this.view.getCoordinate();\n    var axisId = this.getId('axis', scale.field);\n    var gridId = this.getId('grid', scale.field);\n\n    if (coordinate.isRect) {\n      // 1. do axis update\n      var axis = this.cache.get(axisId); // 存在则更新\n\n      if (axis) {\n        var cfg = this.getLineAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      } // 2. do grid update\n\n\n      var grid = this.cache.get(gridId); // 存在则更新\n\n      if (grid) {\n        var cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);\n\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else if (coordinate.isPolar) {\n      // 1. do axis update\n      var axis = this.cache.get(axisId); // 存在则更新\n\n      if (axis) {\n        var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            // 默认不渲染转置极坐标下的坐标轴\n            return;\n          } else {\n            // 如果用户打开了隐藏的坐标轴 chart.axis(true)/chart.axis('x', true)\n            // 那么对于转置了的极坐标，半径轴显示的是 x 轴对应的数据\n            axis = this.createLineAxis(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);\n        }\n\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      } // 2. do grid update\n\n\n      var grid = this.cache.get(gridId); // 存在则更新\n\n      if (grid) {\n        var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale, xAxisOption, DIRECTION.CIRCLE, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            return;\n          } else {\n            grid = this.createCircleGrid(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          // grid，极坐标下的 x 轴网格线沿着半径方向绘制\n          grid = this.createLineGrid(scale, xAxisOption, layer, DIRECTION.CIRCLE, dim);\n        }\n\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else {// helix and other, do not draw axis\n    }\n  };\n\n  Axis.prototype.updateYAxes = function (updatedCache) {\n    var _this = this; // y axes\n\n\n    var yScales = this.view.getYScales();\n    each(yScales, function (scale, idx) {\n      // @ts-ignore\n      if (!scale || scale.isIdentity) {\n        return;\n      }\n\n      var field = scale.field;\n      var yAxisOption = getAxisOption(_this.option, field);\n\n      if (yAxisOption !== false) {\n        var layer = LAYER.BG;\n        var dim = 'y';\n\n        var axisId = _this.getId('axis', field);\n\n        var gridId = _this.getId('grid', field);\n\n        var coordinate = _this.view.getCoordinate();\n\n        if (coordinate.isRect) {\n          var direction = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT); // 1. do axis update\n\n          var axis = _this.cache.get(axisId); // 存在则更新\n\n\n          if (axis) {\n            var cfg = _this.getLineAxisCfg(scale, yAxisOption, direction);\n\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);\n\n            _this.cache.set(axisId, axis);\n\n            updatedCache.set(axisId, axis);\n          } // 2. do grid update\n\n\n          var grid = _this.cache.get(gridId); // 存在则更新\n\n\n          if (grid) {\n            var cfg = _this.getLineGridCfg(scale, yAxisOption, direction, dim);\n\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);\n\n            if (grid) {\n              _this.cache.set(gridId, grid);\n\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else if (coordinate.isPolar) {\n          // 1. do axis update\n          var axis = _this.cache.get(axisId); // 存在则更新\n\n\n          if (axis) {\n            var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale, yAxisOption, DIRECTION.RADIUS); // @ts-ignore\n\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                axis = _this.createCircleAxis(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              axis = _this.createLineAxis(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            _this.cache.set(axisId, axis);\n\n            updatedCache.set(axisId, axis);\n          } // 2. do grid update\n\n\n          var grid = _this.cache.get(gridId); // 存在则更新\n\n\n          if (grid) {\n            var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale, yAxisOption, DIRECTION.RADIUS, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                grid = _this.createLineGrid(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              grid = _this.createCircleGrid(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            if (grid) {\n              _this.cache.set(gridId, grid);\n\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else {// helix and other, do not draw axis\n        }\n      }\n    });\n  };\n  /**\n   * 创建 line axis\n   * @param scale\n   * @param option\n   * @param layer\n   * @param direction\n   * @param dim\n   */\n\n\n  Axis.prototype.createLineAxis = function (scale, option, layer, direction, dim) {\n    // axis\n    var axis = {\n      component: new LineAxis(this.getLineAxisCfg(scale, option, direction)),\n      layer: layer,\n      direction: direction === DIRECTION.RADIUS ? DIRECTION.NONE : direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: {\n        dim: dim,\n        scale: scale\n      }\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n    return axis;\n  };\n\n  Axis.prototype.createLineGrid = function (scale, option, layer, direction, dim) {\n    var cfg = this.getLineGridCfg(scale, option, direction, dim);\n\n    if (cfg) {\n      var grid = {\n        component: new LineGrid(cfg),\n        layer: layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim: dim,\n          scale: scale,\n          alignTick: get(cfg, 'alignTick', true)\n        }\n      };\n      grid.component.init();\n      return grid;\n    }\n  };\n\n  Axis.prototype.createCircleAxis = function (scale, option, layer, direction, dim) {\n    var axis = {\n      component: new CircleAxis(this.getCircleAxisCfg(scale, option, direction)),\n      layer: layer,\n      direction: direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: {\n        dim: dim,\n        scale: scale\n      }\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n    return axis;\n  };\n\n  Axis.prototype.createCircleGrid = function (scale, option, layer, direction, dim) {\n    var cfg = this.getCircleGridCfg(scale, option, direction, dim);\n\n    if (cfg) {\n      var grid = {\n        component: new CircleGrid(cfg),\n        layer: layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim: dim,\n          scale: scale,\n          alignTick: get(cfg, 'alignTick', true)\n        }\n      };\n      grid.component.init();\n      return grid;\n    }\n  };\n  /**\n   * generate line axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return line axis cfg\n   */\n\n\n  Axis.prototype.getLineAxisCfg = function (scale, axisOption, direction) {\n    var container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    var coordinate = this.view.getCoordinate();\n    var region = getAxisRegion(coordinate, direction);\n    var titleText = getAxisTitleText(scale, axisOption);\n    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction); // the cfg order should be ensure\n\n    var optionWithTitle = get(axisOption, ['title']) ? deepMix({\n      title: {\n        style: {\n          text: titleText\n        }\n      }\n    }, {\n      title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title)\n    }, axisOption) : axisOption;\n    var cfg = deepMix(__assign(__assign({\n      container: container\n    }, region), {\n      ticks: scale.getTicks().map(function (tick) {\n        return {\n          id: \"\".concat(tick.tickValue),\n          name: tick.text,\n          value: tick.value\n        };\n      }),\n      verticalFactor: coordinate.isPolar ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate.getCenter()),\n      theme: axisThemeCfg\n    }), axisThemeCfg, optionWithTitle);\n\n    var _a = this.getAnimateCfg(cfg),\n        animate = _a.animate,\n        animateOption = _a.animateOption;\n\n    cfg.animateOption = animateOption;\n    cfg.animate = animate; // 计算 verticalLimitLength\n\n    var isAxisVertical = isVertical(region); // TODO: 1 / 3 等默认值需要有一个全局的配置的地方\n\n    var verticalLimitLength = get(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);\n\n    if (verticalLimitLength <= 1) {\n      // 配置的相对值，相对于画布\n      var canvasWidth = this.view.getCanvas().get('width');\n      var canvasHeight = this.view.getCanvas().get('height');\n      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);\n    }\n\n    return cfg;\n  };\n  /**\n   * generate line grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @param dim\n   * @return line grid cfg\n   */\n\n\n  Axis.prototype.getLineGridCfg = function (scale, axisOption, direction, dim) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n\n    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction); // the cfg order should be ensure\n    // grid 动画以 axis 为准\n\n    var gridCfg = deepMix({\n      container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer\n    }, gridThemeCfg, get(axisOption, 'grid'), this.getAnimateCfg(axisOption));\n    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale, dim, get(gridCfg, 'alignTick', true));\n    return gridCfg;\n  };\n  /**\n   * generate circle axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle axis cfg\n   */\n\n\n  Axis.prototype.getCircleAxisCfg = function (scale, axisOption, direction) {\n    var container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    var coordinate = this.view.getCoordinate();\n    var ticks = scale.getTicks().map(function (tick) {\n      return {\n        id: \"\".concat(tick.tickValue),\n        name: tick.text,\n        value: tick.value\n      };\n    });\n\n    if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {\n      // x 轴对应的值如果是非 cat 类型，在整圆的情况下坐标轴第一个和最后一个文本会重叠，默认只展示第一个文本\n      ticks.pop();\n    }\n\n    var titleText = getAxisTitleText(scale, axisOption);\n    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE); // the cfg order should be ensure\n\n    var optionWithTitle = get(axisOption, ['title']) ? deepMix({\n      title: {\n        style: {\n          text: titleText\n        }\n      }\n    }, {\n      title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title)\n    }, axisOption) : axisOption;\n    var cfg = deepMix(__assign(__assign({\n      container: container\n    }, getCircleAxisCenterRadius(this.view.getCoordinate())), {\n      ticks: ticks,\n      verticalFactor: 1,\n      theme: axisThemeCfg\n    }), axisThemeCfg, optionWithTitle);\n\n    var _a = this.getAnimateCfg(cfg),\n        animate = _a.animate,\n        animateOption = _a.animateOption;\n\n    cfg.animate = animate;\n    cfg.animateOption = animateOption;\n    return cfg;\n  };\n  /**\n   * generate circle grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle grid cfg\n   */\n\n\n  Axis.prototype.getCircleGridCfg = function (scale, axisOption, direction, dim) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    } // the cfg order should be ensure\n    // grid 动画以 axis 为准\n\n\n    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);\n    var gridCfg = deepMix({\n      container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,\n      center: this.view.getCoordinate().getCenter()\n    }, gridThemeCfg, get(axisOption, 'grid'), this.getAnimateCfg(axisOption));\n    var alignTick = get(gridCfg, 'alignTick', true);\n    var verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();\n    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale, alignTick, dim); // the cfg order should be ensure\n    // grid 动画以 axis 为准\n\n    return gridCfg;\n  };\n\n  Axis.prototype.getId = function (name, key) {\n    var coordinate = this.view.getCoordinate(); // 坐标系类型也作为组件的 key\n\n    return \"\".concat(name, \"-\").concat(key, \"-\").concat(coordinate.type);\n  };\n\n  Axis.prototype.getAnimateCfg = function (cfg) {\n    return {\n      animate: this.view.getOptions().animate && get(cfg, 'animate'),\n      animateOption: cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG\n    };\n  };\n\n  return Axis;\n}(Controller);\n\nexport default Axis;","map":null,"metadata":{},"sourceType":"module"}