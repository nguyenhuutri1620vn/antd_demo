{"ast":null,"code":"import { isEqual } from '@antv/util';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot, getDistance } from './utils/data-preprocessing';\nimport Vector from './utils/vector';\nimport { DistanceType } from './types'; // 获取质心\n\nvar getCentroid = function getCentroid(distanceType, allPropertiesWeight, index) {\n  var centroid = [];\n\n  switch (distanceType) {\n    case DistanceType.EuclideanDistance:\n      centroid = allPropertiesWeight[index];\n      break;\n\n    default:\n      centroid = [];\n      break;\n  }\n\n  return centroid;\n};\n/**\n *  k-means算法 根据节点之间的距离将节点聚类为K个簇\n * @param data 图数据\n * @param k 质心（聚类中心）个数\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param distanceType 距离类型 默认节点属性的欧式距离\n */\n\n\nvar kMeans = function kMeans(data, k, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {\n  if (k === void 0) {\n    k = 3;\n  }\n\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n\n  if (distanceType === void 0) {\n    distanceType = DistanceType.EuclideanDistance;\n  }\n\n  var nodes = data.nodes,\n      edges = data.edges; // 距离类型为欧式距离且没有属性时，直接return\n\n  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function (node) {\n    return node.hasOwnProperty(propertyKey);\n  })) {\n    return {\n      clusters: [{\n        id: \"0\",\n        nodes: nodes\n      }],\n      clusterEdges: []\n    };\n  } // 所有节点属性集合\n\n\n  var properties = []; // 所有节点属性one-hot特征向量集合\n\n  var allPropertiesWeight = [];\n\n  if (distanceType === DistanceType.EuclideanDistance) {\n    properties = getAllProperties(nodes, propertyKey);\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  } // 记录节点的原始index，与allPropertiesWeight对应\n\n\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].originIndex = i;\n  } // 初始化质心（聚类中心）\n\n\n  var centroids = [];\n  var centroidIndexList = [];\n  var clusters = [];\n\n  for (var i = 0; i < k; i++) {\n    if (i === 0) {\n      // 随机选取质心（聚类中心）\n      var randomIndex = Math.floor(Math.random() * nodes.length);\n\n      switch (distanceType) {\n        case DistanceType.EuclideanDistance:\n          centroids[i] = allPropertiesWeight[randomIndex];\n          break;\n\n        default:\n          centroids[i] = [];\n          break;\n      }\n\n      centroidIndexList.push(randomIndex);\n      clusters[i] = [nodes[randomIndex]];\n      nodes[randomIndex].clusterId = String(i);\n    } else {\n      var maxDistance = -Infinity;\n      var maxDistanceNodeIndex = 0;\n\n      var _loop_1 = function _loop_1(m) {\n        if (!centroidIndexList.includes(m)) {\n          var totalDistance = 0;\n\n          for (var j = 0; j < centroids.length; j++) {\n            // 求节点到质心的距离（默认节点属性的欧式距离）\n            var distance = 0;\n\n            switch (distanceType) {\n              case DistanceType.EuclideanDistance:\n                distance = getDistance(allPropertiesWeight[nodes[m].originIndex], centroids[j], distanceType);\n                break;\n\n              default:\n                break;\n            }\n\n            totalDistance += distance;\n          } // 节点到各质心的平均距离（默认欧式距离）\n\n\n          var avgDistance = totalDistance / centroids.length; // 记录到已有质心最远的的距离和节点索引\n\n          if (avgDistance > maxDistance && !centroids.find(function (centroid) {\n            return isEqual(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m].originIndex));\n          })) {\n            maxDistance = avgDistance;\n            maxDistanceNodeIndex = m;\n          }\n        }\n      }; // 选取与已有质心平均距离最远的点做为新的质心\n\n\n      for (var m = 0; m < nodes.length; m++) {\n        _loop_1(m);\n      }\n\n      centroids[i] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);\n      centroidIndexList.push(maxDistanceNodeIndex);\n      clusters[i] = [nodes[maxDistanceNodeIndex]];\n      nodes[maxDistanceNodeIndex].clusterId = String(i);\n    }\n  }\n\n  var iterations = 0;\n\n  while (true) {\n    for (var i = 0; i < nodes.length; i++) {\n      var minDistanceIndex = 0;\n      var minDistance = Infinity;\n\n      if (!(iterations === 0 && centroidIndexList.includes(i))) {\n        for (var j = 0; j < centroids.length; j++) {\n          // 求节点到质心的距离（默认节点属性的欧式距离）\n          var distance = 0;\n\n          switch (distanceType) {\n            case DistanceType.EuclideanDistance:\n              distance = getDistance(allPropertiesWeight[i], centroids[j], distanceType);\n              break;\n\n            default:\n              break;\n          } // 记录节点最近的质心的索引\n\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            minDistanceIndex = j;\n          }\n        } // 从原来的类别删除节点\n\n\n        if (nodes[i].clusterId !== undefined) {\n          for (var n = clusters[Number(nodes[i].clusterId)].length - 1; n >= 0; n--) {\n            if (clusters[Number(nodes[i].clusterId)][n].id === nodes[i].id) {\n              clusters[Number(nodes[i].clusterId)].splice(n, 1);\n            }\n          }\n        } // 将节点划分到距离最小的质心（聚类中心）所对应的类中\n\n\n        nodes[i].clusterId = String(minDistanceIndex);\n        clusters[minDistanceIndex].push(nodes[i]);\n      }\n    } // 是否存在质心（聚类中心）移动\n\n\n    var centroidsEqualAvg = false;\n\n    for (var i = 0; i < clusters.length; i++) {\n      var clusterNodes = clusters[i];\n      var totalVector = new Vector([]);\n\n      for (var j = 0; j < clusterNodes.length; j++) {\n        totalVector = totalVector.add(new Vector(allPropertiesWeight[clusterNodes[j].originIndex]));\n      } // 计算每个类别的均值向量\n\n\n      var avgVector = totalVector.avg(clusterNodes.length); // 如果均值向量不等于质心向量\n\n      if (!avgVector.equal(new Vector(centroids[i]))) {\n        centroidsEqualAvg = true; // 移动/更新每个类别的质心（聚类中心）到该均值向量\n\n        centroids[i] = avgVector.getArr();\n      }\n    }\n\n    iterations++; // 如果每个节点都归属了类别，且不存在质心（聚类中心）移动或者迭代次数超过1000，则停止\n\n    if (nodes.every(function (node) {\n      return node.clusterId !== undefined;\n    }) && centroidsEqualAvg || iterations >= 1000) {\n      break;\n    }\n  } // get the cluster edges\n\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var _a, _b;\n\n    var source = edge.source,\n        target = edge.target;\n    var sourceClusterId = (_a = nodes.find(function (node) {\n      return node.id === source;\n    })) === null || _a === void 0 ? void 0 : _a.clusterId;\n    var targetClusterId = (_b = nodes.find(function (node) {\n      return node.id === target;\n    })) === null || _b === void 0 ? void 0 : _b.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  return {\n    clusters: clusters,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default kMeans;","map":null,"metadata":{},"sourceType":"module"}