{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport React, { useState, useCallback, useLayoutEffect, useRef } from 'react';\nimport ReactDOM from 'react-dom';\nimport { NodeView } from '@antv/x6';\nimport { Wrap } from '../wrap';\nconst action = 'react';\nexport function createPortal(uniqViewId) {\n  const setGraphRef = {\n    current: () => {}\n  };\n\n  const setGraph = graph => {\n    setGraphRef.current(graph);\n  };\n\n  let add;\n  let remove;\n\n  function connect(id, portal) {\n    add({\n      id,\n      portal\n    });\n  }\n\n  function disconnect(id) {\n    remove(id);\n  }\n\n  const Portal = () => {\n    const [items, setItems] = useState([]);\n    const [graph, setGraphInstance] = useState();\n    const pendingAddIdsRef = useRef([]);\n    const pendingAddItemsRef = useRef([]);\n    setGraphRef.current = setGraphInstance;\n    const addItem = useCallback(payload => {\n      const {\n        id\n      } = payload;\n\n      if (pendingAddIdsRef.current.includes(id)) {\n        // if in pendingAddIds queue\n        const itms = pendingAddItemsRef.current;\n        const matchIndex = itms.findIndex(item => item.id === id);\n\n        if (matchIndex > -1) {\n          itms[matchIndex] = payload;\n        } else {\n          itms.push(payload);\n        }\n\n        pendingAddItemsRef.current = itms;\n      } else {\n        // if not in pendingAddIds queue\n        setItems(prevItems => {\n          const nextItems = [...prevItems];\n          const matchIndex = nextItems.findIndex(item => item.id === id);\n\n          if (matchIndex > -1) {\n            nextItems[matchIndex] = payload;\n          } else {\n            nextItems.push(payload);\n          }\n\n          return nextItems;\n        });\n      }\n    }, []);\n    add = addItem;\n    const removeItem = useCallback(id => {\n      if (pendingAddIdsRef.current.includes(id)) {\n        pendingAddIdsRef.current = pendingAddIdsRef.current.filter(cId => cId !== id);\n      }\n\n      if (pendingAddItemsRef.current.map(c => c.id).includes(id)) {\n        pendingAddItemsRef.current = pendingAddItemsRef.current.filter(c => c.id !== id);\n      }\n\n      setItems(itms => itms.filter(item => item.id !== id));\n    }, []);\n    remove = removeItem;\n    const startBatch = useCallback(args => {\n      const {\n        name,\n        data\n      } = args;\n      const {\n        cells = []\n      } = data || {};\n\n      if (name === 'add') {\n        const cellIds = cells.filter(cell => cell.isNode()).map(cell => cell.id);\n        pendingAddIdsRef.current = Array.from(new Set([...pendingAddIdsRef.current, ...cellIds]));\n      }\n    }, []);\n    const stopBatch = useCallback(_ref => {\n      let {\n        name\n      } = _ref;\n\n      if (name === 'add') {\n        const pendingAdds = pendingAddItemsRef.current;\n\n        if (pendingAdds.length) {\n          const currentPendingAddIds = pendingAdds.map(pendingAddItem => pendingAddItem.id);\n          pendingAddIdsRef.current = pendingAddIdsRef.current.filter(id => !currentPendingAddIds.includes(id));\n          pendingAddItemsRef.current = [];\n          setItems(prevItems => {\n            const nextItems = [...prevItems];\n            pendingAdds.forEach(pendingAddItem => {\n              const matchIndex = nextItems.findIndex(item => item.id === pendingAddItem.id);\n\n              if (matchIndex > -1) {\n                nextItems[matchIndex] = pendingAddItem;\n              } else {\n                nextItems.push(pendingAddItem);\n              }\n            });\n            return nextItems;\n          });\n        }\n      }\n    }, []);\n    useLayoutEffect(() => {\n      if (graph) {\n        graph.on('batch:start', startBatch);\n        graph.on('batch:stop', stopBatch);\n      }\n\n      return () => {\n        if (graph) {\n          graph.off('batch:start', startBatch);\n          graph.off('batch:stop', stopBatch);\n          setItems([]);\n          pendingAddIdsRef.current = [];\n          pendingAddItemsRef.current = [];\n        }\n      };\n    }, [graph, startBatch, stopBatch]);\n    return React.createElement(React.Fragment, null, ...items.map(item => item.portal));\n  };\n\n  class ReactShapeView extends NodeView {\n    init() {\n      super.init();\n      this.cell.on('removed', () => {\n        disconnect(this.cell.id);\n      });\n    }\n\n    getComponentContainer() {\n      return this.cell.prop('useForeignObject') === false ? this.selectors.content : this.selectors.foContent;\n    }\n\n    confirmUpdate(flag) {\n      const ret = super.confirmUpdate(flag);\n      return this.handleAction(ret, action, () => this.renderReactComponent());\n    }\n\n    renderReactComponent() {\n      this.unmountReactComponent();\n      const root = this.getComponentContainer();\n      const node = this.cell;\n      const graph = this.graph;\n\n      if (root) {\n        const component = this.graph.hook.getReactComponent(node);\n        const elem = React.createElement(Wrap, {\n          graph,\n          node,\n          component\n        });\n        connect(this.cell.id, ReactDOM.createPortal(elem, root));\n      }\n    }\n\n    unmountReactComponent() {\n      const root = this.getComponentContainer();\n\n      if (root) {\n        ReactDOM.unmountComponentAtNode(root);\n      }\n\n      return root;\n    }\n\n    onMouseDown(e, x, y) {\n      const target = e.target;\n      const tagName = target.tagName.toLowerCase();\n\n      if (tagName === 'input') {\n        const type = target.getAttribute('type');\n\n        if (type == null || ['text', 'password', 'number', 'email', 'search', 'tel', 'url'].includes(type)) {\n          return;\n        }\n      }\n\n      super.onMouseDown(e, x, y);\n    }\n\n    dispose() {\n      disconnect(this.cell.id);\n      this.unmountReactComponent();\n    }\n\n  }\n\n  __decorate([NodeView.dispose()], ReactShapeView.prototype, \"dispose\", null);\n\n  ReactShapeView.config({\n    bootstrap: [action],\n    actions: {\n      component: action\n    }\n  });\n  NodeView.registry.register(uniqViewId, ReactShapeView, true);\n  return {\n    Portal,\n    setGraph\n  };\n}\nexport function usePortal(uniqViewId) {\n  const initializedRef = useRef(false);\n  const [PortalContainer] = useState(() => {\n    if (!initializedRef.current) {\n      initializedRef.current = true;\n      return createPortal(uniqViewId);\n    }\n\n    return {}; // won't be used\n  });\n  return [PortalContainer.Portal, PortalContainer.setGraph];\n}","map":null,"metadata":{},"sourceType":"module"}