{"ast":null,"code":"import * as util from './util';\nimport { Angle } from './angle';\nimport { Geometry } from './geometry';\nexport class Point extends Geometry {\n  constructor(x, y) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n  }\n\n  get [Symbol.toStringTag]() {\n    return Point.toStringTag;\n  }\n  /**\n   * Rounds the point to the given precision.\n   */\n\n\n  round() {\n    let precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.x = util.round(this.x, precision);\n    this.y = util.round(this.y, precision);\n    return this;\n  }\n\n  add(x, y) {\n    const p = Point.create(x, y);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  update(x, y) {\n    const p = Point.create(x, y);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.x += t.x;\n    this.y += t.y;\n    return this;\n  }\n  /**\n   * Rotate the point by `degree` around `center`.\n   */\n\n\n  rotate(degree, center) {\n    const p = Point.rotate(this, degree, center);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n  /**\n   * Scale point by `sx` and `sy` around the given `origin`. If origin is not\n   * specified, the point is scaled around `0,0`.\n   */\n\n\n  scale(sx, sy) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    const ref = Point.create(origin);\n    this.x = ref.x + sx * (this.x - ref.x);\n    this.y = ref.y + sy * (this.y - ref.y);\n    return this;\n  }\n  /**\n   * Chooses the point closest to this point from among `points`. If `points`\n   * is an empty array, `null` is returned.\n   */\n\n\n  closest(points) {\n    if (points.length === 1) {\n      return Point.create(points[0]);\n    }\n\n    let ret = null;\n    let min = Infinity;\n    points.forEach(p => {\n      const dist = this.squaredDistance(p);\n\n      if (dist < min) {\n        ret = p;\n        min = dist;\n      }\n    });\n    return ret ? Point.create(ret) : null;\n  }\n  /**\n   * Returns the distance between the point and another point `p`.\n   */\n\n\n  distance(p) {\n    return Math.sqrt(this.squaredDistance(p));\n  }\n  /**\n   * Returns the squared distance between the point and another point `p`.\n   *\n   * Useful for distance comparisons in which real distance is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n\n\n  squaredDistance(p) {\n    const ref = Point.create(p);\n    const dx = this.x - ref.x;\n    const dy = this.y - ref.y;\n    return dx * dx + dy * dy;\n  }\n\n  manhattanDistance(p) {\n    const ref = Point.create(p);\n    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);\n  }\n  /**\n   * Returns the magnitude of the point vector.\n   *\n   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n   */\n\n\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p` and\n   * the x-axis.\n   */\n\n\n  theta() {\n    let p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Point();\n    const ref = Point.create(p);\n    const y = -(ref.y - this.y); // invert the y-axis.\n\n    const x = ref.x - this.x;\n    let rad = Math.atan2(y, x); // Correction for III. and IV. quadrant.\n\n    if (rad < 0) {\n      rad = 2 * Math.PI + rad;\n    }\n\n    return 180 * rad / Math.PI;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p1` and\n   * the vector from this point to `p2`.\n   *\n   * The ordering of points `p1` and `p2` is important.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n   * `360` when the angle is counterclockwise.\n   *\n   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n   */\n\n\n  angleBetween(p1, p2) {\n    if (this.equals(p1) || this.equals(p2)) {\n      return NaN;\n    }\n\n    let angle = this.theta(p2) - this.theta(p1);\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    return angle;\n  }\n  /**\n   * Returns the angle(in degrees) between the line from `(0,0)` and this point\n   * and the line from `(0,0)` to `p`.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from this point to `p`) is clockwise, and a value between `180`\n   * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n   * point `(0,0)` or if `p` is `(0,0)`.\n   */\n\n\n  vectorAngle(p) {\n    const zero = new Point(0, 0);\n    return zero.angleBetween(this, p);\n  }\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n\n\n  toPolar(origin) {\n    this.update(Point.toPolar(this, origin));\n    return this;\n  }\n  /**\n   * Returns the change in angle(in degrees) that is the result of moving the\n   * point from its previous position to its current position.\n   *\n   * More specifically, this function computes the angle between the line from\n   * the ref point to the previous position of this point(i.e. current position\n   * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n   * this point.\n   *\n   * The function returns a positive value between `0` and `180` when the angle\n   * (in the direction from previous position of this point to its current\n   * position) is clockwise, and a negative value between `0` and `-180` when\n   * the angle is counterclockwise.\n   *\n   * The function returns `0` if the previous and current positions of this\n   * point are the same (i.e. both `dx` and `dy` are `0`).\n   */\n\n\n  changeInAngle(dx, dy) {\n    let ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);\n  }\n  /**\n   * If the point lies outside the rectangle `rect`, adjust the point so that\n   * it becomes the nearest point on the boundary of `rect`.\n   */\n\n\n  adhereToRect(rect) {\n    if (!util.containsPoint(rect, this)) {\n      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);\n      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the bearing(cardinal direction) between me and the given point.\n   *\n   * @see https://en.wikipedia.org/wiki/Cardinal_direction\n   */\n\n\n  bearing(p) {\n    const ref = Point.create(p);\n    const lat1 = Angle.toRad(this.y);\n    const lat2 = Angle.toRad(ref.y);\n    const lon1 = this.x;\n    const lon2 = ref.x;\n    const dLon = Angle.toRad(lon2 - lon1);\n    const y = Math.sin(dLon) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n    const brng = Angle.toDeg(Math.atan2(y, x));\n    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n    let index = brng - 22.5;\n\n    if (index < 0) {\n      index += 360;\n    }\n\n    index = parseInt(index / 45, 10);\n    return bearings[index];\n  }\n  /**\n   * Returns the cross product of the vector from me to `p1` and the vector\n   * from me to `p2`.\n   *\n   * The left-hand rule is used because the coordinate system is left-handed.\n   */\n\n\n  cross(p1, p2) {\n    if (p1 != null && p2 != null) {\n      const a = Point.create(p1);\n      const b = Point.create(p2);\n      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);\n    }\n\n    return NaN;\n  }\n  /**\n   * Returns the dot product of this point with given other point.\n   */\n\n\n  dot(p) {\n    const ref = Point.create(p);\n    return this.x * ref.x + this.y * ref.y;\n  }\n\n  diff(dx, dy) {\n    if (typeof dx === 'number') {\n      return new Point(this.x - dx, this.y - dy);\n    }\n\n    const p = Point.create(dx);\n    return new Point(this.x - p.x, this.y - p.y);\n  }\n  /**\n   * Returns an interpolation between me and point `p` for a parametert in\n   * the closed interval `[0, 1]`.\n   */\n\n\n  lerp(p, t) {\n    const ref = Point.create(p);\n    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);\n  }\n  /**\n   * Normalize the point vector, scale the line segment between `(0, 0)`\n   * and the point in order for it to have the given length. If length is\n   * not specified, it is considered to be `1`; in that case, a unit vector\n   * is computed.\n   */\n\n\n  normalize() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const scale = length / this.magnitude();\n    return this.scale(scale, scale);\n  }\n  /**\n   * Moves this point along the line starting from `ref` to this point by a\n   * certain `distance`.\n   */\n\n\n  move(ref, distance) {\n    const p = Point.create(ref);\n    const rad = Angle.toRad(p.theta(this));\n    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);\n  }\n  /**\n   * Returns a point that is the reflection of me with the center of inversion\n   * in `ref` point.\n   */\n\n\n  reflection(ref) {\n    return Point.create(ref).move(this, this.distance(ref));\n  }\n\n  snapToGrid(gx, gy) {\n    this.x = util.snapToGrid(this.x, gx);\n    this.y = util.snapToGrid(this.y, gy == null ? gx : gy);\n    return this;\n  }\n\n  equals(p) {\n    const ref = Point.create(p);\n    return ref != null && ref.x === this.x && ref.y === this.y;\n  }\n\n  clone() {\n    return Point.clone(this);\n  }\n  /**\n   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n   */\n\n\n  toJSON() {\n    return Point.toJSON(this);\n  }\n\n  serialize() {\n    return `${this.x} ${this.y}`;\n  }\n\n}\n\n(function (Point) {\n  Point.toStringTag = `X6.Geometry.${Point.name}`;\n\n  function isPoint(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Point) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const point = instance;\n\n    if ((tag == null || tag === Point.toStringTag) && typeof point.x === 'number' && typeof point.y === 'number' && typeof point.toPolar === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Point.isPoint = isPoint;\n})(Point || (Point = {}));\n\n(function (Point) {\n  function isPointLike(p) {\n    return p != null && typeof p === 'object' && typeof p.x === 'number' && typeof p.y === 'number';\n  }\n\n  Point.isPointLike = isPointLike;\n\n  function isPointData(p) {\n    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number';\n  }\n\n  Point.isPointData = isPointData;\n})(Point || (Point = {}));\n\n(function (Point) {\n  function create(x, y) {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y);\n    }\n\n    return clone(x);\n  }\n\n  Point.create = create;\n\n  function clone(p) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y);\n    }\n\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1]);\n    }\n\n    return new Point(p.x, p.y);\n  }\n\n  Point.clone = clone;\n\n  function toJSON(p) {\n    if (Point.isPoint(p)) {\n      return {\n        x: p.x,\n        y: p.y\n      };\n    }\n\n    if (Array.isArray(p)) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n\n    return {\n      x: p.x,\n      y: p.y\n    };\n  }\n\n  Point.toJSON = toJSON;\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n\n  function fromPolar(r, rad) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    let x = Math.abs(r * Math.cos(rad));\n    let y = Math.abs(r * Math.sin(rad));\n    const org = clone(origin);\n    const deg = Angle.normalize(Angle.toDeg(rad));\n\n    if (deg < 90) {\n      y = -y;\n    } else if (deg < 180) {\n      x = -x;\n      y = -y;\n    } else if (deg < 270) {\n      x = -x;\n    }\n\n    return new Point(org.x + x, org.y + y);\n  }\n\n  Point.fromPolar = fromPolar;\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n\n  function toPolar(point) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point();\n    const p = clone(point);\n    const o = clone(origin);\n    const dx = p.x - o.x;\n    const dy = p.y - o.y;\n    return new Point(Math.sqrt(dx * dx + dy * dy), // r\n    Angle.toRad(o.theta(p)));\n  }\n\n  Point.toPolar = toPolar;\n\n  function equals(p1, p2) {\n    if (p1 === p2) {\n      return true;\n    }\n\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y;\n    }\n\n    return false;\n  }\n\n  Point.equals = equals;\n\n  function equalPoints(p1, p2) {\n    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {\n      return false;\n    }\n\n    if (p1 != null && p2 != null) {\n      for (let i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  Point.equalPoints = equalPoints;\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n\n  function random(x1, x2, y1, y2) {\n    return new Point(util.random(x1, x2), util.random(y1, y2));\n  }\n\n  Point.random = random;\n\n  function rotate(point, angle, center) {\n    const rad = Angle.toRad(Angle.normalize(-angle));\n    const sin = Math.sin(rad);\n    const cos = Math.cos(rad);\n    return rotateEx(point, cos, sin, center);\n  }\n\n  Point.rotate = rotate;\n\n  function rotateEx(point, cos, sin) {\n    let center = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Point();\n    const source = clone(point);\n    const origin = clone(center);\n    const dx = source.x - origin.x;\n    const dy = source.y - origin.y;\n    const x1 = dx * cos - dy * sin;\n    const y1 = dy * cos + dx * sin;\n    return new Point(x1 + origin.x, y1 + origin.y);\n  }\n\n  Point.rotateEx = rotateEx;\n})(Point || (Point = {}));","map":null,"metadata":{},"sourceType":"module"}