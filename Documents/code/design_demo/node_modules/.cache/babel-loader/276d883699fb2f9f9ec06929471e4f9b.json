{"ast":null,"code":"import { Line } from '../line';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class LineTo extends Segment {\n  constructor(x, y) {\n    super();\n\n    if (Line.isLine(x)) {\n      this.endPoint = x.end.clone().round(2);\n    } else {\n      this.endPoint = Point.create(x, y).round(2);\n    }\n  }\n\n  get type() {\n    return 'L';\n  }\n\n  get line() {\n    return new Line(this.start, this.end);\n  }\n\n  bbox() {\n    return this.line.bbox();\n  }\n\n  closestPoint(p) {\n    return this.line.closestPoint(p);\n  }\n\n  closestPointLength(p) {\n    return this.line.closestPointLength(p);\n  }\n\n  closestPointNormalizedLength(p) {\n    return this.line.closestPointNormalizedLength(p);\n  }\n\n  closestPointTangent(p) {\n    return this.line.closestPointTangent(p);\n  }\n\n  length() {\n    return this.line.length();\n  }\n\n  divideAt(ratio) {\n    const divided = this.line.divideAt(ratio);\n    return [new LineTo(divided[0]), new LineTo(divided[1])];\n  }\n\n  divideAtLength(length) {\n    const divided = this.line.divideAtLength(length);\n    return [new LineTo(divided[0]), new LineTo(divided[1])];\n  }\n\n  getSubdivisions() {\n    return [];\n  }\n\n  pointAt(ratio) {\n    return this.line.pointAt(ratio);\n  }\n\n  pointAtLength(length) {\n    return this.line.pointAtLength(length);\n  }\n\n  tangentAt(ratio) {\n    return this.line.tangentAt(ratio);\n  }\n\n  tangentAtLength(length) {\n    return this.line.tangentAtLength(length);\n  }\n\n  isDifferentiable() {\n    if (this.previousSegment == null) {\n      return false;\n    }\n\n    return !this.start.equals(this.end);\n  }\n\n  clone() {\n    return new LineTo(this.end);\n  }\n\n  scale(sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty);\n    } else {\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  equals(s) {\n    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    const end = this.end;\n    return `${this.type} ${end.x} ${end.y}`;\n  }\n\n}\n\n(function (LineTo) {\n  function create() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const len = args.length;\n    const arg0 = args[0]; // line provided\n\n    if (Line.isLine(arg0)) {\n      return new LineTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new LineTo(arg0);\n      } // poly-line segment\n\n\n      return args.map(arg => new LineTo(arg));\n    } // coordinates provided\n\n\n    if (len === 2) {\n      return new LineTo(+args[0], +args[1]);\n    } // poly-line segment\n\n\n    const segments = [];\n\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i];\n      const y = +args[i + 1];\n      segments.push(new LineTo(x, y));\n    }\n\n    return segments;\n  }\n\n  LineTo.create = create;\n})(LineTo || (LineTo = {}));","map":null,"metadata":{},"sourceType":"module"}