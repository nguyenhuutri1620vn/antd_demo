{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nimport { Point, Line, Path } from '../../geometry'; // takes care of math. error for case when jump is too close to end of line\n\nconst CLOSE_PROXIMITY_PADDING = 1;\nconst F13 = 1 / 3;\nconst F23 = 2 / 3;\n\nfunction setupUpdating(view) {\n  let updateList = view.graph._jumpOverUpdateList; // first time setup for this paper\n\n  if (updateList == null) {\n    updateList = view.graph._jumpOverUpdateList = [];\n    /**\n     * Handler for a batch:stop event to force\n     * update of all registered links with jump over connector\n     */\n\n    view.graph.on('cell:mouseup', () => {\n      const list = view.graph._jumpOverUpdateList;\n\n      for (let i = 0; i < list.length; i += 1) {\n        list[i].update();\n      }\n    });\n    view.graph.on('model:reseted', () => {\n      updateList = view.graph._jumpOverUpdateList = [];\n    });\n  } // add this link to a list so it can be updated when some other link is updated\n\n\n  if (updateList.indexOf(view) < 0) {\n    updateList.push(view); // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n\n    const clean = () => updateList.splice(updateList.indexOf(view), 1);\n\n    view.cell.once('change:connector', clean);\n    view.cell.once('removed', clean);\n  }\n}\n\nfunction createLines(sourcePoint, targetPoint) {\n  let route = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const points = [sourcePoint, ...route, targetPoint];\n  const lines = [];\n  points.forEach((point, idx) => {\n    const next = points[idx + 1];\n\n    if (next != null) {\n      lines.push(new Line(point, next));\n    }\n  });\n  return lines;\n}\n\nfunction findLineIntersections(line, crossCheckLines) {\n  const intersections = [];\n  crossCheckLines.forEach(crossCheckLine => {\n    const intersection = line.intersectsWithLine(crossCheckLine);\n\n    if (intersection) {\n      intersections.push(intersection);\n    }\n  });\n  return intersections;\n}\n\nfunction getDistence(p1, p2) {\n  return new Line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n */\n\n\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce((memo, point, idx) => {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (skippedPoints.includes(point)) {\n      return memo;\n    } // always grab the last line from buffer and modify it\n\n\n    const lastLine = memo.pop() || line; // calculate start and end of jump by moving by a given size of jump\n\n    const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);\n    let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize); // now try to look at the next intersection point\n\n    const nextPoint = intersections[idx + 1];\n\n    if (nextPoint != null) {\n      const distance = jumpEnd.distance(nextPoint);\n\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        skippedPoints.push(nextPoint);\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      const endDistance = jumpStart.distance(lastLine.end); // if the end is too close to possible jump, draw remaining line instead of a jump\n\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        memo.push(lastLine);\n        return memo;\n      }\n    }\n\n    const startDistance = jumpEnd.distance(lastLine.start);\n\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      memo.push(lastLine);\n      return memo;\n    } // finally create a jump line\n\n\n    const jumpLine = new Line(jumpStart, jumpEnd); // it's just simple line but with a `isJump` property\n\n    jumppedLines.push(jumpLine);\n    memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));\n    return memo;\n  }, []);\n}\n\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  const path = new Path();\n  let segment; // first move to the start of a first line\n\n  segment = Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment);\n  lines.forEach((line, index) => {\n    if (jumppedLines.includes(line)) {\n      let angle;\n      let diff;\n      let control1;\n      let control2;\n\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90; // determine rotation of arc based on difference between points\n\n        diff = line.start.diff(line.end); // make sure the arc always points up (or right)\n\n        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n\n        if (xAxisRotate) {\n          angle += 180;\n        }\n\n        const center = line.getCenter();\n        const centerLine = new Line(center, line.end).rotate(angle, center);\n        let halfLine; // first half\n\n        halfLine = new Line(line.start, center);\n        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);\n        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);\n        segment = Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment); // second half\n\n        halfLine = new Line(center, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);\n        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        const xOffset = jumpSize * 0.6;\n        let yOffset = jumpSize * 1.35; // determine rotation of arc based on difference between points\n\n        diff = line.start.diff(line.end); // make sure the arc always points up (or right)\n\n        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n\n        if (xAxisRotate) {\n          yOffset *= -1;\n        }\n\n        control1 = new Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);\n        control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      const nextLine = lines[index + 1];\n\n      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {\n        segment = Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  const prevDistance = curr.distance(prev) / 2;\n  const nextDistance = curr.distance(next) / 2;\n  const startMove = -Math.min(offset, prevDistance);\n  const endMove = -Math.min(offset, nextDistance);\n  const roundedStart = curr.clone().move(prev, startMove).round();\n  const roundedEnd = curr.clone().move(next, endMove).round();\n  const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);\n  const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);\n  let segment;\n  segment = Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\n\nlet jumppedLines;\nlet skippedPoints;\nexport const jumpover = function (sourcePoint, targetPoint, routePoints) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  jumppedLines = [];\n  skippedPoints = [];\n  setupUpdating(this);\n  const jumpSize = options.size || 5;\n  const jumpType = options.type || 'arc';\n  const radius = options.radius || 0; // list of connector types not to jump over.\n\n  const ignoreConnectors = options.ignoreConnectors || ['smooth'];\n  const graph = this.graph;\n  const model = graph.model;\n  const allLinks = model.getEdges(); // there is just one link, draw it directly\n\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);\n  }\n\n  const edge = this.cell;\n  const thisIndex = allLinks.indexOf(edge);\n  const defaultConnector = graph.options.connecting.connector || {}; // not all links are meant to be jumped over.\n\n  const edges = allLinks.filter((link, idx) => {\n    const connector = link.getConnector() || defaultConnector; // avoid jumping over links with connector type listed in `ignored connectors`.\n\n    if (ignoreConnectors.includes(connector.name)) {\n      return false;\n    } // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n\n\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n\n    return true;\n  }); // find views for all links\n\n  const linkViews = edges.map(edge => {\n    return graph.renderer.findViewByCell(edge);\n  }); // create lines for this link\n\n  const thisLines = createLines(sourcePoint, targetPoint, routePoints); // create lines for all other links\n\n  const linkLines = linkViews.map(linkView => {\n    if (linkView == null) {\n      return [];\n    }\n\n    if (linkView === this) {\n      return thisLines;\n    }\n\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);\n  }); // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n\n  const jumpingLines = [];\n  thisLines.forEach(line => {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n    const intersections = edges.reduce((memo, link, i) => {\n      // don't intersection with itself\n      if (link !== edge) {\n        const lineIntersections = findLineIntersections(line, linkLines[i]);\n        memo.push(...lineIntersections);\n      }\n\n      return memo;\n    }, []).sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));\n\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      jumpingLines.push(...createJumps(line, intersections, jumpSize));\n    } else {\n      // without any intersection the line goes uninterrupted\n      jumpingLines.push(line);\n    }\n  });\n  const path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  jumppedLines = [];\n  skippedPoints = [];\n  return options.raw ? path : path.serialize();\n};","map":null,"metadata":{},"sourceType":"module"}