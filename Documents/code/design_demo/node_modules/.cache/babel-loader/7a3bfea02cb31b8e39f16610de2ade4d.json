{"ast":null,"code":"import { ArrayExt } from '../../util';\nimport { Config } from '../../global/config';\nimport { Graph } from '../../graph/graph';\nimport { Model } from '../../model/model';\nexport class Clipboard {\n  constructor() {\n    this.cells = [];\n  }\n\n  copy(cells, graph) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.options = Object.assign({}, options);\n    const model = Model.isModel(graph) ? graph : graph.model;\n    const cloned = model.cloneSubGraph(cells, options); // sort asc by cell type\n\n    this.cells = ArrayExt.sortBy(Object.keys(cloned).map(key => cloned[key]), cell => cell.isEdge() ? 2 : 1);\n    this.serialize(options);\n  }\n\n  cut(cells, graph) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.copy(cells, graph, options);\n    const model = Graph.isGraph(graph) ? graph.model : graph;\n    model.batchUpdate('cut', () => {\n      cells.forEach(cell => cell.remove());\n    });\n  }\n\n  paste(graph) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const localOptions = Object.assign(Object.assign({}, this.options), options);\n    const {\n      offset,\n      edgeProps,\n      nodeProps\n    } = localOptions;\n    let dx = 20;\n    let dy = 20;\n\n    if (offset) {\n      dx = typeof offset === 'number' ? offset : offset.dx;\n      dy = typeof offset === 'number' ? offset : offset.dy;\n    }\n\n    this.deserialize(localOptions);\n    const cells = this.cells;\n    cells.forEach(cell => {\n      cell.model = null;\n      cell.removeProp('zIndex');\n\n      if (dx || dy) {\n        cell.translate(dx, dy);\n      }\n\n      if (nodeProps && cell.isNode()) {\n        cell.prop(nodeProps);\n      }\n\n      if (edgeProps && cell.isEdge()) {\n        cell.prop(edgeProps);\n      }\n    });\n    const model = Graph.isGraph(graph) ? graph.model : graph;\n    model.batchUpdate('paste', () => {\n      model.addCells(this.cells);\n    });\n    this.copy(cells, graph, options);\n    return cells;\n  }\n\n  serialize(options) {\n    if (options.useLocalStorage !== false) {\n      Storage.save(this.cells);\n    }\n  }\n\n  deserialize(options) {\n    if (options.useLocalStorage) {\n      const cells = Storage.fetch();\n\n      if (cells) {\n        this.cells = cells;\n      }\n    }\n  }\n\n  isEmpty() {\n    return this.cells.length <= 0;\n  }\n\n  clean() {\n    this.options = {};\n    this.cells = [];\n    Storage.clean();\n  }\n\n}\nvar Storage;\n\n(function (Storage) {\n  const LOCAL_STORAGE_KEY = `${Config.prefixCls}.clipboard.cells`;\n\n  function save(cells) {\n    if (window.localStorage) {\n      const data = cells.map(cell => cell.toJSON());\n      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));\n    }\n  }\n\n  Storage.save = save;\n\n  function fetch() {\n    if (window.localStorage) {\n      const raw = localStorage.getItem(LOCAL_STORAGE_KEY);\n      const cells = raw ? JSON.parse(raw) : [];\n\n      if (cells) {\n        return Model.fromJSON(cells);\n      }\n    }\n  }\n\n  Storage.fetch = fetch;\n\n  function clean() {\n    if (window.localStorage) {\n      localStorage.removeItem(LOCAL_STORAGE_KEY);\n    }\n  }\n\n  Storage.clean = clean;\n})(Storage || (Storage = {}));","map":null,"metadata":{},"sourceType":"module"}