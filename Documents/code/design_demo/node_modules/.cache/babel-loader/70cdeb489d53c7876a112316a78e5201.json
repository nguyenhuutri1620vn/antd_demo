{"ast":null,"code":"import { Point } from '../../geometry';\nimport { Dom, NumberExt, FunctionExt } from '../../util';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nexport class Button extends ToolsView.ToolItem {\n  onRender() {\n    Dom.addClass(this.container, this.prefixClassName('cell-tool-button'));\n    this.update();\n  }\n\n  update() {\n    this.updatePosition();\n    return this;\n  }\n\n  updatePosition() {\n    const view = this.cellView;\n    const matrix = view.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();\n    Dom.transform(this.container, matrix, {\n      absolute: true\n    });\n  }\n\n  getNodeMatrix() {\n    const view = this.cellView;\n    const options = this.options;\n    let {\n      x = 0,\n      y = 0\n    } = options;\n    const {\n      offset,\n      useCellGeometry,\n      rotate\n    } = options;\n    let bbox = Util.getViewBBox(view, useCellGeometry);\n    const angle = view.cell.getAngle();\n\n    if (!rotate) {\n      bbox = bbox.bbox(angle);\n    }\n\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (typeof offset === 'number') {\n      offsetX = offset;\n      offsetY = offset;\n    } else if (typeof offset === 'object') {\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n\n    x = NumberExt.normalizePercentage(x, bbox.width);\n    y = NumberExt.normalizePercentage(y, bbox.height);\n    let matrix = Dom.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\n    if (rotate) {\n      matrix = matrix.rotate(angle);\n    }\n\n    matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n    return matrix;\n  }\n\n  getEdgeMatrix() {\n    const view = this.cellView;\n    const options = this.options;\n    const {\n      offset = 0,\n      distance = 0,\n      rotate\n    } = options;\n    let tangent;\n    let position;\n    let angle;\n\n    if (NumberExt.isPercentage(distance)) {\n      tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n    } else {\n      tangent = view.getTangentAtLength(distance);\n    }\n\n    if (tangent) {\n      position = tangent.start;\n      angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n    } else {\n      position = view.getConnection().start;\n      angle = 0;\n    }\n\n    let matrix = Dom.createSVGMatrix().translate(position.x, position.y).rotate(angle);\n\n    if (typeof offset === 'object') {\n      matrix = matrix.translate(offset.x || 0, offset.y || 0);\n    } else {\n      matrix = matrix.translate(0, offset);\n    }\n\n    if (!rotate) {\n      matrix = matrix.rotate(-angle);\n    }\n\n    return matrix;\n  }\n\n  onMouseDown(e) {\n    if (this.guard(e)) {\n      return;\n    }\n\n    e.stopPropagation();\n    e.preventDefault();\n    const onClick = this.options.onClick;\n\n    if (typeof onClick === 'function') {\n      FunctionExt.call(onClick, this.cellView, {\n        e,\n        view: this.cellView,\n        cell: this.cellView.cell,\n        btn: this\n      });\n    }\n  }\n\n}\n\n(function (Button) {\n  Button.config({\n    name: 'button',\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown'\n    }\n  });\n})(Button || (Button = {}));\n\n(function (Button) {\n  Button.Remove = Button.define({\n    name: 'button-remove',\n    markup: [{\n      tagName: 'circle',\n      selector: 'button',\n      attrs: {\n        r: 7,\n        fill: '#FF1D00',\n        cursor: 'pointer'\n      }\n    }, {\n      tagName: 'path',\n      selector: 'icon',\n      attrs: {\n        d: 'M -3 -3 3 3 M -3 3 3 -3',\n        fill: 'none',\n        stroke: '#FFFFFF',\n        'stroke-width': 2,\n        'pointer-events': 'none'\n      }\n    }],\n    distance: 60,\n    offset: 0,\n\n    onClick(_ref) {\n      let {\n        view,\n        btn\n      } = _ref;\n      btn.parent.remove();\n      view.cell.remove({\n        ui: true,\n        toolId: btn.cid\n      });\n    }\n\n  });\n})(Button || (Button = {}));","map":null,"metadata":{},"sourceType":"module"}