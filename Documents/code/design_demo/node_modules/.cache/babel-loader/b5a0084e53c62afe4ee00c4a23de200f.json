{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { contains, filter, find, isArray, isEmpty, isFunction, isNil, isNumberEqual, isObject, memoize, get, values } from '@antv/util';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { getName, inferScaleType } from './scale';\n\nfunction snapEqual(v1, v2, scale) {\n  var value1 = scale.translate(v1);\n  var value2 = scale.translate(v2);\n  return isNumberEqual(value1, value2);\n}\n\nfunction getXValueByPoint(point, geometry) {\n  var coordinate = geometry.coordinate;\n  var xScale = geometry.getXScale();\n  var range = xScale.range;\n  var rangeMax = range[range.length - 1];\n  var rangeMin = range[0];\n  var invertPoint = coordinate.invert(point);\n  var xValue = invertPoint.x;\n\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n\n  return xScale.translate(xScale.invert(xValue));\n}\n\nfunction filterYValue(data, point, geometry) {\n  var coordinate = geometry.coordinate;\n  var yScale = geometry.getYScale();\n  var yField = yScale.field;\n  var invertPoint = coordinate.invert(point);\n  var yValue = yScale.invert(invertPoint.y);\n  var result = find(data, function (obj) {\n    var originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\n\nvar getXDistance = memoize(function (scale) {\n  if (scale.isCategory) {\n    return 1;\n  }\n\n  var scaleValues = scale.values; // values 是无序的\n\n  var length = scaleValues.length;\n  var min = scale.translate(scaleValues[0]);\n  var max = min;\n\n  for (var index = 0; index < length; index++) {\n    var value = scaleValues[index]; // 时间类型需要 translate\n\n    var numericValue = scale.translate(value);\n\n    if (numericValue < min) {\n      min = numericValue;\n    }\n\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n\n  return (max - min) / (length - 1);\n});\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\n\nfunction getTooltipTitle(originData, geometry, title) {\n  var positionAttr = geometry.getAttribute('position');\n  var fields = positionAttr.getFields();\n  var scales = geometry.scales;\n  var titleField = isFunction(title) || !title ? fields[0] : title;\n  var titleScale = scales[titleField]; // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n\n  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\n\nfunction getAttributesForLegend(geometry) {\n  var attributes = values(geometry.attributes);\n  return filter(attributes, function (attribute) {\n    return contains(GROUP_ATTRS, attribute.type);\n  });\n}\n\nfunction getTooltipValueScale(geometry) {\n  var attributes = getAttributesForLegend(geometry);\n  var scale;\n\n  for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n    var attribute = attributes_1[_i];\n    var tmpScale = attribute.getScale(attribute.type);\n\n    if (tmpScale && tmpScale.isLinear) {\n      var tmpScaleDef = get(geometry.scaleDefs, tmpScale.field);\n      var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);\n\n      if (inferedScaleType !== 'cat') {\n        // 如果指定字段是非 position 的，同时是连续的\n        scale = tmpScale;\n        break;\n      }\n    }\n  }\n\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  return scale || yScale || xScale;\n}\n\nfunction getTooltipValue(originData, valueScale) {\n  var field = valueScale.field;\n  var value = originData[field];\n\n  if (isArray(value)) {\n    var texts = value.map(function (eachValue) {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n\n  return valueScale.getText(value);\n} // 根据原始数据获取 tooltip item 中 name 值\n\n\nfunction getTooltipName(originData, geometry) {\n  var nameScale;\n  var groupScales = geometry.getGroupScales();\n\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n\n  if (nameScale) {\n    var field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n\n  var valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\n\n\nexport function findDataByPoint(point, data, geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n\n  var geometryType = geometry.type;\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  var xField = xScale.field;\n  var yField = yScale.field;\n  var rst = null; // 热力图采用最小逼近策略查找 point 击中的数据\n\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    var coordinate = geometry.coordinate;\n    var invertPoint = coordinate.invert(point); // 转换成归一化的数据\n\n    var x = xScale.invert(invertPoint.x); // 转换为原始值\n\n    var y = yScale.invert(invertPoint.y); // 转换为原始值\n\n    var min = Infinity;\n\n    for (var index = 0; index < data.length; index++) {\n      var obj = data[index];\n      var originData = obj[FIELD_ORIGIN];\n      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);\n\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n\n    return rst;\n  } // 其他 Geometry 类型按照 x 字段数据进行查找\n\n\n  var first = data[0];\n  var last = data[data.length - 1];\n  var xValue = getXValueByPoint(point, geometry);\n  var firstXValue = first[FIELD_ORIGIN][xField];\n  var firstYValue = first[FIELD_ORIGIN][yField];\n  var lastXValue = last[FIELD_ORIGIN][xField];\n  var isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n  // 如果 x 的值是数组\n\n  if (isArray(firstXValue)) {\n    for (var index = 0; index < data.length; index++) {\n      var record = data[index];\n      var originData = record[FIELD_ORIGIN]; // xValue 在 originData[xField] 的数值区间内\n\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    var next = void 0;\n\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (var index = 0; index < data.length; index++) {\n        var record = data[index];\n        var originData = record[FIELD_ORIGIN];\n\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {\n        // 不在数据范围内\n        return null;\n      }\n\n      var firstIdx = 0;\n      var lastIdx = data.length - 1;\n      var middleIdx = void 0;\n\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        var item = data[middleIdx][FIELD_ORIGIN][xField];\n\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n\n    if (last && next) {\n      // 计算最逼近的\n      if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {\n        last = next;\n      }\n    }\n  }\n\n  var distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n\n  return rst;\n}\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\n\nexport function getTooltipItems(data, geometry, title, showNil) {\n  if (title === void 0) {\n    title = '';\n  }\n\n  if (showNil === void 0) {\n    showNil = false;\n  }\n\n  var originData = data[FIELD_ORIGIN];\n  var tooltipTitle = getTooltipTitle(originData, geometry, title);\n  var tooltipOption = geometry.tooltipOption;\n  var defaultColor = geometry.theme.defaultColor;\n  var items = [];\n  var name;\n  var value;\n\n  function addItem(itemName, itemValue) {\n    if (showNil || !isNil(itemValue) && itemValue !== '') {\n      // 值为 null的时候，忽视\n      var item = {\n        title: tooltipTitle,\n        data: originData,\n        mappingData: data,\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true\n      };\n      items.push(item);\n    }\n  }\n\n  if (isObject(tooltipOption)) {\n    var fields = tooltipOption.fields,\n        callback = tooltipOption.callback;\n\n    if (callback) {\n      // 用户定义了回调函数\n      var callbackParams = fields.map(function (field) {\n        return data[FIELD_ORIGIN][field];\n      });\n      var cfg = callback.apply(void 0, callbackParams);\n\n      var itemCfg = __assign({\n        data: data[FIELD_ORIGIN],\n        mappingData: data,\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true\n      }, cfg);\n\n      items.push(itemCfg);\n    } else {\n      var scales = geometry.scales;\n\n      for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n        var field = fields_1[_i];\n\n        if (!isNil(originData[field])) {\n          // 字段数据为null, undefined 时不显示\n          var scale = scales[field];\n          name = getName(scale);\n          value = scale.getText(originData[field]);\n          addItem(name, value);\n        }\n      }\n    }\n  } else {\n    var valueScale = getTooltipValueScale(geometry); // 字段数据为null ,undefined时不显示\n\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n\n  return items;\n}\n\nfunction getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {\n  var showNil = tooltipCfg.showNil;\n  var result = [];\n  var dataArray = geometry.dataArray;\n\n  if (!isEmpty(dataArray)) {\n    geometry.sort(dataArray); // 先进行排序，便于 tooltip 查找\n\n    for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {\n      var data = dataArray_1[_i];\n      var record = findDataByPoint(point, data, geometry);\n\n      if (record) {\n        var elementId = geometry.getElementId(record);\n        var element = geometry.elementsMap[elementId];\n\n        if (geometry.type === 'heatmap' || element.visible) {\n          // Heatmap 没有 Element\n          // 如果图形元素隐藏了，怎不再 tooltip 上展示相关数据\n          var items = getTooltipItems(record, geometry, title, showNil);\n\n          if (items.length) {\n            result.push(items);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {\n  var showNil = tooltipCfg.showNil;\n  var result = [];\n  var container = geometry.container;\n  var shape = container.getShape(point.x, point.y);\n\n  if (shape && shape.get('visible') && shape.get('origin')) {\n    var mappingData = shape.get('origin').mappingData;\n    var items = getTooltipItems(mappingData, geometry, title, showNil);\n\n    if (items.length) {\n      result.push(items);\n    }\n  }\n\n  return result;\n}\n/**\n * 不进行递归查找\n */\n\n\nexport function findItemsFromView(view, point, tooltipCfg) {\n  var result = []; // 先从 view 本身查找\n\n  var geometries = view.geometries;\n  var shared = tooltipCfg.shared,\n      title = tooltipCfg.title,\n      reversed = tooltipCfg.reversed;\n\n  for (var _i = 0, geometries_1 = geometries; _i < geometries_1.length; _i++) {\n    var geometry = geometries_1[_i];\n\n    if (geometry.visible && geometry.tooltipOption !== false) {\n      // geometry 可见同时未关闭 tooltip\n      var geometryType = geometry.type;\n      var tooltipItems = void 0;\n\n      if (['point', 'edge', 'polygon'].includes(geometryType)) {\n        // 始终通过图形拾取\n        tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n      } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {\n        // 如果是 'area', 'line', 'path'，始终通过数据查找方法查找 tooltip\n        tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n      } else {\n        if (shared !== false) {\n          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n        } else {\n          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n        }\n      }\n\n      if (tooltipItems.length) {\n        if (reversed) {\n          tooltipItems.reverse();\n        } // geometry 有可能会有多个 item，因为用户可以设置 geometry.tooltip('x*y*z')\n\n\n        result.push(tooltipItems);\n      }\n    }\n  }\n\n  return result;\n}\nexport function findItemsFromViewRecurisive(view, point, tooltipCfg) {\n  var result = findItemsFromView(view, point, tooltipCfg); // 递归查找，并合并结果\n\n  for (var _i = 0, _a = view.views; _i < _a.length; _i++) {\n    var childView = _a[_i];\n    result = result.concat(findItemsFromView(childView, point, tooltipCfg));\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}