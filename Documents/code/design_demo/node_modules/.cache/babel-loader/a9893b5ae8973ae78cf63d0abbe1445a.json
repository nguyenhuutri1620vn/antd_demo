{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _isNumber from \"lodash/isNumber\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { earthTriangulation } from '../../core/triangulation';\nvar atmoSphereFrag = \"\\nuniform float u_opacity;\\nuniform vec3 u_CameraPosition;\\n\\nvarying vec3 vVertexNormal;\\nvarying float v_offset;\\nvarying vec4 v_Color;\\nvoid main() {\\n    \\n    \\n    // float intensity = pow(0.5 + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\\n    float intensity = pow(v_offset + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\\n    // TODO: \\u53BB\\u9664\\u80CC\\u9762\\n    if(intensity > 1.0) intensity = 0.0;\\n\\n    gl_FragColor = vec4(v_Color.rgb, v_Color.a * intensity * u_opacity);\\n}\\n\";\nvar atmoSphereVert = \"\\nattribute vec3 a_Position;\\nattribute vec3 a_Normal;\\nattribute vec2 a_Uv;\\nattribute vec4 a_Color;\\nuniform vec3 u_CameraPosition;\\nvarying float v_CamreaDistance;\\n\\nuniform mat4 u_ViewProjectionMatrix;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_ViewMatrix;\\n\\nvarying vec3 vVertexNormal;\\nvarying vec4 v_Color;\\nvarying float v_offset;\\n\\nvoid main() {\\n    float EARTH_RADIUS = 100.0;\\n    \\n    v_Color = a_Color;\\n\\n    v_offset = min(((length(u_CameraPosition) - EARTH_RADIUS)/600.0) * 0.5 + 0.4, 1.0);\\n    vVertexNormal = a_Normal;\\n\\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\\n}\\n\";\n\nvar EarthAtomSphereModel = function (_BaseModel) {\n  _inherits(EarthAtomSphereModel, _BaseModel);\n\n  var _super = _createSuper(EarthAtomSphereModel);\n\n  function EarthAtomSphereModel() {\n    _classCallCheck(this, EarthAtomSphereModel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EarthAtomSphereModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          _ref$opacity = _ref.opacity,\n          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity;\n\n      return {\n        u_opacity: _isNumber(opacity) ? opacity : 1.0\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      return this.buildModels();\n    }\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      return '';\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      this.layer.zIndex = -997;\n      return [this.layer.buildLayerModel({\n        moduleName: 'earthAtmoSphere',\n        vertexShader: atmoSphereVert,\n        fragmentShader: atmoSphereFrag,\n        triangulation: earthTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$size = feature.size,\n                size = _feature$size === void 0 ? 1 : _feature$size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'normal',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Normal',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {\n            return normal;\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'uv',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Uv',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return EarthAtomSphereModel;\n}(BaseModel);\n\nexport { EarthAtomSphereModel as default };","map":null,"metadata":{},"sourceType":"module"}