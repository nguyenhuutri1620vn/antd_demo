{"ast":null,"code":"import { FunctionExt } from '../../util';\nimport { grid } from '../../layout/grid';\nimport { Node } from '../../model/node';\nimport { Model } from '../../model/model';\nimport { View } from '../../view/view';\nimport { Graph } from '../../graph/graph';\nimport { Dnd } from '../dnd';\nexport class Stencil extends View {\n  constructor(options) {\n    super();\n    this.graphs = {};\n    this.$groups = {};\n    this.options = Object.assign(Object.assign({}, Stencil.defaultOptions), options);\n    this.dnd = new Dnd(this.options);\n    this.onSearch = FunctionExt.debounce(this.onSearch, 200);\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container).addClass(this.prefixClassName(ClassNames.base)).attr('data-not-found-text', this.options.notFoundText || 'No matches found');\n    this.options.collapsable = options.collapsable && options.groups && options.groups.some(group => group.collapsable !== false);\n\n    if (this.options.collapsable) {\n      this.$container.addClass('collapsable');\n      const collapsed = options.groups && options.groups.every(group => group.collapsed || group.collapsable === false);\n\n      if (collapsed) {\n        this.$container.addClass('collapsed');\n      }\n    }\n\n    this.$('<div/>').addClass(this.prefixClassName(ClassNames.title)).html(this.options.title).appendTo(this.$container);\n\n    if (options.search) {\n      this.$container.addClass('searchable').append(this.renderSearch());\n    }\n\n    this.$content = this.$('<div/>').addClass(this.prefixClassName(ClassNames.content)).appendTo(this.$container);\n    const globalGraphOptions = options.stencilGraphOptions || {};\n\n    if (options.groups && options.groups.length) {\n      options.groups.forEach(group => {\n        const $group = this.$('<div/>').addClass(this.prefixClassName(ClassNames.group)).attr('data-name', group.name);\n\n        if (group.collapsable == null && options.collapsable || group.collapsable !== false) {\n          $group.addClass('collapsable');\n        }\n\n        $group.toggleClass('collapsed', group.collapsed === true);\n        const $title = this.$('<h3/>').addClass(this.prefixClassName(ClassNames.groupTitle)).html(group.title || group.name);\n        const $content = this.$('<div/>').addClass(this.prefixClassName(ClassNames.groupContent));\n        const graphOptionsInGroup = group.graphOptions;\n        const graph = new Graph(Object.assign(Object.assign(Object.assign({}, globalGraphOptions), graphOptionsInGroup), {\n          container: document.createElement('div'),\n          model: globalGraphOptions.model || new Model(),\n          width: group.graphWidth || options.stencilGraphWidth,\n          height: group.graphHeight || options.stencilGraphHeight,\n          interacting: false,\n          preventDefaultBlankAction: false\n        }));\n        $content.append(graph.container);\n        $group.append($title, $content).appendTo(this.$content);\n        this.$groups[group.name] = $group;\n        this.graphs[group.name] = graph;\n      });\n    } else {\n      const graph = new Graph(Object.assign(Object.assign({}, globalGraphOptions), {\n        container: document.createElement('div'),\n        model: globalGraphOptions.model || new Model(),\n        width: options.stencilGraphWidth,\n        height: options.stencilGraphHeight,\n        interacting: false,\n        preventDefaultBlankAction: false\n      }));\n      this.$content.append(graph.container);\n      this.graphs[Private.defaultGroupName] = graph;\n    }\n\n    this.startListening();\n    return this;\n  }\n\n  get targetScroller() {\n    const target = this.options.target;\n    return Graph.isGraph(target) ? target.scroller.widget : target;\n  }\n\n  get targetGraph() {\n    const target = this.options.target;\n    return Graph.isGraph(target) ? target : target.graph;\n  }\n\n  get targetModel() {\n    return this.targetGraph.model;\n  }\n\n  renderSearch() {\n    return this.$('<div/>').addClass(this.prefixClassName(ClassNames.search)).append(this.$('<input/>').attr({\n      type: 'search',\n      placeholder: this.options.placeholder || 'Search'\n    }).addClass(this.prefixClassName(ClassNames.searchText)));\n  }\n\n  startListening() {\n    const title = this.prefixClassName(ClassNames.title);\n    const searchText = this.prefixClassName(ClassNames.searchText);\n    const groupTitle = this.prefixClassName(ClassNames.groupTitle);\n    this.delegateEvents({\n      [`click .${title}`]: 'onTitleClick',\n      [`touchstart .${title}`]: 'onTitleClick',\n      [`click .${groupTitle}`]: 'onGroupTitleClick',\n      [`touchstart .${groupTitle}`]: 'onGroupTitleClick',\n      [`input .${searchText}`]: 'onSearch',\n      [`focusin .${searchText}`]: 'onSearchFocusIn',\n      [`focusout .${searchText}`]: 'onSearchFocusOut'\n    });\n    Object.keys(this.graphs).forEach(groupName => {\n      const graph = this.graphs[groupName];\n      graph.on('cell:mousedown', this.onDragStart, this);\n    });\n  }\n\n  stopListening() {\n    this.undelegateEvents();\n    Object.keys(this.graphs).forEach(groupName => {\n      const graph = this.graphs[groupName];\n      graph.off('cell:mousedown', this.onDragStart, this);\n    });\n  }\n\n  load(data, groupName) {\n    if (Array.isArray(data)) {\n      this.loadGroup(data, groupName);\n    } else if (this.options.groups) {\n      Object.keys(this.options.groups).forEach(groupName => {\n        if (data[groupName]) {\n          this.loadGroup(data[groupName], groupName);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  loadGroup(cells, groupName) {\n    const model = this.getModel(groupName);\n\n    if (model) {\n      const nodes = cells.map(cell => Node.isNode(cell) ? cell : Node.create(cell));\n      model.resetCells(nodes);\n    }\n\n    const group = this.getGroup(groupName);\n    let height = this.options.stencilGraphHeight;\n\n    if (group && group.graphHeight != null) {\n      height = group.graphHeight;\n    }\n\n    const layout = group && group.layout || this.options.layout;\n\n    if (layout && model) {\n      FunctionExt.call(layout, this, model, group);\n    }\n\n    if (!height) {\n      const graph = this.getGraph(groupName);\n      graph.fitToContent({\n        minWidth: graph.options.width,\n        gridHeight: 1,\n        padding: group && group.graphPadding || this.options.stencilGraphPadding || 10\n      });\n    }\n\n    return this;\n  }\n\n  onDragStart(args) {\n    const {\n      e,\n      node\n    } = args;\n    this.dnd.start(node, e);\n  }\n\n  filter(keyword, filter) {\n    const found = Object.keys(this.graphs).reduce((memo, groupName) => {\n      const graph = this.graphs[groupName];\n      const name = groupName === Private.defaultGroupName ? null : groupName;\n      const items = graph.model.getNodes().filter(cell => {\n        let matched = false;\n\n        if (typeof filter === 'function') {\n          matched = FunctionExt.call(filter, this, cell, keyword, name, this);\n        } else if (typeof filter === 'boolean') {\n          matched = filter;\n        } else {\n          matched = this.isCellMatched(cell, keyword, filter, keyword.toLowerCase() !== keyword);\n        }\n\n        const view = graph.renderer.findViewByCell(cell);\n\n        if (view) {\n          view.$(view.container).toggleClass('unmatched', !matched);\n        }\n\n        return matched;\n      });\n      const found = items.length > 0;\n      const options = this.options;\n      const model = new Model();\n      model.resetCells(items);\n\n      if (options.layout) {\n        FunctionExt.call(options.layout, this, model, this.getGroup(groupName));\n      }\n\n      if (this.$groups[groupName]) {\n        this.$groups[groupName].toggleClass('unmatched', !found);\n      }\n\n      graph.fitToContent({\n        gridWidth: 1,\n        gridHeight: 1,\n        padding: options.stencilGraphPadding || 10\n      });\n      return memo || found;\n    }, false);\n    this.$container.toggleClass('not-found', !found);\n  }\n\n  isCellMatched(cell, keyword, filters, ignoreCase) {\n    if (keyword && filters) {\n      return Object.keys(filters).some(shape => {\n        if (shape === '*' || cell.shape === shape) {\n          const filter = filters[shape];\n\n          if (typeof filter === 'boolean') {\n            return filter;\n          }\n\n          const paths = Array.isArray(filter) ? filter : [filter];\n          return paths.some(path => {\n            let val = cell.getPropByPath(path);\n\n            if (val != null) {\n              val = `${val}`;\n\n              if (!ignoreCase) {\n                val = val.toLowerCase();\n              }\n\n              return val.indexOf(keyword) >= 0;\n            }\n\n            return false;\n          });\n        }\n\n        return false;\n      });\n    }\n\n    return true;\n  }\n\n  onSearch(evt) {\n    this.filter(evt.target.value, this.options.search);\n  }\n\n  onSearchFocusIn() {\n    this.$container.addClass('is-focused');\n  }\n\n  onSearchFocusOut() {\n    this.$container.removeClass('is-focused');\n  }\n\n  onTitleClick() {\n    if (this.options.collapsable) {\n      this.$container.toggleClass('collapsed');\n\n      if (this.$container.hasClass('collapsed')) {\n        this.collapseGroups();\n      } else {\n        this.expandGroups();\n      }\n    }\n  }\n\n  onGroupTitleClick(evt) {\n    const $group = this.$(evt.target).closest(`.${this.prefixClassName(ClassNames.group)}`);\n    this.toggleGroup($group.attr('data-name') || '');\n    const allCollapsed = Object.keys(this.$groups).every(name => {\n      const group = this.getGroup(name);\n      const $group = this.$groups[name];\n      return group && group.collapsable === false || $group.hasClass('collapsed');\n    });\n    this.$container.toggleClass('collapsed', allCollapsed);\n  }\n\n  getModel(groupName) {\n    const graph = this.getGraph(groupName);\n    return graph ? graph.model : null;\n  }\n\n  getGraph(groupName) {\n    return this.graphs[groupName || Private.defaultGroupName];\n  }\n\n  getGroup(groupName) {\n    const groups = this.options.groups;\n\n    if (groupName != null && groups && groups.length) {\n      return groups.find(group => group.name === groupName);\n    }\n\n    return null;\n  }\n\n  toggleGroup(groupName) {\n    if (this.isGroupCollapsed(groupName)) {\n      this.expandGroup(groupName);\n    } else {\n      this.collapseGroup(groupName);\n    }\n\n    return this;\n  }\n\n  collapseGroup(groupName) {\n    if (this.isGroupCollapsable(groupName)) {\n      const $group = this.$groups[groupName];\n\n      if ($group && !this.isGroupCollapsed(groupName)) {\n        this.trigger('group:collapse', {\n          name: groupName\n        });\n        $group.addClass('collapsed');\n      }\n    }\n\n    return this;\n  }\n\n  expandGroup(groupName) {\n    if (this.isGroupCollapsable(groupName)) {\n      const $group = this.$groups[groupName];\n\n      if ($group && this.isGroupCollapsed(groupName)) {\n        this.trigger('group:expand', {\n          name: groupName\n        });\n        $group.removeClass('collapsed');\n      }\n    }\n\n    return this;\n  }\n\n  isGroupCollapsable(groupName) {\n    const $group = this.$groups[groupName];\n    return $group.hasClass('collapsable');\n  }\n\n  isGroupCollapsed(groupName) {\n    const $group = this.$groups[groupName];\n    return $group && $group.hasClass('collapsed');\n  }\n\n  collapseGroups() {\n    Object.keys(this.$groups).forEach(groupName => this.collapseGroup(groupName));\n    return this;\n  }\n\n  expandGroups() {\n    Object.keys(this.$groups).forEach(groupName => this.expandGroup(groupName));\n    return this;\n  }\n\n  resizeGroup(groupName, size) {\n    const graph = this.graphs[groupName];\n\n    if (graph) {\n      graph.resize(size.width, size.height);\n    }\n\n    return this;\n  }\n\n  onRemove() {\n    Object.keys(this.graphs).forEach(groupName => {\n      const graph = this.graphs[groupName];\n      graph.view.remove();\n      delete this.graphs[groupName];\n    });\n    this.dnd.remove();\n    this.stopListening();\n    this.undelegateDocumentEvents();\n  }\n\n}\n\n(function (Stencil) {\n  Stencil.defaultOptions = Object.assign({\n    stencilGraphWidth: 200,\n    stencilGraphHeight: 800,\n    title: 'Stencil',\n    collapsable: false,\n    placeholder: 'Search',\n    notFoundText: 'No matches found',\n\n    layout(model, group) {\n      const options = {\n        columnWidth: this.options.stencilGraphWidth / 2 - 10,\n        columns: 2,\n        rowHeight: 80,\n        resizeToFit: false,\n        dx: 10,\n        dy: 10\n      };\n      grid(model, Object.assign(Object.assign(Object.assign({}, options), this.options.layoutOptions), group ? group.layoutOptions : {}));\n    }\n\n  }, Dnd.defaults);\n})(Stencil || (Stencil = {}));\n\nvar ClassNames;\n\n(function (ClassNames) {\n  ClassNames.base = 'widget-stencil';\n  ClassNames.title = `${ClassNames.base}-title`;\n  ClassNames.search = `${ClassNames.base}-search`;\n  ClassNames.searchText = `${ClassNames.search}-text`;\n  ClassNames.content = `${ClassNames.base}-content`;\n  ClassNames.group = `${ClassNames.base}-group`;\n  ClassNames.groupTitle = `${ClassNames.group}-title`;\n  ClassNames.groupContent = `${ClassNames.group}-content`;\n})(ClassNames || (ClassNames = {}));\n\nvar Private;\n\n(function (Private) {\n  Private.defaultGroupName = '__default__';\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}