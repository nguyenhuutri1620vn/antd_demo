{"ast":null,"code":"export default function d3Linear(cfg) {\n  var min = cfg.min,\n      max = cfg.max,\n      nice = cfg.nice,\n      tickCount = cfg.tickCount;\n  var linear = new D3Linear();\n  linear.domain([min, max]);\n\n  if (nice) {\n    linear.nice(tickCount);\n  }\n\n  return linear.ticks(tickCount);\n}\nvar DEFAULT_COUNT = 5;\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2); // https://github.com/d3/d3-scale\n\nvar D3Linear =\n/** @class */\nfunction () {\n  function D3Linear() {\n    this._domain = [0, 1];\n  }\n\n  D3Linear.prototype.domain = function (domain) {\n    if (domain) {\n      this._domain = Array.from(domain, Number);\n      return this;\n    }\n\n    return this._domain.slice();\n  };\n\n  D3Linear.prototype.nice = function (count) {\n    var _a, _b;\n\n    if (count === void 0) {\n      count = DEFAULT_COUNT;\n    }\n\n    var d = this._domain.slice();\n\n    var i0 = 0;\n    var i1 = this._domain.length - 1;\n    var start = this._domain[i0];\n    var stop = this._domain[i1];\n    var step;\n\n    if (stop < start) {\n      _a = [stop, start], start = _a[0], stop = _a[1];\n      _b = [i1, i0], i0 = _b[0], i1 = _b[1];\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      this.domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      this.domain(d);\n    }\n\n    return this;\n  };\n\n  D3Linear.prototype.ticks = function (count) {\n    if (count === void 0) {\n      count = DEFAULT_COUNT;\n    }\n\n    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);\n  };\n\n  return D3Linear;\n}();\n\nexport { D3Linear };\n\nfunction d3ArrayTicks(start, stop, count) {\n  var reverse;\n  var i = -1;\n  var n;\n  var ticks;\n  var step;\n  stop = +stop, start = +start, count = +count;\n\n  if (start === stop && count > 0) {\n    return [start];\n  } // tslint:disable-next-line\n\n\n  if (reverse = stop < start) {\n    n = start, start = stop, stop = n;\n  } // tslint:disable-next-line\n\n\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {\n    return [];\n  }\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n\n    while (++i < n) {\n      ticks[i] = (start + i) * step;\n    }\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n\n    while (++i < n) {\n      ticks[i] = (start - i) / step;\n    }\n  }\n\n  if (reverse) {\n    ticks.reverse();\n  }\n\n  return ticks;\n}\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count);\n  var power = Math.floor(Math.log(step) / Math.LN10);\n  var error = step / Math.pow(10, power);\n  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}","map":null,"metadata":{},"sourceType":"module"}