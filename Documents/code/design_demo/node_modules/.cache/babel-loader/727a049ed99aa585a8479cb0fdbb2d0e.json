{"ast":null,"code":"import { ObjectExt, Dom, Vector } from '../../util';\nimport { Util } from '../../global';\nconst defaultOptions = {\n  padding: 3,\n  rx: 0,\n  ry: 0,\n  attrs: {\n    'stroke-width': 3,\n    stroke: '#FEB663'\n  }\n};\nexport const stroke = {\n  highlight(cellView, magnet, options) {\n    const id = Private.getHighlighterId(magnet, options);\n\n    if (Private.hasCache(id)) {\n      return;\n    } // eslint-disable-next-line\n\n\n    options = ObjectExt.defaultsDeep({}, options, defaultOptions);\n    const magnetVel = Vector.create(magnet);\n    let pathData;\n    let magnetBBox;\n\n    try {\n      pathData = magnetVel.toPathData();\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the entire cell view instead.\n      magnetBBox = magnetVel.bbox(true\n      /* without transforms */\n      );\n      pathData = Dom.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));\n    }\n\n    const path = Dom.createSvgElement('path');\n    Dom.attr(path, Object.assign({\n      d: pathData,\n      'pointer-events': 'none',\n      'vector-effect': 'non-scaling-stroke',\n      fill: 'none'\n    }, options.attrs ? Dom.kebablizeAttrs(options.attrs) : null)); // const highlightVel = v.create('path').attr()\n\n    if (cellView.isEdgeElement(magnet)) {\n      Dom.attr(path, 'd', cellView.getConnectionPathData());\n    } else {\n      let highlightMatrix = magnetVel.getTransformToElement(cellView.container); // Add padding to the highlight element.\n\n      const padding = options.padding;\n\n      if (padding) {\n        if (magnetBBox == null) {\n          magnetBBox = magnetVel.bbox(true);\n        }\n\n        const cx = magnetBBox.x + magnetBBox.width / 2;\n        const cy = magnetBBox.y + magnetBBox.height / 2;\n        magnetBBox = Dom.transformRectangle(magnetBBox, highlightMatrix);\n        const width = Math.max(magnetBBox.width, 1);\n        const height = Math.max(magnetBBox.height, 1);\n        const sx = (width + padding) / width;\n        const sy = (height + padding) / height;\n        const paddingMatrix = Dom.createSVGMatrix({\n          a: sx,\n          b: 0,\n          c: 0,\n          d: sy,\n          e: cx - sx * cx,\n          f: cy - sy * cy\n        });\n        highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n      }\n\n      Dom.transform(path, highlightMatrix);\n    }\n\n    Dom.addClass(path, Util.prefix('highlight-stroke'));\n    const cell = cellView.cell;\n\n    const removeHandler = () => Private.removeHighlighter(id);\n\n    cell.on('removed', removeHandler);\n\n    if (cell.model) {\n      cell.model.on('reseted', removeHandler);\n    }\n\n    cellView.container.appendChild(path);\n    Private.setCache(id, path);\n  },\n\n  unhighlight(cellView, magnet, opt) {\n    Private.removeHighlighter(Private.getHighlighterId(magnet, opt));\n  }\n\n};\nvar Private;\n\n(function (Private) {\n  function getHighlighterId(magnet, options) {\n    Dom.ensureId(magnet);\n    return magnet.id + JSON.stringify(options);\n  }\n\n  Private.getHighlighterId = getHighlighterId;\n  const cache = {};\n\n  function setCache(id, elem) {\n    cache[id] = elem;\n  }\n\n  Private.setCache = setCache;\n\n  function hasCache(id) {\n    return cache[id] != null;\n  }\n\n  Private.hasCache = hasCache;\n\n  function removeHighlighter(id) {\n    const elem = cache[id];\n\n    if (elem) {\n      Dom.remove(elem);\n      delete cache[id];\n    }\n  }\n\n  Private.removeHighlighter = removeHighlighter;\n})(Private || (Private = {}));","map":null,"metadata":{},"sourceType":"module"}