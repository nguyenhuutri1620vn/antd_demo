{"ast":null,"code":"import barycenter from './barycenter';\nimport resolveConflicts from './resolve-conflicts';\nimport sort from './sort';\n\nconst sortSubgraph = (g, v, cg, biasRight, usePrev) => {\n  var _a, _b, _c, _d;\n\n  let movable = g.children(v); // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）\n\n  const node = g.node(v);\n  const bl = node ? node.borderLeft : undefined;\n  const br = node ? node.borderRight : undefined;\n  const subgraphs = {};\n\n  if (bl) {\n    movable = movable === null || movable === void 0 ? void 0 : movable.filter(w => {\n      return w !== bl && w !== br;\n    });\n  }\n\n  const barycenters = barycenter(g, movable || []);\n  barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach(entry => {\n    var _a;\n\n    if ((_a = g.children(entry.v)) === null || _a === void 0 ? void 0 : _a.length) {\n      const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n\n      if (subgraphResult.hasOwnProperty(\"barycenter\")) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n  const entries = resolveConflicts(barycenters, cg);\n  expandSubgraphs(entries, subgraphs); // 添加fixorder信息到entries里边\n  // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现\n\n  (_a = entries.filter(e => {\n    var _a;\n\n    return !!e.vs || ((_a = e.vs) === null || _a === void 0 ? void 0 : _a.length) > 0;\n  })) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n    const node = g.node(e.vs[0]);\n    e.fixorder = node.fixorder;\n    e.order = node.order;\n  });\n  const result = sort(entries, biasRight, usePrev);\n\n  if (bl) {\n    // @ts-ignore\n    result.vs = [bl, result.vs, br].flat();\n\n    if ((_b = g.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {\n      const blPred = g.node(((_c = g.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || {});\n      const brPred = g.node(((_d = g.predecessors(br)) === null || _d === void 0 ? void 0 : _d[0]) || {});\n\n      if (!result.hasOwnProperty(\"barycenter\")) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n\n      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n\n  return result;\n};\n\nconst expandSubgraphs = (entries, subgraphs) => {\n  entries === null || entries === void 0 ? void 0 : entries.forEach(entry => {\n    var _a;\n\n    const vss = (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.map(v => {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs;\n      }\n\n      return v;\n    });\n    entry.vs = vss.flat();\n  });\n};\n\nconst mergeBarycenters = (target, other) => {\n  if (target.barycenter !== undefined) {\n    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n};\n\nexport default sortSubgraph;","map":null,"metadata":{},"sourceType":"module"}