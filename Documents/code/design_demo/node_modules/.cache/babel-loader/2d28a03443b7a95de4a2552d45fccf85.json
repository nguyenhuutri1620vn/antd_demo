{"ast":null,"code":"import { Dom, FunctionExt } from '../../util';\nimport { Point } from '../../geometry';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\n\nclass Anchor extends ToolsView.ToolItem {\n  get type() {\n    return this.options.type;\n  }\n\n  onRender() {\n    Dom.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));\n    this.toggleArea(false);\n    this.update();\n  }\n\n  update() {\n    const type = this.type;\n    const edgeView = this.cellView;\n    const terminalView = edgeView.getTerminalView(type);\n\n    if (terminalView) {\n      this.updateAnchor();\n      this.updateArea();\n      this.container.style.display = '';\n    } else {\n      this.container.style.display = 'none';\n    }\n\n    return this;\n  }\n\n  updateAnchor() {\n    const childNodes = this.childNodes;\n\n    if (!childNodes) {\n      return;\n    }\n\n    const anchorNode = childNodes.anchor;\n\n    if (!anchorNode) {\n      return;\n    }\n\n    const type = this.type;\n    const edgeView = this.cellView;\n    const options = this.options;\n    const position = edgeView.getTerminalAnchor(type);\n    const customAnchor = edgeView.cell.prop([type, 'anchor']);\n    anchorNode.setAttribute('transform', `translate(${position.x}, ${position.y})`);\n    const anchorAttrs = customAnchor ? options.customAnchorAttrs : options.defaultAnchorAttrs;\n\n    if (anchorAttrs) {\n      Object.keys(anchorAttrs).forEach(attrName => {\n        anchorNode.setAttribute(attrName, anchorAttrs[attrName]);\n      });\n    }\n  }\n\n  updateArea() {\n    const childNodes = this.childNodes;\n\n    if (!childNodes) {\n      return;\n    }\n\n    const areaNode = childNodes.area;\n\n    if (!areaNode) {\n      return;\n    }\n\n    const type = this.type;\n    const edgeView = this.cellView;\n    const terminalView = edgeView.getTerminalView(type);\n\n    if (terminalView) {\n      const terminalCell = terminalView.cell;\n      const magnet = edgeView.getTerminalMagnet(type);\n      let padding = this.options.areaPadding || 0;\n\n      if (!Number.isFinite(padding)) {\n        padding = 0;\n      }\n\n      let bbox;\n      let angle;\n      let center;\n\n      if (terminalView.isEdgeElement(magnet)) {\n        bbox = terminalView.getBBox();\n        angle = 0;\n        center = bbox.getCenter();\n      } else {\n        bbox = terminalView.getUnrotatedBBoxOfElement(magnet);\n        angle = terminalCell.getAngle();\n        center = bbox.getCenter();\n\n        if (angle) {\n          center.rotate(-angle, terminalCell.getBBox().getCenter());\n        }\n      }\n\n      bbox.inflate(padding);\n      Dom.attr(areaNode, {\n        x: -bbox.width / 2,\n        y: -bbox.height / 2,\n        width: bbox.width,\n        height: bbox.height,\n        transform: `translate(${center.x}, ${center.y}) rotate(${angle})`\n      });\n    }\n  }\n\n  toggleArea(visible) {\n    if (this.childNodes) {\n      const elem = this.childNodes.area;\n\n      if (elem) {\n        elem.style.display = visible ? '' : 'none';\n      }\n    }\n  }\n\n  onMouseDown(evt) {\n    if (this.guard(evt)) {\n      return;\n    }\n\n    evt.stopPropagation();\n    evt.preventDefault();\n    this.graph.view.undelegateEvents();\n\n    if (this.options.documentEvents) {\n      this.delegateDocumentEvents(this.options.documentEvents);\n    }\n\n    this.focus();\n    this.toggleArea(this.options.restrictArea);\n    this.cell.startBatch('move-anchor', {\n      ui: true,\n      toolId: this.cid\n    });\n  }\n\n  resetAnchor(anchor) {\n    const type = this.type;\n    const cell = this.cell;\n\n    if (anchor) {\n      cell.prop([type, 'anchor'], anchor, {\n        rewrite: true,\n        ui: true,\n        toolId: this.cid\n      });\n    } else {\n      cell.removeProp([type, 'anchor'], {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n  }\n\n  onMouseMove(evt) {\n    const terminalType = this.type;\n    const edgeView = this.cellView;\n    const terminalView = edgeView.getTerminalView(terminalType);\n\n    if (terminalView == null) {\n      return;\n    }\n\n    const e = this.normalizeEvent(evt);\n    const terminalCell = terminalView.cell;\n    const terminalMagnet = edgeView.getTerminalMagnet(terminalType);\n    let coords = this.graph.clientToLocal(e.clientX, e.clientY);\n    const snapFn = this.options.snap;\n\n    if (typeof snapFn === 'function') {\n      const tmp = FunctionExt.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n      coords = Point.create(tmp);\n    }\n\n    if (this.options.restrictArea) {\n      if (terminalView.isEdgeElement(terminalMagnet)) {\n        const pointAtConnection = terminalView.getClosestPoint(coords);\n\n        if (pointAtConnection) {\n          coords = pointAtConnection;\n        }\n      } else {\n        const bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);\n        const angle = terminalCell.getAngle();\n        const origin = terminalCell.getBBox().getCenter();\n        const rotatedCoords = coords.clone().rotate(angle, origin);\n\n        if (!bbox.containsPoint(rotatedCoords)) {\n          coords = bbox.getNearestPointToPoint(rotatedCoords).rotate(-angle, origin);\n        }\n      }\n    }\n\n    let anchor;\n    const anchorFn = this.options.anchor;\n\n    if (typeof anchorFn === 'function') {\n      anchor = FunctionExt.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n    }\n\n    this.resetAnchor(anchor);\n    this.update();\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onMouseUp(evt) {\n    this.graph.view.delegateEvents();\n    this.undelegateDocumentEvents();\n    this.blur();\n    this.toggleArea(false);\n    const edgeView = this.cellView;\n\n    if (this.options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({\n        ui: true,\n        toolId: this.cid\n      });\n    }\n\n    this.cell.stopBatch('move-anchor', {\n      ui: true,\n      toolId: this.cid\n    });\n  }\n\n  onDblClick() {\n    const anchor = this.options.resetAnchor;\n\n    if (anchor) {\n      this.resetAnchor(anchor === true ? undefined : anchor);\n    }\n\n    this.update();\n  }\n\n}\n\n(function (Anchor) {\n  Anchor.config({\n    tagName: 'g',\n    markup: [{\n      tagName: 'circle',\n      selector: 'anchor',\n      attrs: {\n        cursor: 'pointer'\n      }\n    }, {\n      tagName: 'rect',\n      selector: 'area',\n      attrs: {\n        'pointer-events': 'none',\n        fill: 'none',\n        stroke: '#33334F',\n        'stroke-dasharray': '2,4',\n        rx: 5,\n        ry: 5\n      }\n    }],\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown',\n      dblclick: 'onDblClick'\n    },\n    documentEvents: {\n      mousemove: 'onMouseMove',\n      touchmove: 'onMouseMove',\n      mouseup: 'onMouseUp',\n      touchend: 'onMouseUp',\n      touchcancel: 'onMouseUp'\n    },\n    customAnchorAttrs: {\n      'stroke-width': 4,\n      stroke: '#33334F',\n      fill: '#FFFFFF',\n      r: 5\n    },\n    defaultAnchorAttrs: {\n      'stroke-width': 2,\n      stroke: '#FFFFFF',\n      fill: '#33334F',\n      r: 6\n    },\n    areaPadding: 6,\n    snapRadius: 10,\n    resetAnchor: true,\n    restrictArea: true,\n    removeRedundancies: true,\n    anchor: Util.getAnchor,\n\n    snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {\n      const snapRadius = toolView.options.snapRadius || 0;\n      const isSource = terminalType === 'source';\n      const refIndex = isSource ? 0 : -1;\n      const ref = this.cell.getVertexAt(refIndex) || this.getTerminalAnchor(isSource ? 'target' : 'source');\n\n      if (ref) {\n        if (Math.abs(ref.x - pos.x) < snapRadius) pos.x = ref.x;\n        if (Math.abs(ref.y - pos.y) < snapRadius) pos.y = ref.y;\n      }\n\n      return pos;\n    }\n\n  });\n})(Anchor || (Anchor = {}));\n\nexport const SourceAnchor = Anchor.define({\n  name: 'source-anchor',\n  type: 'source'\n});\nexport const TargetAnchor = Anchor.define({\n  name: 'target-anchor',\n  type: 'target'\n});","map":null,"metadata":{},"sourceType":"module"}