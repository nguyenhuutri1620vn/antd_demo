{"ast":null,"code":"import { isString, isNumber, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return \"\".concat(type, \"-\").concat(Math.random()).concat(Date.now());\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\nexport var formatPadding = function formatPadding(padding) {\n  if (isArray(padding)) {\n    switch (padding.length) {\n      case 4:\n        return padding;\n\n      case 3:\n        padding.push(padding[1]);\n        return padding;\n\n      case 2:\n        return padding.concat(padding);\n\n      case 1:\n        return [padding[0], padding[0], padding[0], padding[0]];\n\n      default:\n        return [0, 0, 0, 0];\n    }\n  }\n\n  if (isNumber(padding)) {\n    return [padding, padding, padding, padding];\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    return [intPadding, intPadding, intPadding, intPadding];\n  }\n\n  return [0, 0, 0, 0];\n};\n/**\n * clone event\n * @param e\n */\n\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = \"\".concat(source, \"-\").concat(target);\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[\"\".concat(src, \"|\").concat(dst, \"|\").concat(edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[\"\".concat(current.source, \"|\").concat(current.target, \"|\").concat(k)] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};","map":null,"metadata":{},"sourceType":"module"}