{"ast":null,"code":"import { Util } from '../../../global/util';\nimport { Point, Line, Angle } from '../../../geometry';\nexport function getSourceBBox(view, options) {\n  const bbox = view.sourceBBox.clone();\n\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox);\n  }\n\n  return bbox;\n}\nexport function getTargetBBox(view, options) {\n  const bbox = view.targetBBox.clone();\n\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox);\n  }\n\n  return bbox;\n}\nexport function getSourceEndpoint(view, options) {\n  if (view.sourceAnchor) {\n    return view.sourceAnchor;\n  }\n\n  const sourceBBox = getSourceBBox(view, options);\n  return sourceBBox.getCenter();\n}\nexport function getTargetEndpoint(view, options) {\n  if (view.targetAnchor) {\n    return view.targetAnchor;\n  }\n\n  const targetBBox = getTargetBBox(view, options);\n  return targetBBox.getCenter();\n} // returns a direction index from start point to end point\n// corrects for grid deformation between start and end\n\nexport function getDirectionAngle(start, end, directionCount, grid, options) {\n  const quadrant = 360 / directionCount;\n  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));\n  const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n  return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\nfunction fixAngleEnd(start, end, grid, options) {\n  const step = options.step;\n  const diffX = end.x - start.x;\n  const diffY = end.y - start.y;\n  const gridStepsX = diffX / grid.x;\n  const gridStepsY = diffY / grid.y;\n  const distanceX = gridStepsX * step;\n  const distanceY = gridStepsY * step;\n  return new Point(start.x + distanceX, start.y + distanceY);\n}\n/**\n * Returns the change in direction between two direction angles.\n */\n\n\nexport function getDirectionChange(angle1, angle2) {\n  const change = Math.abs(angle1 - angle2);\n  return change > 180 ? 360 - change : change;\n} // fix direction offsets according to current grid\n\nexport function getGridOffsets(grid, options) {\n  const step = options.step;\n  options.directions.forEach(direction => {\n    direction.gridOffsetX = direction.offsetX / step * grid.x;\n    direction.gridOffsetY = direction.offsetY / step * grid.y;\n  });\n  return options.directions;\n} // get grid size in x and y dimensions, adapted to source and target positions\n\nexport function getGrid(step, source, target) {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step)\n  };\n}\n\nfunction getGridDimension(diff, step) {\n  // return step if diff = 0\n  if (!diff) {\n    return step;\n  }\n\n  const abs = Math.abs(diff);\n  const count = Math.round(abs / step); // return `abs` if less than one step apart\n\n  if (!count) {\n    return abs;\n  } // otherwise, return corrected step\n\n\n  const roundedDiff = count * step;\n  const remainder = abs - roundedDiff;\n  const correction = remainder / count;\n  return step + correction;\n}\n\nfunction snapGrid(point, grid) {\n  const source = grid.source;\n  const x = Util.snapToGrid(point.x - source.x, grid.x) + source.x;\n  const y = Util.snapToGrid(point.y - source.y, grid.y) + source.y;\n  return new Point(x, y);\n}\n\nexport function round(point, precision) {\n  return point.round(precision);\n}\nexport function align(point, grid, precision) {\n  return round(snapGrid(point.clone(), grid), precision);\n}\nexport function getKey(point) {\n  return point.toString();\n}\nexport function normalizePoint(point) {\n  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n}\nexport function getCost(from, anchors) {\n  let min = Infinity;\n\n  for (let i = 0, len = anchors.length; i < len; i += 1) {\n    const dist = from.manhattanDistance(anchors[i]);\n\n    if (dist < min) {\n      min = dist;\n    }\n  }\n\n  return min;\n} // Find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\n\nexport function getRectPoints(anchor, bbox, directionList, grid, options) {\n  const precision = options.precision;\n  const directionMap = options.directionMap;\n  const centerVector = anchor.diff(bbox.getCenter());\n  const rectPoints = Object.keys(directionMap).reduce((res, key) => {\n    if (directionList.includes(key)) {\n      const direction = directionMap[key]; // Create a line that is guaranteed to intersect the bbox if bbox\n      // is in the direction even if anchor lies outside of bbox.\n\n      const ending = new Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));\n      const intersectionLine = new Line(anchor, ending); // Get the farther intersection, in case there are two\n      // (that happens if anchor lies next to bbox)\n\n      const intersections = intersectionLine.intersect(bbox) || [];\n      let farthestIntersectionDistance;\n      let farthestIntersection = null;\n\n      for (let i = 0; i < intersections.length; i += 1) {\n        const intersection = intersections[i];\n        const distance = anchor.squaredDistance(intersection);\n\n        if (farthestIntersectionDistance == null || distance > farthestIntersectionDistance) {\n          farthestIntersectionDistance = distance;\n          farthestIntersection = intersection;\n        }\n      } // If an intersection was found in this direction, it is our rectPoint\n\n\n      if (farthestIntersection) {\n        let target = align(farthestIntersection, grid, precision); // If the rectPoint lies inside the bbox, offset it by one more step\n\n        if (bbox.containsPoint(target)) {\n          target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);\n        }\n\n        res.push(target);\n      }\n    }\n\n    return res;\n  }, []); // if anchor lies outside of bbox, add it to the array of points\n\n  if (!bbox.containsPoint(anchor)) {\n    rectPoints.push(align(anchor, grid, precision));\n  }\n\n  return rectPoints;\n} // reconstructs a route by concatenating points with their parents\n\nexport function reconstructRoute(parents, points, tailPoint, from, to) {\n  const route = [];\n  let prevDiff = normalizePoint(to.diff(tailPoint)); // tailPoint is assumed to be aligned already\n\n  let currentKey = getKey(tailPoint);\n  let parent = parents[currentKey];\n  let point;\n\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey];\n    const diff = normalizePoint(point.diff(parent));\n\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point);\n      prevDiff = diff;\n    } // parent is assumed to be aligned already\n\n\n    currentKey = getKey(parent);\n    parent = parents[currentKey];\n  } // leadPoint is assumed to be aligned already\n\n\n  const leadPoint = points[currentKey];\n  const fromDiff = normalizePoint(leadPoint.diff(from));\n\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint);\n  }\n\n  return route;\n}","map":null,"metadata":{},"sourceType":"module"}