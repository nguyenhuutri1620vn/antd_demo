{"ast":null,"code":"import { hasClass } from './class';\nlet idCounter = 0;\nexport function uniqueId() {\n  idCounter += 1;\n  return `v${idCounter}`;\n}\nexport function ensureId(elem) {\n  if (elem.id == null || elem.id === '') {\n    elem.id = uniqueId();\n  }\n\n  return elem.id;\n}\n/**\n * Returns true if object is an instance of SVGGraphicsElement.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n */\n\nexport function isSVGGraphicsElement(elem) {\n  if (elem == null) {\n    return false;\n  }\n\n  return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;\n}\nexport const ns = {\n  svg: 'http://www.w3.org/2000/svg',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xhtml: 'http://www.w3.org/1999/xhtml'\n};\nexport const svgVersion = '1.1';\nexport function createElement(tagName) {\n  let doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  return doc.createElement(tagName);\n}\nexport function createElementNS(tagName) {\n  let namespaceURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ns.xhtml;\n  let doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;\n  return doc.createElementNS(namespaceURI, tagName);\n}\nexport function createSvgElement(tagName) {\n  let doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  return createElementNS(tagName, ns.svg, doc);\n}\nexport function createSvgDocument(content) {\n  if (content) {\n    const xml = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${svgVersion}\">${content}</svg>`; // lgtm[js/html-constructed-from-input]\n\n    const {\n      documentElement\n    } = parseXML(xml, {\n      async: false\n    });\n    return documentElement;\n  }\n\n  const svg = document.createElementNS(ns.svg, 'svg');\n  svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n  svg.setAttribute('version', svgVersion);\n  return svg;\n}\nexport function parseXML(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let xml;\n\n  try {\n    const parser = new DOMParser();\n\n    if (options.async != null) {\n      const instance = parser;\n      instance.async = options.async;\n    }\n\n    xml = parser.parseFromString(data, options.mimeType || 'text/xml');\n  } catch (error) {\n    xml = undefined;\n  }\n\n  if (!xml || xml.getElementsByTagName('parsererror').length) {\n    throw new Error(`Invalid XML: ${data}`);\n  }\n\n  return xml;\n}\nexport function tagName(node) {\n  let lowercase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const nodeName = node.nodeName;\n  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();\n}\nexport function index(elem) {\n  let index = 0;\n  let node = elem.previousSibling;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      index += 1;\n    }\n\n    node = node.previousSibling;\n  }\n\n  return index;\n}\nexport function find(elem, selector) {\n  return elem.querySelectorAll(selector);\n}\nexport function findOne(elem, selector) {\n  return elem.querySelector(selector);\n}\nexport function findParentByClass(elem, className, terminator) {\n  const ownerSVGElement = elem.ownerSVGElement;\n  let node = elem.parentNode;\n\n  while (node && node !== terminator && node !== ownerSVGElement) {\n    if (hasClass(node, className)) {\n      return node;\n    }\n\n    node = node.parentNode;\n  }\n\n  return null;\n}\nexport function contains(parent, child) {\n  const bup = child && child.parentNode;\n  return parent === bup || !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise\n  ;\n}\nexport function remove(elem) {\n  if (elem.parentNode) {\n    elem.parentNode.removeChild(elem);\n  }\n}\nexport function empty(elem) {\n  while (elem.firstChild) {\n    elem.removeChild(elem.firstChild);\n  }\n}\nexport function append(elem, elems) {\n  const arr = Array.isArray(elems) ? elems : [elems];\n  arr.forEach(child => {\n    if (child != null) {\n      elem.appendChild(child);\n    }\n  });\n}\nexport function prepend(elem, elems) {\n  const child = elem.firstChild;\n  return child ? before(child, elems) : append(elem, elems);\n}\nexport function before(elem, elems) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems];\n    arr.forEach(child => {\n      if (child != null) {\n        parent.insertBefore(child, elem);\n      }\n    });\n  }\n}\nexport function appendTo(elem, target) {\n  if (target != null) {\n    target.appendChild(elem);\n  }\n} // Determines whether a node is an HTML node\n\nexport function isHTMLElement(elem) {\n  try {\n    // Using W3 DOM2 (works for FF, Opera and Chrome)\n    return elem instanceof HTMLElement;\n  } catch (e) {\n    // Browsers not supporting W3 DOM2 don't have HTMLElement and\n    // an exception is thrown and we end up here. Testing some\n    // properties that all elements have (works on IE7)\n    return typeof elem === 'object' && elem.nodeType === 1 && typeof elem.style === 'object' && typeof elem.ownerDocument === 'object';\n  }\n}","map":null,"metadata":{},"sourceType":"module"}