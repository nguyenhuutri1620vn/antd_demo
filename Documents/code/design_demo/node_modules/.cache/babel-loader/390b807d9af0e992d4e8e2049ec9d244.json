{"ast":null,"code":"import graphlib from '../graphlib';\nimport util from '../util';\nconst Graph = graphlib.Graph;\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\n\nconst findType1Conflicts = (g, layering) => {\n  const conflicts = {};\n\n  const visitLayer = (prevLayer, layer) => {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0; // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n\n    let scanPos = 0;\n    const prevLayerLength = prevLayer.length;\n    const lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];\n    layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {\n      var _a;\n\n      const w = findOtherInnerSegmentNode(g, v);\n      const k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach(scanNode => {\n          var _a;\n\n          (_a = g.predecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach(u => {\n            const uLabel = g.node(u);\n            const uPos = uLabel.order;\n\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n    return layer;\n  };\n\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n\n  return conflicts;\n};\n\nconst findType2Conflicts = (g, layering) => {\n  const conflicts = {};\n\n  const scan = (south, southPos, southEnd, prevNorthBorder, nextNorthBorder) => {\n    let v;\n    const range = [];\n\n    for (let i = southPos; i < southEnd; i++) {\n      range.push(i);\n    }\n\n    range.forEach(i => {\n      var _a;\n\n      v = south[i];\n\n      if (g.node(v).dummy) {\n        (_a = g.predecessors(v)) === null || _a === void 0 ? void 0 : _a.forEach(u => {\n          const uNode = g.node(u);\n\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  };\n\n  const visitLayer = (north, south) => {\n    let prevNorthPos = -1;\n    let nextNorthPos;\n    let southPos = 0;\n    south === null || south === void 0 ? void 0 : south.forEach((v, southLookahead) => {\n      if (g.node(v).dummy === \"border\") {\n        const predecessors = g.predecessors(v) || [];\n\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n    return south;\n  };\n\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n\n  return conflicts;\n};\n\nconst findOtherInnerSegmentNode = (g, v) => {\n  var _a;\n\n  if (g.node(v).dummy) {\n    return (_a = g.predecessors(v)) === null || _a === void 0 ? void 0 : _a.find(u => g.node(u).dummy);\n  }\n};\n\nconst addConflict = (conflicts, v, w) => {\n  let vv = v;\n  let ww = w;\n\n  if (vv > ww) {\n    const tmp = vv;\n    vv = ww;\n    ww = tmp;\n  }\n\n  let conflictsV = conflicts[vv];\n\n  if (!conflictsV) {\n    conflicts[vv] = conflictsV = {};\n  }\n\n  conflictsV[ww] = true;\n};\n\nconst hasConflict = (conflicts, v, w) => {\n  let vv = v;\n  let ww = w;\n\n  if (vv > ww) {\n    const tmp = v;\n    vv = ww;\n    ww = tmp;\n  }\n\n  return conflicts[vv] && conflicts[vv].hasOwnProperty(ww);\n};\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\n\n\nconst verticalAlignment = (g, layering, conflicts, neighborFn) => {\n  const root = {};\n  const align = {};\n  const pos = {}; // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n\n  layering === null || layering === void 0 ? void 0 : layering.forEach(layer => {\n    layer === null || layer === void 0 ? void 0 : layer.forEach((v, order) => {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n  layering === null || layering === void 0 ? void 0 : layering.forEach(layer => {\n    let prevIdx = -1;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(v => {\n      let ws = neighborFn(v);\n\n      if (ws.length) {\n        ws = ws.sort((a, b) => pos[a] - pos[b]);\n        const mp = (ws.length - 1) / 2;\n\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i];\n\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n  return {\n    root,\n    align\n  };\n};\n\nconst horizontalCompaction = (g, layering, root, align, reverseSep) => {\n  var _a; // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n\n\n  const xs = {};\n  const blockG = buildBlockGraph(g, layering, root, reverseSep);\n  const borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  const iterate = (setXsFunc, nextNodesFunc) => {\n    let stack = blockG.nodes();\n    let elem = stack.pop();\n    const visited = {};\n\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }; // First pass, assign smallest coordinates\n\n\n  const pass1 = elem => {\n    xs[elem] = (blockG.inEdges(elem) || []).reduce((acc, e) => {\n      return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e));\n    }, 0);\n  }; // Second pass, assign greatest coordinates\n\n\n  const pass2 = elem => {\n    const min = (blockG.outEdges(elem) || []).reduce((acc, e) => {\n      return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n    const node = g.node(elem);\n\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  };\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG)); // Assign x coordinates to all nodes\n  // @ts-ignore\n\n  (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach(v => {\n    xs[v] = xs[root[v]];\n  });\n  return xs;\n};\n\nconst buildBlockGraph = (g, layering, root, reverseSep) => {\n  const blockGraph = new Graph();\n  const graphLabel = g.graph();\n  const sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n  layering === null || layering === void 0 ? void 0 : layering.forEach(layer => {\n    let u;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(v => {\n      const vRoot = root[v];\n      blockGraph.setNode(vRoot);\n\n      if (u) {\n        const uRoot = root[u];\n        const prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n\n      u = v;\n    });\n  });\n  return blockGraph;\n};\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\n\n\nconst findSmallestWidthAlignment = (g, xss) => {\n  // @ts-ignore\n  return util.minBy(Object.values(xss), xs => {\n    var _a;\n\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach(v => {\n      const x = xs[v];\n      const halfWidth = width(g, v) / 2;\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n    return max - min;\n  });\n};\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\n\n\nfunction alignCoordinates(xss, alignTo) {\n  // @ts-ignore\n  const alignToVals = Object.values(alignTo);\n  const alignToMin = Math.min(...alignToVals);\n  const alignToMax = Math.max(...alignToVals);\n  [\"u\", \"d\"].forEach(vert => {\n    [\"l\", \"r\"].forEach(horiz => {\n      const alignment = vert + horiz;\n      const xs = xss[alignment];\n      let delta;\n      if (xs === alignTo) return;\n      const xsVals = Object.values(xs);\n      delta = horiz === \"l\" ? alignToMin - Math.min(...xsVals) : alignToMax - Math.max(...xsVals);\n\n      if (delta) {\n        xss[alignment] = {};\n        Object.keys(xs).forEach(key => {\n          xss[alignment][key] = xs[key] + delta;\n        });\n      }\n    });\n  });\n}\n\nconst balance = (xss, align) => {\n  const result = {};\n  Object.keys(xss.ul).forEach(key => {\n    if (align) {\n      result[key] = xss[align.toLowerCase()][key];\n    } else {\n      // @ts-ignore\n      const values = Object.values(xss).map(x => x[key]);\n      const xs = values.sort((a, b) => a - b);\n      result[key] = (xs[1] + xs[2]) / 2;\n    }\n  });\n  return result; // return _.mapValues(xss.ul, function(ignore, v) {\n  //   if (align) {\n  //     return xss[align.toLowerCase()][v];\n  //   } else {\n  //     const xs = _.sortBy(_.map(xss, v));\n  //     return (xs[1] + xs[2]) / 2;\n  //   }\n  // });\n};\n\nconst positionX = g => {\n  const layering = util.buildLayerMatrix(g);\n  const conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n  const xss = {};\n  let adjustedLayering;\n  [\"u\", \"d\"].forEach(vert => {\n    // @ts-ignore\n    adjustedLayering = vert === \"u\" ? layering : Object.values(layering).reverse();\n    [\"l\", \"r\"].forEach(horiz => {\n      if (horiz === \"r\") {\n        // @ts-ignore\n        adjustedLayering = adjustedLayering.map(inner => Object.values(inner).reverse());\n      }\n\n      const neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      let xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n\n      if (horiz === \"r\") {\n        // @ts-ignore\n        xs = Object.values(xs).map(x => -x);\n      }\n\n      xss[vert + horiz] = xs;\n    });\n  });\n  const smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n};\n\nconst sep = (nodeSep, edgeSep, reverseSep) => {\n  return (g, v, w) => {\n    const vLabel = g.node(v);\n    const wLabel = g.node(w);\n    let sum = 0;\n    let delta;\n    sum += vLabel.width / 2;\n\n    if (vLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((vLabel.labelpos || '').toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += wLabel.width / 2;\n\n    if (wLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((wLabel.labelpos || '').toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width / 2;\n          break;\n\n        case \"r\":\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n\n    delta = 0;\n    return sum;\n  };\n};\n\nconst width = (g, v) => {\n  var _a;\n\n  return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.width) || 0;\n};\n\nexport { positionX, findType1Conflicts, findType2Conflicts, addConflict, hasConflict, verticalAlignment, horizontalCompaction, alignCoordinates, findSmallestWidthAlignment, balance };\nexport default {\n  positionX,\n  findType1Conflicts,\n  findType2Conflicts,\n  addConflict,\n  hasConflict,\n  verticalAlignment,\n  horizontalCompaction,\n  alignCoordinates,\n  findSmallestWidthAlignment,\n  balance\n};","map":null,"metadata":{},"sourceType":"module"}