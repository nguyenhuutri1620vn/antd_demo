{"ast":null,"code":"import { feasibleTree } from './feasible-tree';\nimport { slack, longestPath as initRank } from './util';\nimport { minBy, simplify } from '../util';\nimport graphlib from '../graphlib';\nconst alg = graphlib.alg;\nconst {\n  preorder,\n  postorder\n} = alg;\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\n\nconst networkSimplex = g => {\n  // tslint:disable-next-line\n  g = simplify(g);\n  initRank(g);\n  const t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n  let e;\n  let f;\n\n  while (e = leaveEdge(t)) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n};\n/*\n * Initializes cut values for all edges in the tree.\n */\n\n\nconst initCutValues = (t, g) => {\n  let vs = postorder(t, t.nodes());\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(v => {\n    assignCutValue(t, g, v);\n  });\n};\n\nconst assignCutValue = (t, g, child) => {\n  const childLab = t.node(child);\n  const parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n};\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\n\n\nconst calcCutValue = (t, g, child) => {\n  var _a;\n\n  const childLab = t.node(child);\n  const parent = childLab.parent; // True if the child is on the tail end of the edge in the directed graph\n\n  let childIsTail = true; // The graph's view of the tree edge we're inspecting\n\n  let graphEdge = g.edge(child, parent); // The accumulated cut value for the edge between this node and its parent\n\n  let cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n  (_a = g.nodeEdges(child)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n    const isOutEdge = e.v === child;\n    const other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail;\n      const otherWeight = g.edge(e).weight;\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n\n      if (isTreeEdge(t, child, other)) {\n        const otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n  return cutValue;\n};\n\nconst initLowLimValues = (tree, root) => {\n  if (root !== undefined) {\n    // tslint:disable-next-line\n    root = tree.nodes()[0];\n  }\n\n  dfsAssignLowLim(tree, {}, 1, root);\n};\n\nconst dfsAssignLowLim = (tree, visited, nextLim, v, parent) => {\n  var _a;\n\n  const low = nextLim;\n  let useNextLim = nextLim;\n  const label = tree.node(v);\n  visited[v] = true;\n  (_a = tree.neighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach(w => {\n    if (!visited.hasOwnProperty(w)) {\n      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);\n    }\n  });\n  label.low = low;\n  label.lim = useNextLim++;\n\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return useNextLim;\n};\n\nconst leaveEdge = tree => {\n  return tree.edges().find(e => {\n    return tree.edge(e).cutvalue < 0;\n  });\n};\n\nconst enterEdge = (t, g, edge) => {\n  let v = edge.v;\n  let w = edge.w; // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  const vLabel = t.node(v);\n  const wLabel = t.node(w);\n  let tailLabel = vLabel;\n  let flip = false; // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  const candidates = g.edges().filter(edge => {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n  return minBy(candidates, edge => {\n    return slack(g, edge);\n  });\n};\n\nconst exchangeEdges = (t, g, e, f) => {\n  const v = e.v;\n  const w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n};\n\nconst updateRanks = (t, g) => {\n  const root = t.nodes().find(v => {\n    return !g.node(v).parent;\n  });\n  let vs = preorder(t, root);\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(v => {\n    const parent = t.node(v).parent;\n    let edge = g.edge(v, parent);\n    let flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n};\n/*\n * Returns true if the edge is in the tree.\n */\n\n\nconst isTreeEdge = (tree, u, v) => {\n  return tree.hasEdge(u, v);\n};\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\n\n\nconst isDescendant = (tree, vLabel, rootLabel) => {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}; // Expose some internals for testing purposes\n\n\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\nexport default networkSimplex;","map":null,"metadata":{},"sourceType":"module"}