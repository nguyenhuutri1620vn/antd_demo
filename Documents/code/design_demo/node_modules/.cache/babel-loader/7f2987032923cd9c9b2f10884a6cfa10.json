{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt, FunctionExt, Dom, Vector } from '../util';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint } from '../registry';\nimport { Edge } from '../model/edge';\nimport { Markup } from './markup';\nimport { CellView } from './cell';\nexport class EdgeView extends CellView {\n  constructor() {\n    super(...arguments);\n    this.POINT_ROUNDING = 2;\n    this.markerCache = {}; // #endregion\n    // #endregion\n  }\n\n  get [Symbol.toStringTag]() {\n    return EdgeView.toStringTag;\n  }\n\n  getContainerClassName() {\n    return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');\n  }\n\n  get sourceBBox() {\n    const sourceView = this.sourceView;\n\n    if (!sourceView) {\n      const sourceDef = this.cell.getSource();\n      return new Rectangle(sourceDef.x, sourceDef.y);\n    }\n\n    const sourceMagnet = this.sourceMagnet;\n\n    if (sourceView.isEdgeElement(sourceMagnet)) {\n      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n    }\n\n    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n  }\n\n  get targetBBox() {\n    const targetView = this.targetView;\n\n    if (!targetView) {\n      const targetDef = this.cell.getTarget();\n      return new Rectangle(targetDef.x, targetDef.y);\n    }\n\n    const targetMagnet = this.targetMagnet;\n\n    if (targetView.isEdgeElement(targetMagnet)) {\n      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n    }\n\n    return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n  }\n\n  isEdgeView() {\n    return true;\n  }\n\n  confirmUpdate(flag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let ref = flag;\n\n    if (this.hasAction(ref, 'source')) {\n      if (!this.updateTerminalProperties('source')) {\n        return ref;\n      }\n\n      ref = this.removeAction(ref, 'source');\n    }\n\n    if (this.hasAction(ref, 'target')) {\n      if (!this.updateTerminalProperties('target')) {\n        return ref;\n      }\n\n      ref = this.removeAction(ref, 'target');\n    }\n\n    const graph = this.graph;\n    const sourceView = this.sourceView;\n    const targetView = this.targetView;\n\n    if (graph && (sourceView && !graph.renderer.isViewMounted(sourceView) || targetView && !graph.renderer.isViewMounted(targetView))) {\n      // Wait for the sourceView and targetView to be rendered.\n      return ref;\n    }\n\n    if (this.hasAction(ref, 'render')) {\n      this.render();\n      ref = this.removeAction(ref, ['render', 'update', 'vertices', 'labels', 'tools', 'widget']);\n      return ref;\n    }\n\n    ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers());\n    ref = this.handleAction(ref, 'update', () => this.update(null, options));\n    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));\n    ref = this.handleAction(ref, 'tools', () => {\n      this.renderTools();\n      this.updateToolsPosition();\n    });\n    ref = this.handleAction(ref, 'widget', () => this.renderExternalTools());\n    return ref;\n  }\n\n  onLabelsChange() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // Note: this optimization works in async=false mode only\n    if (this.shouldRerenderLabels(options)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n\n    this.updateLabelPositions();\n  }\n\n  shouldRerenderLabels() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const previousLabels = this.cell.previous('labels');\n\n    if (previousLabels == null) {\n      return true;\n    } // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n\n\n    if ('propertyPathArray' in options && 'propertyValue' in options) {\n      // The label is setting by `prop()` method\n      const pathArray = options.propertyPathArray || [];\n      const pathLength = pathArray.length;\n\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        const index = pathArray[1];\n\n        if (previousLabels[index]) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return typeof options.propertyValue === 'object' && ObjectExt.has(options.propertyValue, 'markup');\n          } // We are changing a label property but not the markup\n\n\n          if (pathArray[2] !== 'markup') {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  render() {\n    this.empty();\n    this.containers = {};\n    this.renderMarkup();\n    this.renderLabels();\n    this.update();\n    return this;\n  }\n\n  renderMarkup() {\n    const markup = this.cell.markup;\n\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.renderStringMarkup(markup);\n      }\n\n      return this.renderJSONMarkup(markup);\n    }\n\n    throw new TypeError('Invalid edge markup.');\n  }\n\n  renderJSONMarkup(markup) {\n    const ret = this.parseJSONMarkup(markup, this.container);\n    this.selectors = ret.selectors;\n    this.container.append(ret.fragment);\n  }\n\n  renderStringMarkup(markup) {\n    const cache = this.containers;\n    const children = Vector.createVectors(markup); // Cache children elements for quicker access.\n\n    children.forEach(child => {\n      const className = child.attr('class');\n\n      if (className) {\n        cache[StringExt.camelCase(className)] = child.node;\n      }\n    });\n    this.renderTools();\n    this.renderVertexMarkers();\n    this.renderArrowheadMarkers();\n    Dom.append(this.container, children.map(child => child.node));\n  }\n\n  renderLabels() {\n    const edge = this.cell;\n    const labels = edge.getLabels();\n    const count = labels.length;\n    let container = this.containers.labels;\n    this.labelCache = {};\n    this.labelSelectors = {};\n\n    if (count <= 0) {\n      if (container && container.parentNode) {\n        container.parentNode.removeChild(container);\n      }\n\n      return this;\n    }\n\n    if (container) {\n      this.empty(container);\n    } else {\n      container = Dom.createSvgElement('g');\n      this.addClass(this.prefixClassName('edge-labels'), container);\n      this.containers.labels = container;\n    }\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n      let labelNode;\n      let selectors;\n\n      if (normalized) {\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      } else {\n        const defaultLabel = edge.getDefaultLabel();\n        const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      }\n\n      labelNode.setAttribute('data-index', `${i}`);\n      container.appendChild(labelNode);\n      const rootSelector = this.rootSelector;\n\n      if (selectors[rootSelector]) {\n        throw new Error('Ambiguous label root selector.');\n      }\n\n      selectors[rootSelector] = labelNode;\n      this.labelCache[i] = labelNode;\n      this.labelSelectors[i] = selectors;\n    }\n\n    if (container.parentNode == null) {\n      this.container.appendChild(container);\n    }\n\n    this.updateLabels();\n    this.customizeLabels();\n    return this;\n  }\n\n  parseLabelMarkup(markup) {\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.parseLabelStringMarkup(markup);\n      }\n\n      return this.parseJSONMarkup(markup);\n    }\n\n    return null;\n  }\n\n  parseLabelStringMarkup(labelMarkup) {\n    const children = Vector.createVectors(labelMarkup);\n    const fragment = document.createDocumentFragment();\n\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node;\n      fragment.appendChild(currentChild);\n    }\n\n    return {\n      fragment,\n      selectors: {}\n    };\n  }\n\n  normalizeLabelMarkup(markup) {\n    if (markup == null) {\n      return;\n    }\n\n    const fragment = markup.fragment;\n\n    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n      throw new Error('Invalid label markup.');\n    }\n\n    let vel;\n    const childNodes = fragment.childNodes;\n\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in `<g/>`\n      // add a `<g/>` container\n      vel = Vector.create('g').append(fragment);\n    } else {\n      vel = Vector.create(childNodes[0]);\n    }\n\n    vel.addClass(this.prefixClassName('edge-label'));\n    return {\n      node: vel.node,\n      selectors: markup.selectors\n    };\n  }\n\n  updateLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell;\n      const labels = edge.labels;\n      const canLabelMove = this.can('edgeLabelMovable');\n      const defaultLabel = edge.getDefaultLabel();\n\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const elem = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n        const label = labels[i];\n        const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n        this.updateAttrs(elem, attrs, {\n          selectors,\n          rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined\n        });\n      }\n    }\n  }\n\n  mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {\n    if (labelAttrs === null) {\n      return null;\n    }\n\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) {\n        return null;\n      }\n\n      if (defaultLabelAttrs === undefined) {\n        return undefined;\n      }\n\n      if (hasCustomMarkup) {\n        return defaultLabelAttrs;\n      }\n\n      return ObjectExt.merge({}, defaultLabelAttrs);\n    }\n\n    if (hasCustomMarkup) {\n      return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);\n    }\n  }\n\n  customizeLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell;\n      const labels = edge.labels;\n\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const label = labels[i];\n        const container = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        this.graph.hook.onEdgeLabelRendered({\n          edge,\n          label,\n          container,\n          selectors\n        });\n      }\n    }\n  }\n\n  renderTools() {\n    const container = this.containers.tools;\n\n    if (container == null) {\n      return this;\n    }\n\n    const markup = this.cell.toolMarkup;\n    const $container = this.$(container).empty();\n\n    if (Markup.isStringMarkup(markup)) {\n      let template = StringExt.template(markup);\n      const tool = Vector.create(template());\n      $container.append(tool.node);\n      this.toolCache = tool.node; // If `doubleTools` is enabled, we render copy of the tools on the\n      // other side of the edge as well but only if the edge is longer\n      // than `longLength`.\n\n      if (this.options.doubleTools) {\n        let tool2;\n        const doubleToolMarkup = this.cell.doubleToolMarkup;\n\n        if (Markup.isStringMarkup(doubleToolMarkup)) {\n          template = StringExt.template(doubleToolMarkup);\n          tool2 = Vector.create(template());\n        } else {\n          tool2 = tool.clone();\n        }\n\n        $container.append(tool2.node);\n        this.tool2Cache = tool2.node;\n      }\n    }\n\n    return this;\n  }\n\n  renderExternalTools() {\n    const tools = this.cell.getTools();\n    this.addTools(tools);\n    return this;\n  }\n\n  renderVertexMarkers() {\n    const container = this.containers.vertices;\n\n    if (container == null) {\n      return this;\n    }\n\n    const markup = this.cell.vertexMarkup;\n    const $container = this.$(container).empty();\n\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup);\n      this.cell.getVertices().forEach((vertex, index) => {\n        $container.append(Vector.create(template(Object.assign({\n          index\n        }, vertex))).node);\n      });\n    }\n\n    return this;\n  }\n\n  renderArrowheadMarkers() {\n    const container = this.containers.arrowheads;\n\n    if (container == null) {\n      return this;\n    }\n\n    const markup = this.cell.arrowheadMarkup;\n    const $container = this.$(container).empty();\n\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup);\n      const sourceArrowhead = Vector.create(template({\n        end: 'source'\n      })).node;\n      const targetArrowhead = Vector.create(template({\n        end: 'target'\n      })).node;\n      this.containers.sourceArrowhead = sourceArrowhead;\n      this.containers.targetArrowhead = targetArrowhead;\n      $container.append(sourceArrowhead, targetArrowhead);\n    }\n\n    return this;\n  } // #endregion\n  // #region updating\n\n\n  update(partialAttrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.cleanCache();\n    this.updateConnection(options);\n    const attrs = this.cell.getAttrs();\n\n    if (attrs != null) {\n      this.updateAttrs(this.container, attrs, {\n        attrs: partialAttrs === attrs ? null : partialAttrs,\n        selectors: this.selectors\n      });\n    }\n\n    this.updateConnectionPath();\n    this.updateLabelPositions();\n    this.updateToolsPosition();\n    this.updateArrowheadMarkers();\n\n    if (options.toolId == null) {\n      this.renderExternalTools();\n    } else {\n      this.updateTools(options);\n    }\n\n    return this;\n  }\n\n  removeRedundantLinearVertices() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const rawCount = routePoints.length; // Puts the route points into a polyline and try to simplify.\n\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: 0.01\n    });\n    const simplifiedPoints = polyline.points.map(point => point.toJSON());\n    const simplifiedCount = simplifiedPoints.length; // If simplification did not remove any redundant vertices.\n\n    if (rawCount === simplifiedCount) {\n      return 0;\n    } // Sets simplified polyline points as edge vertices.\n    // Removes first and last polyline points again (source/target anchors).\n\n\n    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n    return rawCount - simplifiedCount;\n  }\n\n  updateConnectionPath() {\n    const containers = this.containers;\n\n    if (containers.connection) {\n      const pathData = this.getConnectionPathData();\n      containers.connection.setAttribute('d', pathData);\n    }\n\n    if (containers.connectionWrap) {\n      const pathData = this.getConnectionPathData();\n      containers.connectionWrap.setAttribute('d', pathData);\n    }\n\n    if (containers.sourceMarker && containers.targetMarker) {\n      this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);\n    }\n  }\n\n  getTerminalView(type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n\n      case 'target':\n        return this.targetView || null;\n\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n\n  getTerminalAnchor(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourceAnchor);\n\n      case 'target':\n        return Point.create(this.targetAnchor);\n\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n\n  getTerminalConnectionPoint(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourcePoint);\n\n      case 'target':\n        return Point.create(this.targetPoint);\n\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n\n  getTerminalMagnet(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    switch (type) {\n      case 'source':\n        {\n          if (options.raw) {\n            return this.sourceMagnet;\n          }\n\n          const sourceView = this.sourceView;\n\n          if (!sourceView) {\n            return null;\n          }\n\n          return this.sourceMagnet || sourceView.container;\n        }\n\n      case 'target':\n        {\n          if (options.raw) {\n            return this.targetMagnet;\n          }\n\n          const targetView = this.targetView;\n\n          if (!targetView) {\n            return null;\n          }\n\n          return this.targetMagnet || targetView.container;\n        }\n\n      default:\n        {\n          throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n  }\n\n  updateConnection() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const edge = this.cell; // The edge is being translated by an ancestor that will shift\n    // source, target and vertices by an equal distance.\n\n    if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {\n      const tx = options.tx || 0;\n      const ty = options.ty || 0;\n      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n      this.translateConnectionPoints(tx, ty);\n      this.path.translate(tx, ty);\n    } else {\n      const vertices = edge.getVertices(); // 1. Find anchor points\n\n      const anchors = this.findAnchors(vertices);\n      this.sourceAnchor = anchors.source;\n      this.targetAnchor = anchors.target; // 2. Find route points\n\n      this.routePoints = this.findRoutePoints(vertices); // 3. Find connection points\n\n      const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n      this.sourcePoint = connectionPoints.source;\n      this.targetPoint = connectionPoints.target; // 4. Find Marker Connection Point\n\n      const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint); // 5. Make path\n\n      this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n    }\n\n    this.cleanCache();\n  }\n\n  findAnchors(vertices) {\n    const edge = this.cell;\n    const source = edge.source;\n    const target = edge.target;\n    const firstVertex = vertices[0];\n    const lastVertex = vertices[vertices.length - 1];\n\n    if (target.priority && !source.priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    } // Usual order\n\n\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  }\n\n  findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n    let firstAnchor;\n    let secondAnchor;\n    const edge = this.cell;\n    const firstTerminal = edge[firstType];\n    const secondTerminal = edge[secondType];\n    const firstView = this.getTerminalView(firstType);\n    const secondView = this.getTerminalView(secondType);\n    const firstMagnet = this.getTerminalMagnet(firstType);\n    const secondMagnet = this.getTerminalMagnet(secondType);\n\n    if (firstView) {\n      let firstRef;\n\n      if (firstPoint) {\n        firstRef = Point.create(firstPoint);\n      } else if (secondView) {\n        firstRef = secondMagnet;\n      } else {\n        firstRef = Point.create(secondTerminal);\n      }\n\n      firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n    } else {\n      firstAnchor = Point.create(firstTerminal);\n    }\n\n    if (secondView) {\n      const secondRef = Point.create(secondPoint || firstAnchor);\n      secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n    } else {\n      secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();\n    }\n\n    return {\n      [firstType]: firstAnchor,\n      [secondType]: secondAnchor\n    };\n  }\n\n  getAnchor(def, cellView, magnet, ref, terminalType) {\n    const isEdge = cellView.isEdgeElement(magnet);\n    const connecting = this.graph.options.connecting;\n    let config = typeof def === 'string' ? {\n      name: def\n    } : def;\n\n    if (!config) {\n      const defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;\n      config = typeof defaults === 'string' ? {\n        name: defaults\n      } : defaults;\n    }\n\n    if (!config) {\n      throw new Error(`Anchor should be specified.`);\n    }\n\n    let anchor;\n    const name = config.name;\n\n    if (isEdge) {\n      const fn = EdgeAnchor.registry.get(name);\n\n      if (typeof fn !== 'function') {\n        return EdgeAnchor.registry.onNotFound(name);\n      }\n\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    } else {\n      const fn = NodeAnchor.registry.get(name);\n\n      if (typeof fn !== 'function') {\n        return NodeAnchor.registry.onNotFound(name);\n      }\n\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    }\n\n    return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n  }\n\n  findRoutePoints() {\n    let vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n    const router = this.cell.getRouter() || defaultRouter;\n    let routePoints;\n\n    if (typeof router === 'function') {\n      routePoints = FunctionExt.call(router, this, vertices, {}, this);\n    } else {\n      const name = typeof router === 'string' ? router : router.name;\n      const args = typeof router === 'string' ? {} : router.args || {};\n      const fn = name ? Router.registry.get(name) : Router.presets.normal;\n\n      if (typeof fn !== 'function') {\n        return Router.registry.onNotFound(name);\n      }\n\n      routePoints = FunctionExt.call(fn, this, vertices, args, this);\n    }\n\n    return routePoints == null ? vertices.map(p => Point.create(p)) : routePoints.map(p => Point.create(p));\n  }\n\n  findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n    const edge = this.cell;\n    const connecting = this.graph.options.connecting;\n    const sourceTerminal = edge.getSource();\n    const targetTerminal = edge.getTarget();\n    const sourceView = this.sourceView;\n    const targetView = this.targetView;\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1]; // source\n\n    let sourcePoint;\n\n    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n      const sourceMagnet = this.sourceMagnet || sourceView.container;\n      const sourcePointRef = firstRoutePoint || targetAnchor;\n      const sourceLine = new Line(sourcePointRef, sourceAnchor);\n      const connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;\n      sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    } // target\n\n\n    let targetPoint;\n\n    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n      const targetMagnet = this.targetMagnet || targetView.container;\n      const targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;\n      const targetPointRef = lastRoutePoint || sourceAnchor;\n      const targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  }\n\n  getConnectionPoint(def, view, magnet, line, endType) {\n    const anchor = line.end;\n\n    if (def == null) {\n      return anchor;\n    }\n\n    const name = typeof def === 'string' ? def : def.name;\n    const args = typeof def === 'string' ? {} : def.args;\n    const fn = ConnectionPoint.registry.get(name);\n\n    if (typeof fn !== 'function') {\n      return ConnectionPoint.registry.onNotFound(name);\n    }\n\n    const connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n  }\n\n  updateMarkerAttr(type) {\n    const attrs = this.cell.getAttrs();\n    const key = `.${type}-marker`;\n    const partial = attrs && attrs[key];\n\n    if (partial) {\n      this.updateAttrs(this.container, {}, {\n        attrs: {\n          [key]: partial\n        },\n        selectors: this.selectors\n      });\n    }\n  }\n\n  findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n    const getLineWidth = type => {\n      const attrs = this.cell.getAttrs();\n      const keys = Object.keys(attrs);\n\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const attr = attrs[keys[i]];\n\n        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n          const strokeWidth = attr.strokeWidth || attr['stroke-width'];\n\n          if (strokeWidth) {\n            return parseFloat(strokeWidth);\n          }\n\n          break;\n        }\n      }\n\n      return null;\n    };\n\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1];\n    const sourceMarkerElem = this.containers.sourceMarker;\n    const targetMarkerElem = this.containers.targetMarker;\n    const cache = this.markerCache;\n    let sourceMarkerPoint;\n    let targetMarkerPoint; // Move the source point by the width of the marker taking into\n    // account its scale around x-axis. Note that scale is the only\n    // transform that makes sense to be set in `.marker-source`\n    // attributes object as all other transforms (translate/rotate)\n    // will be replaced by the `translateAndAutoOrient()` function.\n\n    if (sourceMarkerElem) {\n      this.updateMarkerAttr('source'); // support marker connection point registry???\n\n      cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem);\n\n      if (cache.sourceBBox.width > 0) {\n        const scale = Dom.scale(sourceMarkerElem);\n        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);\n      }\n    } else {\n      const strokeWidth = getLineWidth('source');\n\n      if (strokeWidth) {\n        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -strokeWidth);\n      }\n    }\n\n    if (targetMarkerElem) {\n      this.updateMarkerAttr('target');\n      cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem);\n\n      if (cache.targetBBox.width > 0) {\n        const scale = Dom.scale(targetMarkerElem);\n        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, cache.targetBBox.width * scale.sx * -1);\n      }\n    } else {\n      const strokeWidth = getLineWidth('target');\n\n      if (strokeWidth) {\n        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -strokeWidth);\n      }\n    } // If there was no markup for the marker, use the connection point.\n\n\n    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n    cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint\n    };\n  }\n\n  findPath(routePoints, sourcePoint, targetPoint) {\n    const def = this.cell.getConnector() || this.graph.options.connecting.connector;\n    let name;\n    let args;\n    let fn;\n\n    if (typeof def === 'string') {\n      name = def;\n    } else {\n      name = def.name;\n      args = def.args;\n    }\n\n    if (name) {\n      const method = Connector.registry.get(name);\n\n      if (typeof method !== 'function') {\n        return Connector.registry.onNotFound(name);\n      }\n\n      fn = method;\n    } else {\n      fn = Connector.presets.normal;\n    }\n\n    const path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {\n      raw: true\n    }), this);\n    return typeof path === 'string' ? Path.parse(path) : path;\n  }\n\n  translateConnectionPoints(tx, ty) {\n    const cache = this.markerCache;\n\n    if (cache.sourcePoint) {\n      cache.sourcePoint.translate(tx, ty);\n    }\n\n    if (cache.targetPoint) {\n      cache.targetPoint.translate(tx, ty);\n    }\n\n    this.sourcePoint.translate(tx, ty);\n    this.targetPoint.translate(tx, ty);\n    this.sourceAnchor.translate(tx, ty);\n    this.targetAnchor.translate(tx, ty);\n  }\n\n  updateLabelPositions() {\n    if (this.containers.labels == null) {\n      return this;\n    }\n\n    const path = this.path;\n\n    if (!path) {\n      return this;\n    }\n\n    const edge = this.cell;\n    const labels = edge.getLabels();\n\n    if (labels.length === 0) {\n      return this;\n    }\n\n    const defaultLabel = edge.getDefaultLabel();\n    const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const labelPosition = this.normalizeLabelPosition(label.position);\n      const pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n      const matrix = this.getLabelTransformationMatrix(pos);\n      this.labelCache[i].setAttribute('transform', Dom.matrixToTransformString(matrix));\n    }\n\n    return this;\n  }\n\n  updateToolsPosition() {\n    if (this.containers.tools == null) {\n      return this;\n    } // Move the tools a bit to the target position but don't cover the\n    // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n    // The offset should be always more than the\n    // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n    // this up all the time would be slow.\n\n\n    let scale = '';\n    let offset = this.options.toolsOffset;\n    const connectionLength = this.getConnectionLength(); // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n    // In that case we won't update tools position at all.\n\n    if (connectionLength != null) {\n      // If the edge is too short, make the tools half the\n      // size and the offset twice as low.\n      if (connectionLength < this.options.shortLength) {\n        scale = 'scale(.5)';\n        offset /= 2;\n      }\n\n      let pos = this.getPointAtLength(offset);\n\n      if (pos != null) {\n        Dom.attr(this.toolCache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n      }\n\n      if (this.options.doubleTools && connectionLength >= this.options.longLength) {\n        const doubleToolsOffset = this.options.doubleToolsOffset || offset;\n        pos = this.getPointAtLength(connectionLength - doubleToolsOffset);\n\n        if (pos != null) {\n          Dom.attr(this.tool2Cache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n        }\n\n        Dom.attr(this.tool2Cache, 'visibility', 'visible');\n      } else if (this.options.doubleTools) {\n        Dom.attr(this.tool2Cache, 'visibility', 'hidden');\n      }\n    }\n\n    return this;\n  }\n\n  updateArrowheadMarkers() {\n    const container = this.containers.arrowheads;\n\n    if (container == null) {\n      return this;\n    }\n\n    if (container.style.display === 'none') {\n      return this;\n    }\n\n    const sourceArrowhead = this.containers.sourceArrowhead;\n    const targetArrowhead = this.containers.targetArrowhead;\n\n    if (sourceArrowhead && targetArrowhead) {\n      const len = this.getConnectionLength() || 0;\n      const sx = len < this.options.shortLength ? 0.5 : 1;\n      Dom.scale(sourceArrowhead, sx);\n      Dom.scale(targetArrowhead, sx);\n      this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);\n    }\n\n    return this;\n  }\n\n  updateTerminalProperties(type) {\n    const edge = this.cell;\n    const graph = this.graph;\n    const terminal = edge[type];\n    const nodeId = terminal && terminal.cell;\n    const viewKey = `${type}View`; // terminal is a point\n\n    if (!nodeId) {\n      this[viewKey] = null;\n      this.updateTerminalMagnet(type);\n      return true;\n    }\n\n    const terminalCell = graph.getCellById(nodeId);\n\n    if (!terminalCell) {\n      throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`);\n    }\n\n    const endView = terminalCell.findView(graph);\n\n    if (!endView) {\n      return false;\n    }\n\n    this[viewKey] = endView;\n    this.updateTerminalMagnet(type);\n    return true;\n  }\n\n  updateTerminalMagnet(type) {\n    const propName = `${type}Magnet`;\n    const terminalView = this.getTerminalView(type);\n\n    if (terminalView) {\n      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n\n      if (magnet === terminalView.container) {\n        magnet = null;\n      }\n\n      this[propName] = magnet;\n    } else {\n      this[propName] = null;\n    }\n  }\n\n  translateAndAutoOrientArrows(sourceArrow, targetArrow) {\n    const route = this.routePoints;\n\n    if (sourceArrow) {\n      Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);\n    }\n\n    if (targetArrow) {\n      Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);\n    }\n  }\n\n  getLabelPositionAngle(idx) {\n    const label = this.cell.getLabelAt(idx);\n\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.angle || 0;\n    }\n\n    return 0;\n  }\n\n  getLabelPositionArgs(idx) {\n    const label = this.cell.getLabelAt(idx);\n\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.options;\n    }\n  }\n\n  getDefaultLabelPositionArgs() {\n    const defaultLabel = this.cell.getDefaultLabel();\n\n    if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {\n      return defaultLabel.position.options;\n    }\n  } // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n\n\n  mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) {\n      return null;\n    }\n\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) {\n        return null;\n      }\n\n      return defaultLabelPositionArgs;\n    }\n\n    return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  }\n\n  addLabel(p1, p2, p3, options) {\n    let localX;\n    let localY;\n    let localAngle = 0;\n    let localOptions;\n\n    if (typeof p1 !== 'number') {\n      localX = p1.x;\n      localY = p1.y;\n\n      if (typeof p2 === 'number') {\n        localAngle = p2;\n        localOptions = p3;\n      } else {\n        localOptions = p2;\n      }\n    } else {\n      localX = p1;\n      localY = p2;\n\n      if (typeof p3 === 'number') {\n        localAngle = p3;\n        localOptions = options;\n      } else {\n        localOptions = p3;\n      }\n    } // merge label position arguments\n\n\n    const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n    const labelPositionArgs = localOptions;\n    const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array\n\n    const label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n    };\n    const index = -1;\n    this.cell.insertLabel(label, index, localOptions);\n    return index;\n  }\n\n  addVertex(x, y, options) {\n    const isPoint = typeof x !== 'number';\n    const localX = isPoint ? x.x : x;\n    const localY = isPoint ? x.y : y;\n    const localOptions = isPoint ? y : options;\n    const vertex = {\n      x: localX,\n      y: localY\n    };\n    const index = this.getVertexIndex(localX, localY);\n    this.cell.insertVertex(vertex, index, localOptions);\n    return index;\n  }\n\n  sendToken(token, options, callback) {\n    let duration;\n    let reversed;\n    let selector;\n    let rorate;\n    let timing = 'linear';\n\n    if (typeof options === 'object') {\n      duration = options.duration;\n      reversed = options.reversed === true;\n      selector = options.selector;\n\n      if (options.rotate === false) {\n        rorate = '';\n      } else if (options.rotate === true) {\n        rorate = 'auto';\n      } else if (options.rotate != null) {\n        rorate = `${options.rotate}`;\n      }\n\n      if (options.timing) {\n        timing = options.timing;\n      }\n    } else {\n      duration = options;\n      reversed = false;\n      selector = null;\n    }\n\n    duration = duration || 1000;\n    const attrs = {\n      dur: `${duration}ms`,\n      repeatCount: '1',\n      calcMode: timing,\n      fill: 'freeze'\n    };\n\n    if (rorate) {\n      attrs.rotate = rorate;\n    }\n\n    if (reversed) {\n      attrs.keyPoints = '1;0';\n      attrs.keyTimes = '0;1';\n    }\n\n    if (typeof options === 'object') {\n      const {\n        duration,\n        reversed,\n        selector,\n        rotate,\n        timing\n      } = options,\n            others = __rest(options, [\"duration\", \"reversed\", \"selector\", \"rotate\", \"timing\"]);\n\n      Object.keys(others).forEach(key => {\n        attrs[key] = others[key];\n      });\n    }\n\n    let path;\n\n    if (typeof selector === 'string') {\n      path = this.findOne(selector, this.container, this.selectors);\n    } else {\n      // Select connection path automatically.\n      path = this.containers.connection ? this.containers.connection : this.container.querySelector('path');\n    }\n\n    if (!(path instanceof SVGPathElement)) {\n      throw new Error('Token animation requires a valid connection path.');\n    }\n\n    const target = typeof token === 'string' ? this.findOne(token) : token;\n\n    if (target == null) {\n      throw new Error('Token animation requires a valid token element.');\n    }\n\n    const parent = target.parentNode;\n\n    const revert = () => {\n      if (!parent) {\n        Dom.remove(target);\n      }\n    };\n\n    const vToken = Vector.create(target);\n\n    if (!parent) {\n      vToken.appendTo(this.graph.view.stage);\n    }\n\n    const onComplete = attrs.complete;\n\n    attrs.complete = e => {\n      revert();\n\n      if (callback) {\n        callback();\n      }\n\n      if (onComplete) {\n        onComplete(e);\n      }\n    };\n\n    const stop = vToken.animateAlongPath(attrs, path);\n    return () => {\n      revert();\n      stop();\n    };\n  } // #endregion\n\n\n  getConnection() {\n    return this.path != null ? this.path.clone() : null;\n  }\n\n  getConnectionPathData() {\n    if (this.path == null) {\n      return '';\n    }\n\n    const cache = this.cache.pathCache;\n\n    if (!ObjectExt.has(cache, 'data')) {\n      cache.data = this.path.serialize();\n    }\n\n    return cache.data || '';\n  }\n\n  getConnectionSubdivisions() {\n    if (this.path == null) {\n      return null;\n    }\n\n    const cache = this.cache.pathCache;\n\n    if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n      cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n    }\n\n    return cache.segmentSubdivisions;\n  }\n\n  getConnectionLength() {\n    if (this.path == null) {\n      return 0;\n    }\n\n    const cache = this.cache.pathCache;\n\n    if (!ObjectExt.has(cache, 'length')) {\n      cache.length = this.path.length({\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n\n    return cache.length;\n  }\n\n  getPointAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getPointAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n\n    if (NumberExt.isPercentage(ratio)) {\n      // eslint-disable-next-line\n      ratio = parseFloat(ratio) / 100;\n    }\n\n    return this.path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getTangentAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getTangentAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getClosestPoint(point) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getClosestPointLength(point) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getClosestPointRatio(point) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getLabelPosition(x, y, p3, p4) {\n    const pos = {\n      distance: 0\n    }; // normalize data from the two possible signatures\n\n    let angle = 0;\n    let options;\n\n    if (typeof p3 === 'number') {\n      angle = p3;\n      options = p4;\n    } else {\n      options = p3;\n    }\n\n    if (options != null) {\n      pos.options = options;\n    } // identify distance/offset settings\n\n\n    const isOffsetAbsolute = options && options.absoluteOffset;\n    const isDistanceRelative = !(options && options.absoluteDistance);\n    const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance; // find closest point t\n\n    const path = this.path;\n    const pathOptions = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const labelPoint = new Point(x, y);\n    const t = path.closestPointT(labelPoint, pathOptions); // distance\n\n    const totalLength = this.getConnectionLength() || 0;\n    let labelDistance = path.lengthAtT(t, pathOptions);\n\n    if (isDistanceRelative) {\n      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n    }\n\n    if (isDistanceAbsoluteReverse) {\n      // fix for end point (-0 => 1)\n      labelDistance = -1 * (totalLength - labelDistance) || 1;\n    }\n\n    pos.distance = labelDistance; // offset\n    // use absolute offset if:\n    // - options.absoluteOffset is true,\n    // - options.absoluteOffset is not true but there is no tangent\n\n    let tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    let labelOffset;\n\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      const closestPoint = path.pointAtT(t);\n      const labelOffsetDiff = labelPoint.diff(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n\n    pos.offset = labelOffset;\n    pos.angle = angle;\n    return pos;\n  }\n\n  normalizeLabelPosition(pos) {\n    if (typeof pos === 'number') {\n      return {\n        distance: pos\n      };\n    }\n\n    return pos;\n  }\n\n  getLabelTransformationMatrix(labelPosition) {\n    const pos = this.normalizeLabelPosition(labelPosition);\n    const options = pos.options || {};\n    const labelAngle = pos.angle || 0;\n    const labelDistance = pos.distance;\n    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    let labelOffset = 0;\n    const offsetCoord = {\n      x: 0,\n      y: 0\n    };\n    const offset = pos.offset;\n\n    if (offset) {\n      if (typeof offset === 'number') {\n        labelOffset = offset;\n      } else {\n        if (offset.x != null) {\n          offsetCoord.x = offset.x;\n        }\n\n        if (offset.y != null) {\n          offsetCoord.y = offset.y;\n        }\n      }\n    }\n\n    const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n    const isKeepGradient = options.keepGradient;\n    const isEnsureLegibility = options.ensureLegibility;\n    const path = this.path;\n    const pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    const tangent = path.tangentAtLength(distance, pathOpt);\n    let translation;\n    let angle = labelAngle;\n\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start;\n        translation.translate(offsetCoord);\n      } else {\n        const normal = tangent.clone();\n        normal.rotate(-90, tangent.start);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n\n        if (isEnsureLegibility) {\n          angle = Angle.normalize((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start;\n\n      if (isOffsetAbsolute) {\n        translation.translate(offsetCoord);\n      }\n    }\n\n    return Dom.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  }\n\n  getLabelCoordinates(pos) {\n    const matrix = this.getLabelTransformationMatrix(pos);\n    return new Point(matrix.e, matrix.f);\n  }\n\n  getVertexIndex(x, y) {\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const vertexLength = this.getClosestPointLength(new Point(x, y));\n    let index = 0;\n\n    if (vertexLength != null) {\n      for (const ii = vertices.length; index < ii; index += 1) {\n        const currentVertex = vertices[index];\n        const currentLength = this.getClosestPointLength(currentVertex);\n\n        if (currentLength != null && vertexLength < currentLength) {\n          break;\n        }\n      }\n    }\n\n    return index;\n  }\n\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line\n\n    const edge = view.cell;\n    const cell = edge;\n\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        edge,\n        cell\n      };\n    }\n\n    return {\n      e,\n      x,\n      y,\n      view,\n      edge,\n      cell\n    };\n  }\n\n  notifyUnhandledMouseDown(e, x, y) {\n    this.notify('edge:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n\n  notifyMouseDown(e, x, y) {\n    super.onMouseDown(e, x, y);\n    this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n  }\n\n  notifyMouseMove(e, x, y) {\n    super.onMouseMove(e, x, y);\n    this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n  }\n\n  notifyMouseUp(e, x, y) {\n    super.onMouseUp(e, x, y);\n    this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n  }\n\n  onClick(e, x, y) {\n    super.onClick(e, x, y);\n    this.notify('edge:click', this.getEventArgs(e, x, y));\n  }\n\n  onDblClick(e, x, y) {\n    super.onDblClick(e, x, y);\n    this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n  }\n\n  onContextMenu(e, x, y) {\n    super.onContextMenu(e, x, y);\n    this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n  }\n\n  onMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    const className = e.target.getAttribute('class');\n\n    switch (className) {\n      case 'vertex':\n        {\n          this.startVertexDragging(e, x, y);\n          return;\n        }\n\n      case 'vertex-remove':\n      case 'vertex-remove-area':\n        {\n          this.handleVertexRemoving(e, x, y);\n          return;\n        }\n\n      case 'connection':\n      case 'connection-wrap':\n        {\n          this.handleVertexAdding(e, x, y);\n          return;\n        }\n\n      case 'arrowhead':\n        {\n          this.startArrowheadDragging(e, x, y);\n          return;\n        }\n\n      case 'source-marker':\n      case 'target-marker':\n        {\n          this.notifyUnhandledMouseDown(e, x, y);\n          return;\n        }\n\n      default:\n        break;\n    }\n\n    this.startEdgeDragging(e, x, y);\n  }\n\n  onMouseMove(e, x, y) {\n    const data = this.getEventData(e);\n\n    switch (data.action) {\n      case 'drag-vertex':\n        {\n          this.dragVertex(e, x, y);\n          break;\n        }\n\n      case 'drag-label':\n        {\n          this.dragLabel(e, x, y);\n          break;\n        }\n\n      case 'drag-arrowhead':\n        {\n          this.dragArrowhead(e, x, y);\n          break;\n        }\n\n      case 'drag-edge':\n        {\n          this.dragEdge(e, x, y);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    this.notifyMouseMove(e, x, y);\n    return data;\n  }\n\n  onMouseUp(e, x, y) {\n    const data = this.getEventData(e);\n\n    switch (data.action) {\n      case 'drag-vertex':\n        {\n          this.stopVertexDragging(e, x, y);\n          break;\n        }\n\n      case 'drag-label':\n        {\n          this.stopLabelDragging(e, x, y);\n          break;\n        }\n\n      case 'drag-arrowhead':\n        {\n          this.stopArrowheadDragging(e, x, y);\n          break;\n        }\n\n      case 'drag-edge':\n        {\n          this.stopEdgeDragging(e, x, y);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    this.notifyMouseUp(e, x, y);\n    this.checkMouseleave(e);\n    return data;\n  }\n\n  onMouseOver(e) {\n    super.onMouseOver(e);\n    this.notify('edge:mouseover', this.getEventArgs(e));\n  }\n\n  onMouseOut(e) {\n    super.onMouseOut(e);\n    this.notify('edge:mouseout', this.getEventArgs(e));\n  }\n\n  onMouseEnter(e) {\n    super.onMouseEnter(e);\n    this.notify('edge:mouseenter', this.getEventArgs(e));\n  }\n\n  onMouseLeave(e) {\n    super.onMouseLeave(e);\n    this.notify('edge:mouseleave', this.getEventArgs(e));\n  }\n\n  onMouseWheel(e, x, y, delta) {\n    super.onMouseWheel(e, x, y, delta);\n    this.notify('edge:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n\n  onCustomEvent(e, name, x, y) {\n    // For default edge tool\n    const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n\n    if (tool) {\n      e.stopPropagation(); // no further action to be executed\n\n      if (this.can('useEdgeTools')) {\n        if (name === 'edge:remove') {\n          this.cell.remove({\n            ui: true\n          });\n          return;\n        }\n\n        this.notify('edge:customevent', Object.assign({\n          name\n        }, this.getEventArgs(e, x, y)));\n      }\n\n      this.notifyMouseDown(e, x, y);\n    } else {\n      this.notify('edge:customevent', Object.assign({\n        name\n      }, this.getEventArgs(e, x, y)));\n      super.onCustomEvent(e, name, x, y);\n    }\n  }\n\n  onLabelMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    this.startLabelDragging(e, x, y);\n    const stopPropagation = this.getEventData(e).stopPropagation;\n\n    if (stopPropagation) {\n      e.stopPropagation();\n    }\n  } // #region drag edge\n\n\n  startEdgeDragging(e, x, y) {\n    if (!this.can('edgeMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    this.setEventData(e, {\n      x,\n      y,\n      moving: false,\n      action: 'drag-edge'\n    });\n  }\n\n  dragEdge(e, x, y) {\n    const data = this.getEventData(e);\n\n    if (!data.moving) {\n      data.moving = true;\n      this.addClass('edge-moving');\n      this.notify('edge:move', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n\n    this.cell.translate(x - data.x, y - data.y, {\n      ui: true\n    });\n    this.setEventData(e, {\n      x,\n      y\n    });\n    this.notify('edge:moving', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n\n  stopEdgeDragging(e, x, y) {\n    const data = this.getEventData(e);\n\n    if (data.moving) {\n      this.removeClass('edge-moving');\n      this.notify('edge:moved', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n\n    data.moving = false;\n  } // #endregion\n  // #region drag arrowhead\n\n\n  prepareArrowheadDragging(type, options) {\n    const magnet = this.getTerminalMagnet(type);\n    const data = {\n      action: 'drag-arrowhead',\n      x: options.x,\n      y: options.y,\n      isNewEdge: options.isNewEdge === true,\n      terminalType: type,\n      initialMagnet: magnet,\n      initialTerminal: ObjectExt.clone(this.cell[type]),\n      fallbackAction: options.fallbackAction || 'revert',\n      getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n      options: options.options\n    };\n    this.beforeArrowheadDragging(data);\n    return data;\n  }\n\n  createValidateConnectionArgs(type) {\n    const args = [];\n    args[4] = type;\n    args[5] = this;\n    let opposite;\n    let i = 0;\n    let j = 0;\n\n    if (type === 'source') {\n      i = 2;\n      opposite = 'target';\n    } else {\n      j = 2;\n      opposite = 'source';\n    }\n\n    const terminal = this.cell[opposite];\n    const cellId = terminal.cell;\n\n    if (cellId) {\n      let magnet;\n      const view = args[i] = this.graph.renderer.findViewByCell(cellId);\n\n      if (view) {\n        magnet = view.getMagnetFromEdgeTerminal(terminal);\n\n        if (magnet === view.container) {\n          magnet = undefined;\n        }\n      }\n\n      args[i + 1] = magnet;\n    }\n\n    return (cellView, magnet) => {\n      args[j] = cellView;\n      args[j + 1] = cellView.container === magnet ? undefined : magnet;\n      return args;\n    };\n  }\n\n  beforeArrowheadDragging(data) {\n    data.zIndex = this.cell.zIndex;\n    this.cell.toFront();\n    const style = this.container.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n\n    if (this.graph.options.connecting.highlight) {\n      this.highlightAvailableMagnets(data);\n    }\n  }\n\n  afterArrowheadDragging(data) {\n    if (data.zIndex != null) {\n      this.cell.setZIndex(data.zIndex, {\n        ui: true\n      });\n      data.zIndex = null;\n    }\n\n    const container = this.container;\n    container.style.pointerEvents = data.pointerEvents || '';\n\n    if (this.graph.options.connecting.highlight) {\n      this.unhighlightAvailableMagnets(data);\n    }\n  }\n\n  arrowheadDragging(target, x, y, data) {\n    data.x = x;\n    data.y = y; // Checking views right under the pointer\n\n    if (data.currentTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.currentMagnet && data.currentView) {\n        data.currentView.unhighlight(data.currentMagnet, {\n          type: 'magnetAdsorbed'\n        });\n      }\n\n      data.currentView = this.graph.renderer.findViewByElem(target);\n\n      if (data.currentView) {\n        // If we found a view that is under the pointer, we need to find\n        // the closest magnet based on the real target element of the event.\n        data.currentMagnet = data.currentView.findMagnet(target);\n\n        if (data.currentMagnet && this.graph.hook.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {\n          data.currentView.highlight(data.currentMagnet, {\n            type: 'magnetAdsorbed'\n          });\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.currentMagnet = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.currentMagnet = null;\n      }\n    }\n\n    data.currentTarget = target;\n    this.cell.prop(data.terminalType, {\n      x,\n      y\n    }, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n\n  arrowheadDragged(data, x, y) {\n    const view = data.currentView;\n    const magnet = data.currentMagnet;\n\n    if (!magnet || !view) {\n      return;\n    }\n\n    view.unhighlight(magnet, {\n      type: 'magnetAdsorbed'\n    });\n    const type = data.terminalType;\n    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n    this.cell.setTerminal(type, terminal, {\n      ui: true\n    });\n  }\n\n  snapArrowhead(x, y, data) {\n    const graph = this.graph;\n    const snap = graph.options.connecting.snap;\n    const radius = typeof snap === 'object' && snap.radius || 50;\n    const views = graph.renderer.findViewsInArea({\n      x: x - radius,\n      y: y - radius,\n      width: 2 * radius,\n      height: 2 * radius\n    });\n    const prevView = data.closestView || null;\n    const prevMagnet = data.closestMagnet || null;\n    data.closestView = null;\n    data.closestMagnet = null;\n    let distance;\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    const pos = new Point(x, y);\n    views.forEach(view => {\n      if (view.container.getAttribute('magnet') !== 'false') {\n        // Find distance from the center of the cell to pointer coordinates\n        distance = view.cell.getBBox().getCenter().distance(pos); // the connection is looked up in a circle area by `distance < r`\n\n        if (distance < radius && distance < minDistance) {\n          if (prevMagnet === view.container || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = view.container;\n          }\n        }\n      }\n\n      view.container.querySelectorAll('[magnet]').forEach(magnet => {\n        if (magnet.getAttribute('magnet') !== 'false') {\n          const bbox = view.getBBoxOfElement(magnet);\n          distance = pos.distance(bbox.getCenter());\n\n          if (distance < radius && distance < minDistance) {\n            if (prevMagnet === magnet || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {\n              minDistance = distance;\n              data.closestView = view;\n              data.closestMagnet = magnet;\n            }\n          }\n        }\n      });\n    });\n    let terminal;\n    const type = data.terminalType;\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n    const changed = prevMagnet !== closestMagnet;\n\n    if (prevView && changed) {\n      prevView.unhighlight(prevMagnet, {\n        type: 'magnetAdsorbed'\n      });\n    }\n\n    if (closestView) {\n      if (!changed) {\n        return;\n      }\n\n      closestView.highlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n    } else {\n      terminal = {\n        x,\n        y\n      };\n    }\n\n    this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n\n  snapArrowheadEnd(data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      data.currentMagnet = closestView.findMagnet(closestMagnet);\n    }\n\n    data.closestView = null;\n    data.closestMagnet = null;\n  }\n\n  finishEmbedding(data) {\n    // Resets parent of the edge if embedding is enabled\n    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n      // Make sure we don't reverse to the original 'z' index\n      data.zIndex = null;\n    }\n  }\n\n  fallbackConnection(data) {\n    switch (data.fallbackAction) {\n      case 'remove':\n        this.cell.remove({\n          ui: true\n        });\n        break;\n\n      case 'revert':\n      default:\n        this.cell.prop(data.terminalType, data.initialTerminal, {\n          ui: true\n        });\n        break;\n    }\n  }\n\n  notifyConnectionEvent(data, e) {\n    const terminalType = data.terminalType;\n    const initialTerminal = data.initialTerminal;\n    const currentTerminal = this.cell[terminalType];\n    const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n\n    if (changed) {\n      const graph = this.graph;\n      const previous = initialTerminal;\n      const previousCell = previous.cell ? graph.getCellById(previous.cell) : null;\n      const previousPort = previous.port;\n      const previousView = previousCell ? graph.findViewByCell(previousCell) : null;\n      const previousPoint = previousCell || data.isNewEdge ? null : Point.create(initialTerminal).toJSON();\n      const current = currentTerminal;\n      const currentCell = current.cell ? graph.getCellById(current.cell) : null;\n      const currentPort = current.port;\n      const currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n      const currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();\n      this.notify('edge:connected', {\n        e,\n        previousCell,\n        previousPort,\n        previousView,\n        previousPoint,\n        currentCell,\n        currentView,\n        currentPort,\n        currentPoint,\n        previousMagnet: data.initialMagnet,\n        currentMagnet: data.currentMagnet,\n        edge: this.cell,\n        view: this,\n        type: terminalType,\n        isNew: data.isNewEdge\n      });\n    }\n  }\n\n  highlightAvailableMagnets(data) {\n    const graph = this.graph;\n    const cells = graph.model.getCells();\n    data.marked = {};\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const view = graph.renderer.findViewByCell(cells[i]);\n\n      if (!view) {\n        continue;\n      }\n\n      const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n\n      if (view.container.getAttribute('magnet') !== 'false') {\n        magnets.push(view.container);\n      }\n\n      const availableMagnets = magnets.filter(magnet => graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));\n\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n          view.highlight(availableMagnets[j], {\n            type: 'magnetAvailable'\n          });\n        } // highlight the entire view\n\n\n        view.highlight(null, {\n          type: 'nodeAvailable'\n        });\n        data.marked[view.cell.id] = availableMagnets;\n      }\n    }\n  }\n\n  unhighlightAvailableMagnets(data) {\n    const marked = data.marked || {};\n    Object.keys(marked).forEach(id => {\n      const view = this.graph.renderer.findViewByCell(id);\n\n      if (view) {\n        const magnets = marked[id];\n        magnets.forEach(magnet => {\n          view.unhighlight(magnet, {\n            type: 'magnetAvailable'\n          });\n        });\n        view.unhighlight(null, {\n          type: 'nodeAvailable'\n        });\n      }\n    });\n    data.marked = null;\n  }\n\n  startArrowheadDragging(e, x, y) {\n    if (!this.can('arrowheadMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    const elem = e.target;\n    const type = elem.getAttribute('data-terminal');\n    const data = this.prepareArrowheadDragging(type, {\n      x,\n      y\n    });\n    this.setEventData(e, data);\n  }\n\n  dragArrowhead(e, x, y) {\n    const data = this.getEventData(e);\n\n    if (this.graph.options.connecting.snap) {\n      this.snapArrowhead(x, y, data);\n    } else {\n      this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n    }\n  }\n\n  stopArrowheadDragging(e, x, y) {\n    const graph = this.graph;\n    const data = this.getEventData(e);\n\n    if (graph.options.connecting.snap) {\n      this.snapArrowheadEnd(data);\n    } else {\n      this.arrowheadDragged(data, x, y);\n    }\n\n    const valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n\n    if (valid) {\n      this.finishEmbedding(data);\n      this.notifyConnectionEvent(data, e);\n    } else {\n      // If the changed edge is not allowed, revert to its previous state.\n      this.fallbackConnection(data);\n    }\n\n    this.afterArrowheadDragging(data);\n  } // #endregion\n  // #region drag lable\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  startLabelDragging(e, x, y) {\n    if (this.can('edgeLabelMovable')) {\n      const target = e.currentTarget;\n      const index = parseInt(target.getAttribute('data-index'), 10);\n      const positionAngle = this.getLabelPositionAngle(index);\n      const labelPositionArgs = this.getLabelPositionArgs(index);\n      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n      const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n      this.setEventData(e, {\n        index,\n        positionAngle,\n        positionArgs,\n        stopPropagation: true,\n        action: 'drag-label'\n      });\n    } else {\n      // If labels can't be dragged no default action is triggered.\n      this.setEventData(e, {\n        stopPropagation: true\n      });\n    }\n\n    this.graph.view.delegateDragEvents(e, this);\n  }\n\n  dragLabel(e, x, y) {\n    const data = this.getEventData(e);\n    const originLabel = this.cell.getLabelAt(data.index);\n    const label = ObjectExt.merge({}, originLabel, {\n      position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n    });\n    this.cell.setLabelAt(data.index, label);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  stopLabelDragging(e, x, y) {} // #endregion\n  // #region drag vertex\n\n\n  handleVertexAdding(e, x, y) {\n    if (!this.can('vertexAddable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    } // Store the index at which the new vertex has just been placed.\n    // We'll be update the very same vertex position in `pointermove()`.\n\n\n    const index = this.addVertex({\n      x,\n      y\n    }, {\n      ui: true\n    });\n    this.setEventData(e, {\n      index,\n      action: 'drag-vertex'\n    });\n  }\n\n  handleVertexRemoving(e, x, y) {\n    if (!this.can('vertexDeletable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    const target = e.target;\n    const index = parseInt(target.getAttribute('idx'), 10);\n    this.cell.removeVertexAt(index);\n  }\n\n  startVertexDragging(e, x, y) {\n    if (!this.can('vertexMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    const target = e.target;\n    const index = parseInt(target.getAttribute('idx'), 10);\n    this.setEventData(e, {\n      index,\n      action: 'drag-vertex'\n    });\n  }\n\n  dragVertex(e, x, y) {\n    const data = this.getEventData(e);\n    this.cell.setVertexAt(data.index, {\n      x,\n      y\n    }, {\n      ui: true\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  stopVertexDragging(e, x, y) {}\n\n}\n\n(function (EdgeView) {\n  EdgeView.toStringTag = `X6.${EdgeView.name}`;\n\n  function isEdgeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof EdgeView) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n\n    if ((tag == null || tag === EdgeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.getConnection === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\n\nEdgeView.config({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    vertices: ['vertices', 'update'],\n    vertexMarkup: ['vertices'],\n    toolMarkup: ['tools'],\n    tools: ['widget']\n  },\n  shortLength: 105,\n  longLength: 155,\n  toolsOffset: 40,\n  doubleTools: false,\n  doubleToolsOffset: 65,\n  sampleInterval: 50\n});\nEdgeView.registry.register('edge', EdgeView, true);","map":null,"metadata":{},"sourceType":"module"}