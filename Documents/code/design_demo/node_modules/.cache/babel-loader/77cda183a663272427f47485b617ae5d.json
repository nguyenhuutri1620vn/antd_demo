{"ast":null,"code":"// @ts-nocheck\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\"; // @ts-ignore\n\nimport { World } from \"@antv/g-webgpu\"; // compile at runtime in dev mode\n\nimport { buildTextureData, attributesToTextureData } from \"../../util/gpu\"; // use compiled bundle in prod mode\n\nimport { fruchtermanBundle, clusterBundle } from \"./fruchtermanShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * fruchterman 布局\n */\n\nexport class FruchtermanGPULayout extends Base {\n  constructor(options) {\n    super();\n    /** 停止迭代的最大迭代数 */\n\n    this.maxIteration = 1000;\n    /** 重力大小，影响图的紧凑程度 */\n\n    this.gravity = 10;\n    /** 速度 */\n\n    this.speed = 1;\n    /** 是否产生聚类力 */\n\n    this.clustering = false;\n    /** 根据哪个字段聚类 */\n\n    this.clusterField = \"cluster\";\n    /** 聚类力大小 */\n\n    this.clusterGravity = 10;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    this.workerEnabled = false;\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.nodeMap = {};\n    this.nodeIdxMap = {};\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      maxIteration: 1000,\n      gravity: 10,\n      speed: 1,\n      clustering: false,\n      clusterGravity: 10\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      const center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      const nodeMap = {};\n      const nodeIdxMap = {};\n      nodes.forEach((node, i) => {\n        if (!isNumber(node.x)) node.x = Math.random() * this.width;\n        if (!isNumber(node.y)) node.y = Math.random() * this.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap; // layout\n\n      yield self.run();\n    });\n  }\n\n  executeWithWorker(canvas, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n      const center = self.center;\n\n      if (!nodes || nodes.length === 0) {\n        return;\n      }\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        return;\n      }\n\n      const nodeMap = {};\n      const nodeIdxMap = {};\n      nodes.forEach((node, i) => {\n        if (!isNumber(node.x)) node.x = Math.random() * this.width;\n        if (!isNumber(node.y)) node.y = Math.random() * this.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap; // layout\n\n      yield self.run(canvas, ctx);\n    });\n  }\n\n  run(canvas, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n      const edges = self.edges;\n      const maxIteration = self.maxIteration;\n      const center = self.center;\n      const area = self.height * self.width;\n      let maxDisplace = Math.sqrt(area) / 10;\n      const k2 = area / (nodes.length + 1);\n      const k = Math.sqrt(k2);\n      const speed = self.speed;\n      const clustering = self.clustering;\n      const {\n        array: attributeArray,\n        count: clusterCount\n      } = attributesToTextureData([self.clusterField], nodes); // pushing the fx and fy\n\n      nodes.forEach((node, i) => {\n        let fx = 0;\n        let fy = 0;\n\n        if (isNumber(node.fx) && isNumber(node.fy)) {\n          fx = node.fx || 0.001;\n          fy = node.fy || 0.001;\n        }\n\n        attributeArray[4 * i + 1] = fx;\n        attributeArray[4 * i + 2] = fy;\n      });\n      const numParticles = nodes.length;\n      const {\n        maxEdgePerVetex,\n        array: nodesEdgesArray\n      } = buildTextureData(nodes, edges);\n      const workerEnabled = self.workerEnabled;\n      let world;\n\n      if (workerEnabled) {\n        world = World.create({\n          canvas,\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } else {\n        world = World.create({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } // compile at runtime in dev mode\n      // const compiler = new Compiler()\n      // const fruchtermanBundle = compiler.compileBundle(fruchtermanCode)\n      // const clusterBundle = compiler.compileBundle(clusterCode)\n      // use compiled bundle in prod mode\n      // console.log(fruchtermanBundle.toString())\n      // console.log(clusterBundle.toString())\n\n\n      const onLayoutEnd = self.onLayoutEnd;\n      const clusterCenters = [];\n\n      for (let i = 0; i < clusterCount; i++) {\n        clusterCenters.push(0, 0, 0, 0);\n      }\n\n      const kernelFruchterman = world.createKernel(fruchtermanBundle).setDispatch([numParticles, 1, 1]).setBinding({\n        u_Data: nodesEdgesArray,\n        u_K: k,\n        u_K2: k2,\n        u_Gravity: self.gravity,\n        u_ClusterGravity: self.clusterGravity || self.gravity || 1,\n        u_Speed: speed,\n        u_MaxDisplace: maxDisplace,\n        u_Clustering: clustering ? 1 : 0,\n        u_Center: center,\n        u_AttributeArray: attributeArray,\n        u_ClusterCenters: clusterCenters,\n        MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n        VERTEX_COUNT: numParticles\n      });\n      let kernelCluster;\n\n      if (clustering) {\n        kernelCluster = world.createKernel(clusterBundle).setDispatch([clusterCount, 1, 1]).setBinding({\n          u_Data: nodesEdgesArray,\n          u_NodeAttributes: attributeArray,\n          u_ClusterCenters: clusterCenters,\n          VERTEX_COUNT: numParticles,\n          CLUSTER_COUNT: clusterCount\n        });\n      }\n\n      const execute = () => __awaiter(this, void 0, void 0, function* () {\n        for (let i = 0; i < maxIteration; i++) {\n          // eslint-disable-next-line no-await-in-loop\n          yield kernelFruchterman.execute();\n\n          if (clustering) {\n            kernelCluster.setBinding({\n              u_Data: kernelFruchterman\n            }); // eslint-disable-next-line no-await-in-loop\n\n            yield kernelCluster.execute();\n            kernelFruchterman.setBinding({\n              u_ClusterCenters: kernelCluster\n            });\n          }\n\n          kernelFruchterman.setBinding({\n            u_MaxDisplace: maxDisplace *= 0.99\n          });\n        }\n\n        const finalParticleData = yield kernelFruchterman.getOutput();\n\n        if (canvas) {\n          // 传递数据给主线程\n          ctx.postMessage({\n            type: LAYOUT_MESSAGE.GPUEND,\n            vertexEdgeData: finalParticleData // edgeIndexBufferData,\n\n          });\n        } else {\n          nodes.forEach((node, i) => {\n            const x = finalParticleData[4 * i];\n            const y = finalParticleData[4 * i + 1];\n            node.x = x;\n            node.y = y;\n          });\n        }\n\n        if (onLayoutEnd) onLayoutEnd();\n      });\n\n      yield execute();\n    });\n  }\n\n  getType() {\n    return \"fruchterman-gpu\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}