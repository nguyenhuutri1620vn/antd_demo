{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { each, mix } from '@antv/util';\nimport { Util } from '@antv/g6-core';\nimport Base from '../base';\nvar pointLineDistance = Util.pointLineDistance; // 对齐线样式\n\nvar alignLineStyle = {\n  stroke: '#FA8C16',\n  lineWidth: 1\n};\n\nvar SnapLine =\n/** @class */\nfunction (_super) {\n  __extends(SnapLine, _super);\n\n  function SnapLine(props) {\n    return _super.call(this, props) || this;\n  }\n\n  SnapLine.prototype.getDefaultCfgs = function () {\n    return {\n      line: alignLineStyle,\n\n      /**\n       * item align type\n       * @type {String|True|False}\n       */\n      itemAlignType: 'center',\n\n      /**\n       * tolerance to item force align\n       * @type {String|True|False}\n       */\n      tolerance: 5,\n      horizontalLines: {},\n      verticalLines: {},\n      alignLines: []\n    };\n  };\n\n  SnapLine.prototype.init = function () {}; // class-methods-use-this\n\n\n  SnapLine.prototype.getEvents = function () {\n    return {\n      'node:dragstart': 'onDragStart',\n      'node:drag': 'onDrag',\n      'node:dragend': 'onDragEnd'\n    };\n  };\n\n  SnapLine.prototype.onDragStart = function () {\n    this.initBoxLine();\n  };\n\n  SnapLine.prototype.onDrag = function (e) {\n    var item = e.item; // 计算辅助线位置,拖动过程中更新辅助线\n\n    var delegateShape = item.get('delegateShape') || item;\n    var bbox = delegateShape.getBBox();\n    var model = item.getModel();\n    var dx = model.x - bbox.x;\n    var dy = model.y - bbox.y;\n    this.show({\n      x: bbox.minX + dx,\n      y: bbox.minY + dy\n    }, {\n      width: bbox.width,\n      height: bbox.height\n    });\n  };\n\n  SnapLine.prototype.onDragEnd = function () {\n    // 拖动结束时候删除辅助线\n    this.destory();\n  };\n  /**\n   * 每次开始拖动之前，计算出所有节点在水平和垂直方向上，左中右三条中线，并缓存起来\n   *\n   * @param {object} item Node节点\n   * @memberof AlignLine\n   */\n\n\n  SnapLine.prototype.initBoxLine = function () {\n    var _a = this._cfgs,\n        horizontalLines = _a.horizontalLines,\n        verticalLines = _a.verticalLines,\n        itemAlignType = _a.itemAlignType;\n    var graph = this.get('graph');\n    var nodes = graph.getNodes();\n    nodes.forEach(function (item) {\n      var bbox = item.getBBox();\n      var nodeId = item.get('id'); // 设置水平方向辅助线\n\n      if (itemAlignType === true || itemAlignType === 'horizontal') {\n        // tltr: top left top right\n        // lcrc: left center right center\n        // blbr: bottom left bottom right\n        horizontalLines[\"\".concat(nodeId, \"tltr\")] = [bbox.minX, bbox.minY, bbox.maxX, bbox.minY, item];\n        horizontalLines[\"\".concat(nodeId, \"lcrc\")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];\n        horizontalLines[\"\".concat(nodeId, \"blbr\")] = [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY, item];\n      } else if (itemAlignType === 'center') {\n        horizontalLines[\"\".concat(nodeId, \"lcrc\")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];\n      } // 设置垂直方向辅助线\n\n\n      if (itemAlignType === true || itemAlignType === 'vertical') {\n        // tlbl: top left bottom left\n        // tcbc: top center bottom center\n        // trbr: top right bottom right\n        verticalLines[\"\".concat(nodeId, \"tlbl\")] = [bbox.minX, bbox.minY, bbox.minX, bbox.maxY, item];\n        verticalLines[\"\".concat(nodeId, \"tcbc\")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];\n        verticalLines[\"\".concat(nodeId, \"trbr\")] = [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY, item];\n      } else if (itemAlignType === 'center') {\n        verticalLines[\"\".concat(nodeId, \"tcbc\")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];\n      }\n    });\n  };\n  /**\n   * 显示AlignLine\n   *\n   * @param {object} point 起始点\n   * @param {object} bbox BBox\n   * @returns\n   * @memberof AlignLine\n   */\n\n\n  SnapLine.prototype.show = function (point, bbox) {\n    var originPoint = mix({}, point);\n    this.itemAlign(point, bbox, originPoint);\n    return point;\n  };\n  /**\n   * 拖动拖出中添加辅助线\n   *\n   * @param {object} point 起始点\n   * @param {object} bbox 代理形状的bbox\n   * @param {object} originPoint 原始点，同point\n   * @memberof AlignLine\n   */\n\n\n  SnapLine.prototype.itemAlign = function (point, bbox, originPoint) {\n    var _this = this;\n\n    var _a = this._cfgs,\n        horizontalLines = _a.horizontalLines,\n        verticalLines = _a.verticalLines,\n        tolerance = _a.tolerance;\n    var tc = {\n      x: originPoint.x + bbox.width / 2,\n      y: originPoint.y\n    };\n    var cc = {\n      x: originPoint.x + bbox.width / 2,\n      y: originPoint.y + bbox.height / 2\n    };\n    var bc = {\n      x: originPoint.x + bbox.width / 2,\n      y: originPoint.y + bbox.height\n    };\n    var lc = {\n      x: originPoint.x,\n      y: originPoint.y + bbox.height / 2\n    };\n    var rc = {\n      x: originPoint.x + bbox.width,\n      y: originPoint.y + bbox.height / 2\n    };\n    var horizontalDis = [];\n    var verticalDis = [];\n    var alignCfg = null;\n    this.clearAlignLine();\n    each(horizontalLines, function (line) {\n      if (line[4].isVisible) {\n        horizontalDis.push(_this.getLineDisObject(line, tc));\n        horizontalDis.push(_this.getLineDisObject(line, cc));\n        horizontalDis.push(_this.getLineDisObject(line, bc));\n      }\n    });\n    each(verticalLines, function (line) {\n      if (line[4].isVisible) {\n        verticalDis.push(_this.getLineDisObject(line, lc));\n        verticalDis.push(_this.getLineDisObject(line, cc));\n        verticalDis.push(_this.getLineDisObject(line, rc));\n      }\n    });\n    horizontalDis.sort(function (a, b) {\n      return a.dis - b.dis;\n    });\n    verticalDis.sort(function (a, b) {\n      return a.dis - b.dis;\n    });\n\n    if (horizontalDis.length !== 0 && horizontalDis[0].dis < tolerance) {\n      point.y = horizontalDis[0].line[1] - horizontalDis[0].point.y + originPoint.y;\n      alignCfg = {\n        type: 'item',\n        horizontals: [horizontalDis[0]]\n      };\n\n      for (var i = 1; i < 3; i++) {\n        if (horizontalDis[0].dis === horizontalDis[i].dis) {\n          alignCfg.horizontals.push(horizontalDis[i]);\n        }\n      }\n    }\n\n    if (verticalDis.length !== 0 && verticalDis[0].dis < tolerance) {\n      point.x = verticalDis[0].line[0] - verticalDis[0].point.x + originPoint.x;\n\n      if (!alignCfg) {\n        alignCfg = {\n          type: 'item',\n          verticals: [verticalDis[0]]\n        };\n      } else {\n        alignCfg.verticals = [verticalDis[0]];\n      }\n\n      for (var i = 1; i < 3; i++) {\n        if (verticalDis[0].dis === verticalDis[i].dis) {\n          alignCfg.verticals.push(verticalDis[i]);\n        }\n      }\n    }\n\n    if (alignCfg) {\n      alignCfg.bbox = bbox;\n      this.addAlignLine(alignCfg);\n    }\n  };\n  /**\n   * 根据配置项添加辅助线\n   *\n   * @param {object} cfg\n   * @memberof AlignLine\n   */\n\n\n  SnapLine.prototype.addAlignLine = function (cfg) {\n    var bbox = cfg.bbox,\n        type = cfg.type,\n        horizontals = cfg.horizontals,\n        verticals = cfg.verticals;\n    var _a = this._cfgs,\n        lineStyle = _a.line,\n        alignLines = _a.alignLines;\n    var graph = this.get('graph');\n    var group = graph.get('group');\n\n    if (type === 'item') {\n      if (horizontals) {\n        each(horizontals, function (horizontal) {\n          var refLine = horizontal.line,\n              refPoint = horizontal.point;\n          var lineCenterX = (refLine[0] + refLine[2]) / 2;\n          var x1;\n          var x2;\n\n          if (refPoint.x < lineCenterX) {\n            x1 = refPoint.x - bbox.width / 2;\n            x2 = Math.max(refLine[0], refLine[2]);\n          } else {\n            x1 = refPoint.x + bbox.width / 2;\n            x2 = Math.min(refLine[0], refLine[2]);\n          }\n\n          var lineAttrs = mix({\n            x1: x1,\n            y1: refLine[1],\n            x2: x2,\n            y2: refLine[1]\n          }, lineStyle);\n          var line = group.addShape('line', {\n            attrs: lineAttrs,\n            capture: false\n          });\n          alignLines.push(line);\n        });\n      }\n\n      if (verticals) {\n        each(verticals, function (vertical) {\n          var refLine = vertical.line,\n              refPoint = vertical.point;\n          var lineCenterY = (refLine[1] + refLine[3]) / 2;\n          var y1;\n          var y2;\n\n          if (refPoint.y < lineCenterY) {\n            y1 = refPoint.y - bbox.height / 2;\n            y2 = Math.max(refLine[1], refLine[3]);\n          } else {\n            y1 = refPoint.y + bbox.height / 2;\n            y2 = Math.min(refLine[1], refLine[3]);\n          }\n\n          var lineAtts = mix({\n            x1: refLine[0],\n            y1: y1,\n            x2: refLine[0],\n            y2: y2\n          }, lineStyle);\n          var line = group.addShape('line', {\n            attrs: lineAtts,\n            capture: false\n          });\n          alignLines.push(line);\n        });\n      }\n    }\n  };\n  /**\n   * 获取点到线的距离\n   *\n   * @param {array} line [x1, y1, x2, y2] 线的四个点\n   * @param {object} point 点的x和y坐标点 {x, y}\n   * @returns\n   * @memberof AlignLine\n   */\n\n\n  SnapLine.prototype.getLineDisObject = function (line, point) {\n    return {\n      line: line,\n      point: point,\n      dis: pointLineDistance(line, point)\n    };\n  };\n\n  SnapLine.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 拖动过程中，清楚上次绘制的线\n   *\n   * @memberof AlignLine\n   */\n\n\n  SnapLine.prototype.clearAlignLine = function () {\n    var alignLines = this._cfgs.alignLines;\n    each(alignLines, function (line) {\n      line.remove();\n    });\n    alignLines.length = 0;\n  };\n  /**\n   * 拖动结束时候，情况缓存的节点的辅助线，同时删除绘制的线\n   *\n   * @memberof AlignLine\n   */\n\n\n  SnapLine.prototype.destory = function () {\n    var _a = this._cfgs,\n        horizontalLines = _a.horizontalLines,\n        verticalLines = _a.verticalLines;\n    var graph = this.get('graph');\n    var nodes = graph.getNodes();\n    nodes.forEach(function (node) {\n      var itemId = node.get('id');\n      delete horizontalLines[\"\".concat(itemId, \"tltr\")];\n      delete horizontalLines[\"\".concat(itemId, \"lcrc\")];\n      delete horizontalLines[\"\".concat(itemId, \"blbr\")];\n      delete verticalLines[\"\".concat(itemId, \"tlbl\")];\n      delete verticalLines[\"\".concat(itemId, \"tcbc\")];\n      delete verticalLines[\"\".concat(itemId, \"trbr\")];\n    });\n    this.clearAlignLine();\n  };\n\n  return SnapLine;\n}(Base);\n\nexport default SnapLine;","map":null,"metadata":{},"sourceType":"module"}