{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isObject from \"lodash/isObject\";\nimport _isFunction from \"lodash/isFunction\";\nvar _excluded = [\"passes\"],\n    _excluded2 = [\"moduleName\", \"vertexShader\", \"fragmentShader\", \"triangulation\", \"segmentNumber\"];\n\nvar _dec, _class, _descriptor;\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { SyncBailHook, SyncHook, SyncWaterfallHook } from '@antv/async-hook';\nimport { BlendType, lazyInject, TYPES } from '@antv/l7-core';\nimport { encodePickingColor } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport { normalizePasses } from '../plugins/MultiPassRendererPlugin';\nimport { BlendTypes } from '../utils/blend';\nimport { handleStyleDataMapping } from '../utils/dataMappingStyle';\nimport { updateShape } from '../utils/updateShape';\nvar layerIdCounter = 0;\nvar BaseLayer = (_dec = lazyInject(TYPES.IGlobalConfigService), (_class = function (_EventEmitter) {\n  _inherits(BaseLayer, _EventEmitter);\n\n  var _super = _createSuper(BaseLayer);\n\n  function BaseLayer() {\n    var _this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BaseLayer);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", \"\".concat(layerIdCounter++));\n\n    _defineProperty(_assertThisInitialized(_this), \"name\", \"\".concat(layerIdCounter));\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"visible\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"zIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"minZoom\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"maxZoom\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"inited\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"layerModelNeedUpdate\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"pickedFeatureID\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"selectedFeatureID\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"styleNeedUpdate\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"rendering\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"clusterZoom\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dataState\", {\n      dataSourceNeedUpdate: false,\n      dataMappingNeedUpdate: false,\n      filterNeedUpdate: false,\n      featureScaleNeedUpdate: false,\n      StyleAttrNeedUpdate: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"hooks\", {\n      init: new SyncBailHook(),\n      afterInit: new SyncBailHook(),\n      beforeRender: new SyncBailHook(),\n      beforeRenderData: new SyncWaterfallHook(),\n      afterRender: new SyncHook(),\n      beforePickingEncode: new SyncHook(),\n      afterPickingEncode: new SyncHook(),\n      beforeHighlight: new SyncHook(['pickedColor']),\n      afterHighlight: new SyncHook(),\n      beforeSelect: new SyncHook(['pickedColor']),\n      afterSelect: new SyncHook(),\n      beforeDestroy: new SyncHook(),\n      afterDestroy: new SyncHook()\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"models\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"multiPassRenderer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"plugins\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"sourceOption\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"layerModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"shapeOption\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"sceneContainer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"layerChildren\", []);\n\n    _initializerDefineProperty(_assertThisInitialized(_this), \"configService\", _descriptor, _assertThisInitialized(_this));\n\n    _defineProperty(_assertThisInitialized(_this), \"shaderModuleService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cameraService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"coordinateService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"iconService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"fontService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"pickingService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"rendererService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"layerService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"interactionService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"mapService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"styleAttributeService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"layerSource\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"postProcessingPassFactory\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"normalPassFactory\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"animateOptions\", {\n      enable: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"container\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"encodedData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"configSchema\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"currentPickId\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"rawConfig\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"needUpdateConfig\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"pendingStyleAttributes\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"scaleOptions\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"animateStartTime\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"aniamateStatus\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"bottomColor\", 'rgba(0, 0, 0, 0)');\n\n    _defineProperty(_assertThisInitialized(_this), \"isDestroied\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"sourceEvent\", function () {\n      _this.dataState.dataSourceNeedUpdate = true;\n\n      var _this$getLayerConfig = _this.getLayerConfig(),\n          autoFit = _this$getLayerConfig.autoFit,\n          fitBoundsOptions = _this$getLayerConfig.fitBoundsOptions;\n\n      if (autoFit) {\n        _this.fitBounds(fitBoundsOptions);\n      }\n\n      _this.emit('dataUpdate');\n\n      _this.reRender();\n    });\n\n    _this.name = config.name || _this.id;\n    _this.zIndex = config.zIndex || 0;\n    _this.rawConfig = config;\n    return _this;\n  }\n\n  _createClass(BaseLayer, [{\n    key: \"getLayerConfig\",\n    value: function getLayerConfig() {\n      return this.configService.getLayerConfig(this.id);\n    }\n  }, {\n    key: \"updateLayerConfig\",\n    value: function updateLayerConfig(configToUpdate) {\n      if (!this.inited) {\n        this.needUpdateConfig = _objectSpread(_objectSpread({}, this.needUpdateConfig), configToUpdate);\n      } else {\n        var sceneId = this.container.get(TYPES.SceneID);\n        handleStyleDataMapping(configToUpdate, this);\n        this.configService.setLayerConfig(sceneId, this.id, _objectSpread(_objectSpread(_objectSpread({}, this.configService.getLayerConfig(this.id)), this.needUpdateConfig), configToUpdate));\n        this.needUpdateConfig = {};\n      }\n    }\n  }, {\n    key: \"setContainer\",\n    value: function setContainer(container, sceneContainer) {\n      this.container = container;\n      this.sceneContainer = sceneContainer;\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n  }, {\n    key: \"setBottomColor\",\n    value: function setBottomColor(color) {\n      this.bottomColor = color;\n    }\n  }, {\n    key: \"getBottomColor\",\n    value: function getBottomColor() {\n      return this.bottomColor;\n    }\n  }, {\n    key: \"addPlugin\",\n    value: function addPlugin(plugin) {\n      this.plugins.push(plugin);\n      return this;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var sceneId = this.container.get(TYPES.SceneID);\n      this.configService.setLayerConfig(sceneId, this.id, this.rawConfig);\n      this.iconService = this.container.get(TYPES.IIconService);\n      this.fontService = this.container.get(TYPES.IFontService);\n      this.rendererService = this.container.get(TYPES.IRendererService);\n      this.layerService = this.container.get(TYPES.ILayerService);\n      this.interactionService = this.container.get(TYPES.IInteractionService);\n      this.pickingService = this.container.get(TYPES.IPickingService);\n      this.mapService = this.container.get(TYPES.IMapService);\n      this.cameraService = this.container.get(TYPES.ICameraService);\n      this.coordinateService = this.container.get(TYPES.ICoordinateSystemService);\n      this.shaderModuleService = this.container.get(TYPES.IShaderModuleService);\n      this.postProcessingPassFactory = this.container.get(TYPES.IFactoryPostProcessingPass);\n      this.normalPassFactory = this.container.get(TYPES.IFactoryNormalPass);\n      this.styleAttributeService = this.container.get(TYPES.IStyleAttributeService);\n      this.multiPassRenderer = this.container.get(TYPES.IMultiPassRenderer);\n      this.multiPassRenderer.setLayer(this);\n      this.pendingStyleAttributes.forEach(function (_ref) {\n        var attributeName = _ref.attributeName,\n            attributeField = _ref.attributeField,\n            attributeValues = _ref.attributeValues,\n            updateOptions = _ref.updateOptions;\n\n        _this2.styleAttributeService.updateStyleAttribute(attributeName, {\n          scale: _objectSpread({\n            field: attributeField\n          }, _this2.splitValuesAndCallbackInAttribute(attributeValues, _this2.getLayerConfig()[attributeName]))\n        }, updateOptions);\n      });\n      this.pendingStyleAttributes = [];\n      this.plugins = this.container.getAll(TYPES.ILayerPlugin);\n\n      var _iterator = _createForOfIteratorHelper(this.plugins),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var plugin = _step.value;\n          plugin.apply(this, {\n            rendererService: this.rendererService,\n            mapService: this.mapService,\n            styleAttributeService: this.styleAttributeService,\n            normalPassFactory: this.normalPassFactory,\n            postProcessingPassFactory: this.postProcessingPassFactory\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.hooks.init.call();\n      this.hooks.afterInit.call();\n      this.emit('inited', {\n        target: this,\n        type: 'inited'\n      });\n      this.emit('add', {\n        target: this,\n        type: 'add'\n      });\n      return this;\n    }\n  }, {\n    key: \"prepareBuildModel\",\n    value: function prepareBuildModel() {\n      this.inited = true;\n      this.updateLayerConfig(_objectSpread(_objectSpread({}, this.getDefaultConfig()), this.rawConfig));\n\n      var _this$getLayerConfig2 = this.getLayerConfig(),\n          animateOption = _this$getLayerConfig2.animateOption;\n\n      if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {\n        this.layerService.startAnimate();\n        this.aniamateStatus = true;\n      }\n    }\n  }, {\n    key: \"color\",\n    value: function color(field, values, updateOptions) {\n      this.updateStyleAttribute('color', field, values, updateOptions);\n      return this;\n    }\n  }, {\n    key: \"texture\",\n    value: function texture(field, values, updateOptions) {\n      this.updateStyleAttribute('texture', field, values, updateOptions);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(field, values, updateOptions) {\n      this.updateStyleAttribute('rotate', field, values, updateOptions);\n      return this;\n    }\n  }, {\n    key: \"size\",\n    value: function size(field, values, updateOptions) {\n      this.updateStyleAttribute('size', field, values, updateOptions);\n      return this;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(field, values, updateOptions) {\n      this.updateStyleAttribute('filter', field, values, updateOptions);\n      return this;\n    }\n  }, {\n    key: \"shape\",\n    value: function shape(field, values, updateOptions) {\n      var _this$styleAttributeS, _this$styleAttributeS2, _this$styleAttributeS3;\n\n      var lastShape = (_this$styleAttributeS = this.styleAttributeService) === null || _this$styleAttributeS === void 0 ? void 0 : (_this$styleAttributeS2 = _this$styleAttributeS.getLayerStyleAttribute('shape')) === null || _this$styleAttributeS2 === void 0 ? void 0 : (_this$styleAttributeS3 = _this$styleAttributeS2.scale) === null || _this$styleAttributeS3 === void 0 ? void 0 : _this$styleAttributeS3.field;\n      var currentShape = field;\n      this.shapeOption = {\n        field: field,\n        values: values\n      };\n      this.updateStyleAttribute('shape', field, values, updateOptions);\n      updateShape(this, lastShape, currentShape);\n      return this;\n    }\n  }, {\n    key: \"label\",\n    value: function label(field, values, updateOptions) {\n      this.pendingStyleAttributes.push({\n        attributeName: 'label',\n        attributeField: field,\n        attributeValues: values,\n        updateOptions: updateOptions\n      });\n      return this;\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(options) {\n      var rawAnimate = {};\n\n      if (_isObject(options)) {\n        rawAnimate.enable = true;\n        rawAnimate = _objectSpread(_objectSpread({}, rawAnimate), options);\n      } else {\n        rawAnimate.enable = options;\n      }\n\n      this.updateLayerConfig({\n        animateOption: rawAnimate\n      });\n      return this;\n    }\n  }, {\n    key: \"source\",\n    value: function source(data, options) {\n      if (data !== null && data !== void 0 && data.data) {\n        this.setSource(data);\n        return this;\n      }\n\n      this.sourceOption = {\n        data: data,\n        options: options\n      };\n      this.clusterZoom = 0;\n      return this;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data, options) {\n      var _this3 = this;\n\n      if (this.inited) {\n        this.layerSource.setData(data, options);\n      } else {\n        this.on('inited', function () {\n          _this3.layerSource.setData(data, options);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"style\",\n    value: function style(options) {\n      var _this4 = this;\n\n      var passes = options.passes,\n          rest = _objectWithoutProperties(options, _excluded);\n\n      if (passes) {\n        normalizePasses(passes).forEach(function (pass) {\n          var postProcessingPass = _this4.multiPassRenderer.getPostProcessor().getPostProcessingPassByName(pass[0]);\n\n          if (postProcessingPass) {\n            postProcessingPass.updateOptions(pass[1]);\n          }\n        });\n      }\n\n      this.rawConfig = _objectSpread(_objectSpread({}, this.rawConfig), rest);\n\n      if (this.container) {\n        this.updateLayerConfig(this.rawConfig);\n        this.styleNeedUpdate = true;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(field, cfg) {\n      if (_isObject(field)) {\n        this.scaleOptions = _objectSpread(_objectSpread({}, this.scaleOptions), field);\n      } else {\n        this.scaleOptions[field] = cfg;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      this.rendering = true;\n      this.layerService.renderLayers();\n      this.rendering = false;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.getEncodedData().length !== 0) {\n        this.renderModels();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderMultiPass\",\n    value: function () {\n      var _renderMultiPass = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.getEncodedData().length !== 0)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                if (!(this.multiPassRenderer && this.multiPassRenderer.getRenderFlag())) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 4;\n                return this.multiPassRenderer.render();\n\n              case 4:\n                _context.next = 7;\n                break;\n\n              case 6:\n                if (this.multiPassRenderer) {\n                  this.renderModels();\n                } else {\n                  this.renderModels();\n                }\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function renderMultiPass() {\n        return _renderMultiPass.apply(this, arguments);\n      }\n\n      return renderMultiPass;\n    }()\n  }, {\n    key: \"active\",\n    value: function active(options) {\n      var activeOption = {};\n      activeOption.enableHighlight = _isObject(options) ? true : options;\n\n      if (_isObject(options)) {\n        activeOption.enableHighlight = true;\n\n        if (options.color) {\n          activeOption.highlightColor = options.color;\n        }\n\n        if (options.mix) {\n          activeOption.activeMix = options.mix;\n        }\n      } else {\n        activeOption.enableHighlight = !!options;\n      }\n\n      this.updateLayerConfig(activeOption);\n      return this;\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive(id, options) {\n      var _this5 = this;\n\n      if (_isObject(id)) {\n        var _id$x = id.x,\n            x = _id$x === void 0 ? 0 : _id$x,\n            _id$y = id.y,\n            y = _id$y === void 0 ? 0 : _id$y;\n        this.updateLayerConfig({\n          highlightColor: _isObject(options) ? options.color : this.getLayerConfig().highlightColor,\n          activeMix: _isObject(options) ? options.mix : this.getLayerConfig().activeMix\n        });\n        this.pick({\n          x: x,\n          y: y\n        });\n      } else {\n        this.updateLayerConfig({\n          pickedFeatureID: id,\n          highlightColor: _isObject(options) ? options.color : this.getLayerConfig().highlightColor,\n          activeMix: _isObject(options) ? options.mix : this.getLayerConfig().activeMix\n        });\n        this.hooks.beforeSelect.call(encodePickingColor(id)).then(function () {\n          setTimeout(function () {\n            _this5.reRender();\n          }, 1);\n        });\n      }\n    }\n  }, {\n    key: \"select\",\n    value: function select(option) {\n      var activeOption = {};\n      activeOption.enableSelect = _isObject(option) ? true : option;\n\n      if (_isObject(option)) {\n        activeOption.enableSelect = true;\n\n        if (option.color) {\n          activeOption.selectColor = option.color;\n        }\n\n        if (option.mix) {\n          activeOption.selectMix = option.mix;\n        }\n      } else {\n        activeOption.enableSelect = !!option;\n      }\n\n      this.updateLayerConfig(activeOption);\n      return this;\n    }\n  }, {\n    key: \"setSelect\",\n    value: function setSelect(id, options) {\n      var _this6 = this;\n\n      if (_isObject(id)) {\n        var _id$x2 = id.x,\n            x = _id$x2 === void 0 ? 0 : _id$x2,\n            _id$y2 = id.y,\n            y = _id$y2 === void 0 ? 0 : _id$y2;\n        this.updateLayerConfig({\n          selectColor: _isObject(options) ? options.color : this.getLayerConfig().selectColor,\n          selectMix: _isObject(options) ? options.mix : this.getLayerConfig().selectMix\n        });\n        this.pick({\n          x: x,\n          y: y\n        });\n      } else {\n        this.updateLayerConfig({\n          pickedFeatureID: id,\n          selectColor: _isObject(options) ? options.color : this.getLayerConfig().selectColor,\n          selectMix: _isObject(options) ? options.mix : this.getLayerConfig().selectMix\n        });\n        this.hooks.beforeSelect.call(encodePickingColor(id)).then(function () {\n          setTimeout(function () {\n            _this6.reRender();\n          }, 1);\n        });\n      }\n    }\n  }, {\n    key: \"setBlend\",\n    value: function setBlend(type) {\n      this.updateLayerConfig({\n        blend: type\n      });\n      this.layerModelNeedUpdate = true;\n      this.reRender();\n      return this;\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.updateLayerConfig({\n        visible: true\n      });\n      this.reRender();\n      return this;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.updateLayerConfig({\n        visible: false\n      });\n      this.reRender();\n      return this;\n    }\n  }, {\n    key: \"setIndex\",\n    value: function setIndex(index) {\n      this.zIndex = index;\n      this.layerService.updateLayerRenderList();\n      this.layerService.renderLayers();\n      return this;\n    }\n  }, {\n    key: \"setCurrentPickId\",\n    value: function setCurrentPickId(id) {\n      this.currentPickId = id;\n    }\n  }, {\n    key: \"getCurrentPickId\",\n    value: function getCurrentPickId() {\n      return this.currentPickId;\n    }\n  }, {\n    key: \"setCurrentSelectedId\",\n    value: function setCurrentSelectedId(id) {\n      this.selectedFeatureID = id;\n    }\n  }, {\n    key: \"getCurrentSelectedId\",\n    value: function getCurrentSelectedId() {\n      return this.selectedFeatureID;\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      var zoom = this.mapService.getZoom();\n\n      var _this$getLayerConfig3 = this.getLayerConfig(),\n          visible = _this$getLayerConfig3.visible,\n          _this$getLayerConfig4 = _this$getLayerConfig3.minZoom,\n          minZoom = _this$getLayerConfig4 === void 0 ? -Infinity : _this$getLayerConfig4,\n          _this$getLayerConfig5 = _this$getLayerConfig3.maxZoom,\n          maxZoom = _this$getLayerConfig5 === void 0 ? Infinity : _this$getLayerConfig5;\n\n      return !!visible && zoom >= minZoom && zoom <= maxZoom;\n    }\n  }, {\n    key: \"setMinZoom\",\n    value: function setMinZoom(minZoom) {\n      this.updateLayerConfig({\n        minZoom: minZoom\n      });\n      return this;\n    }\n  }, {\n    key: \"getMinZoom\",\n    value: function getMinZoom() {\n      var _this$getLayerConfig6 = this.getLayerConfig(),\n          minZoom = _this$getLayerConfig6.minZoom;\n\n      return minZoom;\n    }\n  }, {\n    key: \"getMaxZoom\",\n    value: function getMaxZoom() {\n      var _this$getLayerConfig7 = this.getLayerConfig(),\n          maxZoom = _this$getLayerConfig7.maxZoom;\n\n      return maxZoom;\n    }\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      var cfg = this.getLayerConfig();\n      return cfg[name];\n    }\n  }, {\n    key: \"setMaxZoom\",\n    value: function setMaxZoom(maxZoom) {\n      this.updateLayerConfig({\n        maxZoom: maxZoom\n      });\n      return this;\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds(fitBoundsOptions) {\n      if (!this.inited) {\n        this.updateLayerConfig({\n          autoFit: true\n        });\n        return this;\n      }\n\n      var source = this.getSource();\n      var extent = source.extent;\n      var isValid = extent.some(function (v) {\n        return Math.abs(v) === Infinity;\n      });\n\n      if (isValid) {\n        return this;\n      }\n\n      this.mapService.fitBounds([[extent[0], extent[1]], [extent[2], extent[3]]], fitBoundsOptions);\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.isDestroied) {\n        return;\n      }\n\n      this.hooks.beforeDestroy.call();\n      this.layerSource.off('update', this.sourceEvent);\n      this.multiPassRenderer.destroy();\n      this.styleAttributeService.clearAllAttributes();\n      this.hooks.afterDestroy.call();\n      this.models = [];\n      this.layerService.cleanRemove(this);\n      this.emit('remove', {\n        target: this,\n        type: 'remove'\n      });\n      this.emit('destroy', {\n        target: this,\n        type: 'destroy'\n      });\n      this.removeAllListeners();\n      this.isDestroied = true;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.styleAttributeService.clearAllAttributes();\n    }\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      this.models.forEach(function (model) {\n        return model.destroy();\n      });\n      this.layerModel.clearModels();\n    }\n  }, {\n    key: \"isDirty\",\n    value: function isDirty() {\n      return !!(this.styleAttributeService.getLayerStyleAttributes() || []).filter(function (attribute) {\n        return attribute.needRescale || attribute.needRemapping || attribute.needRegenerateVertices;\n      }).length;\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(source) {\n      if (this.layerSource) {\n        this.layerSource.off('update', this.sourceEvent);\n      }\n\n      this.layerSource = source;\n      this.clusterZoom = 0;\n\n      if (this.inited && this.layerSource.cluster) {\n        var zoom = this.mapService.getZoom();\n        this.layerSource.updateClusterData(zoom);\n      }\n\n      this.layerSource.on('update', this.sourceEvent);\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.layerSource;\n    }\n  }, {\n    key: \"getScaleOptions\",\n    value: function getScaleOptions() {\n      return this.scaleOptions;\n    }\n  }, {\n    key: \"setEncodedData\",\n    value: function setEncodedData(encodedData) {\n      this.encodedData = encodedData;\n    }\n  }, {\n    key: \"getEncodedData\",\n    value: function getEncodedData() {\n      return this.encodedData;\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale(name) {\n      return this.styleAttributeService.getLayerAttributeScale(name);\n    }\n  }, {\n    key: \"getLegendItems\",\n    value: function getLegendItems(name) {\n      var scale = this.styleAttributeService.getLayerAttributeScale(name);\n\n      if (!scale) {\n        return [];\n      }\n\n      if (scale.invertExtent) {\n        var items = scale.range().map(function (item) {\n          return _defineProperty({\n            value: scale.invertExtent(item)\n          }, name, item);\n        });\n        return items;\n      } else if (scale.ticks) {\n        var _items = scale.ticks().map(function (item) {\n          return _defineProperty({\n            value: item\n          }, name, scale(item));\n        });\n\n        return _items;\n      } else if (scale !== null && scale !== void 0 && scale.domain) {\n        var _items2 = scale.domain().filter(function (item) {\n          return !_isUndefined(item);\n        }).map(function (item) {\n          return _defineProperty({\n            value: item\n          }, name, scale(item));\n        });\n\n        return _items2;\n      }\n\n      return [];\n    }\n  }, {\n    key: \"pick\",\n    value: function pick(_ref5) {\n      var x = _ref5.x,\n          y = _ref5.y;\n      this.interactionService.triggerHover({\n        x: x,\n        y: y\n      });\n    }\n  }, {\n    key: \"boxSelect\",\n    value: function boxSelect(box, cb) {\n      this.pickingService.boxPickLayer(this, box, cb);\n    }\n  }, {\n    key: \"buildLayerModel\",\n    value: function buildLayerModel(options) {\n      var moduleName = options.moduleName,\n          vertexShader = options.vertexShader,\n          fragmentShader = options.fragmentShader,\n          triangulation = options.triangulation,\n          segmentNumber = options.segmentNumber,\n          rest = _objectWithoutProperties(options, _excluded2);\n\n      this.shaderModuleService.registerModule(moduleName, {\n        vs: vertexShader,\n        fs: fragmentShader\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule(moduleName),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var createModel = this.rendererService.createModel;\n\n      var _this$styleAttributeS4 = this.styleAttributeService.createAttributesAndIndices(this.encodedData, triangulation, segmentNumber),\n          attributes = _this$styleAttributeS4.attributes,\n          elements = _this$styleAttributeS4.elements;\n\n      return createModel(_objectSpread({\n        attributes: attributes,\n        uniforms: uniforms,\n        fs: fs,\n        vs: vs,\n        elements: elements,\n        blend: BlendTypes[BlendType.normal]\n      }, rest));\n    }\n  }, {\n    key: \"getTime\",\n    value: function getTime() {\n      return this.layerService.clock.getDelta();\n    }\n  }, {\n    key: \"setAnimateStartTime\",\n    value: function setAnimateStartTime() {\n      this.animateStartTime = this.layerService.clock.getElapsedTime();\n    }\n  }, {\n    key: \"stopAnimate\",\n    value: function stopAnimate() {\n      if (this.aniamateStatus) {\n        this.layerService.stopAnimate();\n        this.aniamateStatus = false;\n        this.updateLayerConfig({\n          animateOption: {\n            enable: false\n          }\n        });\n      }\n    }\n  }, {\n    key: \"getLayerAnimateTime\",\n    value: function getLayerAnimateTime() {\n      return this.layerService.clock.getElapsedTime() - this.animateStartTime;\n    }\n  }, {\n    key: \"needPick\",\n    value: function needPick(type) {\n      var _this$getLayerConfig8 = this.getLayerConfig(),\n          _this$getLayerConfig9 = _this$getLayerConfig8.enableHighlight,\n          enableHighlight = _this$getLayerConfig9 === void 0 ? true : _this$getLayerConfig9,\n          _this$getLayerConfig10 = _this$getLayerConfig8.enableSelect,\n          enableSelect = _this$getLayerConfig10 === void 0 ? true : _this$getLayerConfig10;\n\n      var isPick = this.eventNames().indexOf(type) !== -1 || this.eventNames().indexOf('un' + type) !== -1;\n\n      if ((type === 'click' || type === 'dblclick') && enableSelect) {\n        isPick = true;\n      }\n\n      if (type === 'mousemove' && (enableHighlight || this.eventNames().indexOf('mouseenter') !== -1 || this.eventNames().indexOf('unmousemove') !== -1 || this.eventNames().indexOf('mouseout') !== -1)) {\n        isPick = true;\n      }\n\n      return this.isVisible() && isPick;\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"rebuildModels\",\n    value: function rebuildModels() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"renderMulPass\",\n    value: function () {\n      var _renderMulPass = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(multiPassRenderer) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return multiPassRenderer.render();\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function renderMulPass(_x) {\n        return _renderMulPass.apply(this, arguments);\n      }\n\n      return renderMulPass;\n    }()\n  }, {\n    key: \"renderModels\",\n    value: function renderModels(isPicking) {\n      var _this7 = this;\n\n      if (this.getEncodedData().length > 0) {\n        if (this.layerModelNeedUpdate && this.layerModel) {\n          this.models = this.layerModel.buildModels();\n          this.hooks.beforeRender.call();\n          this.layerModelNeedUpdate = false;\n        }\n\n        this.models.forEach(function (model) {\n          model.draw({\n            uniforms: _this7.layerModel.getUninforms()\n          }, isPicking);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateStyleAttribute\",\n    value: function updateStyleAttribute(type, field, values, updateOptions) {\n      if (!this.inited) {\n        this.pendingStyleAttributes.push({\n          attributeName: type,\n          attributeField: field,\n          attributeValues: values,\n          updateOptions: updateOptions\n        });\n      } else {\n        this.styleAttributeService.updateStyleAttribute(type, {\n          scale: _objectSpread({\n            field: field\n          }, this.splitValuesAndCallbackInAttribute(values, this.getLayerConfig()[field]))\n        }, updateOptions);\n      }\n    }\n  }, {\n    key: \"getShaderPickStat\",\n    value: function getShaderPickStat() {\n      return this.layerService.getShaderPickStat();\n    }\n  }, {\n    key: \"setEarthTime\",\n    value: function setEarthTime(time) {\n      console.warn('empty fn');\n    }\n  }, {\n    key: \"getConfigSchema\",\n    value: function getConfigSchema() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"getModelType\",\n    value: function getModelType() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"getDefaultConfig\",\n    value: function getDefaultConfig() {\n      return {};\n    }\n  }, {\n    key: \"reRender\",\n    value: function reRender() {\n      if (this.inited) {\n        this.layerService.updateLayerRenderList();\n        this.layerService.renderLayers();\n      }\n    }\n  }, {\n    key: \"splitValuesAndCallbackInAttribute\",\n    value: function splitValuesAndCallbackInAttribute(valuesOrCallback, defaultValues) {\n      return {\n        values: _isFunction(valuesOrCallback) ? undefined : valuesOrCallback || defaultValues,\n        callback: _isFunction(valuesOrCallback) ? valuesOrCallback : undefined\n      };\n    }\n  }]);\n\n  return BaseLayer;\n}(EventEmitter), _descriptor = _applyDecoratedDescriptor(_class.prototype, \"configService\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class));\nexport { BaseLayer as default };","map":null,"metadata":{},"sourceType":"module"}