{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, FunctionExt } from '../../util';\nimport { Rectangle, Angle } from '../../geometry';\nimport { View } from '../../view/view';\nexport class Snapline extends View {\n  constructor(options) {\n    super();\n\n    const {\n      graph\n    } = options,\n          others = __rest(options, [\"graph\"]);\n\n    this.graph = graph;\n    this.options = Object.assign({\n      tolerance: 10\n    }, others);\n    this.render();\n    this.parseFilter();\n\n    if (!this.disabled) {\n      this.startListening();\n    }\n  }\n\n  get model() {\n    return this.graph.model;\n  }\n\n  get containerClassName() {\n    return this.prefixClassName('widget-snapline');\n  }\n\n  get verticalClassName() {\n    return `${this.containerClassName}-vertical`;\n  }\n\n  get horizontalClassName() {\n    return `${this.containerClassName}-horizontal`;\n  }\n\n  get disabled() {\n    return this.options.enabled !== true || this.graph.options.snapline.enabled !== true;\n  }\n\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true;\n      this.graph.options.snapline.enabled = true;\n      this.startListening();\n    }\n  }\n\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false;\n      this.graph.options.snapline.enabled = false;\n      this.stopListening();\n    }\n  }\n\n  setFilter(filter) {\n    this.options.filter = filter;\n    this.parseFilter();\n  }\n\n  render() {\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container);\n    this.$horizontal = this.$(document.createElement('div')).addClass(this.horizontalClassName);\n    this.$vertical = this.$(document.createElement('div')).addClass(this.verticalClassName);\n    this.$container.hide().addClass(this.containerClassName).append([this.$horizontal, this.$vertical]);\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n  }\n\n  startListening() {\n    this.stopListening();\n    this.graph.on('node:mousedown', this.captureCursorOffset, this);\n    this.graph.on('node:mousemove', this.snapOnMoving, this);\n    this.model.on('batch:stop', this.onBatchStop, this);\n    this.delegateDocumentEvents({\n      mouseup: 'hide',\n      touchend: 'hide'\n    });\n  }\n\n  stopListening() {\n    this.graph.off('node:mousedown', this.captureCursorOffset, this);\n    this.graph.off('node:mousemove', this.snapOnMoving, this);\n    this.model.off('batch:stop', this.onBatchStop, this);\n    this.undelegateDocumentEvents();\n  }\n\n  parseFilter() {\n    this.filterShapes = {};\n    this.filterCells = {};\n    this.filterFunction = null;\n    const filter = this.options.filter;\n\n    if (Array.isArray(filter)) {\n      filter.forEach(item => {\n        if (typeof item === 'string') {\n          this.filterShapes[item] = true;\n        } else {\n          this.filterCells[item.id] = true;\n        }\n      });\n    } else if (typeof filter === 'function') {\n      this.filterFunction = filter;\n    }\n  }\n\n  onBatchStop(_ref) {\n    let {\n      name,\n      data\n    } = _ref;\n\n    if (name === 'resize') {\n      this.snapOnResizing(data.cell, data);\n    }\n  }\n\n  captureCursorOffset(_ref2) {\n    let {\n      view,\n      x,\n      y\n    } = _ref2;\n    const targetView = view.getDelegatedView();\n\n    if (targetView && this.isNodeMovable(targetView)) {\n      const pos = view.cell.getPosition();\n      this.offset = {\n        x: x - pos.x,\n        y: y - pos.y\n      };\n    }\n  }\n\n  isNodeMovable(view) {\n    return view && view.cell.isNode() && view.can('nodeMovable');\n  }\n\n  snapOnResizing(node, options) {\n    if (this.options.resizing && !options.snapped && options.ui && options.direction && options.trueDirection) {\n      const view = this.graph.renderer.findViewByCell(node);\n\n      if (view && view.cell.isNode()) {\n        const nodeBbox = node.getBBox();\n        const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());\n        const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n        const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n        const angle = Angle.normalize(node.getAngle());\n        const tolerance = this.options.tolerance || 0;\n        let verticalLeft;\n        let verticalTop;\n        let verticalHeight;\n        let horizontalTop;\n        let horizontalLeft;\n        let horizontalWidth;\n        const snapOrigin = {\n          vertical: 0,\n          horizontal: 0\n        };\n        const direction = options.direction;\n        const trueDirection = options.trueDirection;\n        const relativeDirection = options.relativeDirection;\n\n        if (trueDirection.indexOf('right') !== -1) {\n          snapOrigin.vertical = nodeBottomRight.x;\n        } else {\n          snapOrigin.vertical = nodeTopLeft.x;\n        }\n\n        if (trueDirection.indexOf('bottom') !== -1) {\n          snapOrigin.horizontal = nodeBottomRight.y;\n        } else {\n          snapOrigin.horizontal = nodeTopLeft.y;\n        }\n\n        this.model.getNodes().some(cell => {\n          if (this.isIgnored(node, cell)) {\n            return false;\n          }\n\n          const snapBBox = cell.getBBox().bbox(cell.getAngle());\n          const snapTopLeft = snapBBox.getTopLeft();\n          const snapBottomRight = snapBBox.getBottomRight();\n          const groups = {\n            vertical: [snapTopLeft.x, snapBottomRight.x],\n            horizontal: [snapTopLeft.y, snapBottomRight.y]\n          };\n          const distances = {};\n          Object.keys(groups).forEach(k => {\n            const key = k;\n            const list = groups[key].map(value => ({\n              position: value,\n              distance: Math.abs(value - snapOrigin[key])\n            })).filter(item => item.distance <= tolerance);\n            distances[key] = ArrayExt.sortBy(list, item => item.distance);\n          });\n\n          if (verticalLeft == null && distances.vertical.length > 0) {\n            verticalLeft = distances.vertical[0].position;\n            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n            verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n          }\n\n          if (horizontalTop == null && distances.horizontal.length > 0) {\n            horizontalTop = distances.horizontal[0].position;\n            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n            horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n          }\n\n          return verticalLeft != null && horizontalTop != null;\n        });\n        this.hide();\n        let dx = 0;\n        let dy = 0;\n\n        if (horizontalTop != null || verticalLeft != null) {\n          if (verticalLeft != null) {\n            dx = trueDirection.indexOf('right') !== -1 ? verticalLeft - nodeBottomRight.x : nodeTopLeft.x - verticalLeft;\n          }\n\n          if (horizontalTop != null) {\n            dy = trueDirection.indexOf('bottom') !== -1 ? horizontalTop - nodeBottomRight.y : nodeTopLeft.y - horizontalTop;\n          }\n        }\n\n        let dWidth = 0;\n        let dHeight = 0;\n\n        if (angle % 90 === 0) {\n          if (angle === 90 || angle === 270) {\n            dWidth = dy;\n            dHeight = dx;\n          } else {\n            dWidth = dx;\n            dHeight = dy;\n          }\n        } else {\n          const quadrant = angle >= 0 && angle < 90 ? 1 : angle >= 90 && angle < 180 ? 4 : angle >= 180 && angle < 270 ? 3 : 2;\n\n          if (horizontalTop != null && verticalLeft != null) {\n            if (dx < dy) {\n              dy = 0;\n              horizontalTop = undefined;\n            } else {\n              dx = 0;\n              verticalLeft = undefined;\n            }\n          }\n\n          const rad = Angle.toRad(angle % 90);\n\n          if (dx) {\n            dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);\n          }\n\n          if (dy) {\n            dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);\n          }\n\n          const quadrant13 = quadrant === 1 || quadrant === 3;\n\n          switch (relativeDirection) {\n            case 'top':\n            case 'bottom':\n              dHeight = dy ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n              break;\n\n            case 'left':\n            case 'right':\n              dWidth = dx ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        switch (relativeDirection) {\n          case 'top':\n          case 'bottom':\n            dWidth = 0;\n            break;\n\n          case 'left':\n          case 'right':\n            dHeight = 0;\n            break;\n\n          default:\n            break;\n        }\n\n        const gridSize = this.graph.getGridSize();\n        let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);\n        let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);\n\n        if (options.minWidth && options.minWidth > gridSize) {\n          newWidth = Math.max(newWidth, options.minWidth);\n        }\n\n        if (options.minHeight && options.minHeight > gridSize) {\n          newHeight = Math.max(newHeight, options.minHeight);\n        }\n\n        if (options.maxWidth) {\n          newWidth = Math.min(newWidth, options.maxWidth);\n        }\n\n        if (options.maxHeight) {\n          newHeight = Math.min(newHeight, options.maxHeight);\n        }\n\n        if (options.preserveAspectRatio) {\n          if (dHeight < dWidth) {\n            newHeight = newWidth * (nodeBbox.height / nodeBbox.width);\n          } else {\n            newWidth = newHeight * (nodeBbox.width / nodeBbox.height);\n          }\n        }\n\n        if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n          node.resize(newWidth, newHeight, {\n            direction,\n            relativeDirection,\n            trueDirection,\n            snapped: true,\n            snaplines: this.cid,\n            restrict: this.graph.hook.getRestrictArea(view)\n          });\n\n          if (verticalHeight) {\n            verticalHeight += newHeight - nodeBbox.height;\n          }\n\n          if (horizontalWidth) {\n            horizontalWidth += newWidth - nodeBbox.width;\n          }\n        }\n\n        const newRotatedBBox = node.getBBox().bbox(angle);\n\n        if (verticalLeft && Math.abs(newRotatedBBox.x - verticalLeft) > 1 && Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {\n          verticalLeft = undefined;\n        }\n\n        if (horizontalTop && Math.abs(newRotatedBBox.y - horizontalTop) > 1 && Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {\n          horizontalTop = undefined;\n        }\n\n        this.update({\n          verticalLeft,\n          verticalTop,\n          verticalHeight,\n          horizontalTop,\n          horizontalLeft,\n          horizontalWidth\n        });\n      }\n    }\n  }\n\n  snapOnMoving(_ref3) {\n    let {\n      view,\n      e,\n      x,\n      y\n    } = _ref3;\n    const targetView = view.getEventData(e).delegatedView || view;\n\n    if (!this.isNodeMovable(targetView)) {\n      return;\n    }\n\n    const node = targetView.cell;\n    const size = node.getSize();\n    const position = node.getPosition();\n    const cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);\n    const angle = node.getAngle();\n    const nodeCenter = cellBBox.getCenter();\n    const nodeBBoxRotated = cellBBox.bbox(angle);\n    const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n    const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n    const distance = this.options.tolerance || 0;\n    let verticalLeft;\n    let verticalTop;\n    let verticalHeight;\n    let horizontalTop;\n    let horizontalLeft;\n    let horizontalWidth;\n    let verticalFix = 0;\n    let horizontalFix = 0;\n    this.model.getNodes().some(targetNode => {\n      if (this.isIgnored(node, targetNode)) {\n        return false;\n      }\n\n      const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());\n      const snapCenter = snapBBox.getCenter();\n      const snapTopLeft = snapBBox.getTopLeft();\n      const snapBottomRight = snapBBox.getBottomRight();\n\n      if (verticalLeft == null) {\n        if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n          verticalLeft = snapCenter.x;\n          verticalFix = 0.5;\n        } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapTopLeft.x;\n          verticalFix = 0;\n        } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapTopLeft.x;\n          verticalFix = 1;\n        } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapBottomRight.x;\n          verticalFix = 1;\n        } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapBottomRight.x;\n        }\n\n        if (verticalLeft != null) {\n          verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n          verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n        }\n      }\n\n      if (horizontalTop == null) {\n        if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n          horizontalTop = snapCenter.y;\n          horizontalFix = 0.5;\n        } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapTopLeft.y;\n        } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapTopLeft.y;\n          horizontalFix = 1;\n        } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapBottomRight.y;\n          horizontalFix = 1;\n        } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapBottomRight.y;\n        }\n\n        if (horizontalTop != null) {\n          horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n          horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n        }\n      }\n\n      return verticalLeft != null && horizontalTop != null;\n    });\n    this.hide();\n\n    if (horizontalTop != null || verticalLeft != null) {\n      if (horizontalTop != null) {\n        nodeBBoxRotated.y = horizontalTop - horizontalFix * nodeBBoxRotated.height;\n      }\n\n      if (verticalLeft != null) {\n        nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;\n      }\n\n      const newCenter = nodeBBoxRotated.getCenter();\n      const newX = newCenter.x - cellBBox.width / 2;\n      const newY = newCenter.y - cellBBox.height / 2;\n      const dx = newX - position.x;\n      const dy = newY - position.y;\n\n      if (dx !== 0 || dy !== 0) {\n        node.translate(dx, dy, {\n          snapped: true,\n          restrict: this.graph.hook.getRestrictArea(targetView)\n        });\n\n        if (horizontalWidth) {\n          horizontalWidth += dx;\n        }\n\n        if (verticalHeight) {\n          verticalHeight += dy;\n        }\n      }\n\n      this.update({\n        verticalLeft,\n        verticalTop,\n        verticalHeight,\n        horizontalTop,\n        horizontalLeft,\n        horizontalWidth\n      });\n    }\n  }\n\n  isIgnored(snapNode, targetNode) {\n    return targetNode.id === snapNode.id || targetNode.isDescendantOf(snapNode) || this.filterShapes[targetNode.shape] || this.filterCells[targetNode.id] || this.filterFunction && FunctionExt.call(this.filterFunction, this.graph, targetNode);\n  }\n\n  update(metadata) {\n    const ctm = this.graph.matrix();\n    const sx = ctm.a;\n    const sy = ctm.d;\n    const tx = ctm.e;\n    const ty = ctm.f;\n    const sharp = this.options.sharp;\n    const hasScroller = this.graph.scroller.widget != null;\n\n    if (metadata.horizontalTop) {\n      this.$horizontal.css({\n        top: metadata.horizontalTop * sy + ty,\n        left: sharp ? metadata.horizontalLeft * sx + tx : hasScroller ? '-300%' : 0,\n        width: sharp ? metadata.horizontalWidth * sx : hasScroller ? '700%' : '100%'\n      }).show();\n    } else {\n      this.$horizontal.hide();\n    }\n\n    if (metadata.verticalLeft) {\n      this.$vertical.css({\n        left: metadata.verticalLeft * sx + tx,\n        top: sharp ? metadata.verticalTop * sy + ty : hasScroller ? '-300%' : 0,\n        height: sharp ? metadata.verticalHeight * sy : hasScroller ? '700%' : '100%'\n      }).show();\n    } else {\n      this.$vertical.hide();\n    }\n\n    this.show();\n  }\n\n  resetTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n  }\n\n  show() {\n    this.$container.show();\n    this.resetTimer();\n\n    if (this.container.parentNode == null) {\n      this.graph.container.appendChild(this.container);\n    }\n\n    return this;\n  }\n\n  hide() {\n    this.$container.hide();\n    this.resetTimer();\n    const clean = this.options.clean;\n    const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;\n\n    if (delay > 0) {\n      this.timer = window.setTimeout(() => {\n        this.unmount();\n      }, delay);\n    }\n\n    return this;\n  }\n\n  onRemove() {\n    this.stopListening();\n    this.hide();\n  }\n\n  dispose() {\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Snapline.prototype, \"dispose\", null);","map":null,"metadata":{},"sourceType":"module"}