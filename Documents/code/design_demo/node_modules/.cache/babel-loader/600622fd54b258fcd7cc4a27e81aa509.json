{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nvar tmp = vec2.create();\nvar capEnd = vec2.create();\nvar lineA = vec2.create();\nvar lineB = vec2.create();\nvar tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  var tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\n\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nfunction getArrayUnique(matrix) {\n  var map = new Map();\n\n  for (var i = 0; i < matrix.length; i++) {\n    var key = matrix[0].toString() + '-' + matrix[1].toString();\n\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n\n  return matrix;\n}\n\nvar ExtrudePolyline = function () {\n  function ExtrudePolyline() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ExtrudePolyline);\n\n    _defineProperty(this, \"complex\", void 0);\n\n    _defineProperty(this, \"join\", void 0);\n\n    _defineProperty(this, \"cap\", void 0);\n\n    _defineProperty(this, \"miterLimit\", void 0);\n\n    _defineProperty(this, \"thickness\", void 0);\n\n    _defineProperty(this, \"normal\", void 0);\n\n    _defineProperty(this, \"lastFlip\", -1);\n\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n\n    _defineProperty(this, \"started\", false);\n\n    _defineProperty(this, \"dash\", false);\n\n    _defineProperty(this, \"totalDistance\", 0);\n\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0\n    };\n  }\n\n  _createClass(ExtrudePolyline, [{\n    key: \"extrude_gaode2\",\n    value: function extrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n\n      if (points.length <= 1) {\n        return complex;\n      }\n\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n\n      for (var i = 1; i < total; i++) {\n        var _originPoints$, _originPoints$i$, _originPoints$2;\n\n        var last = points[i - 1];\n        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.segment_gaode2(complex, count, last, cur, next, originLast, originCur, originNext);\n        count += amt;\n      }\n\n      if (this.dash) {\n        for (var _i = 0; _i < complex.positions.length / 6; _i++) {\n          complex.positions[_i * 6 + 5] = this.totalDistance;\n        }\n      }\n\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude_gaode2\",\n    value: function simpleExtrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n\n      if (points.length <= 1) {\n        return complex;\n      }\n\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n\n      for (var i = 1; i < total; i++) {\n        var _originPoints$3, _originPoints$i$2, _originPoints$4;\n\n        var last = points[i - 1];\n        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.simpleSegment(complex, count, last, cur, next, originLast, originCur, originNext);\n        count += amt;\n      }\n\n      if (this.dash) {\n        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {\n          complex.positions[_i2 * 6 + 5] = this.totalDistance;\n        }\n      }\n\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude\",\n    value: function extrude(points) {\n      var complex = this.complex;\n\n      if (points.length <= 1) {\n        return complex;\n      }\n\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.segment(complex, count, last, cur, next);\n        count += amt;\n      }\n\n      if (this.dash) {\n        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {\n          complex.positions[_i3 * 6 + 5] = this.totalDistance;\n        }\n      }\n\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude\",\n    value: function simpleExtrude(points) {\n      var complex = this.complex;\n\n      if (points.length <= 1) {\n        return complex;\n      }\n\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.simpleSegment(complex, count, last, cur, next);\n        count += amt;\n      }\n\n      if (this.dash) {\n        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {\n          complex.positions[_i4 * 6 + 5] = this.totalDistance;\n        }\n      }\n\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"segment_gaode2\",\n    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur, originNext) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([originCur[0], originCur[1]]);\n      var flatLast = aProjectFlat([originLast[0], originLast[1]]);\n      direction(lineA, cur, last);\n      var segmentDistance = 0;\n\n      if (this.dash) {\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n\n      if (!this.started) {\n        this.started = true;\n\n        if (capSquare) {\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n\n      indices.push(index + 0, index + 1, index + 2);\n\n      if (!next) {\n        computeNormal(this.normal, lineA);\n\n        if (capSquare) {\n          var _out = vec2.create();\n\n          var _out2 = vec2.create();\n\n          vec2.sub(_out2, lineA, this.normal);\n          vec2.add(_out, lineA, this.normal);\n          normals.push(_out2[0], _out2[1], 0);\n          normals.push(_out[0], _out[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        if (isPointEqual(cur, next)) {\n          vec2.add(next, cur, vec2.normalize(next, vec2.subtract(next, cur, last)));\n        }\n\n        direction(lineB, next, cur);\n\n        var _computeMiter = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n            _computeMiter2 = _slicedToArray(_computeMiter, 2),\n            miterLen = _computeMiter2[0],\n            miter = _computeMiter2[1];\n\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp);\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n\n        this.lastFlip = flip;\n      }\n\n      return count;\n    }\n  }, {\n    key: \"simpleSegment\",\n    value: function simpleSegment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n\n      if (this.dash) {\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n\n      if (!this.started) {\n        this.started = true;\n        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n      }\n\n      indices.push(index + 0, index + 1, index + 2);\n\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n\n        direction(lineB, flatNext, flatCur);\n\n        var _computeMiter3 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n            _computeMiter4 = _slicedToArray(_computeMiter3, 2),\n            miterLen = _computeMiter4[0],\n            miter = _computeMiter4[1];\n\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        flip = -1;\n        vec2.copy(this.normal, miter);\n        count += 2;\n        this.lastFlip = flip;\n      }\n\n      return count;\n    }\n  }, {\n    key: \"segment\",\n    value: function segment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n\n      if (this.dash) {\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n\n      if (!this.started) {\n        this.started = true;\n\n        if (capSquare) {\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n\n      indices.push(index + 0, index + 1, index + 2);\n\n      if (!next) {\n        computeNormal(this.normal, lineA);\n\n        if (capSquare) {\n          var _out3 = vec2.create();\n\n          var _out4 = vec2.create();\n\n          vec2.sub(_out4, lineA, this.normal);\n          vec2.add(_out3, lineA, this.normal);\n          normals.push(_out4[0], _out4[1], 0);\n          normals.push(_out3[0], _out3[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n\n        direction(lineB, flatNext, flatCur);\n\n        var _computeMiter5 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n            _computeMiter6 = _slicedToArray(_computeMiter5, 2),\n            miterLen = _computeMiter6[0],\n            miter = _computeMiter6[1];\n\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp);\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n\n        this.lastFlip = flip;\n      }\n\n      return count;\n    }\n  }, {\n    key: \"extrusions\",\n    value: function extrusions(positions, normals, point, normal, thickness, distanceRadio) {\n      normals.push(normal[0], normal[1], 0);\n      normals.push(normal[0], normal[1], 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n    }\n  }, {\n    key: \"lineSegmentDistance\",\n    value: function lineSegmentDistance(b1, a1) {\n      var dx = a1[0] - b1[0];\n      var dy = a1[1] - b1[1];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }]);\n\n  return ExtrudePolyline;\n}();\n\nexport { ExtrudePolyline as default };","map":null,"metadata":{},"sourceType":"module"}