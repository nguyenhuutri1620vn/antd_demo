{"ast":null,"code":"/**\n * 按照数据中的结果设置fixorder\n */\nconst initDataOrder = (g, nodeOrder) => {\n  const simpleNodes = g.nodes().filter(v => {\n    var _a;\n\n    return !((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length);\n  });\n  const ranks = simpleNodes.map(v => g.node(v).rank);\n  const maxRank = Math.max(...ranks);\n  const layers = [];\n\n  for (let i = 0; i < maxRank + 1; i++) {\n    layers.push([]);\n  }\n\n  nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach(n => {\n    const node = g.node(n); // 只考虑原有节点，dummy节点需要按照后续算法排出\n\n    if (!node || node.dummy) return;\n\n    if (!isNaN(node.rank)) {\n      node.fixorder = layers[node.rank].length; // 设置fixorder为当层的顺序\n\n      layers[node.rank].push(n);\n    }\n  });\n};\n\nexport default initDataOrder;","map":null,"metadata":{},"sourceType":"module"}