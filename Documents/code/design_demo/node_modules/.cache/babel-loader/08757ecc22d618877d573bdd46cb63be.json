{"ast":null,"code":"import { nelderMead, bisect, conjugateGradient, zeros, zerosM, norm2, scale } from 'fmin';\nimport { intersectionArea, circleOverlap, circleCircleIntersection, distance } from './circleintersection';\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\n\nexport function venn(areas, parameters) {\n  parameters = parameters || {};\n  parameters.maxIterations = parameters.maxIterations || 500;\n  var initialLayout = parameters.initialLayout || bestInitialLayout;\n  var loss = parameters.lossFunction || lossFunction; // add in missing pairwise areas as having 0 size\n\n  areas = addMissingAreas(areas); // initial layout is done greedily\n\n  var circles = initialLayout(areas, parameters); // transform x/y coordinates to a vector to optimize\n\n  var initial = [],\n      setids = [];\n  var setid;\n\n  for (setid in circles) {\n    // eslint-disable-next-line\n    if (circles.hasOwnProperty(setid)) {\n      initial.push(circles[setid].x);\n      initial.push(circles[setid].y);\n      setids.push(setid);\n    }\n  } // optimize initial layout from our loss function\n\n\n  var solution = nelderMead(function (values) {\n    var current = {};\n\n    for (var i = 0; i < setids.length; ++i) {\n      var setid_1 = setids[i];\n      current[setid_1] = {\n        x: values[2 * i],\n        y: values[2 * i + 1],\n        radius: circles[setid_1].radius\n      };\n    }\n\n    return loss(current, areas);\n  }, initial, parameters); // transform solution vector back to x/y points\n\n  var positions = solution.x;\n\n  for (var i = 0; i < setids.length; ++i) {\n    setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\nvar SMALL = 1e-10;\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\n\nexport function distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect(function (distance) {\n    return circleOverlap(r1, r2, distance) - overlap;\n  }, 0, r1 + r2);\n}\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\n\nfunction addMissingAreas(areas) {\n  areas = areas.slice(); // two circle intersections that aren't defined\n\n  var ids = [],\n      pairs = {};\n  var i, j, a, b;\n\n  for (i = 0; i < areas.length; ++i) {\n    var area = areas[i];\n\n    if (area.sets.length == 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length == 2) {\n      a = area.sets[0];\n      b = area.sets[1]; // @ts-ignore\n\n      pairs[[a, b]] = true; // @ts-ignore\n\n      pairs[[b, a]] = true;\n    }\n  }\n\n  ids.sort(function (a, b) {\n    return a > b ? 1 : -1;\n  });\n\n  for (i = 0; i < ids.length; ++i) {\n    a = ids[i];\n\n    for (j = i + 1; j < ids.length; ++j) {\n      b = ids[j]; // @ts-ignore\n\n      if (!([a, b] in pairs)) {\n        areas.push({\n          sets: [a, b],\n          size: 0\n        });\n      }\n    }\n  }\n\n  return areas;\n} /// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\n\n\nexport function getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  var distances = zerosM(sets.length, sets.length),\n      constraints = zerosM(sets.length, sets.length); // compute required distances between all the sets such that\n  // the areas match\n\n  areas.filter(function (x) {\n    return x.sets.length == 2;\n  }).map(function (current) {\n    var left = setids[current.sets[0]],\n        right = setids[current.sets[1]],\n        r1 = Math.sqrt(sets[left].size / Math.PI),\n        r2 = Math.sqrt(sets[right].size / Math.PI),\n        distance = distanceFromIntersectArea(r1, r2, current.size);\n    distances[left][right] = distances[right][left] = distance; // also update constraints to indicate if its a subset or disjoint\n    // relationship\n\n    var c = 0;\n\n    if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n      c = 1;\n    } else if (current.size <= 1e-10) {\n      c = -1;\n    }\n\n    constraints[left][right] = constraints[right][left] = c;\n  });\n  return {\n    distances: distances,\n    constraints: constraints\n  };\n} /// computes the gradient and loss simulatenously for our constrained MDS optimizer\n\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  var loss = 0,\n      i;\n\n  for (i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  for (i = 0; i < distances.length; ++i) {\n    var xi = x[2 * i],\n        yi = x[2 * i + 1];\n\n    for (var j = i + 1; j < distances.length; ++j) {\n      var xj = x[2 * j],\n          yj = x[2 * j + 1],\n          dij = distances[i][j],\n          constraint = constraints[i][j];\n      var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n          distance_1 = Math.sqrt(squaredDistance),\n          delta = squaredDistance - dij * dij;\n\n      if (constraint > 0 && distance_1 <= dij || constraint < 0 && distance_1 >= dij) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n\n  return loss;\n} /// takes the best working variant of either constrained MDS or greedy\n\n\nexport function bestInitialLayout(areas, params) {\n  var initial = greedyLayout(areas, params);\n  var loss = params.lossFunction || lossFunction; // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n\n  if (areas.length >= 8) {\n    var constrained = constrainedMDSLayout(areas, params),\n        constrainedLoss = loss(constrained, areas),\n        greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n\n  return initial;\n} /// use the constrained MDS variant to generate an initial layout\n\nexport function constrainedMDSLayout(areas, params) {\n  params = params || {};\n  var restarts = params.restarts || 10; // bidirectionally map sets to a rowid  (so we can create a matrix)\n\n  var sets = [],\n      setids = {};\n  var i;\n\n  for (i = 0; i < areas.length; ++i) {\n    var area = areas[i];\n\n    if (area.sets.length == 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  var matrices = getDistanceMatrices(areas, sets, setids);\n  var distances = matrices.distances;\n  var constraints = matrices.constraints; // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n\n  var norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map(function (row) {\n    return row.map(function (value) {\n      return value / norm;\n    });\n  });\n\n  var obj = function (x, fxprime) {\n    return constrainedMDSGradient(x, fxprime, distances, constraints);\n  };\n\n  var best, current;\n\n  for (i = 0; i < restarts; ++i) {\n    var initial = zeros(distances.length * 2).map(Math.random);\n    current = conjugateGradient(obj, initial, params);\n\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n\n  var positions = best.x; // translate rows back to (x,y,radius) coordinates\n\n  var circles = {};\n\n  for (i = 0; i < sets.length; ++i) {\n    var set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI)\n    };\n  }\n\n  if (params.history) {\n    for (i = 0; i < params.history.length; ++i) {\n      scale(params.history[i].x, norm);\n    }\n  }\n\n  return circles;\n}\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\n\nexport function greedyLayout(areas, params) {\n  var loss = params && params.lossFunction ? params.lossFunction : lossFunction; // define a circle for each set\n\n  var circles = {},\n      setOverlaps = {};\n  var set;\n\n  for (var i = 0; i < areas.length; ++i) {\n    var area = areas[i];\n\n    if (area.sets.length == 1) {\n      set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        // rowid: circles.length, // fix to ->\n        rowid: Object.keys(circles).length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI)\n      };\n      setOverlaps[set] = [];\n    }\n  }\n\n  areas = areas.filter(function (a) {\n    return a.sets.length == 2;\n  }); // map each set to a list of all the other sets that overlap it\n\n  for (var i = 0; i < areas.length; ++i) {\n    var current = areas[i]; // eslint-disable-next-line\n\n    var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n    var left = current.sets[0],\n        right = current.sets[1]; // completely overlapped circles shouldn't be positioned early here\n\n    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({\n      set: right,\n      size: current.size,\n      weight: weight\n    });\n    setOverlaps[right].push({\n      set: left,\n      size: current.size,\n      weight: weight\n    });\n  } // get list of most overlapped sets\n\n\n  var mostOverlapped = [];\n\n  for (set in setOverlaps) {\n    // eslint-disable-next-line\n    if (setOverlaps.hasOwnProperty(set)) {\n      var size = 0;\n\n      for (var i = 0; i < setOverlaps[set].length; ++i) {\n        size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n      }\n\n      mostOverlapped.push({\n        set: set,\n        size: size\n      });\n    }\n  } // sort by size desc\n\n\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n\n  mostOverlapped.sort(sortOrder); // keep track of what sets have been laid out\n\n  var positioned = {};\n\n  function isPositioned(element) {\n    return element.set in positioned;\n  } // adds a point to the output\n\n\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  } // add most overlapped set at (0,0)\n\n\n  positionSet({\n    x: 0,\n    y: 0\n  }, mostOverlapped[0].set); // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n\n  for (var i = 1; i < mostOverlapped.length; ++i) {\n    var setIndex = mostOverlapped[i].set,\n        overlap = setOverlaps[setIndex].filter(isPositioned);\n    set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    var points = [];\n\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      var p1 = circles[overlap[j].set],\n          d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size); // sample positions at 90 degrees for maximum aesthetics\n\n      points.push({\n        x: p1.x + d1,\n        y: p1.y\n      });\n      points.push({\n        x: p1.x - d1,\n        y: p1.y\n      });\n      points.push({\n        y: p1.y + d1,\n        x: p1.x\n      });\n      points.push({\n        y: p1.y - d1,\n        x: p1.x\n      }); // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n\n      for (var k = j + 1; k < overlap.length; ++k) {\n        var p2 = circles[overlap[k].set],\n            d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n        var extraPoints = circleCircleIntersection({\n          x: p1.x,\n          y: p1.y,\n          radius: d1\n        }, {\n          x: p2.x,\n          y: p2.y,\n          radius: d2\n        });\n\n        for (var l = 0; l < extraPoints.length; ++l) {\n          points.push(extraPoints[l]);\n        }\n      }\n    } // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n\n\n    var bestLoss = 1e50,\n        bestPoint = points[0];\n\n    for (var j = 0; j < points.length; ++j) {\n      circles[setIndex].x = points[j].x;\n      circles[setIndex].y = points[j].y;\n      var localLoss = loss(circles, areas);\n\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = points[j];\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\n\nexport function lossFunction(sets, overlaps) {\n  var output = 0;\n\n  function getCircles(indices) {\n    return indices.map(function (i) {\n      return sets[i];\n    });\n  }\n\n  for (var i = 0; i < overlaps.length; ++i) {\n    var area = overlaps[i];\n    var overlap = void 0;\n\n    if (area.sets.length == 1) {\n      continue;\n    } else if (area.sets.length == 2) {\n      var left = sets[area.sets[0]],\n          right = sets[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(getCircles(area.sets));\n    } // eslint-disable-next-line\n\n\n    var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n} // orientates a bunch of circles to point in orientation\n\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder === null) {\n    circles.sort(function (a, b) {\n      return b.radius - a.radius;\n    });\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  var i; // shift circles so largest circle is at (0, 0)\n\n  if (circles.length > 0) {\n    var largestX = circles[0].x,\n        largestY = circles[0].y;\n\n    for (i = 0; i < circles.length; ++i) {\n      circles[i].x -= largestX;\n      circles[i].y -= largestY;\n    }\n  }\n\n  if (circles.length == 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    var dist = distance(circles[0], circles[1]);\n\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  } // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n\n\n  if (circles.length > 1) {\n    var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    var x = void 0,\n        y = void 0;\n    var c = Math.cos(rotation),\n        s = Math.sin(rotation);\n\n    for (i = 0; i < circles.length; ++i) {\n      x = circles[i].x;\n      y = circles[i].y;\n      circles[i].x = c * x - s * y;\n      circles[i].y = s * x + c * y;\n    }\n  } // mirror solution if third solution is above plane specified by\n  // first two circles\n\n\n  if (circles.length > 2) {\n    var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n\n    if (angle > Math.PI) {\n      var slope = circles[1].y / (1e-10 + circles[1].x);\n\n      for (i = 0; i < circles.length; ++i) {\n        var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);\n        circles[i].x = 2 * d - circles[i].x;\n        circles[i].y = 2 * d * slope - circles[i].y;\n      }\n    }\n  }\n}\n\nexport function disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.map(function (circle) {\n    circle.parent = circle;\n  }); // path compression step in union find\n\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    var xRoot = find(x),\n        yRoot = find(y);\n    xRoot.parent = yRoot;\n  } // get the union of all overlapping sets\n\n\n  for (var i = 0; i < circles.length; ++i) {\n    for (var j = i + 1; j < circles.length; ++j) {\n      var maxDistance = circles[i].radius + circles[j].radius;\n\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  } // find all the disjoint clusters and group them together\n\n\n  var disjointClusters = {};\n  var setid;\n\n  for (var i = 0; i < circles.length; ++i) {\n    setid = find(circles[i]).parent.setid;\n\n    if (!(setid in disjointClusters)) {\n      disjointClusters[setid] = [];\n    }\n\n    disjointClusters[setid].push(circles[i]);\n  } // cleanup bookkeeping\n\n\n  circles.map(function (circle) {\n    delete circle.parent;\n  }); // return in more usable form\n\n  var ret = [];\n\n  for (setid in disjointClusters) {\n    // eslint-disable-next-line\n    if (disjointClusters.hasOwnProperty(setid)) {\n      ret.push(disjointClusters[setid]);\n    }\n  }\n\n  return ret;\n}\n\nfunction getBoundingBox(circles) {\n  var minMax = function (d) {\n    var hi = Math.max.apply(null, circles.map(function (c) {\n      return c[d] + c.radius;\n    })),\n        lo = Math.min.apply(null, circles.map(function (c) {\n      return c[d] - c.radius;\n    }));\n    return {\n      max: hi,\n      min: lo\n    };\n  };\n\n  return {\n    xRange: minMax('x'),\n    yRange: minMax('y')\n  };\n}\n\nexport function normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation === null) {\n    orientation = Math.PI / 2;\n  } // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n\n\n  var circles = [],\n      i,\n      setid;\n\n  for (setid in solution) {\n    // eslint-disable-next-line\n    if (solution.hasOwnProperty(setid)) {\n      var previous = solution[setid];\n      circles.push({\n        x: previous.x,\n        y: previous.y,\n        radius: previous.radius,\n        setid: setid\n      });\n    }\n  } // get all the disjoint clusters\n\n\n  var clusters = disjointCluster(circles); // orientate all disjoint sets, get sizes\n\n  for (i = 0; i < clusters.length; ++i) {\n    orientateCircles(clusters[i], orientation, orientationOrder);\n    var bounds = getBoundingBox(clusters[i]);\n    clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    clusters[i].bounds = bounds;\n  }\n\n  clusters.sort(function (a, b) {\n    return b.size - a.size;\n  }); // orientate the largest at 0,0, and get the bounds\n\n  circles = clusters[0]; // @ts-ignore fixme 从逻辑上看似乎是不对的，后续看看\n\n  var returnBounds = circles.bounds;\n  var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) return;\n    var bounds = cluster.bounds;\n    var xOffset, yOffset, centreing;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) xOffset += centreing;\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) yOffset += centreing;\n    }\n\n    for (var j = 0; j < cluster.length; ++j) {\n      cluster[j].x += xOffset;\n      cluster[j].y += yOffset;\n      circles.push(cluster[j]);\n    }\n  }\n\n  var index = 1;\n\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3; // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n\n    returnBounds = getBoundingBox(circles);\n  } // convert back to solution form\n\n\n  var ret = {};\n\n  for (i = 0; i < circles.length; ++i) {\n    ret[circles[i].setid] = circles[i];\n  }\n\n  return ret;\n}\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\n\nexport function scaleSolution(solution, width, height, padding) {\n  var circles = [],\n      setids = [];\n\n  for (var setid in solution) {\n    // eslint-disable-next-line\n    if (solution.hasOwnProperty(setid)) {\n      setids.push(setid);\n      circles.push(solution[setid]);\n    }\n  }\n\n  width -= 2 * padding;\n  height -= 2 * padding;\n  var bounds = getBoundingBox(circles),\n      xRange = bounds.xRange,\n      yRange = bounds.yRange;\n\n  if (xRange.max == xRange.min || yRange.max == yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  var xScaling = width / (xRange.max - xRange.min),\n      yScaling = height / (yRange.max - yRange.min),\n      scaling = Math.min(yScaling, xScaling),\n      // while we're at it, center the diagram too\n  xOffset = (width - (xRange.max - xRange.min) * scaling) / 2,\n      yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n  var scaled = {};\n\n  for (var i = 0; i < circles.length; ++i) {\n    var circle = circles[i];\n    scaled[setids[i]] = {\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling\n    };\n  }\n\n  return scaled;\n}","map":null,"metadata":{},"sourceType":"module"}