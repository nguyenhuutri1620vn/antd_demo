{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Util } from '../../global';\nimport { FunctionExt } from '../../util';\nimport { Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Graph } from '../../graph/graph';\nexport class Dnd extends View {\n  constructor(options) {\n    super();\n    this.options = Object.assign(Object.assign({}, Dnd.defaults), options);\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container).addClass(this.prefixClassName('widget-dnd'));\n    this.draggingGraph = new Graph(Object.assign(Object.assign({}, this.options.delegateGraphOptions), {\n      container: document.createElement('div'),\n      width: 1,\n      height: 1\n    }));\n    this.$container.append(this.draggingGraph.container);\n  }\n\n  get targetScroller() {\n    const target = this.options.target;\n    return Graph.isGraph(target) ? target.scroller.widget : target;\n  }\n\n  get targetGraph() {\n    const target = this.options.target;\n    return Graph.isGraph(target) ? target : target.graph;\n  }\n\n  get targetModel() {\n    return this.targetGraph.model;\n  }\n\n  get snapline() {\n    return this.targetGraph.snapline.widget;\n  }\n\n  start(node, evt) {\n    const e = evt;\n    e.preventDefault();\n    this.targetModel.startBatch('dnd');\n    this.$container.addClass('dragging').appendTo(this.options.containerParent || document.body);\n    this.sourceNode = node;\n    this.prepareDragging(node, e.clientX, e.clientY);\n    const local = this.updateNodePosition(e.clientX, e.clientY);\n\n    if (this.isSnaplineEnabled()) {\n      this.snapline.captureCursorOffset({\n        e,\n        node,\n        cell: node,\n        view: this.draggingView,\n        x: local.x,\n        y: local.y\n      });\n      this.draggingNode.on('change:position', this.snap, this);\n    }\n\n    this.delegateDocumentEvents(Dnd.documentEvents, e.data);\n  }\n\n  isSnaplineEnabled() {\n    return this.snapline && !this.snapline.disabled;\n  }\n\n  prepareDragging(sourceNode, clientX, clientY) {\n    const draggingGraph = this.draggingGraph;\n    const draggingModel = draggingGraph.model;\n    const draggingNode = this.options.getDragNode(sourceNode, {\n      sourceNode,\n      draggingGraph,\n      targetGraph: this.targetGraph\n    });\n    draggingNode.position(0, 0);\n    let padding = 5;\n\n    if (this.isSnaplineEnabled()) {\n      padding += this.snapline.options.tolerance || 0;\n    }\n\n    if (this.isSnaplineEnabled() || this.options.scaled) {\n      const scale = this.targetGraph.transform.getScale();\n      draggingGraph.scale(scale.sx, scale.sy);\n      padding *= Math.max(scale.sx, scale.sy);\n    } else {\n      draggingGraph.scale(1, 1);\n    }\n\n    this.clearDragging();\n\n    if (this.options.animation) {\n      this.$container.stop(true, true);\n    }\n\n    draggingModel.resetCells([draggingNode]);\n    const delegateView = draggingGraph.findViewByCell(draggingNode);\n    delegateView.undelegateEvents();\n    delegateView.cell.off('changed');\n    draggingGraph.fitToContent({\n      padding,\n      allowNewOrigin: 'any'\n    });\n    const bbox = delegateView.getBBox();\n    this.geometryBBox = delegateView.getBBox({\n      useCellGeometry: true\n    });\n    this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());\n    this.draggingNode = draggingNode;\n    this.draggingView = delegateView;\n    this.draggingBBox = draggingNode.getBBox();\n    this.padding = padding;\n    this.originOffset = this.updateGraphPosition(clientX, clientY);\n  }\n\n  updateGraphPosition(clientX, clientY) {\n    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    const delta = this.delta;\n    const nodeBBox = this.geometryBBox;\n    const padding = this.padding || 5;\n    const offset = {\n      left: clientX - delta.x - nodeBBox.width / 2 - padding,\n      top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop\n    };\n\n    if (this.draggingGraph) {\n      this.$container.offset(offset);\n    }\n\n    return offset;\n  }\n\n  updateNodePosition(x, y) {\n    const local = this.targetGraph.clientToLocal(x, y);\n    const bbox = this.draggingBBox;\n    local.x -= bbox.width / 2;\n    local.y -= bbox.height / 2;\n    this.draggingNode.position(local.x, local.y);\n    return local;\n  }\n\n  snap(_ref) {\n    let {\n      cell,\n      current,\n      options\n    } = _ref;\n    const node = cell;\n\n    if (options.snapped) {\n      const bbox = this.draggingBBox;\n      node.position(bbox.x + options.tx, bbox.y + options.ty, {\n        silent: true\n      });\n      this.draggingView.translate();\n      node.position(current.x, current.y, {\n        silent: true\n      });\n      this.snapOffset = {\n        x: options.tx,\n        y: options.ty\n      };\n    } else {\n      this.snapOffset = null;\n    }\n  }\n\n  onDragging(evt) {\n    const draggingView = this.draggingView;\n\n    if (draggingView) {\n      evt.preventDefault();\n      const e = this.normalizeEvent(evt);\n      const clientX = e.clientX;\n      const clientY = e.clientY;\n      this.updateGraphPosition(clientX, clientY);\n      const local = this.updateNodePosition(clientX, clientY);\n      const embeddingMode = this.targetGraph.options.embedding.enabled;\n      const isValidArea = (embeddingMode || this.isSnaplineEnabled()) && this.isInsideValidArea({\n        x: clientX,\n        y: clientY\n      });\n\n      if (embeddingMode) {\n        draggingView.setEventData(e, {\n          graph: this.targetGraph,\n          candidateEmbedView: this.candidateEmbedView\n        });\n        const data = draggingView.getEventData(e);\n\n        if (isValidArea) {\n          draggingView.processEmbedding(e, data);\n        } else {\n          draggingView.clearEmbedding(data);\n        }\n\n        this.candidateEmbedView = data.candidateEmbedView;\n      } // update snapline\n\n\n      if (this.isSnaplineEnabled()) {\n        if (isValidArea) {\n          this.snapline.snapOnMoving({\n            e,\n            view: draggingView,\n            x: local.x,\n            y: local.y\n          });\n        } else {\n          this.snapline.hide();\n        }\n      }\n    }\n  }\n\n  onDragEnd(evt) {\n    const draggingNode = this.draggingNode;\n\n    if (draggingNode) {\n      const e = this.normalizeEvent(evt);\n      const draggingView = this.draggingView;\n      const draggingBBox = this.draggingBBox;\n      const snapOffset = this.snapOffset;\n      let x = draggingBBox.x;\n      let y = draggingBBox.y;\n\n      if (snapOffset) {\n        x += snapOffset.x;\n        y += snapOffset.y;\n      }\n\n      draggingNode.position(x, y, {\n        silent: true\n      });\n      const ret = this.drop(draggingNode, {\n        x: e.clientX,\n        y: e.clientY\n      });\n\n      const callback = node => {\n        if (node) {\n          this.onDropped(draggingNode);\n\n          if (this.targetGraph.options.embedding.enabled && draggingView) {\n            draggingView.setEventData(e, {\n              cell: node,\n              graph: this.targetGraph,\n              candidateEmbedView: this.candidateEmbedView\n            });\n            draggingView.finalizeEmbedding(e, draggingView.getEventData(e));\n          }\n        } else {\n          this.onDropInvalid();\n        }\n\n        this.candidateEmbedView = null;\n        this.targetModel.stopBatch('dnd');\n      };\n\n      if (FunctionExt.isAsync(ret)) {\n        // stop dragging\n        this.undelegateDocumentEvents();\n        ret.then(callback); // eslint-disable-line\n      } else {\n        callback(ret);\n      }\n    }\n  }\n\n  clearDragging() {\n    if (this.draggingNode) {\n      this.sourceNode = null;\n      this.draggingNode.remove();\n      this.draggingNode = null;\n      this.draggingView = null;\n      this.delta = null;\n      this.padding = null;\n      this.snapOffset = null;\n      this.originOffset = null;\n      this.undelegateDocumentEvents();\n    }\n  }\n\n  onDropped(draggingNode) {\n    if (this.draggingNode === draggingNode) {\n      this.clearDragging();\n      this.$container.removeClass('dragging').remove();\n    }\n  }\n\n  onDropInvalid() {\n    const draggingNode = this.draggingNode;\n\n    if (draggingNode) {\n      const anim = this.options.animation;\n\n      if (anim) {\n        const duration = typeof anim === 'object' && anim.duration || 150;\n        const easing = typeof anim === 'object' && anim.easing || 'swing';\n        this.draggingView = null;\n        this.$container.animate(this.originOffset, duration, easing, () => this.onDropped(draggingNode));\n      } else {\n        this.onDropped(draggingNode);\n      }\n    }\n  }\n\n  isInsideValidArea(p) {\n    let targetRect;\n    const targetGraph = this.targetGraph;\n    const targetScroller = this.targetScroller;\n\n    if (targetScroller) {\n      if (targetScroller.options.autoResize) {\n        targetRect = this.getDropArea(targetScroller.container);\n      } else {\n        const outter = this.getDropArea(targetScroller.container);\n        targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(outter);\n      }\n    } else {\n      targetRect = this.getDropArea(targetGraph.container);\n    }\n\n    return targetRect && targetRect.containsPoint(p);\n  }\n\n  getDropArea(elem) {\n    const $elem = this.$(elem);\n    const offset = $elem.offset();\n    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;\n    return Rectangle.create({\n      x: offset.left + parseInt($elem.css('border-left-width'), 10) - scrollLeft,\n      y: offset.top + parseInt($elem.css('border-top-width'), 10) - scrollTop,\n      width: $elem.innerWidth(),\n      height: $elem.innerHeight()\n    });\n  }\n\n  drop(draggingNode, pos) {\n    if (this.isInsideValidArea(pos)) {\n      const targetGraph = this.targetGraph;\n      const targetModel = targetGraph.model;\n      const local = targetGraph.clientToLocal(pos);\n      const sourceNode = this.sourceNode;\n      const droppingNode = this.options.getDropNode(draggingNode, {\n        sourceNode,\n        draggingNode,\n        targetGraph: this.targetGraph,\n        draggingGraph: this.draggingGraph\n      });\n      const bbox = droppingNode.getBBox();\n      local.x += bbox.x - bbox.width / 2;\n      local.y += bbox.y - bbox.height / 2;\n      const gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();\n      droppingNode.position(Util.snapToGrid(local.x, gridSize), Util.snapToGrid(local.y, gridSize));\n      droppingNode.removeZIndex();\n      const validateNode = this.options.validateNode;\n      const ret = validateNode ? validateNode(droppingNode, {\n        sourceNode,\n        draggingNode,\n        droppingNode,\n        targetGraph,\n        draggingGraph: this.draggingGraph\n      }) : true;\n\n      if (typeof ret === 'boolean') {\n        if (ret) {\n          targetModel.addCell(droppingNode, {\n            stencil: this.cid\n          });\n          return droppingNode;\n        }\n\n        return null;\n      }\n\n      return FunctionExt.toDeferredBoolean(ret).then(valid => {\n        if (valid) {\n          targetModel.addCell(droppingNode, {\n            stencil: this.cid\n          });\n          return droppingNode;\n        }\n\n        return null;\n      });\n    }\n\n    return null;\n  }\n\n  onRemove() {\n    if (this.draggingGraph) {\n      this.draggingGraph.view.remove();\n      this.draggingGraph.dispose();\n    }\n  }\n\n  dispose() {\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Dnd.prototype, \"dispose\", null);\n\n(function (Dnd) {\n  Dnd.defaults = {\n    animation: false,\n    getDragNode: sourceNode => sourceNode.clone(),\n    getDropNode: draggingNode => draggingNode.clone()\n  };\n  Dnd.documentEvents = {\n    mousemove: 'onDragging',\n    touchmove: 'onDragging',\n    mouseup: 'onDragEnd',\n    touchend: 'onDragEnd',\n    touchcancel: 'onDragEnd'\n  };\n})(Dnd || (Dnd = {}));","map":null,"metadata":{},"sourceType":"module"}