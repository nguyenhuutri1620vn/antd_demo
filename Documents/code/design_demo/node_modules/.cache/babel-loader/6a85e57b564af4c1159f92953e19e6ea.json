{"ast":null,"code":"/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { getEdgeTerminal, isNumber } from \"../util\";\nconst SPEED_DIVISOR = 800;\n/**\n * fruchterman 布局\n */\n\nexport class FruchtermanLayout extends Base {\n  constructor(options) {\n    super();\n    /** 停止迭代的最大迭代数 */\n\n    this.maxIteration = 1000;\n    /** 是否启动 worker */\n\n    this.workerEnabled = false;\n    /** 重力大小，影响图的紧凑程度 */\n\n    this.gravity = 10;\n    /** 速度 */\n\n    this.speed = 5;\n    /** 是否产生聚类力 */\n\n    this.clustering = false;\n    /** 聚类力大小 */\n\n    this.clusterGravity = 10;\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.nodeMap = {};\n    this.nodeIdxMap = {};\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n    /** 每次迭代结束的回调函数 */\n\n\n    this.tick = () => {};\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      maxIteration: 1000,\n      gravity: 10,\n      speed: 1,\n      clustering: false,\n      clusterGravity: 10\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    var _a, _b;\n\n    const self = this;\n    const nodes = self.nodes;\n\n    if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n      window.clearInterval(self.timeInterval);\n    }\n\n    if (!nodes || nodes.length === 0) {\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    const center = self.center;\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n      return;\n    }\n\n    const nodeMap = {};\n    const nodeIdxMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * this.width;\n      if (!isNumber(node.y)) node.y = Math.random() * this.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap; // layout\n\n    return self.run();\n  }\n\n  run() {\n    var _a;\n\n    const self = this;\n    const nodes = self.nodes;\n    if (!nodes) return;\n    const {\n      edges,\n      maxIteration,\n      workerEnabled,\n      clustering\n    } = self;\n    const clusterMap = {};\n\n    if (clustering) {\n      nodes.forEach(n => {\n        if (clusterMap[n.cluster] === undefined) {\n          clusterMap[n.cluster] = {\n            name: n.cluster,\n            cx: 0,\n            cy: 0,\n            count: 0\n          };\n        }\n      });\n    }\n\n    if (workerEnabled) {\n      for (let i = 0; i < maxIteration; i++) {\n        self.runOneStep(clusterMap);\n      }\n\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n    } else {\n      if (typeof window === \"undefined\") return;\n      let iter = 0; // interval for render the result after each iteration\n\n      this.timeInterval = window.setInterval(() => {\n        var _a;\n\n        self.runOneStep(clusterMap);\n        iter++;\n\n        if (iter >= maxIteration) {\n          (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n          window.clearInterval(self.timeInterval);\n        }\n      }, 0);\n    }\n\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  runOneStep(clusterMap) {\n    var _a;\n\n    const self = this;\n    const nodes = self.nodes;\n    if (!nodes) return;\n    const {\n      edges,\n      center,\n      gravity,\n      speed,\n      clustering\n    } = self;\n    const area = self.height * self.width;\n    const maxDisplace = Math.sqrt(area) / 10;\n    const k2 = area / (nodes.length + 1);\n    const k = Math.sqrt(k2);\n    const displacements = [];\n    nodes.forEach((_, j) => {\n      displacements[j] = {\n        x: 0,\n        y: 0\n      };\n    });\n    self.applyCalculate(nodes, edges, displacements, k, k2); // gravity for clusters\n\n    if (clustering) {\n      // re-compute the clustering centers\n      for (const key in clusterMap) {\n        clusterMap[key].cx = 0;\n        clusterMap[key].cy = 0;\n        clusterMap[key].count = 0;\n      }\n\n      nodes.forEach(n => {\n        const c = clusterMap[n.cluster];\n\n        if (isNumber(n.x)) {\n          c.cx += n.x;\n        }\n\n        if (isNumber(n.y)) {\n          c.cy += n.y;\n        }\n\n        c.count++;\n      });\n\n      for (const key in clusterMap) {\n        clusterMap[key].cx /= clusterMap[key].count;\n        clusterMap[key].cy /= clusterMap[key].count;\n      } // compute the cluster gravity forces\n\n\n      const clusterGravity = self.clusterGravity || gravity;\n      nodes.forEach((n, j) => {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        const c = clusterMap[n.cluster];\n        const distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));\n        const gravityForce = k * clusterGravity;\n        displacements[j].x -= gravityForce * (n.x - c.cx) / distLength;\n        displacements[j].y -= gravityForce * (n.y - c.cy) / distLength;\n      });\n    } // gravity\n\n\n    nodes.forEach((n, j) => {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      const gravityForce = 0.01 * k * gravity;\n      displacements[j].x -= gravityForce * (n.x - center[0]);\n      displacements[j].y -= gravityForce * (n.y - center[1]);\n    }); // move\n\n    nodes.forEach((n, j) => {\n      if (isNumber(n.fx) && isNumber(n.fy)) {\n        n.x = n.fx;\n        n.y = n.fy;\n        return;\n      }\n\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      const distLength = Math.sqrt(displacements[j].x * displacements[j].x + displacements[j].y * displacements[j].y);\n\n      if (distLength > 0) {\n        // && !n.isFixed()\n        const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n        n.x += displacements[j].x / distLength * limitedDist;\n        n.y += displacements[j].y / distLength * limitedDist;\n      }\n    });\n    (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);\n  }\n\n  applyCalculate(nodes, edges, displacements, k, k2) {\n    const self = this;\n    self.calRepulsive(nodes, displacements, k2);\n    if (edges) self.calAttractive(edges, displacements, k);\n  }\n\n  calRepulsive(nodes, displacements, k2) {\n    nodes.forEach((v, i) => {\n      displacements[i] = {\n        x: 0,\n        y: 0\n      };\n      nodes.forEach((u, j) => {\n        if (i === j) {\n          return;\n        }\n\n        if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n          return;\n        }\n\n        let vecX = v.x - u.x;\n        let vecY = v.y - u.y;\n        let vecLengthSqr = vecX * vecX + vecY * vecY;\n\n        if (vecLengthSqr === 0) {\n          vecLengthSqr = 1;\n          const sign = i > j ? 1 : -1;\n          vecX = 0.01 * sign;\n          vecY = 0.01 * sign;\n        }\n\n        const common = k2 / vecLengthSqr;\n        displacements[i].x += vecX * common;\n        displacements[i].y += vecY * common;\n      });\n    });\n  }\n\n  calAttractive(edges, displacements, k) {\n    edges.forEach(e => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      if (!source || !target) return;\n      const uIndex = this.nodeIdxMap[source];\n      const vIndex = this.nodeIdxMap[target];\n\n      if (uIndex === vIndex) {\n        return;\n      }\n\n      const u = this.nodeMap[source];\n      const v = this.nodeMap[target];\n\n      if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n        return;\n      }\n\n      const vecX = v.x - u.x;\n      const vecY = v.y - u.y;\n      const vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n      const common = vecLength * vecLength / k;\n      displacements[vIndex].x -= vecX / vecLength * common;\n      displacements[vIndex].y -= vecY / vecLength * common;\n      displacements[uIndex].x += vecX / vecLength * common;\n      displacements[uIndex].y += vecY / vecLength * common;\n    });\n  }\n\n  stop() {\n    if (this.timeInterval && typeof window !== \"undefined\") {\n      window.clearInterval(this.timeInterval);\n    }\n  }\n\n  destroy() {\n    const self = this;\n    self.stop();\n    self.tick = null;\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  }\n\n  getType() {\n    return \"fruchterman\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}