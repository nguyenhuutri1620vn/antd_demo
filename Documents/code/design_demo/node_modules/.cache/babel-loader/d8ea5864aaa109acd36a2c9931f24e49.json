{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { each, isNil, isNumber } from '@antv/util';\nimport { distance, getCircleIntersectByPoint, getEllipseIntersectByPoint, getRectIntersectByPoint } from '../util/math';\nimport Item from './item';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\n\nvar Node =\n/** @class */\nfunction (_super) {\n  __extends(Node, _super);\n\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = distance(points[0], curPoint);\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = distance(point, curPoint);\n\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n\n\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n\n\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n\n\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n\n\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n\n    var edges = this.get('edges');\n\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    } // 若未指定 type ，则返回所有邻居\n\n\n    var neighhborsConverter = function neighhborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n\n    return edges.map(neighhborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n\n\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n\n\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n\n    if (itemType === 'combo') {\n      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;\n      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n\n    switch (type) {\n      case 'circle':\n        intersectPoint = getCircleIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n\n      case 'ellipse':\n        intersectPoint = getEllipseIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n\n      default:\n        intersectPoint = getRectIntersectByPoint(bbox, point);\n    }\n\n    var linkPoint = intersectPoint; // 如果存在锚点，则使用交点计算最近的锚点\n\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n\n\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      each(points, function (pointArr, index) {\n        var point = {\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height,\n          anchorIndex: index\n        };\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n\n\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n\n\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n\n\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n\n\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n    if (index > -1) edges.splice(index, 1);\n  };\n\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 判断更新的种类，move 表示仅移动，bbox 表示大小有变化，style 表示仅与大小无关的参数变化\n   * @param cfg 节点数据模型\n   */\n\n\n  Node.prototype.getUpdateType = function (cfg) {\n    var _a, _b, _c, _d, _e;\n\n    if (!cfg) return undefined;\n    var existX = !isNil(cfg.x);\n    var existY = !isNil(cfg.y);\n    var keys = Object.keys(cfg); // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n\n    if (keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY) return 'move';\n    if (isNumber(cfg.x) || isNumber(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a === void 0 ? void 0 : _a.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e === void 0 ? void 0 : _e.ry))) return 'bbox|label';\n    var updateLabel = keys.includes('label') || keys.includes('labelCfg');\n    return updateLabel ? 'style|label' : 'style';\n  };\n\n  return Node;\n}(Item);\n\nexport default Node;","map":null,"metadata":{},"sourceType":"module"}