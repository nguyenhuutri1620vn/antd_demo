{"ast":null,"code":"import { Util } from '../../global';\nimport { StringExt, FunctionExt } from '../../util';\nimport { Point, Rectangle, Angle } from '../../geometry';\nimport { Cell } from '../../model/cell';\nimport { notify } from '../transform/util';\nexport class NodePreset {\n  constructor(halo) {\n    this.halo = halo;\n  }\n\n  get options() {\n    return this.halo.options;\n  }\n\n  get graph() {\n    return this.halo.graph;\n  }\n\n  get model() {\n    return this.halo.model;\n  }\n\n  get view() {\n    return this.halo.view;\n  }\n\n  get cell() {\n    return this.halo.cell;\n  }\n\n  get node() {\n    return this.cell;\n  }\n\n  getPresets() {\n    return {\n      className: 'type-node',\n      handles: [{\n        name: 'remove',\n        position: 'nw',\n        events: {\n          mousedown: this.removeCell.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'resize',\n        position: 'se',\n        events: {\n          mousedown: this.startResize.bind(this),\n          mousemove: this.doResize.bind(this),\n          mouseup: this.stopResize.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'clone',\n        position: 'n',\n        events: {\n          mousedown: this.startClone.bind(this),\n          mousemove: this.doClone.bind(this),\n          mouseup: this.stopClone.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'link',\n        position: 'e',\n        events: {\n          mousedown: this.startLink.bind(this),\n          mousemove: this.doLink.bind(this),\n          mouseup: this.stopLink.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'fork',\n        position: 'ne',\n        events: {\n          mousedown: this.startFork.bind(this),\n          mousemove: this.doFork.bind(this),\n          mouseup: this.stopFork.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'unlink',\n        position: 'w',\n        events: {\n          mousedown: this.unlink.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'rotate',\n        position: 'sw',\n        events: {\n          mousedown: this.startRotate.bind(this),\n          mousemove: this.doRotate.bind(this),\n          mouseup: this.stopRotate.bind(this)\n        },\n        icon: null\n      }],\n\n      bbox(view) {\n        if (this.options.useCellGeometry) {\n          const node = view.cell;\n          return node.getBBox();\n        }\n\n        return view.getBBox();\n      },\n\n      content(view) {\n        const template = StringExt.template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');\n        const cell = view.cell;\n        const bbox = cell.getBBox();\n        return template({\n          x: Math.floor(bbox.x),\n          y: Math.floor(bbox.y),\n          width: Math.floor(bbox.width),\n          height: Math.floor(bbox.height),\n          angle: Math.floor(cell.getAngle())\n        });\n      },\n\n      magnet(view) {\n        return view.container;\n      },\n\n      tinyThreshold: 40,\n      smallThreshold: 80,\n      loopEdgePreferredSide: 'top',\n      loopEdgeWidth: 40,\n      rotateGrid: 15,\n      rotateEmbeds: false\n    };\n  }\n\n  removeCell() {\n    this.model.removeConnectedEdges(this.cell);\n    this.cell.remove();\n  } // #region create edge\n\n\n  startLink(_ref) {\n    let {\n      x,\n      y\n    } = _ref;\n    this.halo.startBatch();\n    const graph = this.graph;\n    const edge = this.createEdgeConnectedToSource();\n    edge.setTarget({\n      x,\n      y\n    });\n    this.model.addEdge(edge, {\n      validation: false,\n      halo: this.halo.cid,\n      async: false\n    });\n    graph.view.undelegateEvents();\n    this.edgeView = graph.renderer.findViewByCell(edge);\n    this.edgeView.prepareArrowheadDragging('target', {\n      x,\n      y,\n      fallbackAction: 'remove'\n    });\n  }\n\n  createEdgeConnectedToSource() {\n    const magnet = this.getMagnet(this.view, 'source');\n    const terminal = this.getEdgeTerminal(this.view, magnet);\n    const edge = this.graph.hook.getDefaultEdge(this.view, magnet);\n    edge.setSource(terminal);\n    return edge;\n  }\n\n  getMagnet(view, terminal) {\n    const magnet = this.options.magnet;\n\n    if (typeof magnet === 'function') {\n      const val = FunctionExt.call(magnet, this.halo, view, terminal);\n\n      if (val instanceof SVGElement) {\n        return val;\n      }\n    }\n\n    throw new Error('`magnet()` has to return an SVGElement');\n  }\n\n  getEdgeTerminal(view, magnet) {\n    const terminal = {\n      cell: view.cell.id\n    };\n\n    if (magnet !== view.container) {\n      const port = magnet.getAttribute('port');\n\n      if (port) {\n        terminal.port = port;\n      } else {\n        terminal.selector = view.getSelector(magnet);\n      }\n    }\n\n    return terminal;\n  }\n\n  doLink(_ref2) {\n    let {\n      e,\n      x,\n      y\n    } = _ref2;\n\n    if (this.edgeView) {\n      this.edgeView.onMouseMove(e, x, y);\n    }\n  }\n\n  stopLink(_ref3) {\n    let {\n      e,\n      x,\n      y\n    } = _ref3;\n    const edgeView = this.edgeView;\n\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y);\n      const edge = edgeView.cell;\n\n      if (edge.hasLoop()) {\n        this.makeLoopEdge(edge);\n      }\n\n      this.halo.stopBatch();\n      this.halo.trigger('action:edge:addde', {\n        edge\n      });\n      this.edgeView = null;\n    }\n\n    this.graph.view.delegateEvents();\n  }\n\n  makeLoopEdge(edge) {\n    let vertex1 = null;\n    let vertex2 = null;\n    const loopEdgeWidth = this.options.loopEdgeWidth;\n    const graphOptions = this.graph.options;\n    const graphRect = new Rectangle(0, 0, graphOptions.width, graphOptions.height);\n    const bbox = this.graph.graphToLocal(this.view.getBBox());\n    const found = [this.options.loopEdgePreferredSide, 'top', 'bottom', 'left', 'right'].some(position => {\n      let point = null;\n      let dx = 0;\n      let dy = 0;\n\n      switch (position) {\n        case 'top':\n          point = new Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);\n          dx = loopEdgeWidth / 2;\n          break;\n\n        case 'bottom':\n          point = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);\n          dx = loopEdgeWidth / 2;\n          break;\n\n        case 'left':\n          point = new Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);\n          dy = loopEdgeWidth / 2;\n          break;\n\n        case 'right':\n          point = new Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);\n          dy = loopEdgeWidth / 2;\n          break;\n\n        default:\n          break;\n      }\n\n      if (point) {\n        vertex1 = point.translate(-dx, -dy);\n        vertex2 = point.translate(dx, dy);\n        return graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2);\n      }\n\n      return false;\n    });\n\n    if (found && vertex1 && vertex2) {\n      edge.setVertices([vertex1, vertex2]);\n    }\n  } // #endregion\n  // #region resize\n\n\n  startResize(_ref4) {\n    let {\n      e\n    } = _ref4;\n    this.halo.startBatch();\n    this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(Angle.normalize(this.node.getAngle()) / 45)];\n    this.view.addClass('node-resizing');\n    notify('node:resize', e, this.view);\n  }\n\n  doResize(_ref5) {\n    let {\n      e,\n      dx,\n      dy\n    } = _ref5;\n    const size = this.node.getSize();\n    const width = Math.max(size.width + (this.flip ? dx : dy), 1);\n    const height = Math.max(size.height + (this.flip ? dy : dx), 1);\n    this.node.resize(width, height, {\n      absolute: true\n    });\n    notify('node:resizing', e, this.view);\n  }\n\n  stopResize(_ref6) {\n    let {\n      e\n    } = _ref6;\n    this.view.removeClass('node-resizing');\n    notify('node:resized', e, this.view);\n    this.halo.stopBatch();\n  } // #endregion\n  // #region clone\n\n\n  startClone(_ref7) {\n    let {\n      e,\n      x,\n      y\n    } = _ref7;\n    this.halo.startBatch();\n    const options = this.options;\n    const cloned = options.clone(this.cell, {\n      clone: true\n    });\n\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\");\n    }\n\n    this.centerNodeAtCursor(cloned, x, y);\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false\n    });\n    const cloneView = this.graph.renderer.findViewByCell(cloned);\n    cloneView.onMouseDown(e, x, y);\n    this.halo.setEventData(e, {\n      cloneView\n    });\n  }\n\n  centerNodeAtCursor(cell, x, y) {\n    const center = cell.getBBox().getCenter();\n    const dx = x - center.x;\n    const dy = y - center.y;\n    cell.translate(dx, dy);\n  }\n\n  doClone(_ref8) {\n    let {\n      e,\n      x,\n      y\n    } = _ref8;\n    const view = this.halo.getEventData(e).cloneView;\n\n    if (view) {\n      view.onMouseMove(e, x, y);\n    }\n  }\n\n  stopClone(_ref9) {\n    let {\n      e,\n      x,\n      y\n    } = _ref9;\n    const nodeView = this.halo.getEventData(e).cloneView;\n\n    if (nodeView) {\n      nodeView.onMouseUp(e, x, y);\n    }\n\n    this.halo.stopBatch();\n  } // #endregion\n  // #region fork\n\n\n  startFork(_ref10) {\n    let {\n      e,\n      x,\n      y\n    } = _ref10;\n    this.halo.startBatch();\n    const cloned = this.options.clone(this.cell, {\n      fork: true\n    });\n\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\");\n    }\n\n    this.centerNodeAtCursor(cloned, x, y);\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false\n    });\n    const edge = this.createEdgeConnectedToSource();\n    const cloneView = this.graph.renderer.findViewByCell(cloned);\n    const magnet = this.getMagnet(cloneView, 'target');\n    const terminal = this.getEdgeTerminal(cloneView, magnet);\n    edge.setTarget(terminal);\n    this.model.addEdge(edge, {\n      halo: this.halo.cid,\n      async: false\n    });\n    cloneView.onMouseDown(e, x, y);\n    this.halo.setEventData(e, {\n      cloneView\n    });\n  }\n\n  doFork(_ref11) {\n    let {\n      e,\n      x,\n      y\n    } = _ref11;\n    const view = this.halo.getEventData(e).cloneView;\n\n    if (view) {\n      view.onMouseMove(e, x, y);\n    }\n  }\n\n  stopFork(_ref12) {\n    let {\n      e,\n      x,\n      y\n    } = _ref12;\n    const view = this.halo.getEventData(e).cloneView;\n\n    if (view) {\n      view.onMouseUp(e, x, y);\n    }\n\n    this.halo.stopBatch();\n  } // #endregion\n  // #region rotate\n\n\n  startRotate(_ref13) {\n    let {\n      e,\n      x,\n      y\n    } = _ref13;\n    this.halo.startBatch();\n    const center = this.node.getBBox().getCenter();\n    const nodes = [this.node];\n\n    if (this.options.rotateEmbeds) {\n      this.node.getDescendants({\n        deep: true\n      }).reduce((memo, cell) => {\n        if (cell.isNode()) {\n          memo.push(cell);\n        }\n\n        return memo;\n      }, nodes);\n    }\n\n    this.halo.setEventData(e, {\n      center,\n      nodes,\n      rotateStartAngles: nodes.map(node => node.getAngle()),\n      clientStartAngle: new Point(x, y).theta(center)\n    });\n    nodes.forEach(node => {\n      const view = this.graph.findViewByCell(node);\n\n      if (view) {\n        view.addClass('node-rotating');\n        notify('node:rotate', e, view);\n      }\n    });\n  }\n\n  doRotate(_ref14) {\n    let {\n      e,\n      x,\n      y\n    } = _ref14;\n    const data = this.halo.getEventData(e);\n    const delta = data.clientStartAngle - new Point(x, y).theta(data.center);\n    data.nodes.forEach((node, index) => {\n      const startAngle = data.rotateStartAngles[index];\n      const targetAngle = Util.snapToGrid(startAngle + delta, this.options.rotateGrid);\n      node.rotate(targetAngle, {\n        absolute: true,\n        center: data.center,\n        halo: this.halo.cid\n      });\n      notify('node:rotating', e, this.graph.findViewByCell(node));\n    });\n  }\n\n  stopRotate(_ref15) {\n    let {\n      e\n    } = _ref15;\n    const data = this.halo.getEventData(e);\n    data.nodes.forEach(node => {\n      const view = this.graph.findViewByCell(node);\n      view.removeClass('node-rotating');\n      notify('node:rotated', e, view);\n    });\n    this.halo.stopBatch();\n  } // #endregion\n  // #region unlink\n\n\n  unlink() {\n    this.halo.startBatch();\n    this.model.removeConnectedEdges(this.cell);\n    this.halo.stopBatch();\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}