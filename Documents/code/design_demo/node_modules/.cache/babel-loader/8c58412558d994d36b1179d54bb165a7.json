{"ast":null,"code":"import * as util from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport class Rectangle extends Geometry {\n  constructor(x, y, width, height) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.width = width == null ? 0 : width;\n    this.height = height == null ? 0 : height;\n  }\n\n  get [Symbol.toStringTag]() {\n    return Rectangle.toStringTag;\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get origin() {\n    return new Point(this.x, this.y);\n  }\n\n  get topLeft() {\n    return new Point(this.x, this.y);\n  }\n\n  get topCenter() {\n    return new Point(this.x + this.width / 2, this.y);\n  }\n\n  get topRight() {\n    return new Point(this.x + this.width, this.y);\n  }\n\n  get center() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  }\n\n  get bottomLeft() {\n    return new Point(this.x, this.y + this.height);\n  }\n\n  get bottomCenter() {\n    return new Point(this.x + this.width / 2, this.y + this.height);\n  }\n\n  get bottomRight() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n\n  get corner() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n\n  get rightMiddle() {\n    return new Point(this.x + this.width, this.y + this.height / 2);\n  }\n\n  get leftMiddle() {\n    return new Point(this.x, this.y + this.height / 2);\n  }\n\n  get topLine() {\n    return new Line(this.topLeft, this.topRight);\n  }\n\n  get rightLine() {\n    return new Line(this.topRight, this.bottomRight);\n  }\n\n  get bottomLine() {\n    return new Line(this.bottomLeft, this.bottomRight);\n  }\n\n  get leftLine() {\n    return new Line(this.topLeft, this.bottomLeft);\n  }\n\n  getOrigin() {\n    return this.origin;\n  }\n\n  getTopLeft() {\n    return this.topLeft;\n  }\n\n  getTopCenter() {\n    return this.topCenter;\n  }\n\n  getTopRight() {\n    return this.topRight;\n  }\n\n  getCenter() {\n    return this.center;\n  }\n\n  getCenterX() {\n    return this.x + this.width / 2;\n  }\n\n  getCenterY() {\n    return this.y + this.height / 2;\n  }\n\n  getBottomLeft() {\n    return this.bottomLeft;\n  }\n\n  getBottomCenter() {\n    return this.bottomCenter;\n  }\n\n  getBottomRight() {\n    return this.bottomRight;\n  }\n\n  getCorner() {\n    return this.corner;\n  }\n\n  getRightMiddle() {\n    return this.rightMiddle;\n  }\n\n  getLeftMiddle() {\n    return this.leftMiddle;\n  }\n\n  getTopLine() {\n    return this.topLine;\n  }\n\n  getRightLine() {\n    return this.rightLine;\n  }\n\n  getBottomLine() {\n    return this.bottomLine;\n  }\n\n  getLeftLine() {\n    return this.leftLine;\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the rectangle.\n   *\n   * If `angle` is specified, the bounding box calculation will take into\n   * account the rotation of the rectangle by angle degrees around its center.\n   */\n\n\n  bbox(angle) {\n    if (!angle) {\n      return this.clone();\n    }\n\n    const rad = Angle.toRad(angle);\n    const st = Math.abs(Math.sin(rad));\n    const ct = Math.abs(Math.cos(rad));\n    const w = this.width * ct + this.height * st;\n    const h = this.width * st + this.height * ct;\n    return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n  }\n\n  round() {\n    let precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.x = util.round(this.x, precision);\n    this.y = util.round(this.y, precision);\n    this.width = util.round(this.width, precision);\n    this.height = util.round(this.height, precision);\n    return this;\n  }\n\n  add(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    const minX = Math.min(this.x, rect.x);\n    const minY = Math.min(this.y, rect.y);\n    const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n    const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n    this.x = minX;\n    this.y = minY;\n    this.width = maxX - minX;\n    this.height = maxY - minY;\n    return this;\n  }\n\n  update(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    this.x = rect.x;\n    this.y = rect.y;\n    this.width = rect.width;\n    this.height = rect.height;\n    return this;\n  }\n\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.x -= w;\n    this.y -= h;\n    this.width += 2 * w;\n    this.height += 2 * h;\n    return this;\n  }\n\n  snapToGrid(gx, gy) {\n    const origin = this.origin.snapToGrid(gx, gy);\n    const corner = this.corner.snapToGrid(gx, gy);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width = corner.x - origin.x;\n    this.height = corner.y - origin.y;\n    return this;\n  }\n\n  translate(tx, ty) {\n    const p = Point.create(tx, ty);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  scale(sx, sy) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    const pos = this.origin.scale(sx, sy, origin);\n    this.x = pos.x;\n    this.y = pos.y;\n    this.width *= sx;\n    this.height *= sy;\n    return this;\n  }\n\n  rotate(degree) {\n    let center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getCenter();\n\n    if (degree !== 0) {\n      const rad = Angle.toRad(degree);\n      const cos = Math.cos(rad);\n      const sin = Math.sin(rad);\n      let p1 = this.getOrigin();\n      let p2 = this.getTopRight();\n      let p3 = this.getBottomRight();\n      let p4 = this.getBottomLeft();\n      p1 = Point.rotateEx(p1, cos, sin, center);\n      p2 = Point.rotateEx(p2, cos, sin, center);\n      p3 = Point.rotateEx(p3, cos, sin, center);\n      p4 = Point.rotateEx(p4, cos, sin, center);\n      const rect = new Rectangle(p1.x, p1.y, 0, 0);\n      rect.add(p2.x, p2.y, 0, 0);\n      rect.add(p3.x, p3.y, 0, 0);\n      rect.add(p4.x, p4.y, 0, 0);\n      this.update(rect);\n    }\n\n    return this;\n  }\n\n  rotate90() {\n    const t = (this.width - this.height) / 2;\n    this.x += t;\n    this.y -= t;\n    const tmp = this.width;\n    this.width = this.height;\n    this.height = tmp;\n    return this;\n  }\n  /**\n   * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n   * `rect.width` and `rect.height`.\n   */\n\n\n  moveAndExpand(rect) {\n    const ref = Rectangle.clone(rect);\n    this.x += ref.x || 0;\n    this.y += ref.y || 0;\n    this.width += ref.width || 0;\n    this.height += ref.height || 0;\n    return this;\n  }\n  /**\n   * Returns an object where `sx` and `sy` give the maximum scaling that can be\n   * applied to the rectangle so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n\n\n  getMaxScaleToFit(limit) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n    const rect = Rectangle.clone(limit);\n    const ox = origin.x;\n    const oy = origin.y; // Find the maximal possible scale for all corners, so when the scale\n    // is applied the point is still inside the rectangle.\n\n    let sx1 = Infinity;\n    let sx2 = Infinity;\n    let sx3 = Infinity;\n    let sx4 = Infinity;\n    let sy1 = Infinity;\n    let sy2 = Infinity;\n    let sy3 = Infinity;\n    let sy4 = Infinity; // Top Left\n\n    const p1 = rect.topLeft;\n\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox);\n    }\n\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy);\n    } // Bottom Right\n\n\n    const p2 = rect.bottomRight;\n\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n    }\n\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n    } // Top Right\n\n\n    const p3 = rect.topRight;\n\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n    }\n\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy);\n    } // Bottom Left\n\n\n    const p4 = rect.bottomLeft;\n\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox);\n    }\n\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n    }\n\n    return {\n      sx: Math.min(sx1, sx2, sx3, sx4),\n      sy: Math.min(sy1, sy2, sy3, sy4)\n    };\n  }\n  /**\n   * Returns a number that specifies the maximum scaling that can be applied to\n   * the rectangle along both axes so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n\n\n  getMaxUniformScaleToFit(limit) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n    const scale = this.getMaxScaleToFit(limit, origin);\n    return Math.min(scale.sx, scale.sy);\n  }\n\n  containsPoint(x, y) {\n    return util.containsPoint(this, Point.create(x, y));\n  }\n\n  containsRect(x, y, width, height) {\n    const b = Rectangle.create(x, y, width, height);\n    const x1 = this.x;\n    const y1 = this.y;\n    const w1 = this.width;\n    const h1 = this.height;\n    const x2 = b.x;\n    const y2 = b.y;\n    const w2 = b.width;\n    const h2 = b.height; // one of the dimensions is 0\n\n    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n      return false;\n    }\n\n    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n  }\n  /**\n   * Returns an array of the intersection points of the rectangle and the line.\n   * Return `null` if no intersection exists.\n   */\n\n\n  intersectsWithLine(line) {\n    const rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const points = [];\n    const dedupeArr = [];\n    rectLines.forEach(l => {\n      const p = line.intersectsWithLine(l);\n\n      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n        points.push(p);\n        dedupeArr.push(p.toString());\n      }\n    });\n    return points.length > 0 ? points : null;\n  }\n  /**\n   * Returns the point on the boundary of the rectangle that is the intersection\n   * of the rectangle with a line starting in the center the rectangle ending in\n   * the point `p`.\n   *\n   * If `angle` is specified, the intersection will take into account the\n   * rotation of the rectangle by `angle` degrees around its center.\n   */\n\n\n  intersectsWithLineFromCenterToPoint(p, angle) {\n    const ref = Point.clone(p);\n    const center = this.center;\n    let result = null;\n\n    if (angle != null && angle !== 0) {\n      ref.rotate(angle, center);\n    }\n\n    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const connector = new Line(center, ref);\n\n    for (let i = sides.length - 1; i >= 0; i -= 1) {\n      const intersection = sides[i].intersectsWithLine(connector);\n\n      if (intersection !== null) {\n        result = intersection;\n        break;\n      }\n    }\n\n    if (result && angle != null && angle !== 0) {\n      result.rotate(-angle, center);\n    }\n\n    return result;\n  }\n\n  intersectsWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height); // no intersection\n\n    if (!this.isIntersectWithRect(ref)) {\n      return null;\n    }\n\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const xx = Math.max(myOrigin.x, rOrigin.x);\n    const yy = Math.max(myOrigin.y, rOrigin.y);\n    return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n  }\n\n  isIntersectWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n\n    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Normalize the rectangle, i.e. make it so that it has non-negative\n   * width and height. If width is less than `0`, the function swaps left and\n   * right corners and if height is less than `0`, the top and bottom corners\n   * are swapped.\n   */\n\n\n  normalize() {\n    let newx = this.x;\n    let newy = this.y;\n    let newwidth = this.width;\n    let newheight = this.height;\n\n    if (this.width < 0) {\n      newx = this.x + this.width;\n      newwidth = -this.width;\n    }\n\n    if (this.height < 0) {\n      newy = this.y + this.height;\n      newheight = -this.height;\n    }\n\n    this.x = newx;\n    this.y = newy;\n    this.width = newwidth;\n    this.height = newheight;\n    return this;\n  }\n  /**\n   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n   */\n\n\n  union(rect) {\n    const ref = Rectangle.clone(rect);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const originX = Math.min(myOrigin.x, rOrigin.x);\n    const originY = Math.min(myOrigin.y, rOrigin.y);\n    const cornerX = Math.max(myCorner.x, rCorner.x);\n    const cornerY = Math.max(myCorner.y, rCorner.y);\n    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n  }\n  /**\n   * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n   * the rectangle which is nearest to the point `p`.\n   */\n\n\n  getNearestSideToPoint(p) {\n    const ref = Point.clone(p);\n    const distLeft = ref.x - this.x;\n    const distRight = this.x + this.width - ref.x;\n    const distTop = ref.y - this.y;\n    const distBottom = this.y + this.height - ref.y;\n    let closest = distLeft;\n    let side = 'left';\n\n    if (distRight < closest) {\n      closest = distRight;\n      side = 'right';\n    }\n\n    if (distTop < closest) {\n      closest = distTop;\n      side = 'top';\n    }\n\n    if (distBottom < closest) {\n      side = 'bottom';\n    }\n\n    return side;\n  }\n  /**\n   * Returns a point on the boundary of the rectangle nearest to the point `p`.\n   */\n\n\n  getNearestPointToPoint(p) {\n    const ref = Point.clone(p);\n\n    if (this.containsPoint(ref)) {\n      const side = this.getNearestSideToPoint(ref);\n\n      switch (side) {\n        case 'right':\n          return new Point(this.x + this.width, ref.y);\n\n        case 'left':\n          return new Point(this.x, ref.y);\n\n        case 'bottom':\n          return new Point(ref.x, this.y + this.height);\n\n        case 'top':\n          return new Point(ref.x, this.y);\n\n        default:\n          break;\n      }\n    }\n\n    return ref.adhereToRect(this);\n  }\n\n  equals(rect) {\n    return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.width} ${this.height}`;\n  }\n\n}\n\n(function (Rectangle) {\n  Rectangle.toStringTag = `X6.Geometry.${Rectangle.name}`;\n\n  function isRectangle(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Rectangle) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const rect = instance;\n\n    if ((tag == null || tag === Rectangle.toStringTag) && typeof rect.x === 'number' && typeof rect.y === 'number' && typeof rect.width === 'number' && typeof rect.height === 'number' && typeof rect.inflate === 'function' && typeof rect.moveAndExpand === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function isRectangleLike(o) {\n    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';\n  }\n\n  Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function create(x, y, width, height) {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height);\n    }\n\n    return clone(x);\n  }\n\n  Rectangle.create = create;\n\n  function clone(rect) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone();\n    }\n\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n    }\n\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n  }\n\n  Rectangle.clone = clone;\n\n  function fromSize(size) {\n    return new Rectangle(0, 0, size.width, size.height);\n  }\n\n  Rectangle.fromSize = fromSize;\n\n  function fromPositionAndSize(pos, size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height);\n  }\n\n  Rectangle.fromPositionAndSize = fromPositionAndSize;\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n\n  function fromEllipse(ellipse) {\n    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n  }\n\n  Rectangle.fromEllipse = fromEllipse;\n})(Rectangle || (Rectangle = {}));","map":null,"metadata":{},"sourceType":"module"}