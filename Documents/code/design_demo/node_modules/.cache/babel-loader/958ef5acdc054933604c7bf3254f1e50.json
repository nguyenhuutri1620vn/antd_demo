{"ast":null,"code":"import { Path } from '../../geometry';\nimport * as Dom from '../dom/core';\nexport class Vector {\n  constructor(elem, attrs, children) {\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector');\n    }\n\n    let node;\n\n    if (Vector.isVector(elem)) {\n      node = elem.node;\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument();\n      } else if (elem[0] === '<') {\n        const doc = Dom.createSvgDocument(elem); // only import the first child\n\n        node = document.importNode(doc.firstChild, true);\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem);\n      }\n    } else {\n      node = elem;\n    }\n\n    this.node = node;\n\n    if (attrs) {\n      this.setAttributes(attrs);\n    }\n\n    if (children) {\n      this.append(children);\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Vector.toStringTag;\n  }\n\n  get type() {\n    return this.node.nodeName;\n  }\n\n  get id() {\n    return this.node.id;\n  }\n\n  set id(id) {\n    this.node.id = id;\n  }\n\n  transform(matrix, options) {\n    if (matrix == null) {\n      return Dom.transform(this.node);\n    }\n\n    Dom.transform(this.node, matrix, options);\n    return this;\n  }\n\n  translate(tx) {\n    let ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (tx == null) {\n      return Dom.translate(this.node);\n    }\n\n    Dom.translate(this.node, tx, ty, options);\n    return this;\n  }\n\n  rotate(angle, cx, cy) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (angle == null) {\n      return Dom.rotate(this.node);\n    }\n\n    Dom.rotate(this.node, angle, cx, cy, options);\n    return this;\n  }\n\n  scale(sx, sy) {\n    if (sx == null) {\n      return Dom.scale(this.node);\n    }\n\n    Dom.scale(this.node, sx, sy);\n    return this;\n  }\n  /**\n   * Returns an SVGMatrix that specifies the transformation necessary\n   * to convert this coordinate system into `target` coordinate system.\n   */\n\n\n  getTransformToElement(target) {\n    const ref = Vector.toNode(target);\n    return Dom.getTransformToElement(this.node, ref);\n  }\n\n  removeAttribute(name) {\n    Dom.removeAttribute(this.node, name);\n    return this;\n  }\n\n  getAttribute(name) {\n    return Dom.getAttribute(this.node, name);\n  }\n\n  setAttribute(name, value) {\n    Dom.setAttribute(this.node, name, value);\n    return this;\n  }\n\n  setAttributes(attrs) {\n    Dom.setAttributes(this.node, attrs);\n    return this;\n  }\n\n  attr(name, value) {\n    if (name == null) {\n      return Dom.attr(this.node);\n    }\n\n    if (typeof name === 'string' && value === undefined) {\n      return Dom.attr(this.node, name);\n    }\n\n    if (typeof name === 'object') {\n      Dom.attr(this.node, name);\n    } else {\n      Dom.attr(this.node, name, value);\n    }\n\n    return this;\n  }\n\n  svg() {\n    return this.node instanceof SVGSVGElement ? this : Vector.create(this.node.ownerSVGElement);\n  }\n\n  defs() {\n    const context = this.svg() || this;\n    const defsNode = context.node.getElementsByTagName('defs')[0];\n\n    if (defsNode) {\n      return Vector.create(defsNode);\n    }\n\n    return Vector.create('defs').appendTo(context);\n  }\n\n  text(content) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Dom.text(this.node, content, options);\n    return this;\n  }\n\n  tagName() {\n    return Dom.tagName(this.node);\n  }\n\n  clone() {\n    return Vector.create(this.node.cloneNode(true));\n  }\n\n  remove() {\n    Dom.remove(this.node);\n    return this;\n  }\n\n  empty() {\n    Dom.empty(this.node);\n    return this;\n  }\n\n  append(elems) {\n    Dom.append(this.node, Vector.toNodes(elems));\n    return this;\n  }\n\n  appendTo(target) {\n    Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n    return this;\n  }\n\n  prepend(elems) {\n    Dom.prepend(this.node, Vector.toNodes(elems));\n    return this;\n  }\n\n  before(elems) {\n    Dom.before(this.node, Vector.toNodes(elems));\n    return this;\n  }\n\n  replace(elem) {\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n    }\n\n    return Vector.create(elem);\n  }\n\n  first() {\n    return this.node.firstChild ? Vector.create(this.node.firstChild) : null;\n  }\n\n  last() {\n    return this.node.lastChild ? Vector.create(this.node.lastChild) : null;\n  }\n\n  get(index) {\n    const child = this.node.childNodes[index];\n    return child ? Vector.create(child) : null;\n  }\n\n  indexOf(elem) {\n    const children = Array.prototype.slice.call(this.node.childNodes);\n    return children.indexOf(Vector.toNode(elem));\n  }\n\n  find(selector) {\n    const vels = [];\n    const nodes = Dom.find(this.node, selector);\n\n    if (nodes) {\n      for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n        vels.push(Vector.create(nodes[i]));\n      }\n    }\n\n    return vels;\n  }\n\n  findOne(selector) {\n    const found = Dom.findOne(this.node, selector);\n    return found ? Vector.create(found) : null;\n  }\n\n  findParentByClass(className, terminator) {\n    const node = Dom.findParentByClass(this.node, className, terminator);\n    return node ? Vector.create(node) : null;\n  }\n\n  matches(selector) {\n    const node = this.node;\n    const matches = this.node.matches;\n    const matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;\n    return matcher && matcher.call(node, selector);\n  }\n\n  contains(child) {\n    return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n  }\n\n  wrap(node) {\n    const vel = Vector.create(node);\n    const parentNode = this.node.parentNode;\n\n    if (parentNode != null) {\n      parentNode.insertBefore(vel.node, this.node);\n    }\n\n    return vel.append(this);\n  }\n\n  parent(type) {\n    let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n    // check for parent\n\n    if (parent.node.parentNode == null) {\n      return null;\n    } // get parent element\n\n\n    parent = Vector.create(parent.node.parentNode);\n\n    if (type == null) {\n      return parent;\n    } // loop trough ancestors if type is given\n\n\n    do {\n      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n        return parent;\n      }\n    } while (parent = Vector.create(parent.node.parentNode));\n\n    return parent;\n  }\n\n  children() {\n    const children = this.node.childNodes;\n    const vels = [];\n\n    for (let i = 0; i < children.length; i += 1) {\n      const currentChild = children[i];\n\n      if (currentChild.nodeType === 1) {\n        vels.push(Vector.create(children[i]));\n      }\n    }\n\n    return vels;\n  }\n\n  eachChild(fn, deep) {\n    const children = this.children();\n\n    for (let i = 0, l = children.length; i < l; i += 1) {\n      fn.call(children[i], children[i], i, children);\n\n      if (deep) {\n        children[i].eachChild(fn, deep);\n      }\n    }\n\n    return this;\n  }\n\n  index() {\n    return Dom.index(this.node);\n  }\n\n  hasClass(className) {\n    return Dom.hasClass(this.node, className);\n  }\n\n  addClass(className) {\n    Dom.addClass(this.node, className);\n    return this;\n  }\n\n  removeClass(className) {\n    Dom.removeClass(this.node, className);\n    return this;\n  }\n\n  toggleClass(className, stateVal) {\n    Dom.toggleClass(this.node, className, stateVal);\n    return this;\n  }\n\n  toLocalPoint(x, y) {\n    return Dom.toLocalPoint(this.node, x, y);\n  }\n\n  toGeometryShape() {\n    return Dom.toGeometryShape(this.node);\n  }\n\n  translateCenterToPoint(p) {\n    const bbox = this.getBBox({\n      target: this.svg()\n    });\n    const center = bbox.getCenter();\n    this.translate(p.x - center.x, p.y - center.y);\n    return this;\n  }\n\n  translateAndAutoOrient(position, reference, target) {\n    Dom.translateAndAutoOrient(this.node, position, reference, target);\n    return this;\n  }\n\n  animate(options) {\n    return Dom.animate(this.node, options);\n  }\n\n  animateTransform(options) {\n    return Dom.animateTransform(this.node, options);\n  }\n\n  animateAlongPath(options, path) {\n    return Dom.animateAlongPath(this.node, options, path);\n  }\n  /**\n   * Normalize this element's d attribute. SVGPathElements without\n   * a path data attribute obtain a value of 'M 0 0'.\n   */\n\n\n  normalizePath() {\n    const tagName = this.tagName();\n\n    if (tagName === 'path') {\n      this.attr('d', Path.normalize(this.attr('d')));\n    }\n\n    return this;\n  }\n  /**\n   * Returns the bounding box of the element after transformations are applied.\n   * If `withoutTransformations` is `true`, transformations of the element\n   * will not be considered when computing the bounding box. If `target` is\n   * specified, bounding box will be computed relatively to the target element.\n   */\n\n\n  bbox(withoutTransformations, target) {\n    return Dom.bbox(this.node, withoutTransformations, target);\n  }\n\n  getBBox() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Dom.getBBox(this.node, {\n      recursive: options.recursive,\n      target: options.target ? Vector.toNode(options.target) : null\n    });\n  }\n  /**\n   * Samples the underlying SVG element (it currently works only on\n   * paths - where it is most useful anyway). Returns an array of objects\n   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n   * objects represent a point on the path. This basically creates a discrete\n   * representation of the path (which is possible a curve). The sampling\n   * interval defines the accuracy of the sampling. In other words, we travel\n   * from the beginning of the path to the end by interval distance (on the\n   * path, not between the resulting points) and collect the discrete points\n   * on the path. This is very useful in many situations. For example, SVG\n   * does not provide a built-in mechanism to find intersections between two\n   * paths. Using sampling, we can just generate bunch of points for each of\n   * the path and find the closest ones from each set.\n   */\n\n\n  sample() {\n    let interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    if (this.node instanceof SVGPathElement) {\n      return Dom.sample(this.node, interval);\n    }\n\n    return [];\n  }\n\n  toPath() {\n    return Vector.create(Dom.toPath(this.node));\n  }\n\n  toPathData() {\n    return Dom.toPathData(this.node);\n  }\n\n}\n\n(function (Vector) {\n  Vector.toStringTag = `X6.${Vector.name}`;\n\n  function isVector(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Vector) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const vector = instance;\n\n    if ((tag == null || tag === Vector.toStringTag) && vector.node instanceof SVGElement && typeof vector.animate === 'function' && typeof vector.sample === 'function' && typeof vector.normalizePath === 'function' && typeof vector.toPath === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Vector.isVector = isVector;\n\n  function create(elem, attrs, children) {\n    return new Vector(elem, attrs, children);\n  }\n\n  Vector.create = create;\n\n  function createVectors(markup) {\n    if (markup[0] === '<') {\n      const svgDoc = Dom.createSvgDocument(markup);\n      const vels = [];\n\n      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        const childNode = svgDoc.childNodes[i];\n        vels.push(create(document.importNode(childNode, true)));\n      }\n\n      return vels;\n    }\n\n    return [create(markup)];\n  }\n\n  Vector.createVectors = createVectors;\n\n  function toNode(elem) {\n    if (isVector(elem)) {\n      return elem.node;\n    }\n\n    return elem;\n  }\n\n  Vector.toNode = toNode;\n\n  function toNodes(elems) {\n    if (Array.isArray(elems)) {\n      return elems.map(elem => toNode(elem));\n    }\n\n    return [toNode(elems)];\n  }\n\n  Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));","map":null,"metadata":{},"sourceType":"module"}