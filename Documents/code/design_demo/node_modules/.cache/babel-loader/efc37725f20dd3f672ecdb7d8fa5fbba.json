{"ast":null,"code":"import { Point, Path, Polyline } from '../../geometry';\nimport { NumberExt, FunctionExt } from '../../util';\nexport const ref = {// We do not set `ref` attribute directly on an element.\n  // The attribute itself does not qualify for relative positioning.\n}; // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n// otherwise, `refX` is the left coordinate of the bounding box\n\nexport const refX = {\n  position: positionWrapper('x', 'width', 'origin')\n};\nexport const refY = {\n  position: positionWrapper('y', 'height', 'origin')\n}; // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n// coordinate of the reference element.\n\nexport const refDx = {\n  position: positionWrapper('x', 'width', 'corner')\n};\nexport const refDy = {\n  position: positionWrapper('y', 'height', 'corner')\n}; // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n// the reference element size\n// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\nexport const refWidth = {\n  set: setWrapper('width', 'width')\n};\nexport const refHeight = {\n  set: setWrapper('height', 'height')\n};\nexport const refRx = {\n  set: setWrapper('rx', 'width')\n};\nexport const refRy = {\n  set: setWrapper('ry', 'height')\n};\nexport const refRInscribed = {\n  set: (attrName => {\n    const widthFn = setWrapper(attrName, 'width');\n    const heightFn = setWrapper(attrName, 'height');\n    return function (value, options) {\n      const refBBox = options.refBBox;\n      const fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n      return FunctionExt.call(fn, this, value, options);\n    };\n  })('r')\n};\nexport const refRCircumscribed = {\n  set(val, _ref) {\n    let {\n      refBBox\n    } = _ref;\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n    let rValue;\n\n    if (Number.isFinite(value)) {\n      if (percentage || value >= 0 && value <= 1) {\n        rValue = value * diagonalLength;\n      } else {\n        rValue = Math.max(value + diagonalLength, 0);\n      }\n    }\n\n    return {\n      r: rValue\n    };\n  }\n\n};\nexport const refCx = {\n  set: setWrapper('cx', 'width')\n};\nexport const refCy = {\n  set: setWrapper('cy', 'height')\n};\nexport const refDResetOffset = {\n  set: dWrapper({\n    resetOffset: true\n  })\n};\nexport const refDKeepOffset = {\n  set: dWrapper({\n    resetOffset: false\n  })\n};\nexport const refPointsResetOffset = {\n  set: pointsWrapper({\n    resetOffset: true\n  })\n};\nexport const refPointsKeepOffset = {\n  set: pointsWrapper({\n    resetOffset: false\n  })\n}; // aliases\n// -------\n\nexport const refR = refRInscribed;\nexport const refD = refDResetOffset;\nexport const refPoints = refPointsResetOffset; // Allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\n\nexport const refX2 = refX;\nexport const refY2 = refY;\nexport const refWidth2 = refWidth;\nexport const refHeight2 = refHeight; // utils\n// -----\n\nfunction positionWrapper(axis, dimension, origin) {\n  return (val, _ref2) => {\n    let {\n      refBBox\n    } = _ref2;\n\n    if (val == null) {\n      return null;\n    }\n\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    let delta;\n\n    if (Number.isFinite(value)) {\n      const refOrigin = refBBox[origin];\n\n      if (percentage || value > 0 && value < 1) {\n        delta = refOrigin[axis] + refBBox[dimension] * value;\n      } else {\n        delta = refOrigin[axis] + value;\n      }\n    }\n\n    const point = new Point();\n    point[axis] = delta || 0;\n    return point;\n  };\n}\n\nfunction setWrapper(attrName, dimension) {\n  return function (val, _ref3) {\n    let {\n      refBBox\n    } = _ref3;\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    const attrs = {};\n\n    if (Number.isFinite(value)) {\n      const attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n      attrs[attrName] = attrValue;\n    }\n\n    return attrs;\n  };\n}\n\nfunction shapeWrapper(shapeConstructor, options) {\n  const cacheName = 'x6-shape';\n  const resetOffset = options && options.resetOffset;\n  return function (value, _ref4) {\n    let {\n      view,\n      elem,\n      refBBox\n    } = _ref4;\n    const $elem = view.$(elem);\n    let cache = $elem.data(cacheName);\n\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      const cachedShape = shapeConstructor(value);\n      cache = {\n        value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox()\n      };\n      $elem.data(cacheName, cache);\n    }\n\n    const shape = cache.shape.clone();\n    const shapeBBox = cache.shapeBBox.clone();\n    const shapeOrigin = shapeBBox.getOrigin();\n    const refOrigin = refBBox.getOrigin();\n    shapeBBox.x = refOrigin.x;\n    shapeBBox.y = refOrigin.y;\n    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin); // `maxRectScaleToFit` can give Infinity if width or height is 0\n\n    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n    shape.scale(sx, sy, shapeOrigin);\n\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n    }\n\n    return shape;\n  };\n} // `d` attribute for SVGPaths\n\n\nfunction dWrapper(options) {\n  function pathConstructor(value) {\n    return Path.parse(value);\n  }\n\n  const shape = shapeWrapper(pathConstructor, options);\n  return (value, args) => {\n    const path = shape(value, args);\n    return {\n      d: path.serialize()\n    };\n  };\n} // `points` attribute for SVGPolylines and SVGPolygons\n\n\nfunction pointsWrapper(options) {\n  const shape = shapeWrapper(points => new Polyline(points), options);\n  return (value, args) => {\n    const polyline = shape(value, args);\n    return {\n      points: polyline.serialize()\n    };\n  };\n}","map":null,"metadata":{},"sourceType":"module"}