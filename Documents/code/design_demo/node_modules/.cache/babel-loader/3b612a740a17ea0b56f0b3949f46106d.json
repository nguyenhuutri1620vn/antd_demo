{"ast":null,"code":"/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 同心圆布局\n */\n\nexport class ConcentricLayout extends Base {\n  constructor(options) {\n    super();\n    this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n\n    this.minNodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n\n    this.equidistant = false;\n    /** where nodes start in radians */\n\n    this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n\n    this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n\n    this.sortBy = \"degree\";\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      nodeSize: 30,\n      minNodeSpacing: 10,\n      preventOverlap: false,\n      sweep: undefined,\n      equidistant: false,\n      startAngle: 3 / 2 * Math.PI,\n      clockwise: true,\n      maxLevelDiff: undefined,\n      sortBy: \"degree\"\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const n = nodes.length;\n\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    const center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    const layoutNodes = [];\n    let maxNodeSize;\n\n    if (isArray(self.nodeSize)) {\n      maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n    } else {\n      maxNodeSize = self.nodeSize;\n    }\n\n    nodes.forEach(node => {\n      layoutNodes.push(node);\n      let nodeSize = maxNodeSize;\n\n      if (isArray(node.size)) {\n        nodeSize = Math.max(node.size[0], node.size[1]);\n      } else if (isNumber(node.size)) {\n        nodeSize = node.size;\n      } else if (isObject(node.size)) {\n        nodeSize = Math.max(node.size.width, node.size.height);\n      }\n\n      maxNodeSize = Math.max(maxNodeSize, nodeSize);\n    });\n    self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise; // layout\n\n    const nodeMap = {};\n    const indexMap = {};\n    layoutNodes.forEach((node, i) => {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    }); // get the node degrees\n\n    if (self.sortBy === \"degree\" || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = \"degree\";\n\n      if (!isNumber(nodes[0].degree)) {\n        const values = getDegree(nodes.length, indexMap, edges);\n        layoutNodes.forEach((node, i) => {\n          node.degree = values[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);\n    self.maxValueNode = layoutNodes[0];\n    self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4; // put the values into levels\n\n    const levels = [[]];\n    let currentLevel = levels[0];\n    layoutNodes.forEach(node => {\n      if (currentLevel.length > 0) {\n        const diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n\n        if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n\n      currentLevel.push(node);\n    }); // create positions for levels\n\n    let minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n\n    if (!self.preventOverlap) {\n      // then strictly constrain to bb\n      const firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      const maxR = Math.min(self.width, self.height) / 2 - minDist;\n      const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n      minDist = Math.min(minDist, rStep);\n    } // find the metrics for each level\n\n\n    let r = 0;\n    levels.forEach(level => {\n      let sweep = self.sweep;\n\n      if (sweep === undefined) {\n        sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n      }\n\n      const dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n      if (level.length > 1 && self.preventOverlap) {\n        // but only if more than one node (can't overlap)\n        const dcos = Math.cos(dTheta) - Math.cos(0);\n        const dsin = Math.sin(dTheta) - Math.sin(0);\n        const rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n\n      level.r = r;\n      r += minDist;\n    });\n\n    if (self.equidistant) {\n      let rDeltaMax = 0;\n      let rr = 0;\n\n      for (let i = 0; i < levels.length; i++) {\n        const level = levels[i];\n        const rDelta = level.r - rr;\n        rDeltaMax = Math.max(rDeltaMax, rDelta);\n      }\n\n      rr = 0;\n      levels.forEach((level, i) => {\n        if (i === 0) {\n          rr = level.r;\n        }\n\n        level.r = rr;\n        rr += rDeltaMax;\n      });\n    } // calculate the node positions\n\n\n    levels.forEach(level => {\n      const dTheta = level.dTheta;\n      const rr = level.r;\n      level.forEach((node, j) => {\n        const theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n        node.x = center[0] + rr * Math.cos(theta);\n        node.y = center[1] + rr * Math.sin(theta);\n      });\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  getType() {\n    return \"concentric\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}