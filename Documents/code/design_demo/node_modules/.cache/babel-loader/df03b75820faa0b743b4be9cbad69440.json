{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { getMask } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { PointExtrudeTriangulation } from '../../core/triangulation';\nvar heatmapGrid3dVert = \"precision highp float;\\n// \\u591A\\u8FB9\\u5F62\\u9876\\u70B9\\u5750\\u6807\\nattribute vec3 a_Position;\\n// \\u591A\\u8FB9\\u5F62\\u7ECF\\u7EAC\\u5EA6\\u5750\\u6807\\nattribute vec3 a_Pos;\\n\\nattribute vec3 a_Normal;\\nattribute float a_Size;\\nattribute vec4 a_Color;\\nuniform vec2 u_radius;\\nuniform float u_coverage: 0.9;\\nuniform float u_angle: 0;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_Mvp;\\nvarying vec4 v_color;\\n\\nuniform vec2 u_SceneCenterMKT;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\n\\nvoid main() {\\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \\u5B9E\\u9645\\u7684\\u7ECF\\u7EAC\\u5EA6\\n  // vec2 lnglat = (a_Pos.xy + offset); \\n  // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\\n  // gl_Position = project_common_position_to_clipspace(project_pos);\\n  // float lightWeight = calc_lighting(project_pos);\\n  // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n    // vec2 lnglat = (a_Pos.xy + offset); \\n    // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\\n\\n    // float lightWeight = calc_lighting(project_pos);\\n    // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n  \\n    // gl_Position = u_Mvp * vec4(lnglat , a_Position.z * a_Size, 1.0);\\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \\u7ECF\\u7EAC\\u5EA6\\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT; // \\u5C06\\u7ECF\\u7EAC\\u5EA6\\u8F6C\\u6362\\u4E3A\\u9AD8\\u5FB72.0\\u9700\\u8981\\u7684\\u5E73\\u9762\\u5750\\u6807\\n    vec4 project_pos = project_position(vec4(customLnglat, a_Position.z * a_Size, 1.0));\\n\\n    float lightWeight = calc_lighting(project_pos);\\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n  \\n    gl_Position = u_Mvp * vec4(customLnglat , a_Position.z * a_Size, 1.0);\\n  } else {\\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \\u5B9E\\u9645\\u7684\\u7ECF\\u7EAC\\u5EA6\\n    vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\\n    \\n    float lightWeight = calc_lighting(project_pos);\\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n    \\n    gl_Position = project_common_position_to_clipspace(project_pos);\\n  }\\n\\n\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nvar heatmapGridFrag = \"precision highp float;\\nvarying vec4 v_color;\\nuniform float u_opacity: 1;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  gl_FragColor.a *= u_opacity;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\n\nvar Grid3DModel = function (_BaseModel) {\n  _inherits(Grid3DModel, _BaseModel);\n\n  var _super = _createSuper(Grid3DModel);\n\n  function Grid3DModel() {\n    _classCallCheck(this, Grid3DModel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Grid3DModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          coverage = _ref.coverage,\n          angle = _ref.angle;\n\n      return {\n        u_opacity: opacity || 1.0,\n        u_coverage: coverage || 1.0,\n        u_angle: angle || 0,\n        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      return this.buildModels();\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      var _ref2 = this.layer.getLayerConfig(),\n          _ref2$mask = _ref2.mask,\n          mask = _ref2$mask === void 0 ? false : _ref2$mask,\n          _ref2$maskInside = _ref2.maskInside,\n          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;\n\n      return [this.layer.buildLayerModel({\n        moduleName: 'grid3dheatmap',\n        vertexShader: heatmapGrid3dVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: PointExtrudeTriangulation,\n        depth: {\n          enable: true\n        },\n        blend: this.getBlend(),\n        stencil: getMask(mask, maskInside)\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'normal',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Normal',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {\n            return normal;\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'pos',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Pos',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx) {\n            var coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;\n            return [coordinates[0], coordinates[1], 0];\n          }\n        }\n      });\n    }\n  }]);\n\n  return Grid3DModel;\n}(BaseModel);\n\nexport { Grid3DModel as default };","map":null,"metadata":{},"sourceType":"module"}