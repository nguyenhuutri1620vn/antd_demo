{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Dom, NumberExt } from '../util';\nimport { Point, Rectangle } from '../geometry';\nimport { Base } from './base';\nexport class TransformManager extends Base {\n  constructor() {\n    super(...arguments);\n    this.widgets = new Map();\n  }\n\n  get container() {\n    return this.graph.view.container;\n  }\n\n  get viewport() {\n    return this.graph.view.viewport;\n  }\n\n  get isSelectionEnabled() {\n    return this.options.selecting.enabled === true;\n  }\n\n  init() {\n    this.startListening();\n    this.resize();\n  }\n\n  startListening() {\n    this.graph.on('node:mouseup', this.onNodeMouseUp, this);\n    this.graph.on('node:selected', this.onNodeSelected, this);\n    this.graph.on('node:unselected', this.onNodeUnSelected, this);\n  }\n\n  stopListening() {\n    this.graph.off('node:mouseup', this.onNodeMouseUp, this);\n    this.graph.off('node:selected', this.onNodeSelected, this);\n    this.graph.off('node:unselected', this.onNodeUnSelected, this);\n  }\n\n  onNodeMouseUp(_ref) {\n    let {\n      node\n    } = _ref;\n\n    if (!this.isSelectionEnabled) {\n      const widget = this.graph.hook.createTransform(node, {\n        clearAll: true\n      });\n\n      if (widget) {\n        this.widgets.set(node, widget);\n      }\n    }\n  }\n\n  onNodeSelected(_ref2) {\n    let {\n      node\n    } = _ref2;\n\n    if (this.isSelectionEnabled) {\n      const widget = this.graph.hook.createTransform(node, {\n        clearAll: false\n      });\n\n      if (widget) {\n        this.widgets.set(node, widget);\n      }\n    }\n  }\n\n  onNodeUnSelected(_ref3) {\n    let {\n      node\n    } = _ref3;\n\n    if (this.isSelectionEnabled) {\n      const widget = this.widgets.get(node);\n\n      if (widget) {\n        widget.dispose();\n      }\n\n      this.widgets.delete(node);\n    }\n  }\n  /**\n   * Returns the current transformation matrix of the graph.\n   */\n\n\n  getMatrix() {\n    const transform = this.viewport.getAttribute('transform');\n\n    if (transform !== this.viewportTransformString) {\n      // `getCTM`: top-left relative to the SVG element\n      // `getScreenCTM`: top-left relative to the document\n      this.viewportMatrix = this.viewport.getCTM();\n      this.viewportTransformString = transform;\n    } // Clone the cached current transformation matrix.\n    // If no matrix previously stored the identity matrix is returned.\n\n\n    return Dom.createSVGMatrix(this.viewportMatrix);\n  }\n  /**\n   * Sets new transformation with the given `matrix`\n   */\n\n\n  setMatrix(matrix) {\n    const ctm = Dom.createSVGMatrix(matrix);\n    const transform = Dom.matrixToTransformString(ctm);\n    this.viewport.setAttribute('transform', transform);\n    this.viewportMatrix = ctm;\n    this.viewportTransformString = transform;\n  }\n\n  resize(width, height) {\n    let w = width === undefined ? this.options.width : width;\n    let h = height === undefined ? this.options.height : height;\n    this.options.width = w;\n    this.options.height = h;\n\n    if (typeof w === 'number') {\n      w = Math.round(w);\n    }\n\n    if (typeof h === 'number') {\n      h = Math.round(h);\n    }\n\n    this.container.style.width = w == null ? '' : `${w}px`;\n    this.container.style.height = h == null ? '' : `${h}px`;\n    const size = this.getComputedSize();\n    this.graph.trigger('resize', Object.assign({}, size));\n    return this;\n  }\n\n  getComputedSize() {\n    let w = this.options.width;\n    let h = this.options.height;\n\n    if (!NumberExt.isNumber(w)) {\n      w = this.container.clientWidth;\n    }\n\n    if (!NumberExt.isNumber(h)) {\n      h = this.container.clientHeight;\n    }\n\n    return {\n      width: w,\n      height: h\n    };\n  }\n\n  getScale() {\n    return Dom.matrixToScale(this.getMatrix());\n  }\n\n  scale(sx) {\n    let sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sx;\n    let ox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let oy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    sx = this.clampScale(sx); // eslint-disable-line\n\n    sy = this.clampScale(sy); // eslint-disable-line\n\n    if (ox || oy) {\n      const ts = this.getTranslation();\n      const tx = ts.tx - ox * (sx - 1);\n      const ty = ts.ty - oy * (sy - 1);\n\n      if (tx !== ts.tx || ty !== ts.ty) {\n        this.translate(tx, ty);\n      }\n    }\n\n    const matrix = this.getMatrix();\n    matrix.a = sx;\n    matrix.d = sy;\n    this.setMatrix(matrix);\n    this.graph.trigger('scale', {\n      sx,\n      sy,\n      ox,\n      oy\n    });\n    return this;\n  }\n\n  clampScale(scale) {\n    const range = this.graph.options.scaling;\n    return NumberExt.clamp(scale, range.min || 0.01, range.max || 16);\n  }\n\n  getZoom() {\n    return this.getScale().sx;\n  }\n\n  zoom(factor, options) {\n    options = options || {}; // eslint-disable-line\n\n    let sx = factor;\n    let sy = factor;\n    const scale = this.getScale();\n    const clientSize = this.getComputedSize();\n    let cx = clientSize.width / 2;\n    let cy = clientSize.height / 2;\n\n    if (!options.absolute) {\n      sx += scale.sx;\n      sy += scale.sy;\n    }\n\n    if (options.scaleGrid) {\n      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n    }\n\n    if (options.maxScale) {\n      sx = Math.min(options.maxScale, sx);\n      sy = Math.min(options.maxScale, sy);\n    }\n\n    if (options.minScale) {\n      sx = Math.max(options.minScale, sx);\n      sy = Math.max(options.minScale, sy);\n    }\n\n    if (options.center) {\n      cx = options.center.x;\n      cy = options.center.y;\n    }\n\n    sx = this.clampScale(sx);\n    sy = this.clampScale(sy);\n\n    if (cx || cy) {\n      const ts = this.getTranslation();\n      const tx = cx - (cx - ts.tx) * (sx / scale.sx);\n      const ty = cy - (cy - ts.ty) * (sy / scale.sy);\n\n      if (tx !== ts.tx || ty !== ts.ty) {\n        this.translate(tx, ty);\n      }\n    }\n\n    this.scale(sx, sy);\n    return this;\n  }\n\n  getRotation() {\n    return Dom.matrixToRotation(this.getMatrix());\n  }\n\n  rotate(angle, cx, cy) {\n    if (cx == null || cy == null) {\n      const bbox = Dom.getBBox(this.graph.view.stage);\n      cx = bbox.width / 2; // eslint-disable-line\n\n      cy = bbox.height / 2; // eslint-disable-line\n    }\n\n    const ctm = this.getMatrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n    this.setMatrix(ctm);\n    return this;\n  }\n\n  getTranslation() {\n    return Dom.matrixToTranslation(this.getMatrix());\n  }\n\n  translate(tx, ty) {\n    const matrix = this.getMatrix();\n    matrix.e = tx || 0;\n    matrix.f = ty || 0;\n    this.setMatrix(matrix);\n    const ts = this.getTranslation();\n    this.options.x = ts.tx;\n    this.options.y = ts.ty;\n    this.graph.trigger('translate', Object.assign({}, ts));\n    return this;\n  }\n\n  setOrigin(ox, oy) {\n    return this.translate(ox || 0, oy || 0);\n  }\n\n  fitToContent(gridWidth, gridHeight, padding, options) {\n    if (typeof gridWidth === 'object') {\n      const opts = gridWidth;\n      gridWidth = opts.gridWidth || 1; // eslint-disable-line\n\n      gridHeight = opts.gridHeight || 1; // eslint-disable-line\n\n      padding = opts.padding || 0; // eslint-disable-line\n\n      options = opts; // eslint-disable-line\n    } else {\n      gridWidth = gridWidth || 1; // eslint-disable-line\n\n      gridHeight = gridHeight || 1; // eslint-disable-line\n\n      padding = padding || 0; // eslint-disable-line\n\n      if (options == null) {\n        options = {}; // eslint-disable-line\n      }\n    }\n\n    const paddings = NumberExt.normalizeSides(padding);\n    const border = options.border || 0;\n    const contentArea = options.contentArea ? Rectangle.create(options.contentArea) : this.getContentArea(options);\n\n    if (border > 0) {\n      contentArea.inflate(border);\n    }\n\n    const scale = this.getScale();\n    const translate = this.getTranslation();\n    const sx = scale.sx;\n    const sy = scale.sy;\n    contentArea.x *= sx;\n    contentArea.y *= sy;\n    contentArea.width *= sx;\n    contentArea.height *= sy;\n    let width = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) * gridWidth;\n    let height = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;\n    let tx = 0;\n    let ty = 0;\n\n    if (options.allowNewOrigin === 'negative' && contentArea.x < 0 || options.allowNewOrigin === 'positive' && contentArea.x >= 0 || options.allowNewOrigin === 'any') {\n      tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;\n      tx += paddings.left;\n      width += tx;\n    }\n\n    if (options.allowNewOrigin === 'negative' && contentArea.y < 0 || options.allowNewOrigin === 'positive' && contentArea.y >= 0 || options.allowNewOrigin === 'any') {\n      ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;\n      ty += paddings.top;\n      height += ty;\n    }\n\n    width += paddings.right;\n    height += paddings.bottom; // Make sure the resulting width and height are greater than minimum.\n\n    width = Math.max(width, options.minWidth || 0);\n    height = Math.max(height, options.minHeight || 0); // Make sure the resulting width and height are lesser than maximum.\n\n    width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);\n    height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);\n    const size = this.getComputedSize();\n    const sizeChanged = width !== size.width || height !== size.height;\n    const originChanged = tx !== translate.tx || ty !== translate.ty; // Change the dimensions only if there is a size discrepency or an origin change\n\n    if (originChanged) {\n      this.translate(tx, ty);\n    }\n\n    if (sizeChanged) {\n      this.resize(width, height);\n    }\n\n    return new Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);\n  }\n\n  scaleContentToFit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.scaleContentToFitImpl(options);\n  }\n\n  scaleContentToFitImpl() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let contentBBox;\n    let contentLocalOrigin;\n\n    if (options.contentArea) {\n      const contentArea = options.contentArea;\n      contentBBox = this.graph.localToGraph(contentArea);\n      contentLocalOrigin = Point.create(contentArea);\n    } else {\n      contentBBox = this.getContentBBox(options);\n      contentLocalOrigin = this.graph.graphToLocal(contentBBox);\n    }\n\n    if (!contentBBox.width || !contentBBox.height) {\n      return;\n    }\n\n    const padding = NumberExt.normalizeSides(options.padding);\n    const minScale = options.minScale || 0;\n    const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;\n    const minScaleX = options.minScaleX || minScale;\n    const maxScaleX = options.maxScaleX || maxScale;\n    const minScaleY = options.minScaleY || minScale;\n    const maxScaleY = options.maxScaleY || maxScale;\n    let fittingBox;\n\n    if (options.viewportArea) {\n      fittingBox = options.viewportArea;\n    } else {\n      const computedSize = this.getComputedSize();\n      const currentTranslate = this.getTranslation();\n      fittingBox = {\n        x: currentTranslate.tx,\n        y: currentTranslate.ty,\n        width: computedSize.width,\n        height: computedSize.height\n      };\n    }\n\n    fittingBox = Rectangle.create(fittingBox).moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.left - padding.right,\n      height: -padding.top - padding.bottom\n    });\n    const currentScale = this.getScale();\n    let newSX = fittingBox.width / contentBBox.width * currentScale.sx;\n    let newSY = fittingBox.height / contentBBox.height * currentScale.sy;\n\n    if (options.preserveAspectRatio !== false) {\n      newSX = newSY = Math.min(newSX, newSY);\n    } // snap scale to a grid\n\n\n    const gridSize = options.scaleGrid;\n\n    if (gridSize) {\n      newSX = gridSize * Math.floor(newSX / gridSize);\n      newSY = gridSize * Math.floor(newSY / gridSize);\n    } // scale min/max boundaries\n\n\n    newSX = NumberExt.clamp(newSX, minScaleX, maxScaleX);\n    newSY = NumberExt.clamp(newSY, minScaleY, maxScaleY);\n    this.scale(newSX, newSY);\n\n    if (translate) {\n      const origin = this.options;\n      const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;\n      const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;\n      this.translate(newOX, newOY);\n    }\n  }\n\n  getContentArea() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.useCellGeometry) {\n      return this.model.getAllCellsBBox() || new Rectangle();\n    }\n\n    return Dom.getBBox(this.graph.view.stage);\n  }\n\n  getContentBBox() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.graph.localToGraph(this.getContentArea(options));\n  }\n\n  getGraphArea() {\n    const rect = Rectangle.fromSize(this.getComputedSize());\n    return this.graph.graphToLocal(rect);\n  }\n\n  zoomToRect(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const area = Rectangle.create(rect);\n    const graph = this.graph;\n    options.contentArea = area;\n\n    if (options.viewportArea == null) {\n      options.viewportArea = {\n        x: graph.options.x,\n        y: graph.options.y,\n        width: this.options.width,\n        height: this.options.height\n      };\n    }\n\n    this.scaleContentToFitImpl(options, false);\n    const center = area.getCenter();\n    this.centerPoint(center.x, center.y);\n    return this;\n  }\n\n  zoomToFit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.zoomToRect(this.getContentArea(options), options);\n  }\n\n  centerPoint(x, y) {\n    const clientSize = this.getComputedSize();\n    const scale = this.getScale();\n    const ts = this.getTranslation();\n    const cx = clientSize.width / 2;\n    const cy = clientSize.height / 2;\n    x = typeof x === 'number' ? x : cx; // eslint-disable-line\n\n    y = typeof y === 'number' ? y : cy; // eslint-disable-line\n\n    x = cx - x * scale.sx; // eslint-disable-line\n\n    y = cy - y * scale.sy; // eslint-disable-line\n\n    if (ts.tx !== x || ts.ty !== y) {\n      this.translate(x, y);\n    }\n  }\n\n  centerContent(options) {\n    const rect = this.graph.getContentArea(options);\n    const center = rect.getCenter();\n    this.centerPoint(center.x, center.y);\n  }\n\n  centerCell(cell) {\n    return this.positionCell(cell, 'center');\n  }\n\n  positionPoint(point, x, y) {\n    const clientSize = this.getComputedSize(); // eslint-disable-next-line\n\n    x = NumberExt.normalizePercentage(x, Math.max(0, clientSize.width));\n\n    if (x < 0) {\n      x = clientSize.width + x; // eslint-disable-line\n    } // eslint-disable-next-line\n\n\n    y = NumberExt.normalizePercentage(y, Math.max(0, clientSize.height));\n\n    if (y < 0) {\n      y = clientSize.height + y; // eslint-disable-line\n    }\n\n    const ts = this.getTranslation();\n    const scale = this.getScale();\n    const dx = x - point.x * scale.sx;\n    const dy = y - point.y * scale.sy;\n\n    if (ts.tx !== dx || ts.ty !== dy) {\n      this.translate(dx, dy);\n    }\n  }\n\n  positionRect(rect, pos) {\n    const bbox = Rectangle.create(rect);\n\n    switch (pos) {\n      case 'center':\n        return this.positionPoint(bbox.getCenter(), '50%', '50%');\n\n      case 'top':\n        return this.positionPoint(bbox.getTopCenter(), '50%', 0);\n\n      case 'top-right':\n        return this.positionPoint(bbox.getTopRight(), '100%', 0);\n\n      case 'right':\n        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%');\n\n      case 'bottom-right':\n        return this.positionPoint(bbox.getBottomRight(), '100%', '100%');\n\n      case 'bottom':\n        return this.positionPoint(bbox.getBottomCenter(), '50%', '100%');\n\n      case 'bottom-left':\n        return this.positionPoint(bbox.getBottomLeft(), 0, '100%');\n\n      case 'left':\n        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%');\n\n      case 'top-left':\n        return this.positionPoint(bbox.getTopLeft(), 0, 0);\n\n      default:\n        return this;\n    }\n  }\n\n  positionCell(cell, pos) {\n    const bbox = cell.getBBox();\n    return this.positionRect(bbox, pos);\n  }\n\n  positionContent(pos, options) {\n    const rect = this.graph.getContentArea(options);\n    return this.positionRect(rect, pos);\n  }\n\n  dispose() {\n    this.widgets.forEach(widget => widget.dispose());\n    this.widgets.clear();\n    this.stopListening();\n  }\n\n}\n\n__decorate([TransformManager.dispose()], TransformManager.prototype, \"dispose\", null);","map":null,"metadata":{},"sourceType":"module"}