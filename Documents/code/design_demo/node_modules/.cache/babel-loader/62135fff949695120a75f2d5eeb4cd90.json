{"ast":null,"code":"import { Base } from \"../base\";\nimport { getEdgeTerminal, isArray, isNumber, isObject } from \"../../util\";\nimport Body from './body';\nimport Quad from './quad';\nimport QuadTree from './quadTree';\nexport class ForceAtlas2Layout extends Base {\n  constructor(options) {\n    super();\n    /** 布局中心 */\n\n    this.center = [0, 0];\n    /** 宽度 */\n\n    this.width = 300;\n    /** 高度 */\n\n    this.height = 300;\n    this.nodes = [];\n    this.edges = [];\n    /**\n     * the parameter for repulsive forces,\n     * it will scale the layout but won't change the layout\n     * larger the kr, looser the layout\n     * @type  {number}\n     */\n\n    this.kr = 5;\n    /**\n     * the parameter for gravity forces\n     * @type  {number}\n     */\n\n    this.kg = 1;\n    /**\n     * modes:\n     * 'normal' for normal using\n     * 'linlog' for compact clusters.\n     * @type  {string}\n     */\n\n    this.mode = 'normal';\n    /**\n     * whether preventing the node overlapping\n     * @type  {boolean}\n     */\n\n    this.preventOverlap = false;\n    /**\n     * whether active the dissuade hub mode\n     * true: grant authorities (nodes with a high indegree)\n     * a more central position than hubs (nodes with a high outdegree)\n     * @type  {boolean}\n     */\n\n    this.dissuadeHubs = false;\n    /**\n     * whether active the barnes hut optimization on computing repulsive forces\n     * @type  {boolean}\n     */\n\n    this.barnesHut = undefined;\n    /**\n     * the max iteration number\n     * @type  {number}\n     */\n\n    this.maxIteration = 0;\n    /**\n     * control the global velocity\n     * defualt: 0.1(gephi)\n     * @type  {number}\n     */\n\n    this.ks = 0.1;\n    /**\n     * the max global velocity\n     * @type  {number}\n     */\n\n    this.ksmax = 10;\n    /**\n     * the tolerance for the global swinging\n     * @type  {number}\n     */\n\n    this.tao = 0.1;\n    /**\n     * the function of layout complete listener, display the legend and minimap after layout\n     * @type  {function}\n     */\n\n    this.onLayoutEnd = () => {};\n    /**\n     * activate prune or not.\n     * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n     * if prune === '', it will be activated when the nodes number > 100\n     * note that it will reduce the quality of the layout\n     * @type  {boolean}\n     */\n\n\n    this.prune = undefined;\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {};\n  } // execute the layout\n\n\n  execute() {\n    const self = this;\n    const {\n      nodes,\n      onLayoutEnd,\n      prune\n    } = self;\n    let maxIteration = self.maxIteration;\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    } // the whidth of each nodes\n\n\n    const sizes = [];\n    const nodeNum = nodes.length;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      const node = nodes[i];\n      let nodeWidth = 10;\n      let nodeHeight = 10;\n\n      if (isNumber(node.size)) {\n        nodeWidth = node.size;\n        nodeHeight = node.size;\n      }\n\n      if (isArray(node.size)) {\n        if (!isNaN(node.size[0])) nodeWidth = node.size[0];\n        if (!isNaN(node.size[1])) nodeHeight = node.size[1];\n      } else if (isObject(node.size)) {\n        nodeWidth = node.size.width;\n        nodeHeight = node.size.height;\n      }\n\n      if (self.getWidth && !isNaN(self.getWidth(node))) nodeHeight = self.getWidth(node);\n      if (self.getHeight && !isNaN(self.getHeight(node))) nodeWidth = self.getHeight(node);\n      const maxSize = Math.max(nodeWidth, nodeHeight);\n      sizes.push(maxSize);\n    }\n\n    if (self.barnesHut === undefined && nodeNum > 250) self.barnesHut = true;\n    if (self.prune === undefined && nodeNum > 100) self.prune = true;\n\n    if (this.maxIteration === 0 && !self.prune) {\n      maxIteration = 250;\n      if (nodeNum <= 200 && nodeNum > 100) maxIteration = 1000;else if (nodeNum > 200) maxIteration = 1200;\n      this.maxIteration = maxIteration;\n    } else if (this.maxIteration === 0 && prune) {\n      maxIteration = 100;\n      if (nodeNum <= 200 && nodeNum > 100) maxIteration = 500;else if (nodeNum > 200) maxIteration = 950;\n      this.maxIteration = maxIteration;\n    }\n\n    if (!self.kr) {\n      self.kr = 50;\n      if (nodeNum > 100 && nodeNum <= 500) self.kr = 20;else if (nodeNum > 500) self.kr = 1;\n    }\n\n    if (!self.kg) {\n      self.kg = 20;\n      if (nodeNum > 100 && nodeNum <= 500) self.kg = 10;else if (nodeNum > 500) self.kg = 1;\n    }\n\n    this.nodes = self.updateNodesByForces(sizes);\n    onLayoutEnd();\n  }\n\n  updateNodesByForces(sizes) {\n    const self = this;\n    const {\n      edges,\n      maxIteration\n    } = self;\n    let nodes = self.nodes;\n    const nonLoopEdges = edges.filter(edge => {\n      const source = getEdgeTerminal(edge, 'source');\n      const target = getEdgeTerminal(edge, 'target');\n      return source !== target;\n    });\n    const size = nodes.length;\n    const esize = nonLoopEdges.length;\n    const degrees = [];\n    const idMap = {};\n    const edgeEndsIdMap = {}; // tslint:disable-next-line\n\n    const Es = [];\n\n    for (let i = 0; i < size; i += 1) {\n      idMap[nodes[i].id] = i;\n      degrees[i] = 0;\n\n      if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n        nodes[i].x = Math.random() * 1000;\n      }\n\n      if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n        nodes[i].y = Math.random() * 1000;\n      }\n\n      Es.push({\n        x: nodes[i].x,\n        y: nodes[i].y\n      });\n    }\n\n    for (let i = 0; i < esize; i += 1) {\n      let node1;\n      let node2;\n      let sIdx = 0;\n      let tIdx = 0;\n\n      for (let j = 0; j < size; j += 1) {\n        const source = getEdgeTerminal(nonLoopEdges[i], 'source');\n        const target = getEdgeTerminal(nonLoopEdges[i], 'target');\n\n        if (nodes[j].id === source) {\n          node1 = nodes[j];\n          sIdx = j;\n        } else if (nodes[j].id === target) {\n          node2 = nodes[j];\n          tIdx = j;\n        }\n\n        edgeEndsIdMap[i] = {\n          sourceIdx: sIdx,\n          targetIdx: tIdx\n        };\n      }\n\n      if (node1) degrees[idMap[node1.id]] += 1;\n      if (node2) degrees[idMap[node2.id]] += 1;\n    }\n\n    let iteration = maxIteration;\n    nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes); // if prune, place the leaves around their parents, and then re-layout for several iterations.\n\n    if (self.prune) {\n      for (let j = 0; j < esize; j += 1) {\n        if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {\n          nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;\n          nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;\n        } else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {\n          nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;\n          nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;\n        }\n      }\n\n      self.prune = false;\n      self.barnesHut = false;\n      iteration = 100;\n      nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n    }\n\n    return nodes;\n  }\n\n  iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n    const self = this;\n    let {\n      nodes\n    } = self;\n    const {\n      kr,\n      preventOverlap\n    } = self;\n    const {\n      barnesHut\n    } = self;\n    const nodeNum = nodes.length;\n    let sg = 0;\n    const krPrime = 100;\n    let iter = iteration;\n    const prevoIter = 50;\n    let forces = [];\n    const preForces = [];\n    const bodies = [];\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      forces[2 * i] = 0;\n      forces[2 * i + 1] = 0;\n\n      if (barnesHut) {\n        const params = {\n          id: i,\n          rx: nodes[i].x,\n          ry: nodes[i].y,\n          mass: 1,\n          g: kr,\n          degree: degrees[i]\n        };\n        bodies[i] = new Body(params);\n      }\n    }\n\n    while (iter > 0) {\n      for (let i = 0; i < nodeNum; i += 1) {\n        preForces[2 * i] = forces[2 * i];\n        preForces[2 * i + 1] = forces[2 * i + 1];\n        forces[2 * i] = 0;\n        forces[2 * i + 1] = 0;\n      } // attractive forces, existing on every actual edge\n\n\n      forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces); // repulsive forces and Gravity, existing on every node pair\n      // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n\n      if (barnesHut && (preventOverlap && iter > prevoIter || !preventOverlap)) {\n        forces = this.getOptRepGraForces(forces, bodies, degrees);\n      } else {\n        forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n      } // update the positions\n\n\n      const res = this.updatePos(forces, preForces, sg, degrees);\n      nodes = res.nodes;\n      sg = res.sg;\n      iter--;\n      if (self.tick) self.tick();\n    }\n\n    return nodes;\n  }\n\n  getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n    const self = this;\n    const {\n      nodes,\n      preventOverlap,\n      dissuadeHubs,\n      mode,\n      prune\n    } = self;\n\n    for (let i = 0; i < esize; i += 1) {\n      const sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n      const sourceIdx = edgeEndsIdMap[i].sourceIdx;\n      const targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n      const targetIdx = edgeEndsIdMap[i].targetIdx;\n      if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1)) continue;\n      const dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n      let eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n      let Fa1 = eucliDis; // tslint:disable-line\n\n      let Fa2 = Fa1; // tslint:disable-line\n\n      if (mode === 'linlog') {\n        Fa1 = Math.log(1 + eucliDis);\n        Fa2 = Fa1;\n      }\n\n      if (dissuadeHubs) {\n        Fa1 = eucliDis / degrees[sourceIdx];\n        Fa2 = eucliDis / degrees[targetIdx];\n      }\n\n      if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n        Fa1 = 0;\n        Fa2 = 0;\n      } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n        Fa1 = eucliDis;\n        Fa2 = eucliDis;\n      }\n\n      forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n      forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n      forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n      forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n    }\n\n    return forces;\n  }\n\n  getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees) {\n    const self = this;\n    const {\n      nodes,\n      preventOverlap,\n      kr,\n      kg,\n      center,\n      prune\n    } = self;\n    const nodeNum = nodes.length;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      for (let j = i + 1; j < nodeNum; j += 1) {\n        if (prune && (degrees[i] <= 1 || degrees[j] <= 1)) continue;\n        const dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n        let eucliDis = Math.hypot(dir[0], dir[1]);\n        eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[i] - sizes[j];\n        let Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis; // tslint:disable-line\n\n        if (preventOverlap && iter < prevoIter && eucliDis < 0) {\n          Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n        } else if (preventOverlap && iter < prevoIter && eucliDis === 0) {\n          Fr = 0;\n        } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n          Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;\n        }\n\n        forces[2 * i] -= Fr * dir[0];\n        forces[2 * j] += Fr * dir[0];\n        forces[2 * i + 1] -= Fr * dir[1];\n        forces[2 * j + 1] += Fr * dir[1];\n      } // gravity\n\n\n      const dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n      const eucliDis = Math.hypot(dir[0], dir[1]);\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      const Fg = kg * (degrees[i] + 1); // tslint:disable-line\n\n      forces[2 * i] -= Fg * dir[0];\n      forces[2 * i + 1] -= Fg * dir[1];\n    }\n\n    return forces;\n  }\n\n  getOptRepGraForces(forces, bodies, degrees) {\n    const self = this;\n    const {\n      nodes,\n      kg,\n      center,\n      prune\n    } = self;\n    const nodeNum = nodes.length;\n    let minx = 9e10;\n    let maxx = -9e10;\n    let miny = 9e10;\n    let maxy = -9e10;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      bodies[i].setPos(nodes[i].x, nodes[i].y);\n      if (nodes[i].x >= maxx) maxx = nodes[i].x;\n      if (nodes[i].x <= minx) minx = nodes[i].x;\n      if (nodes[i].y >= maxy) maxy = nodes[i].y;\n      if (nodes[i].y <= miny) miny = nodes[i].y;\n    }\n\n    const width = Math.max(maxx - minx, maxy - miny);\n    const quadParams = {\n      xmid: (maxx + minx) / 2,\n      ymid: (maxy + miny) / 2,\n      length: width,\n      massCenter: center,\n      mass: nodeNum\n    };\n    const quad = new Quad(quadParams);\n    const quadTree = new QuadTree(quad); // build the tree, insert the nodes(quads) into the tree\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      if (bodies[i].in(quad)) quadTree.insert(bodies[i]);\n    } // update the repulsive forces and the gravity.\n\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      bodies[i].resetForce();\n      quadTree.updateForce(bodies[i]);\n      forces[2 * i] -= bodies[i].fx;\n      forces[2 * i + 1] -= bodies[i].fy; // gravity\n\n      const dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n      let eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      const Fg = kg * (degrees[i] + 1); // tslint:disable-line\n\n      forces[2 * i] -= Fg * dir[0];\n      forces[2 * i + 1] -= Fg * dir[1];\n    }\n\n    return forces;\n  }\n\n  updatePos(forces, preForces, sg, degrees) {\n    const self = this;\n    const {\n      nodes,\n      ks,\n      tao,\n      prune,\n      ksmax\n    } = self;\n    const nodeNum = nodes.length;\n    const swgns = [];\n    const trans = []; // swg(G) and tra(G)\n\n    let swgG = 0;\n    let traG = 0;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      const minus = [forces[2 * i] - preForces[2 * i], forces[2 * i + 1] - preForces[2 * i + 1]];\n      const minusNorm = Math.hypot(minus[0], minus[1]);\n      const add = [forces[2 * i] + preForces[2 * i], forces[2 * i + 1] + preForces[2 * i + 1]];\n      const addNorm = Math.hypot(add[0], add[1]);\n      swgns[i] = minusNorm;\n      trans[i] = addNorm / 2;\n      swgG += (degrees[i] + 1) * swgns[i];\n      traG += (degrees[i] + 1) * trans[i];\n    }\n\n    const preSG = sg;\n    sg = tao * traG / swgG; // tslint:disable-line\n\n    if (preSG !== 0) {\n      sg = sg > 1.5 * preSG ? 1.5 * preSG : sg; // tslint:disable-line\n    } // update the node positions\n\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      let sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));\n      let absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);\n      absForce = absForce < 0.0001 ? 0.0001 : absForce;\n      const max = ksmax / absForce;\n      sn = sn > max ? max : sn;\n      const dnx = sn * forces[2 * i];\n      const dny = sn * forces[2 * i + 1];\n      nodes[i].x += dnx;\n      nodes[i].y += dny;\n    }\n\n    return {\n      nodes,\n      sg\n    };\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}