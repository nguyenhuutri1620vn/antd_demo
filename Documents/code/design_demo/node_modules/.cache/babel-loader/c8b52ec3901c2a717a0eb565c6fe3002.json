{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _isNumber from \"lodash/isNumber\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { LineArcTriangulation } from '../../core/triangulation';\nvar line_arcmini_frag = \"#define LineTypeSolid 0.0\\n#define Animate 0.0\\n\\nuniform float u_opacity;\\nuniform float u_blur : 0.9;\\n// varying vec2 v_normal;\\nvarying vec4 v_color;\\n\\nuniform float u_time;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\n\\nuniform float segmentNumber;\\nvarying float v_distance_ratio;\\n\\nuniform float u_linearColor: 0;\\nuniform vec4 u_sourceColor;\\nuniform vec4 u_targetColor;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n\\n  // \\u8BBE\\u7F6E\\u5F27\\u7EBF\\u7684\\u5E95\\u8272\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    gl_FragColor = mix(u_sourceColor, u_targetColor, v_distance_ratio);\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     gl_FragColor = v_color;\\n  }\\n  \\n \\n  gl_FragColor.a *= u_opacity;\\n\\n  if(u_aimate.x == Animate) {\\n      float animateSpeed = u_time / u_aimate.y; // \\u8FD0\\u52A8\\u901F\\u5EA6\\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\\n      // alpha = smoothstep(0., 1., alpha);\\n      alpha = clamp(alpha, 0.0, 1.0);\\n      gl_FragColor.a *= alpha;\\n  }\\n}\";\nvar line_arcmini_vert = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\n\\nattribute vec4 a_Color;\\nattribute vec3 a_Position;\\nattribute vec4 a_Instance;\\nattribute float a_Size;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_Mvp;\\nuniform float segmentNumber;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\nvarying vec4 v_color;\\n// varying vec2 v_normal;\\n\\nuniform float u_lineDir: 1.0;\\n\\n// \\u504F\\u79FB\\u91CF\\nuniform float u_thetaOffset: 0.314;\\n\\nuniform float u_opacity: 1.0;\\nvarying float v_distance_ratio;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat bezier3(vec3 arr, float t) {\\n  float ut = 1. - t;\\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\\n}\\nvec2 midPoint(vec2 source, vec2 target) {\\n  vec2 center = target - source;\\n  float r = length(center);\\n  float theta = atan(center.y, center.x);\\n  float thetaOffset = u_thetaOffset;\\n  float r2 = r / 2.0 / cos(thetaOffset);\\n  float theta2 = theta + thetaOffset;\\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\\n  if(u_lineDir == 1.0) { // \\u6B63\\u5411\\n    return mid;\\n  } else { // \\u9006\\u5411\\n    // (mid + vmin)/2 = (s + t)/2\\n    vec2 vmid = source + target - mid;\\n    return vmid;\\n  }\\n  // return mid;\\n}\\nfloat getSegmentRatio(float index) {\\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\\n}\\nvec2 interpolate (vec2 source, vec2 target, float t) {\\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\\n  vec2 mid = midPoint(source, target);\\n  vec3 x = vec3(source.x, mid.x, target.x);\\n  vec3 y = vec3(source.y, mid.y, target.y);\\n  return vec2(bezier3(x ,t), bezier3(y,t));\\n}\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\\n  return offset;\\n}\\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\\n}\\n\\nvoid main() {\\n  v_color = a_Color;\\n  \\n  vec2 source = a_Instance.rg;  // \\u8D77\\u59CB\\u70B9\\n  vec2 target =  a_Instance.ba; // \\u7EC8\\u70B9\\n  float segmentIndex = a_Position.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\\n\\n  v_distance_ratio = segmentIndex / segmentNumber;\\n  \\n  if(u_aimate.x == Animate && u_lineDir != 1.0) {\\n      v_distance_ratio = 1.0 - v_distance_ratio;\\n  }\\n\\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio), 0.0, 1.0));\\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio), 0.0, 1.0));\\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\\n  //unProjCustomCoord\\n  \\n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\\n\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\\n  } else {\\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\\n  }\\n}\\n\";\n\nvar ArcMiniModel = function (_BaseModel) {\n  _inherits(ArcMiniModel, _BaseModel);\n\n  var _super = _createSuper(ArcMiniModel);\n\n  function ArcMiniModel() {\n    _classCallCheck(this, ArcMiniModel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ArcMiniModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          sourceColor = _ref.sourceColor,\n          targetColor = _ref.targetColor,\n          _ref$forward = _ref.forward,\n          forward = _ref$forward === void 0 ? true : _ref$forward,\n          _ref$segmentNumber = _ref.segmentNumber,\n          segmentNumber = _ref$segmentNumber === void 0 ? 30 : _ref$segmentNumber,\n          _ref$thetaOffset = _ref.thetaOffset,\n          thetaOffset = _ref$thetaOffset === void 0 ? 0.314 : _ref$thetaOffset;\n\n      var useLinearColor = 0;\n      var sourceColorArr = [0, 0, 0, 0];\n      var targetColorArr = [0, 0, 0, 0];\n\n      if (sourceColor && targetColor) {\n        sourceColorArr = rgb2arr(sourceColor);\n        targetColorArr = rgb2arr(targetColor);\n        useLinearColor = 1;\n      }\n\n      return {\n        u_thetaOffset: thetaOffset,\n        u_opacity: _isNumber(opacity) ? opacity : 1.0,\n        segmentNumber: segmentNumber,\n        u_blur: 0.9,\n        u_lineDir: forward ? 1 : -1,\n        u_linearColor: useLinearColor,\n        u_sourceColor: sourceColorArr,\n        u_targetColor: targetColorArr\n      };\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n          animateOption = _ref2.animateOption;\n\n      return {\n        u_aimate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      return this.buildModels();\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      var _ref3 = this.layer.getLayerConfig(),\n          _ref3$segmentNumber = _ref3.segmentNumber,\n          segmentNumber = _ref3$segmentNumber === void 0 ? 30 : _ref3$segmentNumber;\n\n      return [this.layer.buildLayerModel({\n        moduleName: 'arc2dminiline',\n        vertexShader: line_arcmini_vert,\n        fragmentShader: line_arcmini_frag,\n        triangulation: LineArcTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend(),\n        segmentNumber: segmentNumber\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$size = feature.size,\n                size = _feature$size === void 0 ? 1 : _feature$size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'instance',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Instance',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 4,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4], vertex[5], vertex[6]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return ArcMiniModel;\n}(BaseModel);\n\nexport { ArcMiniModel as default };","map":null,"metadata":{},"sourceType":"module"}