{"ast":null,"code":"import util from '../util';\n\nconst sort = (entries, biasRight, usePrev) => {\n  const parts = util.partition(entries, entry => {\n    // NOTE: 有fixorder的也可以排\n    return entry.hasOwnProperty(\"fixorder\") && !isNaN(entry.fixorder) || entry.hasOwnProperty(\"barycenter\");\n  });\n  const sortable = parts.lhs;\n  const unsortable = parts.rhs.sort((a, b) => -a.i - -b.i);\n  const vs = [];\n  let sum = 0;\n  let weight = 0;\n  let vsIndex = 0;\n  sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  sortable === null || sortable === void 0 ? void 0 : sortable.forEach(entry => {\n    var _a;\n\n    vsIndex += (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n  const result = {\n    vs: vs.flat()\n  };\n\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n\n  return result;\n};\n\nconst consumeUnsortable = (vs, unsortable, index) => {\n  let iindex = index;\n  let last;\n\n  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= iindex) {\n    unsortable.pop();\n    vs === null || vs === void 0 ? void 0 : vs.push(last.vs);\n    iindex++;\n  }\n\n  return iindex;\n};\n/**\n * 配置是否考虑使用之前的布局结果\n */\n\n\nconst compareWithBias = (bias, usePrev) => {\n  return (entryV, entryW) => {\n    // 排序的时候先判断fixorder，不行再判断重心\n    if (entryV.fixorder !== undefined && entryW.fixorder !== undefined) {\n      return entryV.fixorder - entryW.fixorder;\n    }\n\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    }\n\n    if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    } // 重心相同，考虑之前排好的顺序\n\n\n    if (usePrev && entryV.order !== undefined && entryW.order !== undefined) {\n      if (entryV.order < entryW.order) {\n        return -1;\n      }\n\n      if (entryV.order > entryW.order) {\n        return 1;\n      }\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n};\n\nexport default sort;","map":null,"metadata":{},"sourceType":"module"}