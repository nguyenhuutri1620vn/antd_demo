{"ast":null,"code":"import { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport class Path extends Geometry {\n  constructor(args) {\n    super();\n    this.PRECISION = 3;\n    this.segments = [];\n\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj = null;\n        const arr = args;\n        arr.forEach((o, i) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end));\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n          }\n\n          previousObj = o;\n        });\n      } else {\n        const arr = args;\n        arr.forEach(s => {\n          if (s.isSegment) {\n            this.appendSegment(s);\n          }\n        });\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('L', args.end));\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);\n            this.appendSegment(segment);\n          });\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Path.toStringTag;\n  }\n\n  get start() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        return segment.start;\n      }\n    } // if no visible segment, return last segment end point\n\n\n    return segments[count - 1].end;\n  }\n\n  get end() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        return segment.end;\n      }\n    } // if no visible segment, return last segment end point\n\n\n    return segments[count - 1].end;\n  }\n\n  moveTo() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return this.appendSegment(MoveTo.create.call(null, ...args));\n  }\n\n  lineTo() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return this.appendSegment(LineTo.create.call(null, ...args));\n  }\n\n  curveTo() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return this.appendSegment(CurveTo.create.call(null, ...args));\n  }\n\n  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n    const start = this.end || new Point();\n    const points = typeof endX === 'number' ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n      }\n    }\n\n    return this;\n  }\n\n  quadTo(x1, y1, x, y) {\n    const start = this.end || new Point();\n    const data = ['M', start.x, start.y];\n\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1, x, y);\n    } else {\n      const p = y1;\n      data.push(`Q`, x1.x, x1.y, p.x, p.y);\n    }\n\n    const path = Path.parse(data.join(' '));\n    this.appendSegment(path.segments.slice(1));\n    return this;\n  }\n\n  close() {\n    return this.appendSegment(Close.create());\n  }\n\n  drawPoints(points) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const raw = Util.drawPoints(points, options);\n    const sub = Path.parse(raw);\n\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments);\n    }\n  }\n\n  bbox() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    let bbox;\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox();\n\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n        }\n      }\n    }\n\n    if (bbox != null) {\n      return bbox;\n    } // if the path has only invisible elements, return end point of last segment\n\n\n    const lastSegment = segments[count - 1];\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  }\n\n  appendSegment(seg) {\n    const count = this.segments.length;\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null;\n    let currentSegment;\n    const nextSegment = null;\n\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.push(currentSegment);\n    }\n\n    return this;\n  }\n\n  insertSegment(index, seg) {\n    const count = this.segments.length;\n\n    if (index < 0) {\n      index = count + index + 1; // eslint-disable-line\n    }\n\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.');\n    }\n\n    let currentSegment;\n    let previousSegment = null;\n    let nextSegment = null;\n\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1];\n        nextSegment = previousSegment.nextSegment;\n      } else {\n        previousSegment = null;\n        nextSegment = this.segments[0];\n      }\n    }\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(index, 0, currentSegment);\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n\n    return this;\n  }\n\n  removeSegment(index) {\n    const idx = this.fixIndex(index);\n    const removedSegment = this.segments.splice(idx, 1)[0];\n    const previousSegment = removedSegment.previousSegment;\n    const nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)\n\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment;\n    }\n\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment;\n    }\n\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n\n    return removedSegment;\n  }\n\n  replaceSegment(index, seg) {\n    const idx = this.fixIndex(index);\n    let currentSegment;\n    const replacedSegment = this.segments[idx];\n    let previousSegment = replacedSegment.previousSegment;\n    const nextSegment = replacedSegment.nextSegment;\n    let updateSubpathStart = replacedSegment.isSubpathStart;\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(idx, 1, currentSegment);\n\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false;\n      }\n    } else {\n      this.segments.splice(index, 1);\n\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false;\n        }\n      }\n    }\n\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n  }\n\n  getSegment(index) {\n    const idx = this.fixIndex(index);\n    return this.segments[idx];\n  }\n\n  fixIndex(index) {\n    const length = this.segments.length;\n\n    if (length === 0) {\n      throw new Error('Path has no segments.');\n    }\n\n    let i = index;\n\n    while (i < 0) {\n      i = length + i;\n    }\n\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.');\n    }\n\n    return i;\n  }\n\n  segmentAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.segmentIndexAt(ratio, options);\n\n    if (!index) {\n      return null;\n    }\n\n    return this.getSegment(index);\n  }\n\n  segmentAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.segmentIndexAtLength(length, options);\n    if (!index) return null;\n    return this.getSegment(index);\n  }\n\n  segmentIndexAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opt = this.getOptions(options);\n    const len = this.length(opt);\n    const length = len * rate;\n    return this.segmentIndexAtLength(length, opt);\n  }\n\n  segmentIndexAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let lastVisibleIndex = null;\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index;\n        }\n\n        lastVisibleIndex = index;\n      }\n\n      memo += len;\n    } // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n\n\n    return lastVisibleIndex;\n  }\n\n  getSegmentSubdivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = [];\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segment.getSubdivisions({\n        precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n\n    return segmentSubdivisions;\n  }\n\n  updateSubpathStartSegment(segment) {\n    let previous = segment.previousSegment;\n    let current = segment;\n\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment;\n      } else {\n        current.subpathStartSegment = null;\n      }\n\n      previous = current;\n      current = current.nextSegment;\n    }\n  }\n\n  prepareSegment(segment, previousSegment, nextSegment) {\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment;\n    }\n\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment;\n    }\n\n    let updateSubpathStart = segment;\n\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment;\n      updateSubpathStart = nextSegment;\n    } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\n\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart);\n    }\n\n    return segment;\n  }\n\n  closestPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const t = this.closestPointT(p, options);\n\n    if (!t) {\n      return null;\n    }\n\n    return this.pointAtT(t);\n  }\n\n  closestPointLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    const t = this.closestPointT(p, opts);\n\n    if (!t) {\n      return 0;\n    }\n\n    return this.lengthAtT(t, opts);\n  }\n\n  closestPointNormalizedLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n\n    if (cpLength === 0) {\n      return 0;\n    }\n\n    const length = this.length(opts);\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointT(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointT;\n    let minSquaredDistance = Infinity;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointT) {\n      return closestPointT;\n    }\n\n    return {\n      segmentIndex: this.segments.length - 1,\n      value: 1\n    };\n  }\n\n  closestPointTangent(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointTangent;\n    let minSquaredDistance = Infinity;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointTangent) {\n      return closestPointTangent;\n    }\n\n    return null;\n  }\n\n  containsPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const polylines = this.toPolylines(options);\n\n    if (!polylines) {\n      return false;\n    }\n\n    let numIntersections = 0;\n\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1;\n      }\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return numIntersections % 2 === 1;\n  }\n\n  pointAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n\n    const opts = this.getOptions(options);\n    const pathLength = this.length(opts);\n    const length = pathLength * ratio;\n    return this.pointAtLength(length, opts);\n  }\n\n  pointAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    if (length === 0) {\n      return this.start.clone();\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastVisibleSegment;\n    let memo = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const d = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n\n        lastVisibleSegment = segment;\n      }\n\n      memo += d;\n    } // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n\n\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n    } // if no visible segment, return last segment end point\n\n\n    const lastSegment = this.segments[this.segments.length - 1];\n    return lastSegment.end.clone();\n  }\n\n  pointAtT(t) {\n    const segments = this.segments;\n    const numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    const segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1);\n    }\n\n    const tValue = clamp(t.value, 0, 1);\n    return segments[segmentIndex].pointAtT(tValue);\n  }\n\n  divideAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.divideAtLength(length, opts);\n  }\n\n  divideAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let divided;\n    let dividedSegmentIndex;\n    let lastValidSegment;\n    let lastValidSegmentIndex;\n    let t;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.getSegment(index);\n      const subdivisions = segmentSubdivisions[index];\n      const opts = {\n        precision,\n        subdivisions\n      };\n      const len = segment.length(opts);\n\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n\n        if (length <= memo + len) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n          break;\n        }\n      }\n\n      memo += len;\n    }\n\n    if (!lastValidSegment) {\n      return null;\n    }\n\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    } // create a copy of this path and replace the identified segment with its two divided parts:\n\n\n    const pathCopy = this.clone();\n    const index = dividedSegmentIndex;\n    pathCopy.replaceSegment(index, divided);\n    const divisionStartIndex = index;\n    let divisionMidIndex = index + 1;\n    let divisionEndIndex = index + 2; // do not insert the part if it looks like a point\n\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    } // insert a Moveto segment to ensure secondPath will be valid:\n\n\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1; // do not insert the part if it looks like a point\n\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\n    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\n    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {\n      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      const segment = pathCopy.getSegment(i);\n\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    } // distribute pathCopy segments into two paths and return those:\n\n\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  }\n\n  intersectsWithLine(line) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const polylines = this.toPolylines(options);\n\n    if (polylines == null) {\n      return null;\n    }\n\n    let intersections = null;\n\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n      const intersection = line.intersect(polyline);\n\n      if (intersection) {\n        if (intersections == null) {\n          intersections = [];\n        }\n\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection);\n        } else {\n          intersections.push(intersection);\n        }\n      }\n    }\n\n    return intersections;\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n\n      if (segment.isDifferentiable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isValid() {\n    const segments = this.segments;\n    const isValid = segments.length === 0 || segments[0].type === 'M';\n    return isValid;\n  }\n\n  length() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.segments.length === 0) {\n      return 0;\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions\n      });\n    }\n\n    return length;\n  }\n\n  lengthAtT(t) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return 0;\n    }\n\n    let segmentIndex = t.segmentIndex;\n\n    if (segmentIndex < 0) {\n      return 0;\n    }\n\n    let tValue = clamp(t.value, 0, 1);\n\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1;\n      tValue = 1;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precision,\n        subdivisions\n      });\n    }\n\n    const segment = this.segments[segmentIndex];\n    const subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precision,\n      subdivisions\n    });\n    return length;\n  }\n\n  tangentAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.tangentAtLength(length, opts);\n  }\n\n  tangentAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastValidSegment;\n    let memo = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n\n        lastValidSegment = segment;\n      }\n\n      memo += len;\n    } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\n\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    } // if no valid segment, return null\n\n\n    return null;\n  }\n\n  tangentAtT(t) {\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const segmentIndex = t.segmentIndex;\n\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0);\n    }\n\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1);\n    }\n\n    const tValue = clamp(t.value, 0, 1);\n    return this.segments[segmentIndex].tangentAtT(tValue);\n  }\n\n  getPrecision() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n\n  getSubdivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options);\n      return this.getSegmentSubdivisions({\n        precision\n      });\n    }\n\n    return options.segmentSubdivisions;\n  }\n\n  getOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    return {\n      precision,\n      segmentSubdivisions\n    };\n  }\n\n  toPoints() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options);\n    const points = [];\n    let partialPoints = [];\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i];\n\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach(c => partialPoints.push(c.start));\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n\n    return points;\n  }\n\n  toPolylines() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const points = this.toPoints(options);\n\n    if (!points) {\n      return null;\n    }\n\n    return points.map(arr => new Polyline(arr));\n  }\n\n  scale(sx, sy, origin) {\n    this.segments.forEach(s => s.scale(sx, sy, origin));\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.segments.forEach(segment => segment.rotate(angle, origin));\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.segments.forEach(s => s.translate(tx, ty));\n    } else {\n      this.segments.forEach(s => s.translate(tx));\n    }\n\n    return this;\n  }\n\n  clone() {\n    const path = new Path();\n    this.segments.forEach(s => path.appendSegment(s.clone()));\n    return path;\n  }\n\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n\n    const segments = this.segments;\n    const otherSegments = p.segments;\n    const count = segments.length;\n\n    if (otherSegments.length !== count) {\n      return false;\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i];\n      const b = otherSegments[i];\n\n      if (a.type !== b.type || !a.equals(b)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  toJSON() {\n    return this.segments.map(s => s.toJSON());\n  }\n\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.');\n    }\n\n    return this.segments.map(s => s.serialize()).join(' ');\n  }\n\n  toString() {\n    return this.serialize();\n  }\n\n}\n\n(function (Path) {\n  Path.toStringTag = `X6.Geometry.${Path.name}`;\n\n  function isPath(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Path) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const path = instance;\n\n    if ((tag == null || tag === Path.toStringTag) && Array.isArray(path.segments) && typeof path.moveTo === 'function' && typeof path.lineTo === 'function' && typeof path.curveTo === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Path.isPath = isPath;\n})(Path || (Path = {}));\n\n(function (Path) {\n  function parse(pathData) {\n    if (!pathData) {\n      return new Path();\n    }\n\n    const path = new Path();\n    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    const commands = Path.normalize(pathData).match(commandRe);\n\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i];\n        const argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g; // args = [type, coordinate1, coordinate2...]\n\n        const args = command.match(argRe);\n\n        if (args != null) {\n          const type = args[0];\n          const coords = args.slice(1).map(a => +a);\n          const segment = createSegment.call(null, type, ...coords);\n          path.appendSegment(segment);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  Path.parse = parse;\n\n  function createSegment(type) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args);\n    }\n\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args);\n    }\n\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args);\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create();\n    }\n\n    throw new Error(`Invalid path segment type \"${type}\"`);\n  }\n\n  Path.createSegment = createSegment;\n})(Path || (Path = {}));\n\n(function (Path) {\n  Path.normalize = normalizePathData;\n  Path.isValid = Util.isValid;\n  Path.drawArc = Util.drawArc;\n  Path.drawPoints = Util.drawPoints;\n  Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));","map":null,"metadata":{},"sourceType":"module"}