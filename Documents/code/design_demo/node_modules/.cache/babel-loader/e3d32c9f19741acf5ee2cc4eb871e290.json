{"ast":null,"code":"import { Point } from '../../geometry';\nimport { attr } from './attr';\nimport { getBBox, getTransformToElement } from './geom';\nimport { createSVGTransform, parseTransformString, transformStringToMatrix, matrixToTransformString } from './matrix';\nexport function transform(elem, matrix) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'));\n  }\n\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix));\n    return;\n  }\n\n  const transformList = elem.transform;\n  const svgTransform = createSVGTransform(matrix);\n  transformList.baseVal.appendItem(svgTransform);\n}\nexport function translate(elem, tx) {\n  let ty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n\n  if (tx == null) {\n    return transform.translation;\n  }\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n  const newTx = options.absolute ? tx : transform.translation.tx + tx;\n  const newTy = options.absolute ? ty : transform.translation.ty + ty;\n  const newTranslate = `translate(${newTx},${newTy})`; // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n\n  elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());\n}\nexport function rotate(elem, angle, cx, cy) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n\n  if (angle == null) {\n    return transform.rotation;\n  }\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n  angle %= 360; // eslint-disable-line\n\n  const newAngle = options.absolute ? angle : transform.rotation.angle + angle;\n  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';\n  const newRotate = `rotate(${newAngle}${newOrigin})`;\n  elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());\n}\nexport function scale(elem, sx, sy) {\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n\n  if (sx == null) {\n    return transform.scale;\n  }\n\n  sy = sy == null ? sx : sy; // eslint-disable-line\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n  const newScale = `scale(${sx},${sy})`;\n  elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());\n}\nexport function translateAndAutoOrient(elem, position, reference, target) {\n  const pos = Point.create(position);\n  const ref = Point.create(reference);\n\n  if (!target) {\n    const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n    target = svg; // eslint-disable-line\n  } // Clean-up previously set transformations except the scale.\n  // If we didn't clean up the previous transformations then they'd\n  // add up with the old ones. Scale is an exception as it doesn't\n  // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n  // is that the element is scaled by the factor 2, not 8.\n\n\n  const s = scale(elem);\n  elem.setAttribute('transform', '');\n  const bbox = getBBox(elem, {\n    target\n  }).scale(s.sx, s.sy); // 1. Translate to origin.\n\n  const translateToOrigin = createSVGTransform();\n  translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2); // 2. Rotate around origin.\n\n  const rotateAroundOrigin = createSVGTransform();\n  const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));\n  if (angle) rotateAroundOrigin.setRotate(angle, 0, 0); // 3. Translate to the `position` + the offset (half my width)\n  //    towards the `reference` point.\n\n  const translateFromOrigin = createSVGTransform();\n  const finalPosition = pos.clone().move(ref, bbox.width / 2);\n  translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y); // 4. Get the current transformation matrix of this node\n\n  const ctm = getTransformToElement(elem, target); // 5. Apply transformations and the scale\n\n  const transform = createSVGTransform();\n  transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));\n  elem.setAttribute('transform', matrixToTransformString(transform.matrix));\n}","map":null,"metadata":{},"sourceType":"module"}