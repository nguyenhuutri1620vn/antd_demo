{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { FunctionExt } from '../../util';\nimport { View } from '../../view/view';\nimport { Graph } from '../../graph/graph';\nimport { Point } from '../../geometry';\nvar ClassName;\n\n(function (ClassName) {\n  ClassName.root = 'widget-minimap';\n  ClassName.viewport = `${ClassName.root}-viewport`;\n  ClassName.zoom = `${ClassName.viewport}-zoom`;\n})(ClassName || (ClassName = {}));\n\nexport class MiniMap extends View {\n  constructor(options) {\n    super();\n    this.options = Object.assign(Object.assign({}, Util.defaultOptions), options);\n    this.updateViewport = FunctionExt.debounce(this.updateViewport.bind(this), 0);\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container).addClass(this.prefixClassName(ClassName.root));\n    const graphContainer = document.createElement('div');\n    this.container.appendChild(graphContainer);\n    this.$viewport = this.$('<div>').addClass(this.prefixClassName(ClassName.viewport));\n\n    if (this.options.scalable) {\n      this.zoomHandle = this.$('<div>').addClass(this.prefixClassName(ClassName.zoom)).appendTo(this.$viewport).get(0);\n    }\n\n    this.$container.append(this.$viewport).css({\n      width: this.options.width,\n      height: this.options.height,\n      padding: this.options.padding\n    });\n\n    if (this.options.container) {\n      this.options.container.appendChild(this.container);\n    }\n\n    this.sourceGraph = this.graph;\n    const targetGraphOptions = Object.assign(Object.assign({}, this.options.graphOptions), {\n      container: graphContainer,\n      model: this.sourceGraph.model,\n      frozen: true,\n      async: this.sourceGraph.isAsync(),\n      interacting: false,\n      grid: false,\n      background: false,\n      rotating: false,\n      resizing: false,\n      embedding: false,\n      selecting: false,\n      snapline: false,\n      clipboard: false,\n      history: false,\n      scroller: false\n    });\n    this.targetGraph = this.options.createGraph ? this.options.createGraph(targetGraphOptions) : new Graph(targetGraphOptions);\n    this.targetGraph.renderer.unfreeze();\n    this.updatePaper(this.sourceGraph.options.width, this.sourceGraph.options.height);\n    this.startListening();\n  }\n\n  get graph() {\n    return this.options.graph;\n  }\n\n  get scroller() {\n    return this.graph.scroller.widget;\n  }\n\n  get graphContainer() {\n    if (this.scroller) {\n      return this.scroller.container;\n    }\n\n    return this.graph.container;\n  }\n\n  get $graphContainer() {\n    if (this.scroller) {\n      return this.scroller.$container;\n    }\n\n    return this.$(this.graph.container);\n  }\n\n  startListening() {\n    if (this.scroller) {\n      this.$graphContainer.on(`scroll${this.getEventNamespace()}`, this.updateViewport);\n    } else {\n      this.sourceGraph.on('translate', this.onSourceGraphTransform, this);\n      this.sourceGraph.on('scale', this.onSourceGraphTransform, this);\n    }\n\n    this.sourceGraph.on('resize', this.updatePaper, this);\n    this.delegateEvents({\n      mousedown: 'startAction',\n      touchstart: 'startAction',\n      [`mousedown .${this.prefixClassName('graph')}`]: 'scrollTo',\n      [`touchstart .${this.prefixClassName('graph')}`]: 'scrollTo'\n    });\n  }\n\n  stopListening() {\n    if (this.scroller) {\n      this.$graphContainer.off(this.getEventNamespace());\n    } else {\n      this.sourceGraph.off('translate', this.onSourceGraphTransform, this);\n      this.sourceGraph.off('scale', this.onSourceGraphTransform, this);\n    }\n\n    this.sourceGraph.off('resize', this.updatePaper, this);\n    this.undelegateEvents();\n  }\n\n  onRemove() {\n    this.targetGraph.view.remove();\n    this.stopListening();\n    this.targetGraph.dispose();\n  }\n\n  onSourceGraphTransform() {\n    if (!this.targetGraphTransforming) {\n      this.updatePaper(this.sourceGraph.options.width, this.sourceGraph.options.height);\n    } else {\n      this.updateViewport();\n    }\n  }\n\n  updatePaper(w, h) {\n    let width;\n    let height;\n\n    if (typeof w === 'object') {\n      width = w.width;\n      height = w.height;\n    } else {\n      width = w;\n      height = h;\n    }\n\n    const origin = this.sourceGraph.options;\n    const scale = this.sourceGraph.transform.getScale();\n    const maxWidth = this.options.width - 2 * this.options.padding;\n    const maxHeight = this.options.height - 2 * this.options.padding;\n    width /= scale.sx; // eslint-disable-line\n\n    height /= scale.sy; // eslint-disable-line\n\n    this.ratio = Math.min(maxWidth / width, maxHeight / height);\n    const ratio = this.ratio;\n    const x = origin.x * ratio / scale.sx;\n    const y = origin.y * ratio / scale.sy;\n    width *= ratio; // eslint-disable-line\n\n    height *= ratio; // eslint-disable-line\n\n    this.targetGraph.resizeGraph(width, height);\n    this.targetGraph.translate(x, y);\n    this.targetGraph.scale(ratio, ratio);\n    this.updateViewport();\n    return this;\n  }\n\n  updateViewport() {\n    const ratio = this.ratio;\n    const scale = this.sourceGraph.transform.getScale();\n    let origin = null;\n\n    if (this.scroller) {\n      origin = this.scroller.clientToLocalPoint(0, 0);\n    } else {\n      const ctm = this.sourceGraph.matrix();\n      origin = new Point(-ctm.e / ctm.a, -ctm.f / ctm.d);\n    }\n\n    const position = this.$(this.targetGraph.container).position();\n    const translation = this.targetGraph.translate();\n    translation.ty = translation.ty || 0;\n    this.geometry = {\n      top: position.top + origin.y * ratio + translation.ty,\n      left: position.left + origin.x * ratio + translation.tx,\n      width: this.$graphContainer.innerWidth() * ratio / scale.sx,\n      height: this.$graphContainer.innerHeight() * ratio / scale.sy\n    };\n    this.$viewport.css(this.geometry);\n  }\n\n  startAction(evt) {\n    const e = this.normalizeEvent(evt);\n    const action = e.target === this.zoomHandle ? 'zooming' : 'panning';\n    const {\n      tx,\n      ty\n    } = this.sourceGraph.translate();\n    const eventData = {\n      action,\n      clientX: e.clientX,\n      clientY: e.clientY,\n      scrollLeft: this.graphContainer.scrollLeft,\n      scrollTop: this.graphContainer.scrollTop,\n      zoom: this.sourceGraph.zoom(),\n      scale: this.sourceGraph.transform.getScale(),\n      geometry: this.geometry,\n      translateX: tx,\n      translateY: ty\n    };\n    this.targetGraphTransforming = true;\n    this.delegateDocumentEvents(Util.documentEvents, eventData);\n  }\n\n  doAction(evt) {\n    const e = this.normalizeEvent(evt);\n    const clientX = e.clientX;\n    const clientY = e.clientY;\n    const data = e.data;\n\n    switch (data.action) {\n      case 'panning':\n        {\n          const scale = this.sourceGraph.transform.getScale();\n          const rx = (clientX - data.clientX) * scale.sx;\n          const ry = (clientY - data.clientY) * scale.sy;\n\n          if (this.scroller) {\n            this.graphContainer.scrollLeft = data.scrollLeft + rx / this.ratio;\n            this.graphContainer.scrollTop = data.scrollTop + ry / this.ratio;\n          } else {\n            this.sourceGraph.translate(data.translateX - rx / this.ratio, data.translateY - ry / this.ratio);\n          }\n\n          break;\n        }\n\n      case 'zooming':\n        {\n          const startScale = data.scale;\n          const startGeometry = data.geometry;\n          const delta = 1 + (data.clientX - clientX) / startGeometry.width / startScale.sx;\n\n          if (data.frameId) {\n            cancelAnimationFrame(data.frameId);\n          }\n\n          data.frameId = requestAnimationFrame(() => {\n            this.sourceGraph.zoom(delta * data.zoom, {\n              absolute: true,\n              minScale: this.options.minScale,\n              maxScale: this.options.maxScale\n            });\n          });\n          break;\n        }\n\n      default:\n        break;\n    }\n  }\n\n  stopAction() {\n    this.undelegateDocumentEvents();\n    this.targetGraphTransforming = false;\n  }\n\n  scrollTo(evt) {\n    const e = this.normalizeEvent(evt);\n    let x;\n    let y;\n    const ts = this.targetGraph.translate();\n    ts.ty = ts.ty || 0;\n\n    if (e.offsetX == null) {\n      const offset = this.$(this.targetGraph.container).offset();\n      x = e.pageX - offset.left;\n      y = e.pageY - offset.top;\n    } else {\n      x = e.offsetX;\n      y = e.offsetY;\n    }\n\n    const cx = (x - ts.tx) / this.ratio;\n    const cy = (y - ts.ty) / this.ratio;\n    this.sourceGraph.centerPoint(cx, cy);\n  }\n\n  dispose() {\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], MiniMap.prototype, \"dispose\", null);\n\nvar Util;\n\n(function (Util) {\n  Util.defaultOptions = {\n    width: 300,\n    height: 200,\n    padding: 10,\n    scalable: true,\n    minScale: 0.01,\n    maxScale: 16,\n    graphOptions: {},\n    createGraph: options => new Graph(options)\n  };\n  Util.documentEvents = {\n    mousemove: 'doAction',\n    touchmove: 'doAction',\n    mouseup: 'stopAction',\n    touchend: 'stopAction'\n  };\n})(Util || (Util = {}));","map":null,"metadata":{},"sourceType":"module"}