{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { pack } from '../../utils/hierarchy/pack';\nimport { deepAssign, pick } from '../../utils';\nimport { HIERARCHY_DATA_TRANSFORM_PARAMS } from '../../interactions/actions/drill-down';\nimport { resolveAllPadding } from '../../utils/padding';\n/**\n * circle-packing 数据转换\n * @param options\n */\n\nexport function transformData(options) {\n  var data = options.data,\n      hierarchyConfig = options.hierarchyConfig,\n      _a = options.rawFields,\n      rawFields = _a === void 0 ? [] : _a,\n      enableDrillDown = options.enableDrillDown;\n  var nodes = pack(data, __assign(__assign({}, hierarchyConfig), {\n    field: 'value',\n    as: ['x', 'y', 'r']\n  }));\n  var result = [];\n  nodes.forEach(function (node) {\n    var _a;\n\n    var path = node.data.name;\n\n    var ancestorNode = __assign({}, node);\n\n    while (ancestorNode.depth > 1) {\n      path = ((_a = ancestorNode.parent.data) === null || _a === void 0 ? void 0 : _a.name) + \" / \" + path;\n      ancestorNode = ancestorNode.parent;\n    } // 开启下钻，仅加载 depth <= 2 的数据 (加载两层)\n\n\n    if (enableDrillDown && node.depth > 2) {\n      return null;\n    }\n\n    var nodeInfo = deepAssign({}, node.data, __assign(__assign(__assign({}, pick(node.data, rawFields)), {\n      path: path\n    }), node));\n    nodeInfo.ext = hierarchyConfig;\n    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = {\n      hierarchyConfig: hierarchyConfig,\n      rawFields: rawFields,\n      enableDrillDown: enableDrillDown\n    };\n    result.push(nodeInfo);\n  });\n  return result;\n}\n/**\n * 根据传入的 padding 和 现有的 画布大小， 输出针对圆形视图布局需要的 finalPadding 以及 finalSize\n * @param params\n */\n\nexport function resolvePaddingForCircle(padding, appendPadding, containerSize) {\n  var tempPadding = resolveAllPadding([padding, appendPadding]);\n  var top = tempPadding[0],\n      right = tempPadding[1],\n      bottom = tempPadding[2],\n      left = tempPadding[3]; // 没设定，默认是 [0, 0, 0, 0]\n\n  var width = containerSize.width,\n      height = containerSize.height; // 有了 tempPadding 介入以后，计算出coordinate范围宽高的最小值 minSize = circle-packing的直径\n\n  var wSize = width - (left + right);\n  var hSize = height - (top + bottom);\n  var minSize = Math.min(wSize, hSize); // circle-packing的直径\n  // 得到居中后各方向剩余的 padding\n\n  var restWidthPadding = (wSize - minSize) / 2;\n  var restHeightPadding = (hSize - minSize) / 2;\n  var finalTop = top + restHeightPadding;\n  var finalRight = right + restWidthPadding;\n  var finalBottom = bottom + restHeightPadding;\n  var finalLeft = left + restWidthPadding;\n  var finalPadding = [finalTop, finalRight, finalBottom, finalLeft];\n  var finalSize = minSize < 0 ? 0 : minSize; // 防止为负数\n\n  return {\n    finalPadding: finalPadding,\n    finalSize: finalSize\n  };\n}","map":null,"metadata":{},"sourceType":"module"}