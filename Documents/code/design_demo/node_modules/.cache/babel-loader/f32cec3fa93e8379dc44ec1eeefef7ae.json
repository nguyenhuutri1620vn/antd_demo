{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;\n\nimport { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { IDENTIFIER } from '../../identifier';\nexport var SceneGraphSystem = (_dec = injectable(), _dec2 = inject(IDENTIFIER.HierarchyComponentManager), _dec3 = inject(IDENTIFIER.TransformComponentManager), _dec4 = inject(IDENTIFIER.MeshComponentManager), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {\n  function SceneGraphSystem() {\n    _classCallCheck(this, SceneGraphSystem);\n\n    _initializerDefineProperty(this, \"hierarchy\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"transform\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"mesh\", _descriptor3, this);\n  }\n\n  _createClass(SceneGraphSystem, [{\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.runTransformUpdateSystem();\n                this.runHierarchyUpdateSystem();\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute() {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.hierarchy.clear();\n      this.transform.clear();\n    }\n  }, {\n    key: \"getHierarchyComponentManager\",\n    value: function getHierarchyComponentManager() {\n      return this.hierarchy;\n    }\n  }, {\n    key: \"getTransformComponentManager\",\n    value: function getTransformComponentManager() {\n      return this.transform;\n    }\n  }, {\n    key: \"runTransformUpdateSystem\",\n    value: function runTransformUpdateSystem() {\n      var _this = this; // 原版基于 JobSystem 实现\n\n\n      this.transform.forEach(function (entity, transform) {\n        if (transform.isDirty() || transform.isLocalDirty()) {\n          _this.setMeshAABBDirty(_this.mesh.getComponentByEntity(entity));\n\n          transform.updateTransform();\n        }\n      });\n    }\n  }, {\n    key: \"runHierarchyUpdateSystem\",\n    value: function runHierarchyUpdateSystem() {\n      var _this2 = this;\n\n      this.hierarchy.forEach(function (entity, parentComponent) {\n        var transformChild = _this2.transform.getComponentByEntity(entity);\n\n        var transformParent = _this2.transform.getComponentByEntity(parentComponent.parentID);\n\n        if (transformChild !== null && transformParent !== null) {\n          transformChild.updateTransformWithParent(transformParent);\n        }\n      });\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(entity, parent, isChildAlreadyInLocalSpace) {\n      if (this.hierarchy.contains(entity)) {\n        this.detach(entity);\n      }\n\n      this.hierarchy.create(entity, {\n        parentID: parent\n      });\n      var mesh = this.mesh.getComponentByEntity(parent); // inform parent mesh to update its aabb\n\n      this.setMeshAABBDirty(mesh);\n\n      if (mesh && mesh.children.indexOf(entity) === -1) {\n        mesh.children.push(entity);\n      }\n\n      if (this.hierarchy.getCount() > 1) {\n        for (var i = this.hierarchy.getCount() - 1; i > 0; --i) {\n          var parentCandidateEntity = this.hierarchy.getEntity(i); // const parentCandidateComponent = this.hierarchy.getComponent(i);\n\n          for (var j = 0; j < i; ++j) {\n            var childCandidateEntity = this.hierarchy.getComponent(j);\n\n            if (childCandidateEntity.parentID === parentCandidateEntity) {\n              this.hierarchy.moveItem(i, j);\n              ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n\n              break;\n            }\n          }\n        }\n      } // Re-query parent after potential MoveItem(), because it invalidates references:\n\n\n      var parentcomponent = this.hierarchy.getComponentByEntity(entity);\n      var transformParent = this.transform.getComponentByEntity(parent);\n\n      if (transformParent === null) {\n        transformParent = this.transform.create(parent);\n      }\n\n      var transformChild = this.transform.getComponentByEntity(entity);\n\n      if (transformChild === null) {\n        transformChild = this.transform.create(entity); // after transforms.Create(), transform_parent pointer could have become invalidated!\n\n        transformParent = this.transform.getComponentByEntity(parent);\n      }\n\n      transformChild.parent = transformParent;\n\n      if (!isChildAlreadyInLocalSpace && transformParent) {\n        transformChild.matrixTransform(mat4.invert(mat4.create(), transformParent.worldTransform));\n        transformChild.updateTransform();\n      }\n\n      if (transformParent) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach(entity) {\n      var self = this.hierarchy.getComponentByEntity(entity);\n\n      if (self !== null) {\n        var transform = this.transform.getComponentByEntity(entity);\n\n        if (transform !== null) {\n          transform.parent = null;\n          transform.applyTransform();\n        }\n\n        this.hierarchy.removeKeepSorted(entity); // inform parent mesh to update its aabb\n\n        var mesh = this.mesh.getComponentByEntity(self.parentID);\n\n        if (mesh) {\n          var index = mesh.children.indexOf(entity);\n          mesh.children.splice(index, 1);\n        }\n\n        this.setMeshAABBDirty(mesh);\n      }\n    }\n  }, {\n    key: \"detachChildren\",\n    value: function detachChildren(parent) {\n      var mesh = this.mesh.getComponentByEntity(parent);\n\n      if (mesh) {\n        mesh.children = [];\n      }\n\n      for (var i = 0; i < this.hierarchy.getCount();) {\n        var _this$hierarchy$getCo;\n\n        if (((_this$hierarchy$getCo = this.hierarchy.getComponent(i)) === null || _this$hierarchy$getCo === void 0 ? void 0 : _this$hierarchy$getCo.parentID) === parent) {\n          var entity = this.hierarchy.getEntity(i);\n          this.detach(entity);\n        } else {\n          ++i;\n        }\n      }\n    }\n  }, {\n    key: \"setMeshAABBDirty\",\n    value: function setMeshAABBDirty(mesh) {\n      if (mesh) {\n        mesh.aabbDirty = true;\n      }\n    }\n  }]);\n\n  return SceneGraphSystem;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"hierarchy\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"transform\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"mesh\", [_dec4], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":null,"metadata":{},"sourceType":"module"}