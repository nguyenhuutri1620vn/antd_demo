{"ast":null,"code":"export default class Grid {\n  constructor() {\n    this.cells = [];\n    this.columnNum = 0;\n    this.rowNum = 0;\n    this.additionColumn = [];\n    this.additionRow = [];\n  }\n\n  init(width, height, gridSize) {\n    this.cells = [];\n    this.CELL_W = gridSize.CELL_W || Grid.DEFAULT_CELL_W;\n    this.CELL_H = gridSize.CELL_H || Grid.DEFAULT_CELL_H;\n    this.columnNum = Math.ceil(width / this.CELL_W);\n    this.rowNum = Math.ceil(height / this.CELL_H);\n    Grid.MIN_DIST = Math.pow(width, 2) + Math.pow(height, 2);\n\n    for (let i = 0; i < this.columnNum; i++) {\n      const tmp = [];\n\n      for (let j = 0; j < this.rowNum; j++) {\n        const cell = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false\n        };\n        tmp.push(cell);\n      }\n\n      this.cells.push(tmp);\n    }\n  }\n\n  findGridByNodeId(nodeId) {\n    var _a, _b;\n\n    for (let i = 0; i < this.columnNum; i++) {\n      for (let j = 0; j < this.rowNum; j++) {\n        if (this.cells[i][j].node) {\n          if (((_b = (_a = this.cells[i][j]) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.id) === nodeId) {\n            return {\n              column: i,\n              row: j\n            };\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  sqdist(a, b) {\n    return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n  }\n\n  occupyNearest(p) {\n    let minDist = Grid.MIN_DIST;\n    let d;\n    let candidate = null;\n\n    for (let i = 0; i < this.columnNum; i++) {\n      for (let j = 0; j < this.rowNum; j++) {\n        if (!this.cells[i][j].occupied && (d = this.sqdist(p, this.cells[i][j])) < minDist) {\n          minDist = d;\n          candidate = this.cells[i][j];\n        }\n      }\n    }\n\n    if (candidate) {\n      candidate.occupied = true;\n    }\n\n    return candidate;\n  }\n\n  insertColumn(columnIndex, length) {\n    if (length <= 0) return; // 插入空列\n\n    for (let i = 0; i < length; i++) {\n      this.cells[i + this.columnNum] = [];\n\n      for (let j = 0; j < this.rowNum; j++) {\n        this.cells[i + this.columnNum][j] = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false,\n          node: null\n        };\n      }\n    } // 交换数据\n\n\n    for (let i = this.columnNum - 1; i > columnIndex; i--) {\n      for (let j = 0; j < this.rowNum; j++) {\n        this.cells[i + length][j] = Object.assign(Object.assign({}, this.cells[i][j]), {\n          x: (i + length) * this.CELL_W,\n          y: j * this.CELL_H\n        });\n        this.cells[i][j] = {\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: true,\n          node: null\n        };\n      }\n    } // 已有行列的处理\n\n\n    for (let j = 0; j < this.additionColumn.length; j++) {\n      if (this.additionColumn[j] >= columnIndex) {\n        this.additionColumn[j] += length;\n      }\n    } // 记录新增的行列\n\n\n    for (let i = 0; i < length; i++) {\n      this.additionColumn.push(columnIndex + i + 1);\n    }\n\n    this.columnNum += length;\n  }\n\n  insertRow(rowIndex, length) {\n    if (length <= 0) return; // 插入空行\n\n    for (let j = 0; j < length; j++) {\n      for (let i = 0; i < this.columnNum; i++) {\n        this.cells[i][j + this.rowNum] = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false,\n          node: null\n        };\n      }\n    } // 交换数据\n\n\n    for (let i = 0; i < this.columnNum; i++) {\n      for (let j = this.rowNum - 1; j > rowIndex; j--) {\n        this.cells[i][j + length] = Object.assign(Object.assign({}, this.cells[i][j]), {\n          dx: i,\n          dy: j + length,\n          x: i * this.CELL_W,\n          y: (j + length) * this.CELL_H\n        });\n        this.cells[i][j] = {\n          dx: i,\n          dy: j,\n          x: i * this.CELL_W,\n          y: j * this.CELL_H,\n          occupied: false,\n          node: null\n        };\n      }\n    } // 已有行列的处理\n\n\n    for (let j = 0; j < this.additionRow.length; j++) {\n      if (this.additionRow[j] >= rowIndex) {\n        this.additionRow[j] += length;\n      }\n    } // 记录新增的行列\n\n\n    for (let i = 0; i < length; i++) {\n      this.additionRow.push(rowIndex + i + 1);\n    }\n\n    this.rowNum += length;\n  }\n\n  getNodes() {\n    const nodes = [];\n\n    for (let i = 0; i < this.columnNum; i++) {\n      for (let j = 0; j < this.rowNum; j++) {\n        if (this.cells[i][j].node) {\n          nodes.push(this.cells[i][j]);\n        }\n      }\n    }\n\n    return nodes;\n  }\n\n}\nGrid.MIN_DIST = 50;\nGrid.DEFAULT_CELL_W = 80;\nGrid.DEFAULT_CELL_H = 80;","map":null,"metadata":{},"sourceType":"module"}