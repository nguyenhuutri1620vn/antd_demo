{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { mat4, quat, vec3 } from 'gl-matrix';\nimport { Component } from '../../ComponentManager';\nexport var TransformComponent = /*#__PURE__*/function (_Component) {\n  _inherits(TransformComponent, _Component);\n\n  var _super = _createSuper(TransformComponent);\n  /**\n   * local space RTS\n   */\n\n  /**\n   * XMFLOAT4X4._41\n   * @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmfloat4x4-xmfloat4x4(constfloat)#remarks\n   */\n\n  /**\n   * world space RTS\n   */\n  // 高阶函数，利用闭包重复利用临时变量\n  // @see playcanvas graph node\n\n  /**\n   * @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw\n   */\n\n  /**\n   * @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n   */\n\n  /**\n   * TODO: 支持以下两种：\n   * * translate(x, y, z)\n   * * translate(vec3(x, y, z))\n   */\n\n  /**\n   * @see https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline\n   */\n  // public catmullRom = (() => {\n  //   const aS = vec3.create();\n  //   const aR = quat.create();\n  //   const aT = vec3.create();\n  //   const bS = vec3.create();\n  //   const bR = quat.create();\n  //   const bT = vec3.create();\n  //   const cS = vec3.create();\n  //   const cR = quat.create();\n  //   const cT = vec3.create();\n  //   const dS = vec3.create();\n  //   const dR = quat.create();\n  //   const dT = vec3.create();\n  //   const R = quat.create();\n  //   return (\n  //     a: TransformComponent,\n  //     b: TransformComponent,\n  //     c: TransformComponent,\n  //     d: TransformComponent,\n  //     t: number,\n  //   ) => {\n  //     this.setDirty();\n  //     mat4.getScaling(aS, a.worldTransform);\n  //     mat4.getTranslation(aT, a.worldTransform);\n  //     mat4.getRotation(aR, a.worldTransform);\n  //     mat4.getScaling(bS, b.worldTransform);\n  //     mat4.getTranslation(bT, b.worldTransform);\n  //     mat4.getRotation(bR, b.worldTransform);\n  //     mat4.getScaling(cS, c.worldTransform);\n  //     mat4.getTranslation(cT, c.worldTransform);\n  //     mat4.getRotation(cR, c.worldTransform);\n  //     mat4.getScaling(dS, d.worldTransform);\n  //     mat4.getTranslation(dT, d.worldTransform);\n  //     mat4.getRotation(dR, d.worldTransform);\n  //     vec3.catmullRom(this.localPosition, aT, bT, cT, dT, t);\n  //     vec3.catmullRom(R, aR, bR, cR, dR, t);\n  //     quat.normalize(this.localRotation, R);\n  //     vec3.catmullRom(this.localScale, aS, bS, cS, dS, t);\n  //   };\n  // })();\n\n\n  function TransformComponent(data) {\n    var _this;\n\n    _classCallCheck(this, TransformComponent);\n\n    _this = _super.call(this, data);\n    _this.dirtyFlag = void 0;\n    _this.localDirtyFlag = void 0;\n    _this.parent = null;\n    _this.localPosition = vec3.fromValues(0, 0, 0);\n    _this.localRotation = quat.fromValues(0, 0, 0, 1);\n    _this.localScale = vec3.fromValues(1, 1, 1);\n    _this.localTransform = mat4.create();\n    _this.position = vec3.fromValues(0, 0, 0);\n    _this.rotation = quat.fromValues(0, 0, 0, 1);\n    _this.scaling = vec3.fromValues(1, 1, 1);\n    _this.worldTransform = mat4.create();\n\n    _this.matrixTransform = function () {\n      var transformed = mat4.create();\n      return function (mat) {\n        mat4.multiply(transformed, _this.getLocalTransform(), mat);\n        mat4.getScaling(_this.localScale, transformed);\n        mat4.getTranslation(_this.localPosition, transformed);\n        mat4.getRotation(_this.localRotation, transformed);\n      };\n    }();\n\n    _this.rotateRollPitchYaw = function () {\n      var quatX = quat.create();\n      var quatY = quat.create();\n      var quatZ = quat.create();\n      return function (x, y, z) {\n        _this.setDirty();\n\n        quat.fromEuler(quatX, x, 0, 0);\n        quat.fromEuler(quatY, 0, y, 0);\n        quat.fromEuler(quatZ, 0, 0, z);\n        quat.multiply(_this.localRotation, quatX, _this.localRotation);\n        quat.multiply(_this.localRotation, _this.localRotation, quatY);\n        quat.multiply(_this.localRotation, quatZ, _this.localRotation);\n        quat.normalize(_this.localRotation, _this.localRotation);\n      };\n    }();\n\n    _this.lerp = function () {\n      var aS = vec3.create();\n      var aR = quat.create();\n      var aT = vec3.create();\n      var bS = vec3.create();\n      var bR = quat.create();\n      var bT = vec3.create();\n      return function (a, b, t) {\n        _this.setDirty();\n\n        mat4.getScaling(aS, a.worldTransform);\n        mat4.getTranslation(aT, a.worldTransform);\n        mat4.getRotation(aR, a.worldTransform);\n        mat4.getScaling(bS, b.worldTransform);\n        mat4.getTranslation(bT, b.worldTransform);\n        mat4.getRotation(bR, b.worldTransform);\n        vec3.lerp(_this.localScale, aS, bS, t);\n        quat.slerp(_this.localRotation, aR, bR, t);\n        vec3.lerp(_this.localPosition, aT, bT, t);\n      };\n    }();\n\n    _this.translate = function () {\n      var tr = vec3.create();\n      return function (translation) {\n        vec3.add(tr, _this.getPosition(), translation);\n\n        _this.setPosition(tr);\n\n        _this.setDirty(true);\n\n        return _assertThisInitialized(_this);\n      };\n    }();\n\n    _this.translateLocal = function () {\n      return function (translation) {\n        vec3.transformQuat(translation, translation, _this.localRotation);\n        vec3.add(_this.localPosition, _this.localPosition, translation);\n\n        _this.setLocalDirty(true);\n\n        return _assertThisInitialized(_this);\n      };\n    }();\n\n    _this.setPosition = function () {\n      var parentInvertMatrix = mat4.create();\n      return function (position) {\n        _this.position = position;\n\n        _this.setLocalDirty(true);\n\n        if (_this.parent === null) {\n          vec3.copy(_this.localPosition, position);\n        } else {\n          mat4.copy(parentInvertMatrix, _this.parent.worldTransform);\n          mat4.invert(parentInvertMatrix, parentInvertMatrix);\n          vec3.transformMat4(_this.localPosition, position, parentInvertMatrix);\n        }\n\n        return _assertThisInitialized(_this);\n      };\n    }();\n\n    _this.rotate = function () {\n      var parentInvertRotation = quat.create();\n      return function (quaternion) {\n        if (_this.parent === null) {\n          quat.multiply(_this.localRotation, _this.localRotation, quaternion);\n          quat.normalize(_this.localRotation, _this.localRotation);\n        } else {\n          var rot = _this.getRotation();\n\n          var parentRot = _this.parent.getRotation();\n\n          quat.copy(parentInvertRotation, parentRot);\n          quat.invert(parentInvertRotation, parentInvertRotation);\n          quat.multiply(parentInvertRotation, parentInvertRotation, quaternion);\n          quat.multiply(_this.localRotation, quaternion, rot);\n          quat.normalize(_this.localRotation, _this.localRotation);\n        }\n\n        _this.setLocalDirty();\n\n        return _assertThisInitialized(_this);\n      };\n    }();\n\n    _this.rotateLocal = function () {\n      return function (quaternion) {\n        quat.multiply(_this.localRotation, _this.localRotation, quaternion);\n        quat.normalize(_this.localRotation, _this.localRotation);\n\n        _this.setLocalDirty(true);\n\n        return _assertThisInitialized(_this);\n      };\n    }();\n\n    _this.setRotation = function () {\n      var invParentRot = quat.create();\n      return function (rotation) {\n        if (_this.parent === null) {\n          quat.copy(_this.localRotation, rotation);\n        } else {\n          quat.copy(invParentRot, _this.parent.getRotation());\n          quat.invert(invParentRot, invParentRot);\n          quat.copy(_this.localRotation, invParentRot);\n          quat.mul(_this.localRotation, _this.localRotation, rotation);\n        }\n\n        _this.setLocalDirty(true);\n\n        return _assertThisInitialized(_this);\n      };\n    }();\n\n    return _this;\n  }\n\n  _createClass(TransformComponent, [{\n    key: \"setLocalPosition\",\n    value: function setLocalPosition(position) {\n      vec3.copy(this.localPosition, position);\n      this.setLocalDirty(true);\n    }\n  }, {\n    key: \"setLocalScale\",\n    value: function setLocalScale(scale) {\n      vec3.copy(this.localScale, scale);\n      this.setLocalDirty(true);\n    }\n  }, {\n    key: \"setLocalRotation\",\n    value: function setLocalRotation(rotation) {\n      quat.copy(this.localRotation, rotation);\n      this.setLocalDirty(true);\n      return this;\n    }\n  }, {\n    key: \"isDirty\",\n    value: function isDirty() {\n      return this.dirtyFlag;\n    }\n  }, {\n    key: \"setDirty\",\n    value: function setDirty() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (value) {\n        this.dirtyFlag |= TransformComponent.DIRTY;\n      } else {\n        this.dirtyFlag &= ~TransformComponent.DIRTY;\n      }\n    }\n  }, {\n    key: \"isLocalDirty\",\n    value: function isLocalDirty() {\n      return this.localDirtyFlag;\n    }\n  }, {\n    key: \"setLocalDirty\",\n    value: function setLocalDirty() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (value) {\n        this.localDirtyFlag |= TransformComponent.DIRTY;\n        this.setDirty(true);\n      } else {\n        this.localDirtyFlag &= ~TransformComponent.DIRTY;\n      }\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      if (this.isLocalDirty()) {\n        this.getLocalTransform();\n      }\n\n      if (this.isDirty()) {\n        if (this.parent === null) {\n          mat4.copy(this.worldTransform, this.getLocalTransform());\n          this.setDirty(false);\n        }\n      }\n    }\n  }, {\n    key: \"updateTransformWithParent\",\n    value: function updateTransformWithParent(parent) {\n      mat4.multiply(this.worldTransform, parent.worldTransform, this.getLocalTransform());\n    }\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform() {\n      this.setDirty();\n      mat4.getScaling(this.localScale, this.worldTransform);\n      mat4.getTranslation(this.localPosition, this.worldTransform);\n      mat4.getRotation(this.localRotation, this.worldTransform);\n    }\n  }, {\n    key: \"clearTransform\",\n    value: function clearTransform() {\n      this.setDirty();\n      this.localPosition = vec3.fromValues(0, 0, 0);\n      this.localRotation = quat.fromValues(0, 0, 0, 1);\n      this.localScale = vec3.fromValues(1, 1, 1);\n    }\n  }, {\n    key: \"scaleLocal\",\n    value: function scaleLocal(scaling) {\n      this.setLocalDirty();\n      vec3.multiply(this.localScale, this.localScale, scaling);\n      return this;\n    }\n  }, {\n    key: \"getLocalPosition\",\n    value: function getLocalPosition() {\n      return this.localPosition;\n    }\n  }, {\n    key: \"getLocalRotation\",\n    value: function getLocalRotation() {\n      return this.localRotation;\n    }\n  }, {\n    key: \"getLocalScale\",\n    value: function getLocalScale() {\n      return this.localScale;\n    }\n  }, {\n    key: \"getLocalTransform\",\n    value: function getLocalTransform() {\n      if (this.localDirtyFlag) {\n        mat4.fromRotationTranslationScale(this.localTransform, this.localRotation, this.localPosition, this.localScale);\n        this.setLocalDirty(false);\n      }\n\n      return this.localTransform;\n    }\n  }, {\n    key: \"getWorldTransform\",\n    value: function getWorldTransform() {\n      if (!this.isLocalDirty() && !this.isDirty()) {\n        return this.worldTransform;\n      }\n\n      if (this.parent) {\n        this.parent.getWorldTransform();\n      }\n\n      this.updateTransform();\n      return this.worldTransform;\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      mat4.getTranslation(this.position, this.worldTransform);\n      return this.position;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation() {\n      mat4.getRotation(this.rotation, this.worldTransform);\n      return this.rotation;\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      mat4.getScaling(this.scaling, this.worldTransform);\n      return this.scaling;\n    }\n  }]);\n\n  return TransformComponent;\n}(Component);\nTransformComponent.DIRTY = 1 << 0;","map":null,"metadata":{},"sourceType":"module"}