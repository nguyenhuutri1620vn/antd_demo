{"ast":null,"code":"import { __assign } from \"tslib\";\n/*\n * @Author: moyee\n * @LastEditors: moyee\n * @Description: 拖动 Combo\n */\n\nimport { each } from '@antv/util';\nimport Util from '../util';\nimport Global from '../global';\nvar calculationItemsBBox = Util.calculationItemsBBox;\n/**\n * 遍历拖动的 Combo 下的所有 Combo\n * @param data 拖动的 Combo\n * @param fn\n */\n\nvar traverseCombo = function traverseCombo(data, fn) {\n  if (fn(data) === false) {\n    return;\n  }\n\n  if (data) {\n    var combos = data.get('combos');\n\n    if (combos.length === 0) {\n      return false;\n    }\n\n    each(combos, function (child) {\n      traverseCombo(child, fn);\n    });\n  }\n};\n\nexport default {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      enableDelegate: false,\n      delegateStyle: {},\n      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构\n      onlyChangeComboSize: false,\n      // 拖动过程中目标 combo 状态样式\n      activeState: '',\n      selectedState: 'selected'\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'combo:dragstart': 'onDragStart',\n      'combo:drag': 'onDrag',\n      'combo:dragend': 'onDragEnd',\n      'combo:drop': 'onDrop',\n      'node:drop': 'onNodeDrop',\n      'combo:dragenter': 'onDragEnter',\n      'combo:dragleave': 'onDragLeave'\n    };\n  },\n  validationCombo: function validationCombo(evt) {\n    var item = evt.item;\n\n    if (!item || item.destroyed) {\n      return false;\n    }\n\n    if (!this.shouldUpdate.call(this, evt)) {\n      return false;\n    }\n\n    var type = item.getType();\n\n    if (type !== 'combo') {\n      return false;\n    }\n\n    return true;\n  },\n  onDragStart: function onDragStart(evt) {\n    var _this = this;\n\n    var graph = this.graph;\n    var item = evt.item;\n    this.currentShouldEnd = true;\n    if (!this.validationCombo(evt)) return;\n    this.targets = []; // 获取所有选中的 Combo\n\n    var combos = graph.findAllByState('combo', this.selectedState);\n    var currentCombo = item.get('id');\n    var dragCombos = combos.filter(function (combo) {\n      var comboId = combo.get('id');\n      return currentCombo === comboId;\n    });\n\n    if (dragCombos.length === 0) {\n      this.targets.push(item);\n    } else {\n      this.targets = combos;\n    }\n\n    if (this.activeState) {\n      this.targets.map(function (combo) {\n        var model = combo.getModel();\n\n        if (model.parentId) {\n          var parentCombo = graph.findById(model.parentId);\n\n          if (parentCombo) {\n            graph.setItemState(parentCombo, _this.activeState, true);\n          }\n        }\n      });\n    }\n\n    this.point = {};\n    this.originPoint = {};\n    this.origin = {\n      x: evt.x,\n      y: evt.y\n    };\n    this.currentItemChildCombos = [];\n    traverseCombo(item, function (param) {\n      if (param.destroyed) {\n        return false;\n      }\n\n      var model = param.getModel();\n\n      _this.currentItemChildCombos.push(model.id);\n\n      return true;\n    });\n  },\n  onDrag: function onDrag(evt) {\n    var _this = this;\n\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n\n    if (this.enableDelegate) {\n      this.updateDelegate(evt);\n    } else {\n      if (this.activeState) {\n        var graph_1 = this.graph;\n        var item = evt.item;\n        var model_1 = item.getModel(); // 拖动过程中实时计算距离\n\n        var combos = graph_1.getCombos();\n        var sourceBBox = item.getBBox();\n        var centerX_1 = sourceBBox.centerX,\n            centerY_1 = sourceBBox.centerY,\n            width_1 = sourceBBox.width; // 参与计算的 Combo，需要排除掉：\n        // 1、拖动 combo 自己\n        // 2、拖动 combo 的 parent\n        // 3、拖动 Combo 的 children\n\n        var calcCombos = combos.filter(function (combo) {\n          var cmodel = combo.getModel(); // 被拖动的是最外层的 Combo，无 parent，排除自身和子元素\n\n          if (!model_1.parentId) {\n            return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);\n          }\n\n          return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);\n        });\n        calcCombos.map(function (combo) {\n          var _a = combo.getBBox(),\n              cx = _a.centerX,\n              cy = _a.centerY,\n              w = _a.width; // 拖动的 combo 和要进入的 combo 之间的距离\n\n\n          var disX = centerX_1 - cx;\n          var disY = centerY_1 - cy; // 圆心距离\n\n          var distance = 2 * Math.sqrt(disX * disX + disY * disY);\n\n          if (width_1 + w - distance > 0.8 * width_1) {\n            graph_1.setItemState(combo, _this.activeState, true);\n          } else {\n            graph_1.setItemState(combo, _this.activeState, false);\n          }\n        });\n      }\n\n      each(this.targets, function (item) {\n        _this.updateCombo(item, evt);\n      });\n    }\n  },\n  updatePositions: function updatePositions(evt, restore) {\n    var _this = this; // 当启用 delegate 时，拖动结束时需要更新 combo\n\n\n    if (this.enableDelegate || restore) {\n      each(this.targets, function (item) {\n        _this.updateCombo(item, evt, restore);\n      });\n    }\n  },\n  onDrop: function onDrop(evt) {\n    var _this = this; // 被放下的目标 combo\n\n\n    var item = evt.item;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, item);\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd || !item || !this.targets || item.destroyed) return;\n    var graph = this.graph;\n    var targetModel = item.getModel();\n    this.targets.map(function (combo) {\n      var model = combo.getModel();\n\n      if (model.parentId !== targetModel.id) {\n        if (_this.activeState) {\n          graph.setItemState(item, _this.activeState, false);\n        } // 将 Combo 放置到某个 Combo 上面时，只有当 onlyChangeComboSize 为 false 时候才更新 Combo 结构\n\n\n        if (!_this.onlyChangeComboSize) {\n          graph.updateComboTree(combo, targetModel.id);\n        } else {\n          graph.updateCombo(combo);\n        }\n      } else {\n        graph.updateCombo(item);\n      }\n    });\n    this.end(item, evt); // 如果已经拖放下了，则不需要再通过距离判断了\n\n    this.endComparison = true;\n  },\n  onNodeDrop: function onNodeDrop(evt) {\n    var _this = this;\n\n    if (!this.targets || this.targets.length === 0) return;\n    var graph = this.graph;\n    var item = evt.item;\n    var comboId = item.getModel().comboId;\n    var newParentCombo = comboId ? graph.findById(comboId) : undefined;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, newParentCombo);\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd) return;\n    var droppedCombo; // 如果被放置的的节点有 comboId，且这个 comboId 与正在被拖拽的 combo 的父 id 不相同，则更新父亲为 comboId\n\n    if (comboId) {\n      if (this.activeState) {\n        var combo = graph.findById(comboId);\n        graph.setItemState(combo, this.activeState, false);\n      }\n\n      this.targets.map(function (combo) {\n        if (!_this.onlyChangeComboSize) {\n          if (comboId !== combo.getID()) {\n            droppedCombo = graph.findById(comboId);\n            if (comboId !== combo.getModel().parentId) graph.updateComboTree(combo, comboId);\n          }\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    } else {\n      // 如果被放置的节点没有 comboId，且正在被拖拽的 combo 有父 id，则更新父亲为 undefined\n      this.targets.map(function (combo) {\n        if (!_this.onlyChangeComboSize) {\n          var model = combo.getModel();\n\n          if (model.comboId) {\n            graph.updateComboTree(combo);\n          }\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    } // 如果已经拖放下了，则不需要再通过距离判断了\n\n\n    this.endComparison = true;\n    this.end(droppedCombo, evt);\n  },\n  onDragEnter: function onDragEnter(evt) {\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n    var item = evt.item;\n    var graph = this.graph;\n\n    if (this.activeState) {\n      graph.setItemState(item, this.activeState, true);\n    }\n  },\n  onDragLeave: function onDragLeave(evt) {\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n    var item = evt.item;\n    var graph = this.graph;\n\n    if (this.activeState) {\n      graph.setItemState(item, this.activeState, false);\n    }\n  },\n  onDragEnd: function onDragEnd(evt) {\n    if (!this.targets || this.targets.length === 0) return;\n    var item = evt.item;\n\n    if (this.currentShouldEnd) {\n      this.updatePositions(evt);\n    }\n\n    var parentCombo = this.getParentCombo(item.getModel().parentId);\n    var graph = this.graph;\n\n    if (parentCombo && this.activeState) {\n      graph.setItemState(parentCombo, this.activeState, false);\n    }\n\n    this.end(undefined, evt);\n  },\n  end: function end(comboDropedOn, evt) {\n    var _this = this;\n\n    if (!this.origin) return;\n    var graph = this.graph; // 删除delegate shape\n\n    if (this.delegateShape) {\n      var delegateGroup = graph.get('delegateGroup');\n      delegateGroup.clear();\n      this.delegateShape = null;\n    }\n\n    if (comboDropedOn && this.activeState) {\n      graph.setItemState(comboDropedOn, this.activeState, false);\n    } // 若没有被放置的 combo，则是被放置在画布上\n\n\n    if (!comboDropedOn) {\n      this.targets.map(function (combo) {\n        // 将 Combo 放置到某个 Combo 上面时，只有当 onlyChangeComboSize 为 false 时候才更新 Combo 结构\n        if (!_this.onlyChangeComboSize) {\n          graph.updateComboTree(combo);\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    }\n\n    this.point = [];\n    this.origin = null;\n    this.originPoint = null;\n    this.targets.length = 0;\n  },\n\n  /**\n   * 遍历 comboTree，分别更新 node 和 combo\n   * @param data\n   * @param fn\n   */\n  traverse: function traverse(data, fn) {\n    var _this = this;\n\n    if (fn(data) === false) {\n      return;\n    }\n\n    if (data) {\n      var combos = data.get('combos');\n      each(combos, function (child) {\n        _this.traverse(child, fn);\n      });\n      var nodes = data.get('nodes');\n      each(nodes, function (child) {\n        _this.traverse(child, fn);\n      });\n    }\n  },\n  updateCombo: function updateCombo(item, evt, restore) {\n    var _this = this;\n\n    this.traverse(item, function (param) {\n      if (param.destroyed) {\n        return false;\n      }\n\n      _this.updateSignleItem(param, evt, restore);\n\n      return true;\n    });\n  },\n\n  /**\n   *\n   * @param item 当前正在拖动的元素\n   * @param evt\n   */\n  updateSignleItem: function updateSignleItem(item, evt, restore) {\n    var origin = this.origin;\n    var graph = this.graph;\n    var model = item.getModel();\n    var itemId = item.get('id');\n\n    if (!this.point[itemId]) {\n      this.point[itemId] = {\n        x: model.x,\n        y: model.y\n      };\n    }\n\n    var x = evt.x - origin.x + this.point[itemId].x;\n    var y = evt.y - origin.y + this.point[itemId].y;\n\n    if (restore) {\n      x += origin.x - evt.x;\n      y += origin.y - evt.y;\n    }\n\n    graph.updateItem(item, {\n      x: x,\n      y: y\n    });\n  },\n\n  /**\n   * 根据 ID 获取父 Combo\n   * @param parentId 父 Combo ID\n   */\n  getParentCombo: function getParentCombo(parentId) {\n    var graph = this.graph;\n\n    if (!parentId) {\n      return undefined;\n    }\n\n    var parentCombo = graph.findById(parentId);\n\n    if (!parentCombo) {\n      return undefined;\n    }\n\n    return parentCombo;\n  },\n  updateDelegate: function updateDelegate(evt) {\n    var graph = this.graph; // 当没有 delegate shape 时创建\n\n    if (!this.delegateShape) {\n      var delegateGroup = graph.get('delegateGroup');\n      var bbox = null;\n\n      if (this.targets.length > 1) {\n        bbox = calculationItemsBBox(this.targets);\n      } else {\n        bbox = this.targets[0].getBBox();\n      }\n\n      var x = bbox.x,\n          y = bbox.y,\n          width = bbox.width,\n          height = bbox.height,\n          minX = bbox.minX,\n          minY = bbox.minY;\n      this.originPoint = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        minX: minX,\n        minY: minY\n      };\n\n      var attrs = __assign(__assign({}, Global.delegateStyle), this.delegateStyle);\n\n      this.delegateShape = delegateGroup.addShape('rect', {\n        attrs: __assign({\n          width: bbox.width,\n          height: bbox.height,\n          x: bbox.x,\n          y: bbox.y\n        }, attrs),\n        name: 'combo-delegate-shape'\n      });\n      this.delegateShape.set('capture', false);\n      this.delegate = this.delegateShape;\n    } else {\n      var clientX = evt.x - this.origin.x + this.originPoint.minX;\n      var clientY = evt.y - this.origin.y + this.originPoint.minY;\n      this.delegateShape.attr({\n        x: clientX,\n        y: clientY\n      });\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}