{"ast":null,"code":"import { ToolsView } from '../../view/tool';\nimport { Point } from '../../geometry';\nimport { Dom, FunctionExt } from '../../util';\nexport class CellEditor extends ToolsView.ToolItem {\n  constructor() {\n    super(...arguments);\n    this.labelIndex = -1;\n    this.distance = 0.5;\n  }\n\n  render() {\n    this.createElement();\n    this.update();\n    this.autoFocus();\n    this.delegateDocumentEvents(this.options.documentEvents);\n    return this;\n  }\n\n  createElement() {\n    const {\n      cell\n    } = this;\n    const classNames = [this.prefixClassName(`${cell.isEdge() ? 'edge' : 'node'}-tool-editor`), this.prefixClassName('cell-tool-editor')];\n    this.editor = ToolsView.createElement('div', false);\n    this.addClass(classNames, this.editor);\n    this.editor.contentEditable = 'true';\n    this.container.appendChild(this.editor);\n  }\n\n  update() {\n    const {\n      graph,\n      cell,\n      editor\n    } = this;\n    const style = editor.style; // set tool position\n\n    let pos = new Point();\n    let minWidth = 20;\n\n    if (cell.isNode()) {\n      pos = cell.getBBox().center;\n      minWidth = cell.size().width - 4;\n    } else if (cell.isEdge()) {\n      const e = this.options.event;\n      const target = e.target;\n      const parent = target.parentElement;\n      const isEdgeLabel = parent && Dom.hasClass(parent, this.prefixClassName('edge-label'));\n\n      if (isEdgeLabel) {\n        const index = parent.getAttribute('data-index') || '0';\n        this.labelIndex = parseInt(index, 10);\n        const matrix = parent.getAttribute('transform');\n        const {\n          translation\n        } = Dom.parseTransformString(matrix);\n        pos = new Point(translation.tx, translation.ty);\n        minWidth = Dom.getBBox(target).width;\n      } else {\n        pos = graph.clientToLocal(Point.create(e.clientX, e.clientY));\n        const view = this.cellView;\n        const d = view.path.closestPointLength(pos);\n        this.distance = d;\n      }\n    }\n\n    pos = graph.localToGraph(pos);\n    style.left = `${pos.x}px`;\n    style.top = `${pos.y}px`;\n    style.minWidth = `${minWidth}px`; // set tool transform\n\n    const scale = graph.scale();\n    style.transform = `scale(${scale.sx}, ${scale.sy}) translate(-50%, -50%)`; // set font style\n\n    const attrs = this.options.attrs;\n    style.fontSize = `${attrs.fontSize}px`;\n    style.fontFamily = attrs.fontFamily;\n    style.color = attrs.color;\n    style.backgroundColor = attrs.backgroundColor; // set init value\n\n    const getText = this.options.getText;\n    let text;\n\n    if (typeof getText === 'function') {\n      text = FunctionExt.call(getText, this.cellView, {\n        cell: this.cell,\n        index: this.labelIndex\n      });\n    }\n\n    editor.innerText = text || '';\n    return this;\n  }\n\n  onDocumentMouseDown(e) {\n    if (e.target !== this.editor) {\n      const cell = this.cell;\n      const value = this.editor.innerText.replace(/\\n$/, '') || ''; // set value\n\n      const setText = this.options.setText;\n\n      if (value !== '' && typeof setText === 'function') {\n        FunctionExt.call(setText, this.cellView, {\n          cell: this.cell,\n          value,\n          index: this.labelIndex,\n          distance: this.distance\n        });\n      } // remove tool\n\n\n      cell.removeTool(cell.isEdge() ? 'edge-editor' : 'node-editor');\n      this.undelegateDocumentEvents();\n    }\n  }\n\n  onDblClick(e) {\n    e.stopPropagation();\n  }\n\n  onMouseDown(e) {\n    e.stopPropagation();\n  }\n\n  autoFocus() {\n    setTimeout(() => {\n      this.editor.focus();\n      this.selectText();\n    });\n  }\n\n  selectText() {\n    if (window.getSelection) {\n      const range = document.createRange();\n      const selection = window.getSelection();\n      range.selectNodeContents(this.editor);\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n  }\n\n}\n\n(function (CellEditor) {\n  CellEditor.config({\n    tagName: 'div',\n    isSVGElement: false,\n    events: {\n      dblclick: 'onDblClick',\n      mousedown: 'onMouseDown'\n    },\n    documentEvents: {\n      mousedown: 'onDocumentMouseDown'\n    }\n  });\n})(CellEditor || (CellEditor = {}));\n\n(function (CellEditor) {\n  CellEditor.NodeEditor = CellEditor.define({\n    attrs: {\n      fontSize: 14,\n      fontFamily: 'Arial, helvetica, sans-serif',\n      color: '#000',\n      backgroundColor: '#fff'\n    },\n\n    getText(_ref) {\n      let {\n        cell\n      } = _ref;\n      return cell.attr('text/text');\n    },\n\n    setText(_ref2) {\n      let {\n        cell,\n        value\n      } = _ref2;\n      cell.attr('text/text', value);\n    }\n\n  });\n  CellEditor.EdgeEditor = CellEditor.define({\n    attrs: {\n      fontSize: 14,\n      fontFamily: 'Arial, helvetica, sans-serif',\n      color: '#000',\n      backgroundColor: '#fff'\n    },\n\n    getText(_ref3) {\n      let {\n        cell,\n        index\n      } = _ref3;\n\n      if (index === -1) {\n        return '';\n      }\n\n      return cell.prop(`labels/${index}/attrs/label/text`);\n    },\n\n    setText(_ref4) {\n      let {\n        cell,\n        value,\n        index,\n        distance\n      } = _ref4;\n      const edge = cell;\n\n      if (index === -1) {\n        edge.appendLabel({\n          position: {\n            distance: distance\n          },\n          attrs: {\n            label: {\n              text: value\n            }\n          }\n        });\n      } else {\n        edge.prop(`labels/${index}/attrs/label/text`, value);\n      }\n    }\n\n  });\n})(CellEditor || (CellEditor = {}));","map":null,"metadata":{},"sourceType":"module"}