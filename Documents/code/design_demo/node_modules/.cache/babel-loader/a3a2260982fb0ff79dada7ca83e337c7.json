{"ast":null,"code":"export { has, pick, forIn, merge, extend, isEqual, isEmpty, isObject, isPlainObject, clone, cloneDeep, defaults, defaultsDeep } from 'lodash-es';\nexport * from './mixins';\nexport * from './inherit';\nexport function ensure(value, defaultValue) {\n  return value != null ? value : defaultValue;\n}\nexport function getValue(obj, key, defaultValue) {\n  const value = obj != null ? obj[key] : null;\n  return defaultValue !== undefined ? ensure(value, defaultValue) : value;\n}\nexport function getNumber(obj, key, defaultValue) {\n  let value = obj != null ? obj[key] : null;\n\n  if (value == null) {\n    return defaultValue;\n  }\n\n  value = +value;\n\n  if (Number.isNaN(value) || !Number.isFinite(value)) {\n    return defaultValue;\n  }\n\n  return value;\n}\nexport function getBoolean(obj, key, defaultValue) {\n  const value = obj != null ? obj[key] : null;\n\n  if (value == null) {\n    return defaultValue;\n  }\n\n  return !!value;\n}\nexport function getByPath(obj, path) {\n  let delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n  let ret;\n  const keys = Array.isArray(path) ? path : path.split(delimiter);\n\n  if (keys.length) {\n    ret = obj;\n\n    while (keys.length) {\n      const key = keys.shift();\n\n      if (Object(ret) === ret && key && key in ret) {\n        ret = ret[key];\n      } else {\n        return undefined;\n      }\n    }\n  }\n\n  return ret;\n}\nexport function setByPath(obj, path, value) {\n  let delimiter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n  const keys = Array.isArray(path) ? path : path.split(delimiter);\n  const lastKey = keys.pop();\n\n  if (lastKey) {\n    let diver = obj;\n    keys.forEach(key => {\n      if (diver[key] == null) {\n        diver[key] = {};\n      }\n\n      diver = diver[key];\n    });\n    diver[lastKey] = value;\n  }\n\n  return obj;\n}\nexport function unsetByPath(obj, path) {\n  let delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n  const keys = Array.isArray(path) ? path.slice() : path.split(delimiter);\n  const propertyToRemove = keys.pop();\n\n  if (propertyToRemove) {\n    if (keys.length > 0) {\n      const parent = getByPath(obj, keys);\n\n      if (parent) {\n        delete parent[propertyToRemove];\n      }\n    } else {\n      delete obj[propertyToRemove];\n    }\n  }\n\n  return obj;\n}\nexport function flatten(obj) {\n  let delim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';\n  let stop = arguments.length > 2 ? arguments[2] : undefined;\n  const ret = {};\n  Object.keys(obj).forEach(key => {\n    const val = obj[key];\n    let deep = typeof val === 'object' || Array.isArray(val);\n\n    if (deep && stop && stop(val)) {\n      deep = false;\n    }\n\n    if (deep) {\n      const flatObject = flatten(val, delim, stop);\n      Object.keys(flatObject).forEach(flatKey => {\n        ret[key + delim + flatKey] = flatObject[flatKey];\n      });\n    } else {\n      ret[key] = val;\n    }\n  }); // eslint-disable-next-line no-restricted-syntax\n\n  for (const key in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n      continue;\n    }\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"module"}