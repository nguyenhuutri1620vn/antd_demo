{"ast":null,"code":"import { ArrayExt } from '../util';\nimport { Basecoat } from '../common';\nexport class Collection extends Basecoat {\n  constructor(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.length = 0;\n    this.comparator = options.comparator || 'zIndex';\n    this.clean();\n\n    if (cells) {\n      this.reset(cells, {\n        silent: true\n      });\n    }\n  }\n\n  toJSON() {\n    return this.cells.map(cell => cell.toJSON());\n  }\n\n  add(cells, index, options) {\n    let localIndex;\n    let localOptions;\n\n    if (typeof index === 'number') {\n      localIndex = index;\n      localOptions = Object.assign({\n        merge: false\n      }, options);\n    } else {\n      localIndex = this.length;\n      localOptions = Object.assign({\n        merge: false\n      }, index);\n    }\n\n    if (localIndex > this.length) {\n      localIndex = this.length;\n    }\n\n    if (localIndex < 0) {\n      localIndex += this.length + 1;\n    }\n\n    const entities = Array.isArray(cells) ? cells : [cells];\n    const sortable = this.comparator && typeof index !== 'number' && localOptions.sort !== false;\n    const sortAttr = this.comparator || null;\n    let sort = false;\n    const added = [];\n    const merged = [];\n    entities.forEach(cell => {\n      const existing = this.get(cell);\n\n      if (existing) {\n        if (localOptions.merge && !cell.isSameStore(existing)) {\n          existing.setProp(cell.getProp(), options); // merge\n\n          merged.push(existing);\n\n          if (sortable && !sort) {\n            if (sortAttr == null || typeof sortAttr === 'function') {\n              sort = existing.hasChanged();\n            } else if (typeof sortAttr === 'string') {\n              sort = existing.hasChanged(sortAttr);\n            } else {\n              sort = sortAttr.some(key => existing.hasChanged(key));\n            }\n          }\n        }\n      } else {\n        added.push(cell);\n        this.reference(cell);\n      }\n    });\n\n    if (added.length) {\n      if (sortable) {\n        sort = true;\n      }\n\n      this.cells.splice(localIndex, 0, ...added);\n      this.length = this.cells.length;\n    }\n\n    if (sort) {\n      this.sort({\n        silent: true\n      });\n    }\n\n    if (!localOptions.silent) {\n      added.forEach((cell, i) => {\n        const args = {\n          cell,\n          index: localIndex + i,\n          options: localOptions\n        };\n        this.trigger('added', args);\n\n        if (!localOptions.dryrun) {\n          cell.notify('added', Object.assign({}, args));\n        }\n      });\n\n      if (sort) {\n        this.trigger('sorted');\n      }\n\n      if (added.length || merged.length) {\n        this.trigger('updated', {\n          added,\n          merged,\n          removed: [],\n          options: localOptions\n        });\n      }\n    }\n\n    return this;\n  }\n\n  remove(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const arr = Array.isArray(cells) ? cells : [cells];\n    const removed = this.removeCells(arr, options);\n\n    if (!options.silent && removed.length > 0) {\n      this.trigger('updated', {\n        options,\n        removed,\n        added: [],\n        merged: []\n      });\n    }\n\n    return Array.isArray(cells) ? removed : removed[0];\n  }\n\n  removeCells(cells, options) {\n    const removed = [];\n\n    for (let i = 0; i < cells.length; i += 1) {\n      const cell = this.get(cells[i]);\n\n      if (cell == null) {\n        continue;\n      }\n\n      const index = this.cells.indexOf(cell);\n      this.cells.splice(index, 1);\n      this.length -= 1;\n      delete this.map[cell.id];\n      removed.push(cell);\n      this.unreference(cell);\n\n      if (!options.dryrun) {\n        cell.remove();\n      }\n\n      if (!options.silent) {\n        this.trigger('removed', {\n          cell,\n          index,\n          options\n        });\n\n        if (!options.dryrun) {\n          cell.notify('removed', {\n            cell,\n            index,\n            options\n          });\n        }\n      }\n    }\n\n    return removed;\n  }\n\n  reset(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const previous = this.cells.slice();\n    previous.forEach(cell => this.unreference(cell));\n    this.clean();\n    this.add(cells, Object.assign({\n      silent: true\n    }, options));\n\n    if (!options.silent) {\n      const current = this.cells.slice();\n      this.trigger('reseted', {\n        options,\n        previous,\n        current\n      });\n      const added = [];\n      const removed = [];\n      current.forEach(a => {\n        const exist = previous.some(b => b.id === a.id);\n\n        if (!exist) {\n          added.push(a);\n        }\n      });\n      previous.forEach(a => {\n        const exist = current.some(b => b.id === a.id);\n\n        if (!exist) {\n          removed.push(a);\n        }\n      });\n      this.trigger('updated', {\n        options,\n        added,\n        removed,\n        merged: []\n      });\n    }\n\n    return this;\n  }\n\n  push(cell, options) {\n    return this.add(cell, this.length, options);\n  }\n\n  pop(options) {\n    const cell = this.at(this.length - 1);\n    return this.remove(cell, options);\n  }\n\n  unshift(cell, options) {\n    return this.add(cell, 0, options);\n  }\n\n  shift(options) {\n    const cell = this.at(0);\n    return this.remove(cell, options);\n  }\n\n  get(cell) {\n    if (cell == null) {\n      return null;\n    }\n\n    const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;\n    return this.map[id] || null;\n  }\n\n  has(cell) {\n    return this.get(cell) != null;\n  }\n\n  at(index) {\n    if (index < 0) {\n      index += this.length; // eslint-disable-line\n    }\n\n    return this.cells[index] || null;\n  }\n\n  first() {\n    return this.at(0);\n  }\n\n  last() {\n    return this.at(-1);\n  }\n\n  indexOf(cell) {\n    return this.cells.indexOf(cell);\n  }\n\n  toArray() {\n    return this.cells.slice();\n  }\n\n  sort() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.comparator != null) {\n      this.cells = ArrayExt.sortBy(this.cells, this.comparator);\n\n      if (!options.silent) {\n        this.trigger('sorted');\n      }\n    }\n\n    return this;\n  }\n\n  clone() {\n    const constructor = this.constructor;\n    return new constructor(this.cells.slice(), {\n      comparator: this.comparator\n    });\n  }\n\n  reference(cell) {\n    this.map[cell.id] = cell;\n    cell.on('*', this.notifyCellEvent, this);\n  }\n\n  unreference(cell) {\n    cell.off('*', this.notifyCellEvent, this);\n    delete this.map[cell.id];\n  }\n\n  notifyCellEvent(name, args) {\n    const cell = args.cell;\n    this.trigger(`cell:${name}`, args);\n\n    if (cell) {\n      if (cell.isNode()) {\n        this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), {\n          node: cell\n        }));\n      } else if (cell.isEdge()) {\n        this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), {\n          edge: cell\n        }));\n      }\n    }\n  }\n\n  clean() {\n    this.length = 0;\n    this.cells = [];\n    this.map = {};\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}