{"ast":null,"code":"import { Point } from '../point';\nconst regexSupportedData = new RegExp(`^[\\\\s\\\\dLMCZz,.]*$`);\nexport function isValid(data) {\n  if (typeof data !== 'string') {\n    return false;\n  }\n\n  return regexSupportedData.test(data);\n}\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\n\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n\nfunction draw(points, round, initialMove, close, exclude) {\n  const data = [];\n  const end = points[points.length - 1];\n  const rounded = round != null && round > 0;\n  const arcSize = round || 0; // Adds virtual waypoint in the center between start and end point\n\n  if (close && rounded) {\n    points = points.slice(); // eslint-disable-line\n\n    const p0 = points[0];\n    const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);\n    points.splice(0, 0, wp);\n  }\n\n  let pt = points[0];\n  let i = 1; // Draws the line segments\n\n  if (initialMove) {\n    data.push('M', pt.x, pt.y);\n  } else {\n    data.push('L', pt.x, pt.y);\n  }\n\n  while (i < (close ? points.length : points.length - 1)) {\n    let tmp = points[mod(i, points.length)];\n    let dx = pt.x - tmp.x;\n    let dy = pt.y - tmp.y;\n\n    if (rounded && (dx !== 0 || dy !== 0) && (exclude == null || exclude.indexOf(i - 1) < 0)) {\n      // Draws a line from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the last point\n      let dist = Math.sqrt(dx * dx + dy * dy);\n      const nx1 = dx * Math.min(arcSize, dist / 2) / dist;\n      const ny1 = dy * Math.min(arcSize, dist / 2) / dist;\n      const x1 = tmp.x + nx1;\n      const y1 = tmp.y + ny1;\n      data.push('L', x1, y1); // Draws a curve from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the next point\n\n      let next = points[mod(i + 1, points.length)]; // Uses next non-overlapping point\n\n      while (i < points.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {\n        next = points[mod(i + 2, points.length)];\n        i += 1;\n      }\n\n      dx = next.x - tmp.x;\n      dy = next.y - tmp.y;\n      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n      const nx2 = dx * Math.min(arcSize, dist / 2) / dist;\n      const ny2 = dy * Math.min(arcSize, dist / 2) / dist;\n      const x2 = tmp.x + nx2;\n      const y2 = tmp.y + ny2;\n      data.push('Q', tmp.x, tmp.y, x2, y2);\n      tmp = new Point(x2, y2);\n    } else {\n      data.push('L', tmp.x, tmp.y);\n    }\n\n    pt = tmp;\n    i += 1;\n  }\n\n  if (close) {\n    data.push('Z');\n  } else {\n    data.push('L', end.x, end.y);\n  }\n\n  return data.map(v => typeof v === 'string' ? v : +v.toFixed(3)).join(' ');\n}\n\nexport function drawPoints(points) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pts = [];\n\n  if (points && points.length) {\n    points.forEach(p => {\n      if (Array.isArray(p)) {\n        pts.push({\n          x: p[0],\n          y: p[1]\n        });\n      } else {\n        pts.push({\n          x: p.x,\n          y: p.y\n        });\n      }\n    });\n  }\n\n  return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);\n}\n/**\n * Converts the given arc to a series of curves.\n */\n\nexport function arcToCurves(x0, y0, r1, r2) {\n  let angle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let largeArcFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  let sweepFlag = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let x = arguments.length > 7 ? arguments[7] : undefined;\n  let y = arguments.length > 8 ? arguments[8] : undefined;\n\n  if (r1 === 0 || r2 === 0) {\n    return [];\n  }\n\n  x -= x0; // eslint-disable-line\n\n  y -= y0; // eslint-disable-line\n\n  r1 = Math.abs(r1); // eslint-disable-line\n\n  r2 = Math.abs(r2); // eslint-disable-line\n\n  const ctx = -x / 2;\n  const cty = -y / 2;\n  const cpsi = Math.cos(angle * Math.PI / 180);\n  const spsi = Math.sin(angle * Math.PI / 180);\n  const rxd = cpsi * ctx + spsi * cty;\n  const ryd = -1 * spsi * ctx + cpsi * cty;\n  const rxdd = rxd * rxd;\n  const rydd = ryd * ryd;\n  const r1x = r1 * r1;\n  const r2y = r2 * r2;\n  const lamda = rxdd / r1x + rydd / r2y;\n  let sds;\n\n  if (lamda > 1) {\n    r1 = Math.sqrt(lamda) * r1; // eslint-disable-line\n\n    r2 = Math.sqrt(lamda) * r2; // eslint-disable-line\n\n    sds = 0;\n  } else {\n    let seif = 1;\n\n    if (largeArcFlag === sweepFlag) {\n      seif = -1;\n    }\n\n    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n  }\n\n  const txd = sds * r1 * ryd / r2;\n  const tyd = -1 * sds * r2 * rxd / r1;\n  const tx = cpsi * txd - spsi * tyd + x / 2;\n  const ty = spsi * txd + cpsi * tyd + y / 2;\n  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n\n  if (sweepFlag === 0 && dr > 0) {\n    dr -= 2 * Math.PI;\n  } else if (sweepFlag !== 0 && dr < 0) {\n    dr += 2 * Math.PI;\n  }\n\n  const sse = dr * 2 / Math.PI;\n  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n  const segr = dr / seg;\n  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);\n  const cpsir1 = cpsi * r1;\n  const cpsir2 = cpsi * r2;\n  const spsir1 = spsi * r1;\n  const spsir2 = spsi * r2;\n  let mc = Math.cos(s1);\n  let ms = Math.sin(s1);\n  let x2 = -t * (cpsir1 * ms + spsir2 * mc);\n  let y2 = -t * (spsir1 * ms - cpsir2 * mc);\n  let x3 = 0;\n  let y3 = 0;\n  const result = [];\n\n  for (let n = 0; n < seg; n += 1) {\n    s1 += segr;\n    mc = Math.cos(s1);\n    ms = Math.sin(s1);\n    x3 = cpsir1 * mc - spsir2 * ms + tx;\n    y3 = spsir1 * mc + cpsir2 * ms + ty;\n    const dx = -t * (cpsir1 * ms + spsir2 * mc);\n    const dy = -t * (spsir1 * ms - cpsir2 * mc); // CurveTo updates x0, y0 so need to restore it\n\n    const index = n * 6;\n    result[index] = Number(x2 + x0);\n    result[index + 1] = Number(y2 + y0);\n    result[index + 2] = Number(x3 - dx + x0);\n    result[index + 3] = Number(y3 - dy + y0);\n    result[index + 4] = Number(x3 + x0);\n    result[index + 5] = Number(y3 + y0);\n    x2 = x3 + dx;\n    y2 = y3 + dy;\n  }\n\n  return result.map(num => +num.toFixed(2));\n}\nexport function drawArc(startX, startY, rx, ry) {\n  let xAxisRotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let largeArcFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  let sweepFlag = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let stopX = arguments.length > 7 ? arguments[7] : undefined;\n  let stopY = arguments.length > 8 ? arguments[8] : undefined;\n  const data = [];\n  const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);\n\n  if (points != null) {\n    for (let i = 0, ii = points.length; i < ii; i += 6) {\n      data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n    }\n  }\n\n  return data.join(' ');\n}","map":null,"metadata":{},"sourceType":"module"}